"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("jest");
var server_1 = require("../server");
describe('validate io util methods', function () {
    it('validate safeReadJson', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeReadJson('./src/__tests__/mocks/test1.json', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toEqual({});
                    expect(server_1.safeReadJsonSync('./src/__tests__/mocks/test1.json', traceToUse)).toEqual({});
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeReadJson should return undefined for non-existent-file', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeReadJson('/non-existent-file.json', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBeUndefined();
                    expect(server_1.safeReadJsonSync('/non-existent-file.json', traceToUse)).toBeUndefined();
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeReadJson should return undefined for directory path', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeReadJson('./src/__tests__/mocks', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBeUndefined();
                    expect(server_1.safeReadJsonSync('./src/__tests__/mocks', traceToUse)).toBeUndefined();
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeReadJson', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeFileExists('./src/__tests__/mocks/test1.json', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBe('./src/__tests__/mocks/test1.json');
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeReadJson should return false for non-existent-file', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeFileExists('/non-existent-file.json', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBeFalsy();
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeFileExists should return path for valid directory path', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeFileExists('./src/__tests__/mocks', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBe('./src/__tests__/mocks');
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeFileExists should return false for invalid directory path', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var traceToUse, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    traceToUse = {
                        error: jest.fn(),
                        debug: jest.fn()
                    };
                    _a = expect;
                    return [4 /*yield*/, server_1.safeFileExists('./src/__tests__/invalid-directory', traceToUse)];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toBeFalsy();
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeGetAllFilesPath should return paths to all files in the directory', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = expect;
                    return [4 /*yield*/, server_1.safeGetAllFilesPath('./src/__tests__/**/*.ts')];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toEqual(['./src/__tests__/io.test.ts']);
                    return [2 /*return*/];
            }
        });
    }); });
    it('validate safeGetAllFilesPath should return empty for invalid glob pattern', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = expect;
                    return [4 /*yield*/, server_1.safeGetAllFilesPath('./invalid-directory/__tests__/**/*.ts')];
                case 1:
                    _a.apply(void 0, [_b.sent()]).toEqual([]);
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=io.test.js.map
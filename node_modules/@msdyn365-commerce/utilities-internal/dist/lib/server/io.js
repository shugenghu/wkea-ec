"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
// tslint:disable:no-var-requires no-shadowed-variable
var axios_1 = tslib_1.__importDefault(require("axios"));
var fs = tslib_1.__importStar(require("fs-extra"));
var path = tslib_1.__importStar(require("path"));
var util_1 = require("util");
var console_trace_1 = require("./console-trace");
exports.safeReadFile = function (filePath, traceToUse) {
    if (traceToUse === void 0) { traceToUse = console_trace_1.trace; }
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            try {
                // tslint:disable-next-line:no-any
                return [2 /*return*/, fs.readFile(filePath, 'utf8').catch(function (reason) {
                        throw new Error(reason);
                    })];
            }
            catch (error) {
                traceToUse.error("Error reading " + filePath.toString());
                traceToUse.error(error);
                return [2 /*return*/, ''];
            }
            return [2 /*return*/];
        });
    });
};
exports.safeReadFileSync = function (filePath, traceToUse) {
    if (traceToUse === void 0) { traceToUse = console_trace_1.trace; }
    try {
        return fs.readFileSync(filePath, 'utf8');
    }
    catch (error) {
        return '';
    }
};
// tslint:disable-next-line:no-require-imports
var glob = require('glob');
var globAsync = util_1.promisify(glob);
/**
 * Utility function to async check if file exists but returns path of it does, false if it doesn't
 * @param filePath file path to check
 */
exports.safeFileExists = function (filePath, trace) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var logger, errLogger;
    return tslib_1.__generator(this, function (_a) {
        logger = trace || console_trace_1.trace;
        errLogger = logger.error || console_trace_1.trace.error;
        return [2 /*return*/, new Promise(function (resolve, reject) {
                if (!filePath) {
                    resolve(false);
                }
                fs.access(filePath, fs.constants.R_OK, function (err) {
                    if (err) {
                        if (process.env.NODE_ENV === 'development') {
                            logger.debug("Requested file " + filePath + " doesn't exist " + err);
                        }
                        resolve(false);
                    }
                    resolve(filePath);
                });
                // tslint:disable-next-line:no-any
            }).catch(function (err) {
                errLogger(err);
                return false;
            })];
    });
}); };
/**
 * Utility function to sync check if file exists but returns path of it does, false if it doesn't
 * @param filePath file path to check
 */
exports.safeFileExistsSync = function (filePath) {
    try {
        return fs.existsSync(filePath);
    }
    catch (err) {
        return false;
    }
};
function asyncForEach(array, callback) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var index;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    index = 0;
                    _a.label = 1;
                case 1:
                    if (!(index < array.length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, callback(array[index], index, array)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    index++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.asyncForEach = asyncForEach;
// Helper function for parsing/normalizing json, exported
exports.safeParseJson = function (content, trace) {
    try {
        return typeof content === 'string' ? JSON.parse(content) : content;
    }
    catch (error) {
        trace = trace || console_trace_1.trace;
        trace.error(new Error("JSON Parsing failed for content:\n " + content), error);
        return null;
    }
};
/**
 * Implementation to safely read a file and try to parse JSON. If the file does not exist or there is some issue,
 * undefined is returned which is NOT valid JSON and should be checked.
 *
 * @param filePath Path of the file to try to read and parse
 * @param trace optional trace logger to use while reading file
 */
exports.safeReadJson = function (filePath, trace) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var _a, _b, error_1;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _c.trys.push([0, 4, , 5]);
                return [4 /*yield*/, exports.safeFileExists(filePath)];
            case 1:
                if (!_c.sent()) return [3 /*break*/, 3];
                _b = (_a = JSON).parse;
                return [4 /*yield*/, fs.readFile(filePath, 'utf8')];
            case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
            case 3: return [3 /*break*/, 5];
            case 4:
                error_1 = _c.sent();
                trace = trace || console;
                trace.error(new Error("JSON fetch failed in safeReadJson with path: [" + filePath + "]"));
                trace.error(error_1);
                return [3 /*break*/, 5];
            case 5: return [2 /*return*/, undefined];
        }
    });
}); };
exports.safeReadJsonSync = function (filePath, trace) {
    try {
        if (exports.safeFileExistsSync(filePath)) {
            return fs.readJSONSync(filePath);
        }
    }
    catch (error) {
        trace = trace || console_trace_1.trace;
        if (error.code === 'ENOENT') {
            trace.debug("file not found at [" + filePath + "]");
            return undefined;
        }
        trace.error(new Error("JSON fetch failed in safeReadJsonSync with path: [" + path + "]"));
        trace.error(error);
    }
    return undefined;
};
/**
 * Writes starter pack initialization data to file
 */
// tslint:disable-next-line:no-any
exports.safeWriteJson = function (filePath, data, trace, spacing) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var isFileExists, error_2;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 5, , 6]);
                return [4 /*yield*/, exports.safeFileExists(filePath)];
            case 1:
                isFileExists = _a.sent();
                if (!!isFileExists) return [3 /*break*/, 3];
                return [4 /*yield*/, fs.mkdirp(path.dirname(filePath))];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3: return [4 /*yield*/, fs.writeFile(filePath, JSON.stringify(data, null, spacing || 2), 'utf8')];
            case 4:
                _a.sent();
                return [2 /*return*/, true];
            case 5:
                error_2 = _a.sent();
                trace = trace || console_trace_1.trace;
                trace.error(new Error("JSON fetch fails for [" + filePath + "]"), error_2);
                trace.error(error_2);
                return [2 /*return*/, false];
            case 6: return [2 /*return*/];
        }
    });
}); };
/**
 * Writes starter pack initialization data to file
 */
// tslint:disable-next-line:no-any
exports.safeWriteJS = function (filePath, data, trace) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var isFileExists, error_3;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 5, , 6]);
                return [4 /*yield*/, exports.safeFileExists(filePath)];
            case 1:
                isFileExists = _a.sent();
                if (!!isFileExists) return [3 /*break*/, 3];
                return [4 /*yield*/, fs.mkdirp(path.dirname(filePath))];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3: return [4 /*yield*/, fs.writeFile(filePath, data.join('\n'), 'utf8')];
            case 4:
                _a.sent();
                return [2 /*return*/, true];
            case 5:
                error_3 = _a.sent();
                trace = trace || console_trace_1.trace;
                trace.error(new Error("------ JS fetch fails for [" + filePath + "]"), error_3);
                return [2 /*return*/, false];
            case 6: return [2 /*return*/];
        }
    });
}); };
exports.safeGetAllFilesPath = function (globFilePattern, options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var getPaths, paths, promises;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                getPaths = function (pattern) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                    var filePaths, error_4;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                console_trace_1.trace.debug("Tracing all file with path '" + pattern + "'");
                                return [4 /*yield*/, globAsync(pattern, options)];
                            case 1:
                                filePaths = _a.sent();
                                console_trace_1.trace.debug(filePaths);
                                return [2 /*return*/, filePaths];
                            case 2:
                                error_4 = _a.sent();
                                console_trace_1.trace.error(error_4);
                                return [2 /*return*/, []];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); };
                paths = [];
                if (!Array.isArray(globFilePattern)) return [3 /*break*/, 2];
                promises = globFilePattern.map(getPaths);
                return [4 /*yield*/, promises
                        .reduce(function (previousTask, currentTask, result) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var prevOutput, currentOutput;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, previousTask];
                                case 1:
                                    prevOutput = _a.sent();
                                    return [4 /*yield*/, currentTask];
                                case 2:
                                    currentOutput = _a.sent();
                                    return [2 /*return*/, tslib_1.__spreadArrays(prevOutput, currentOutput)];
                            }
                        });
                    }); }, Promise.resolve(promises[0]))
                        .then(function (results) { return (paths = Array.from(new Set(results))); })];
            case 1:
                _a.sent();
                return [3 /*break*/, 4];
            case 2: return [4 /*yield*/, getPaths(globFilePattern)];
            case 3:
                paths = _a.sent();
                _a.label = 4;
            case 4: return [2 /*return*/, paths];
        }
    });
}); };
exports.safeGetAllFilesPathSync = function (globFilePattern, trace, options) {
    trace = trace || console_trace_1.trace;
    try {
        trace.info("Tracing all definition file with path '" + globFilePattern + "'");
        var filePaths = glob.sync(globFilePattern, options);
        trace.info(filePaths);
        return filePaths;
    }
    catch (error) {
        trace.error(error);
        return [];
    }
};
exports.isDirectory = function (source) { return fs.lstatSync(source).isDirectory() || fs.lstatSync(source).isSymbolicLink(); };
exports.getDirectories = function (source) { return fs.readdirSync(source).filter(function (name) { return exports.isDirectory(path.join(source, name)); }); };
// tslint:disable-next-line:no-any
exports.runSchemaValidationWithNestedError = function (validator, runValidationOn, schema) {
    return validator.validate(runValidationOn, schema, { nestedErrors: true });
};
/**
 * Checks to see if the specified path is a file
 * @param source Fully qualified path
 */
exports.isFileSync = function (source) { return source && fs.existsSync(source) && fs.lstatSync(source).isFile(); };
/**
 * Returns all files in a directory
 * @param sourceDir Directory
 */
exports.getFilesInDirSync = function (sourceDir) {
    return fs.readdirSync(sourceDir).filter(function (name) { return exports.isFileSync(path.join(sourceDir, name)); });
};
/**
 * Will write a file in an async way and attempt to create all directories that do not exist.  Any error
 * is gracefully eaten and printed to console
 *
 * @param file file path
 * @param data data to write
 * @param options options
 */
// tslint:disable:no-any
exports.safeWriteFile = function (file, data, options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        console_trace_1.trace.debug("Writing file " + file + ".");
        return [2 /*return*/, fs
                .outputFile(file, data, options)
                .then(function () {
                console_trace_1.trace.debug("Successfully wrote '" + file + "'.");
            })
                .catch(function (err) {
                console_trace_1.trace.error("Error writing '" + file + "'");
                console_trace_1.trace.error(err);
            })];
    });
}); };
/**
 * Returns true if the environment is detected to be yarn workspaces env and cli template has been hoisted
 */
exports.isCliTemplateHoisted = function () {
    var msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce/cli-template-internal');
    return !fs.existsSync(msdyn365ModuleDir);
};
/**
 * Returns true if the environment is detected to be yarn workspaces env and MSDyn365 Commerce Modules has been hoisted
 */
exports.isMSDyn365CommerceModulesHoisted = function () {
    var msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce-modules');
    return !fs.existsSync(msdyn365ModuleDir);
};
/**
 * Returns true if the environment is detected to be yarn workspaces env and MSDyn365 Commerce has been hoisted
 */
exports.isMSDyn365CommerceHoisted = function () {
    var msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce');
    return !fs.existsSync(msdyn365ModuleDir);
};
/**
 * Returns the hoisted node_modules directory
 * Assumes the node modules are two levels above
 * node_modules
 * packages
 *     --> module
 *         ---> process.cwd()
 */
exports.getHoistedNodeModules = function () {
    return path.resolve(process.cwd(), '../../', 'node_modules');
};
/**
 * Gets the current version of a pacakage
 * @param packageNamespace
 * @param packageName
 * @param errorOnFailure
 */
exports.getVersionForPackage = function (packageNamespace, packageName, options) {
    var appDirectory = fs.realpathSync(process.cwd());
    var resolveApp = function (relativePath) { return path.resolve(appDirectory, relativePath); };
    var paths = {
        appNodeModules: resolveApp('node_modules')
    };
    try {
        var pathToPackage = path.join(paths.appNodeModules, packageNamespace, packageName);
        // Hoisted check
        if (!fs.existsSync(path.join(pathToPackage, 'package.json'))) {
            pathToPackage = path.resolve(paths.appNodeModules, '../../../node_modules/', packageNamespace, packageName);
        }
        if (fs.existsSync(path.join(pathToPackage, 'package.json'))) {
            var packageInfo = JSON.parse(fs.readFileSync(path.join(pathToPackage, 'package.json'), 'utf8'));
            return packageInfo.version ? packageInfo.version : '--';
        }
        else {
            throw new Error("Package " + packageNamespace + "/" + packageName + " does not exist in node_modules");
        }
    }
    catch (e) {
        if (options.errorOnFailure) {
            console.error(e);
            console.error("Error in resolving current version of " + packageNamespace + "/" + packageName);
        }
        else {
            console.warn("Unable to resolve current version of " + packageNamespace + "/" + packageName + ". Check to see if the package is installed.");
        }
        return '--';
    }
};
/**
 * Gets the Retail Cloud Scale Unit (RCSU) version info of a partner
 * @param baseUrl Base url from the partners .evn file
 */
exports.getRCSUversion = function (baseUrl) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var url, requestConfig, res, err_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!baseUrl) return [3 /*break*/, 5];
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                url = baseUrl + "Commerce/GetEnvironmentConfiguration";
                requestConfig = {
                    headers: { 'Content-Type': 'application/json' }
                };
                return [4 /*yield*/, axios_1.default.get(url, requestConfig)];
            case 2:
                res = _a.sent();
                if (res.data && res.data.BaseVersion) {
                    return [2 /*return*/, res.data.BaseVersion];
                }
                else {
                    return [2 /*return*/, '--'];
                }
                return [3 /*break*/, 4];
            case 3:
                err_1 = _a.sent();
                return [2 /*return*/, '--'];
            case 4: return [3 /*break*/, 6];
            case 5: return [2 /*return*/, '--'];
            case 6: return [2 /*return*/];
        }
    });
}); };
//# sourceMappingURL=io.js.map
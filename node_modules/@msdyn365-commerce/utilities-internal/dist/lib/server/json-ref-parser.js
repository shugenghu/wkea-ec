"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
// tslint:disable:no-any
var json_schema_ref_parser_1 = tslib_1.__importDefault(require("json-schema-ref-parser"));
var path = tslib_1.__importStar(require("path"));
var extensions_1 = require("../common/extensions");
var io_1 = require("./io");
/**
 * Marks ref paths to save the url from the ref parser
 * @param json JSON object of the module definition
 */
var markRefPaths = function (json) {
    if (extensions_1.isEmptyOrNullObject(json)) {
        return;
    }
    Object.keys(json).forEach(function (key) {
        if (key === '$ref') {
            // Add reference path marker. This is needed so that json-ref-parser
            // sends the path untouched which is required to decide to look for
            // the definition within 'src' or 'node_modules' scopes
            if (json[key].indexOf('#') !== 0) {
                json[key] = "file://json/" + json[key];
            }
        }
        else if (typeof json[key] === 'object') {
            markRefPaths(json[key]);
        }
    });
};
/**
 * Resolves the parent definition file w.r.t child definition file. A definition file can be referenced in a child
 * defintion file. The path follows the standard node resolution process i.e. supports paths relative to the child
 * and also to the node_modules.
 * @param parentDefinitionPath Path to definition file which is referenced in the child definition file
 * @param inheritedModuleDir Path to child definition file which is inheriting parent definition or a part of it
 */
exports.resolveParentDefinitionPath = function (wrappedParentDefinitionPath, inheritedModuleDir) {
    var parentDefinitionPath = wrappedParentDefinitionPath.replace(/file:\/\/json\//, '');
    if (parentDefinitionPath.startsWith('.')) {
        // path is relative to the current module directory, but resolution is
        // relative to src/. Therefore, lets make it relative to the current module directory
        return path.join(inheritedModuleDir, parentDefinitionPath);
    }
    // resolve against partner
    var pathRelativeToPartner = path.join(process.cwd(), 'node_modules', parentDefinitionPath);
    if (io_1.safeFileExistsSync(pathRelativeToPartner)) {
        return pathRelativeToPartner;
    }
    // resolve against hoisted path
    return path.resolve(path.join(process.cwd(), '../../node_modules', parentDefinitionPath));
};
/**
 * Resolves referenced definition files
 * @param moduleDirectory Path to module directory
 * @param trace logger
 */
var refPathResolver = function (moduleDirectory, trace) {
    return {
        order: 1,
        canRead: true,
        // tslint:disable-next-line:no-any
        read: function (wrappedParentDefinitionPath) {
            // Remove reference path marker
            var parentDefinitionPath = exports.resolveParentDefinitionPath(wrappedParentDefinitionPath.url, moduleDirectory);
            return io_1.safeReadJson(parentDefinitionPath);
        }
    };
};
/**
 * Takes definition json object and resolves all the file references ($ref) defined in definition.
 * @param json definition json object
 * @param jsonFilePath path to definition file
 * @param trace logger
 */
exports.resolveRef = function (json, jsonFilePath, trace) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var definitionParser, e_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (extensions_1.isEmptyOrNullObject(json)) {
                    return [2 /*return*/];
                }
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                markRefPaths(json);
                definitionParser = new json_schema_ref_parser_1.default();
                return [4 /*yield*/, definitionParser.dereference(json, {
                        resolve: {
                            file: refPathResolver(path.dirname(jsonFilePath))
                        }
                    })];
            case 2: return [2 /*return*/, _a.sent()];
            case 3:
                e_1 = _a.sent();
                trace = trace || console;
                trace.error("error in processing file [" + jsonFilePath + "]");
                trace.error(e_1);
                return [2 /*return*/, Promise.resolve()];
            case 4: return [2 /*return*/];
        }
    });
}); };
//# sourceMappingURL=json-ref-parser.js.map
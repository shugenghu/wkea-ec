{"version":3,"file":"io.js","sourceRoot":"","sources":["../../../src/server/io.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable:no-var-requires no-shadowed-variable\nimport axios, { AxiosRequestConfig } from 'axios';\nimport * as fs from 'fs-extra';\nimport { IOptions } from 'glob';\nimport { Validator } from 'jsonschema';\nimport * as path from 'path';\nimport { promisify } from 'util';\nimport { trace as Tracer } from './console-trace';\n\nexport type FunctionReturn<TIn = undefined, TOut = undefined> = (input: TIn) => TOut;\n\nexport const safeReadFile = async (filePath: string, traceToUse: { error: Function } = Tracer): Promise<string> => {\n    try {\n        // tslint:disable-next-line:no-any\n        return fs.readFile(filePath, 'utf8').catch((reason: any) => {\n            throw new Error(reason);\n        });\n    } catch (error) {\n        traceToUse.error(`Error reading ${filePath.toString()}`);\n        traceToUse.error(error);\n        return '';\n    }\n};\n\nexport const safeReadFileSync = (filePath: string, traceToUse: { error: Function } = Tracer): string => {\n    try {\n        return fs.readFileSync(filePath, 'utf8');\n    } catch (error) {\n        return '';\n    }\n};\n\n// tslint:disable-next-line:no-require-imports\nconst glob = require('glob');\nconst globAsync = promisify(glob);\n\n/**\n * Utility function to async check if file exists but returns path of it does, false if it doesn't\n * @param filePath file path to check\n */\nexport const safeFileExists = async (\n    filePath: string,\n    trace?: {\n        debug: FunctionReturn<string, void>;\n        error: FunctionReturn<string, void>;\n    }\n): Promise<boolean | string> => {\n    const logger = trace || Tracer;\n    const errLogger: FunctionReturn<string, void> = <FunctionReturn<string, void>>(<unknown>logger.error) || Tracer.error;\n    return new Promise((resolve: (pathToFileThatExists: string | boolean) => void, reject: () => void) => {\n        if (!filePath) {\n            resolve(false);\n        }\n\n        fs.access(filePath, fs.constants.R_OK, (err: NodeJS.ErrnoException) => {\n            if (err) {\n                if (process.env.NODE_ENV === 'development') {\n                    logger.debug(`Requested file ${filePath} doesn't exist ${err}`);\n                }\n                resolve(false);\n            }\n            resolve(filePath);\n        });\n        // tslint:disable-next-line:no-any\n    }).catch((err: any) => {\n        errLogger(err);\n        return false;\n    });\n};\n\n/**\n * Utility function to sync check if file exists but returns path of it does, false if it doesn't\n * @param filePath file path to check\n */\nexport const safeFileExistsSync = (filePath: string): boolean => {\n    try {\n        return fs.existsSync(filePath);\n    } catch (err) {\n        return false;\n    }\n};\n\nexport async function asyncForEach(array: unknown[], callback: Function): Promise<void> {\n    for (let index = 0; index < array.length; index++) {\n        await callback(array[index], index, array);\n    }\n}\n\n// Helper function for parsing/normalizing json, exported\nexport const safeParseJson = <T extends object>(content: string, trace?: { error: Function }): T | null => {\n    try {\n        return typeof content === 'string' ? <T>JSON.parse(content) : <T>content;\n    } catch (error) {\n        trace = trace || Tracer;\n        trace.error(new Error(`JSON Parsing failed for content:\\n ${content}`), error);\n        return null;\n    }\n};\n\n/**\n * Implementation to safely read a file and try to parse JSON. If the file does not exist or there is some issue,\n * undefined is returned which is NOT valid JSON and should be checked.\n *\n * @param filePath Path of the file to try to read and parse\n * @param trace optional trace logger to use while reading file\n */\nexport const safeReadJson = async <T extends object>(filePath: string, trace?: { error: Function }): Promise<T | undefined> => {\n    try {\n        if (await safeFileExists(filePath)) {\n            return <T>JSON.parse(await fs.readFile(filePath, 'utf8'));\n        }\n    } catch (error) {\n        trace = trace || console;\n        trace.error(new Error(`JSON fetch failed in safeReadJson with path: [${filePath}]`));\n        trace.error(error);\n    }\n\n    return undefined;\n};\n\nexport const safeReadJsonSync = <T extends object>(filePath: string, trace?: { debug: Function; error: Function }): T | undefined => {\n    try {\n        if (safeFileExistsSync(filePath)) {\n            return <T>fs.readJSONSync(filePath);\n        }\n    } catch (error) {\n        trace = trace || Tracer;\n        if (error.code === 'ENOENT') {\n            trace.debug(`file not found at [${filePath}]`);\n            return undefined;\n        }\n\n        trace.error(new Error(`JSON fetch failed in safeReadJsonSync with path: [${path}]`));\n        trace.error(error);\n    }\n\n    return undefined;\n};\n\n/**\n * Writes starter pack initialization data to file\n */\n// tslint:disable-next-line:no-any\nexport const safeWriteJson = async (\n    filePath: string,\n    data: object,\n    trace?: { error: Function },\n    spacing?: string | number\n): Promise<boolean> => {\n    try {\n        const isFileExists = await safeFileExists(filePath);\n        if (!isFileExists) {\n            await fs.mkdirp(path.dirname(filePath));\n        }\n        await fs.writeFile(filePath, JSON.stringify(data, null, spacing || 2), 'utf8');\n        return true;\n    } catch (error) {\n        trace = trace || Tracer;\n        trace.error(new Error(`JSON fetch fails for [${filePath}]`), error);\n        trace.error(error);\n        return false;\n    }\n};\n\n/**\n * Writes starter pack initialization data to file\n */\n// tslint:disable-next-line:no-any\nexport const safeWriteJS = async (filePath: string, data: string[], trace?: { error: Function }): Promise<boolean> => {\n    try {\n        const isFileExists = await safeFileExists(filePath);\n        if (!isFileExists) {\n            await fs.mkdirp(path.dirname(filePath));\n        }\n        await fs.writeFile(filePath, data.join('\\n'), 'utf8');\n        return true;\n    } catch (error) {\n        trace = trace || Tracer;\n        trace.error(new Error(`------ JS fetch fails for [${filePath}]`), error);\n        return false;\n    }\n};\n\nexport const safeGetAllFilesPath = async (globFilePattern: string | string[], options?: IOptions): Promise<string[]> => {\n    const getPaths = async (pattern: string) => {\n        try {\n            Tracer.debug(`Tracing all file with path '${pattern}'`);\n            const filePaths = await globAsync(pattern, options);\n            Tracer.debug(filePaths);\n            return filePaths;\n        } catch (error) {\n            Tracer.error(error);\n            return [];\n        }\n    };\n\n    let paths: string[] = [];\n    if (Array.isArray(globFilePattern)) {\n        const promises = globFilePattern.map(getPaths);\n\n        await promises\n            .reduce(async (previousTask, currentTask, result) => {\n                const prevOutput = await previousTask;\n                const currentOutput = await currentTask;\n                return [...prevOutput, ...currentOutput];\n            }, Promise.resolve(promises[0]))\n            .then(results => (paths = Array.from(new Set(results))));\n    } else {\n        paths = await getPaths(globFilePattern);\n    }\n\n    return paths;\n};\n\nexport const safeGetAllFilesPathSync = (\n    globFilePattern: string,\n    trace?: { error: Function; info: Function },\n    options?: IOptions\n): string[] => {\n    trace = trace || Tracer;\n    try {\n        trace.info(`Tracing all definition file with path '${globFilePattern}'`);\n        const filePaths = glob.sync(globFilePattern, options);\n        trace.info(filePaths);\n        return filePaths;\n    } catch (error) {\n        trace.error(error);\n        return [];\n    }\n};\n\nexport const isDirectory = (source: string) => fs.lstatSync(source).isDirectory() || fs.lstatSync(source).isSymbolicLink();\nexport const getDirectories = (source: string) => fs.readdirSync(source).filter((name: string) => isDirectory(path.join(source, name)));\n\n// tslint:disable-next-line:no-any\nexport const runSchemaValidationWithNestedError = (validator: Validator, runValidationOn: any, schema: any) => {\n    return validator.validate(runValidationOn, schema, { nestedErrors: true });\n};\n/**\n * Checks to see if the specified path is a file\n * @param source Fully qualified path\n */\nexport const isFileSync = (source: string | null | undefined) => source && fs.existsSync(source) && fs.lstatSync(source).isFile();\n\n/**\n * Returns all files in a directory\n * @param sourceDir Directory\n */\nexport const getFilesInDirSync = (sourceDir: string) =>\n    fs.readdirSync(sourceDir).filter((name: string) => isFileSync(path.join(sourceDir, name)));\n\n/**\n * Will write a file in an async way and attempt to create all directories that do not exist.  Any error\n * is gracefully eaten and printed to console\n *\n * @param file file path\n * @param data data to write\n * @param options options\n */\n\n// tslint:disable:no-any\nexport const safeWriteFile = async (file: string, data: any, options?: fs.WriteFileOptions | string): Promise<void> => {\n    Tracer.debug(`Writing file ${file}.`);\n    return fs\n        .outputFile(file, data, options)\n        .then(() => {\n            Tracer.debug(`Successfully wrote '${file}'.`);\n        })\n        .catch((err: any) => {\n            Tracer.error(`Error writing '${file}'`);\n            Tracer.error(err);\n        });\n};\n\n/**\n * Returns true if the environment is detected to be yarn workspaces env and cli template has been hoisted\n */\nexport const isCliTemplateHoisted = () => {\n    const msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce/cli-template-internal');\n    return !fs.existsSync(msdyn365ModuleDir);\n};\n\n/**\n * Returns true if the environment is detected to be yarn workspaces env and MSDyn365 Commerce Modules has been hoisted\n */\nexport const isMSDyn365CommerceModulesHoisted = () => {\n    const msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce-modules');\n    return !fs.existsSync(msdyn365ModuleDir);\n};\n\n/**\n * Returns true if the environment is detected to be yarn workspaces env and MSDyn365 Commerce has been hoisted\n */\nexport const isMSDyn365CommerceHoisted = () => {\n    const msdyn365ModuleDir = path.resolve(process.cwd(), 'node_modules/@msdyn365-commerce');\n    return !fs.existsSync(msdyn365ModuleDir);\n};\n\n/**\n * Returns the hoisted node_modules directory\n * Assumes the node modules are two levels above\n * node_modules\n * packages\n *     --> module\n *         ---> process.cwd()\n */\nexport const getHoistedNodeModules = () => {\n    return path.resolve(process.cwd(), '../../', 'node_modules');\n};\n\n/**\n * Gets the current version of a pacakage\n * @param packageNamespace\n * @param packageName\n * @param errorOnFailure\n */\nexport const getVersionForPackage = (packageNamespace: string, packageName: string, options: { errorOnFailure: boolean }): string => {\n    const appDirectory = fs.realpathSync(process.cwd());\n    const resolveApp = (relativePath: string) => path.resolve(appDirectory, relativePath);\n    const paths = {\n        appNodeModules: resolveApp('node_modules')\n    };\n\n    try {\n        let pathToPackage = path.join(paths.appNodeModules, packageNamespace, packageName);\n        // Hoisted check\n        if (!fs.existsSync(path.join(pathToPackage, 'package.json'))) {\n            pathToPackage = path.resolve(paths.appNodeModules, '../../../node_modules/', packageNamespace, packageName);\n        }\n        if (fs.existsSync(path.join(pathToPackage, 'package.json'))) {\n            const packageInfo = JSON.parse(fs.readFileSync(path.join(pathToPackage, 'package.json'), 'utf8'));\n            return packageInfo.version ? packageInfo.version : '--';\n        } else {\n            throw new Error(`Package ${packageNamespace}/${packageName} does not exist in node_modules`);\n        }\n    } catch (e) {\n        if (options.errorOnFailure) {\n            console.error(e);\n            console.error(`Error in resolving current version of ${packageNamespace}/${packageName}`);\n        } else {\n            console.warn(\n                `Unable to resolve current version of ${packageNamespace}/${packageName}. Check to see if the package is installed.`\n            );\n        }\n        return '--';\n    }\n};\n\n/**\n * Gets the Retail Cloud Scale Unit (RCSU) version info of a partner\n * @param baseUrl Base url from the partners .evn file\n */\nexport const getRCSUversion = async (baseUrl: string): Promise<string> => {\n    if (baseUrl) {\n        try {\n            const url = `${baseUrl}Commerce/GetEnvironmentConfiguration`;\n            const requestConfig: AxiosRequestConfig = {\n                headers: { 'Content-Type': 'application/json' }\n            };\n            const res = await axios.get(url, requestConfig);\n            if (res.data && res.data.BaseVersion) {\n                return res.data.BaseVersion;\n            } else {\n                return '--';\n            }\n        } catch (err) {\n            return '--';\n        }\n    } else {\n        return '--';\n    }\n};\n"]}
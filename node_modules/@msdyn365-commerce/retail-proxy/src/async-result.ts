/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

// NOTE: no-any is disabled intentionally, as promises require valid use of the any type
// tslint:disable:no-any
import { observable } from 'mobx';
import { IODataMetadata } from './interfaces/IODataMetadata';

export type AsyncResultStatus = 'LOADING' | 'SUCCESS' | 'FAILED';

export const isAsyncResult = (item: { toString(): string }): item is AsyncResult<unknown> => {
    return item && item.toString && typeof item.toString === 'function' && item.toString() === `[object AsyncResult]`;
};

/**
 * Utility Methods For AsyncResult
 */
const isThenable = (obj: any) => obj && typeof obj === 'object' && typeof obj.then === 'function';

/**
 * TYPES & INTERFACES
 */
interface IHandler<TIn, TOut> {
    onSuccess: HandlerOnSuccess<TIn, TOut>;
    onFail: HandlerOnFail<TOut>;
}

type HandlerOnSuccess<TIn, TOut> = (value: TIn) => TOut | PromiseLike<TOut>;
type HandlerOnFail<TOut = never> = (reason: any) => TOut | PromiseLike<TOut>;

type Resolve<T> = (value?: T | PromiseLike<T>) => void;
type Reject = (value?: any) => void;

/**
 * AsyncResult Class
 * Promise-style class which allows for observation of the status of the promise
 * and it's result during and after is execution.
 */
export class AsyncResult<T> implements Promise<T> {
    @observable public result?: T;

    @observable public status: AsyncResultStatus = 'LOADING';

    @observable public error?: Error;

    @observable public metadata: IODataMetadata = {};

    // @ts-ignore
    private _type: string = 'AsyncResult';

    private _handlers: Array<IHandler<T, any>> = [];

    public static resolve<U = any>(value?: U | PromiseLike<U>): AsyncResult<U> {
        return new AsyncResult<U>(resolve => {
            return resolve(value);
        });
    }

    public static reject<U>(reason?: any): AsyncResult<U> {
        return new AsyncResult<U>((resolve, reject) => {
            return reject(reason);
        });
    }

    /**
     * Class constructor, which starts running the passed executor
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    constructor(executor: (resolve: Resolve<T>, reject: Reject) => void) {
        try {
            executor(this._resolve, this._reject);
        } catch (e) {
            this._reject(e);
        }
    }

    /**
     * Method that allows for an executor to be passed to the promise after inital execution,
     * essentially "rerunning" the promise.
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    public run(executor: (resolve: Resolve<T>, reject: Reject) => void): void {
        this.status = 'LOADING';
        this.error = undefined;
        try {
            executor(this._resolve, this._reject);
        } catch (e) {
            this._reject(e);
        }
    }

    /**
     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult
     * @param onSuccess Callback to be run on successful completion of executor
     * @param onFail Callback to be run when executor cannot be successfully completed
     */
    public then<TResult1 = T, TResult2 = never>(
        onSuccess?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
        onFail?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): AsyncResult<TResult1 | TResult2> {
        const asyncResult = new AsyncResult<TResult1 | TResult2>((resolve, reject) => {
            return this._attachHandler({
                onSuccess: result => {
                    if (!onSuccess) {
                        // @ts-ignore: Type overlap issue
                        return resolve(result);
                    }

                    try {
                        return resolve(onSuccess(result));
                    } catch (e) {
                        return reject(e);
                    }
                },
                onFail: reason => {
                    if (!onFail) {
                        return reject(reason);
                    }

                    try {
                        return resolve(onFail(reason));
                    } catch (e) {
                        return reject(e);
                    }
                }
            });
        });

        // Always pass the metadata on a then
        asyncResult.metadata = this.metadata;

        return asyncResult;
    }

    /**
     * Hook to allow callback on the unsuccessful run of an executor
     * @param onFail Callback to run when executor fails
     */
    public catch<TResult = never>(onFail?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): AsyncResult<T | TResult> {
        const defaultThen = (value: any) => value;
        return this.then(defaultThen, onFail);
    }

    /**
     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor
     * @param callback Callback to be run after original AsyncResult is completed
     */
    public finally(onfinally?: (() => void) | undefined | null): AsyncResult<T> {
        return new AsyncResult((resolve, reject) => {
            let value: T | any;
            let failed: Boolean = false;

            return this.then(
                result => {
                    value = result;
                    return onfinally();
                },
                reason => {
                    failed = true;
                    value = reason;
                    return onfinally();
                }
            ).then(() => {
                if (failed) {
                    return reject(value);
                }

                return resolve(value);
            });
        });
    }

    public toString(): string {
        return `[object AsyncResult]`;
    }

    get [Symbol.toStringTag](): string {
        return '[object AsyncResult]';
    }

    private _attachHandler = (handler: IHandler<T, any>) => {
        this._handlers.push(handler);

        this._executeHandlers();
    }

    private _executeHandlers = () => {
        if (this.status === 'LOADING') {
            return;
        }

        for (const handler of this._handlers) {
            if (this.status === 'FAILED') {
                handler.onFail(this.error);
            } else {
                handler.onSuccess(this.result as T);
            }
        }

        this._handlers = [];
    }

    private _resolve = (value?: T | PromiseLike<T>) => {
        return this._updateStatus(value, 'SUCCESS');
    }

    private _reject = (reason: any) => {
        return this._updateStatus(reason, 'FAILED', true);
    }

    private _updateStatus(result: T | any, newStatus: AsyncResultStatus, isError: Boolean = false): void {
        // Wrap in setTimeout to ensure fully synchronous handlers
        // are still returned AFTER initial class construction
        setTimeout(() => {
            if (this.status !== 'LOADING') {
                return null;
            }

            if (isThenable(result)) {
                return (result as PromiseLike<T>).then(this._resolve, this._reject);
            }

            if (isError) {
                this.error = result;
            } else {
                this.result = result;
            }

            this.status = newStatus;

            return this._executeHandlers();
        }, 0);
    }
}

/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import axios from 'axios';
import { jsonHandler } from './handler';

/**
 * OData request interface.
 */
export interface IODataRequest {
    /**
     * OData endpoint URI
     */
    requestUri: string;

    /**
     * HTTP method (GET, POST, PUT, DELETE)
     */
    method: string;

    /**
     * Payload of the request (in intermediate format)
     */
    data: any;

    /**
     * Object that contains HTTP headers as name value pairs
     */
    headers?: Object;

    /**
     * (Optional) Username to send for BASIC authentication
     */
    user?: string;

    /**
     * (Optional) Password to send for BASIC authentication
     */
    password?: string;

    /**
     * (Optional) Whether or not to use cross domain cookies.
     */
    useCrossDomainCookies?: boolean;
}

const normalHeaders = {
    accept: 'Accept',
    'content-type': 'Content-Type',
    'odata-version': 'OData-Version',
    'odata-maxversion': 'OData-MaxVersion'
};

const isAbsoluteUrl = url => {
    /// <summary>Checks whether the specified URL is an absolute URL.</summary>
    /// <param name="url" type="String">URL to check.</param>
    /// <returns type="Boolean">true if the url is an absolute URL; false otherwise.</returns>

    return url.indexOf('http://') === 0 || url.indexOf('https://') === 0 || url.indexOf('file://') === 0;
};

const normalizeHeaders = headers => {
    /// <summary>Normalizes headers so they can be found with consistent casing.</summary>
    /// <param name="headers" type="Object">Dictionary of name/value pairs.</param>

    for (const name in headers) {
        if (headers.hasOwnProperty(name)) {
            const lowerName = name.toLowerCase();
            const normalName = normalHeaders[lowerName];
            if (normalName && name !== normalName) {
                const val = headers[name];
                delete headers[name];
                headers[normalName] = val;
            }
        }
    }
};

const defaultHttpClient = {
    callbackParameterName: '$callback',
    formatQueryString: '$format=json',
    enableJsonpCallback: false,

    request(request, success, error) {
        /// <summary>Performs a network request.</summary>
        /// <param name="request" type="Object">Request description.</request>
        /// <param name="success" type="Function">Success callback with the response object.</param>
        /// <param name="error" type="Function">Error callback with an error object.</param>
        /// <returns type="Object">Object with an 'abort' method for the operation.</returns>
        const result = { abort: null, handleTimeout: null };

        const cancelToken = axios.CancelToken.source();

        let done = false;
        result.abort = () => {
            if (done) {
                return;
            }
            done = true;
            cancelToken.cancel('Request aborted');
            error({ message: 'Request aborted' });
        };

        request.handleTimeout = () => {
            if (!done) {
                done = true;
                cancelToken.cancel('Request aborted');
                error({ message: 'Request timed out' });
            }
        };

        const url = request.requestUri;
        const enableJsonpCallback = request.enableJsonpCallback || false;
        if (!enableJsonpCallback || !isAbsoluteUrl(url)) {
            let authenticationCreds;
            if (request.user) {
                authenticationCreds = {
                    username: request.user,
                    password: request.password || ''
                };
            }
            // console.log('\r\nDataServiceRequest - \r\n\n', request);
            axios
                .request({
                    method: request.method || 'get',
                    url,
                    data: request.body,
                    auth: authenticationCreds,
                    headers: request.headers || {},
                    timeout: request.timeoutMS || 10000,
                    cancelToken: cancelToken.token
                })
                .then(axiosResponse => {
                    const response = {
                        requestUri: url,
                        statusCode: axiosResponse.status,
                        statusText: axiosResponse.statusText,
                        headers: axiosResponse.headers,
                        body: axiosResponse.data
                    };
                    done = true;
                    success(response);
                })
                .catch(axiosError => {
                    const response = {
                        requestUri: url,
                        statusCode: axiosError.response ? parseInt(axiosError.response.status, 10) : 0,
                        statusText: axiosError.name,
                        body: axiosError.message,
                        data: axiosError.response ? axiosError.response.data : {},
                        headers: axiosError.response ? axiosError.response.headers : {}
                    };
                    error({ message: 'HTTP request failed', request, response });
                });
        } else {
            error({
                message: 'Only requests to non-absolute urls are supported at this time without JSONP callback'
            });
        }
        return result;
    }
};

const prepareRequest = (request, handler, context) => {
    /// <summary>Prepares a request object so that it can be sent through the network.</summary>
    /// <param name="request">Object that represents the request to be sent.</param>
    /// <param name="handler">Handler for data serialization</param>
    /// <param name="context">Context used for preparing the request</param>

    // Default to GET if no method has been specified.
    if (!request.method) {
        request.method = 'GET';
    }

    if (!request.headers) {
        request.headers = {};
    } else {
        normalizeHeaders(request.headers);
    }

    if (request.headers.Accept === undefined) {
        request.headers.Accept = handler.accept;
    }

    if (request.data && request.body === undefined) {
        handler.write(request, context);
    }

    if (!request.headers['OData-MaxVersion']) {
        request.headers['OData-MaxVersion'] = handler.maxDataServiceVersion || '4.0';
    }
};

const invokeRequest = (request, success, error, handler, httpClient, context) => {
    /// <summary>Sends a request containing OData payload to a server.</summary>
    /// <param name="request">Object that represents the request to be sent..</param>
    /// <param name="success">Callback for a successful read operation.</param>
    /// <param name="error">Callback for handling errors.</param>
    /// <param name="handler">Handler for data serialization.</param>
    /// <param name="httpClient">HTTP client layer.</param>
    /// <param name="context">Context used for processing the request</param>

    return httpClient.request(
        request,
        response => {
            try {
                if (response.headers) {
                    normalizeHeaders(response.headers);
                }

                if (response.data === undefined && response.statusCode !== 204) {
                    if (!handler.read(response, context)) {
                        throw { message: 'Handler could not parse response.' };
                    }
                }
            } catch (err) {
                if (err.request === undefined) {
                    err.request = request;
                }
                if (err.response === undefined) {
                    err.response = response;
                }
                error(err);
                return;
            }

            success(response.data, response);
        },
        error
    );
};

export const ODataHttpRequest = (request, success, error) => {
    /// <summary>Sends a request containing OData payload to a server.</summary>
    /// <param name="request" type="Object">Object that represents the request to be sent.</param>
    /// <param name="success" type="Function" optional="true">Callback for a successful read operation.</param>
    /// <param name="error" type="Function" optional="true">Callback for handling errors.</param>
    /// <param name="handler" type="Object" optional="true">Handler for data serialization.</param>
    /// <param name="httpClient" type="Object" optional="true">HTTP client layer.</param>
    /// <param name="metadata" type="Object" optional="true">Conceptual metadata for this request.</param>

    success = success || (data => process.env.NODE_ENV !== 'production' && console.log(JSON.stringify(data)));
    error =
        error ||
        (err => {
            throw err;
        });

    // Augment the request with additional defaults.
    request.recognizeDates = request.recognizeDates || false;
    request.useJsonLight = request.useJsonLight || false;
    request.inferJsonLightFeedAsObject = request.inferJsonLightFeedAsObject || false;
    request.callbackParameterName = request.callbackParameterName || defaultHttpClient.callbackParameterName;
    request.formatQueryString = request.formatQueryString || defaultHttpClient.formatQueryString;
    request.enableJsonpCallback = request.enableJsonpCallback || defaultHttpClient.enableJsonpCallback;

    // Create the base context for read/write operations, also specifying complete settings.
    const context = {
        recognizeDates: request.recognizeDates,
        callbackParameterName: request.callbackParameterName,
        formatQueryString: request.formatQueryString,
        enableJsonpCallback: request.enableJsonpCallback,
        useJsonLight: request.useJsonLight,
        inferJsonLightFeedAsObject: request.inferJsonLightFeedAsObject
    };

    try {
        prepareRequest(request, jsonHandler, context);
        return invokeRequest(request, success, error, jsonHandler, defaultHttpClient, context);
    } catch (err) {
        error(err);
    }
};

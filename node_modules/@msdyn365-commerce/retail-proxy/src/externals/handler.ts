/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

export const MAX_DATA_SERVICE_VERSION = '4.0';
export const jsonMediaType = 'application/json';

const CONTENT_TYPE_HEADER_NAME = 'Content-Type';
const ODATA_VERSION = 'OData-Version';
const ODATA_MAX_VERSION = 'OData-MaxVersion';

const contentType = str => {
    /// <summary>Parses a string into an object with media type and properties.</summary>
    /// <param name="str" type="String">String with media type to parse.</param>
    /// <returns>null if the string is empty; an object with 'mediaType' and a 'properties' dictionary otherwise.</returns>

    if (!str) {
        return null;
    }

    const contentTypeParts = str.split(';');
    const properties = {};

    let i;
    let len;
    for (i = 1, len = contentTypeParts.length; i < len; i++) {
        const contentTypeParams = contentTypeParts[i].split('=');
        properties[contentTypeParams[0].trim()] = contentTypeParams[1];
    }

    return { mediaType: contentTypeParts[0].trim(), properties };
};

export const jsonContentType = contentType(jsonMediaType);

const contentTypeToString = contentTypeObj => {
    /// <summary>Serializes an object with media type and properties dictionary into a string.</summary>
    /// <param name="contentType">Object with media type and properties dictionary to serialize.</param>
    /// <returns>String representation of the media type object; undefined if contentType is null or undefined.</returns>

    if (!contentTypeObj) {
        return undefined;
    }

    let result = contentTypeObj.mediaType;
    for (const property in contentTypeObj.properties) {
        if (contentTypeObj.properties.hasOwnProperty(property)) {
            result += ';' + property + '=' + contentTypeObj.properties[property];
        }
    }
    return result;
};

const createReadWriteContext = (contentTypeStr, dataServiceVersion, context, handler) => {
    /// <summary>Creates an object that is going to be used as the context for the handler's parser and serializer.</summary>
    /// <param name="contentType">Object with media type and properties dictionary.</param>
    /// <param name="dataServiceVersion" type="String">String indicating the version of the protocol to use.</param>
    /// <param name="context">Operation context.</param>
    /// <param name="handler">Handler object that is processing a resquest or response.</param>
    /// <returns>Context object.</returns>

    // First create a clone
    const rwContext = { ...context };

    // And then override with provided parameters
    rwContext['contentType'] = contentTypeStr || jsonContentType;
    rwContext['dataServiceVersion'] = dataServiceVersion;
    rwContext['handler'] = handler;

    return rwContext;
};

const versionRE = /^\s?(\d+\.\d+);?.*$/;
const getDataServiceVersion = headerVersion => {
    /// <summary>Gets the value of the OData-Version header from a request or response.</summary>
    /// <param name="requestOrResponse">Object representing a request or a response.</param>
    /// <returns type="String">Data service version; undefined if the header cannot be found.</returns>

    if (headerVersion) {
        const matches = versionRE.exec(headerVersion);
        if (matches && matches.length) {
            return matches[1];
        }
    }
};

const handlerRead = (handler, response, context) => {
    /// <summary>Invokes the parser associated with a handler for reading the payload of a HTTP response.</summary>
    /// <param name="handler">Handler object that is processing the response.</param>
    /// <param name="parseCallback" type="Function">Parser function that will process the response payload.</param>
    /// <param name="response">HTTP response whose payload is going to be processed.</param>
    /// <param name="context">Object used as the context for processing the response.</param>
    /// <returns type="Boolean">True if the handler processed the response payload and the response.data property was set; false otherwise.</returns>

    if (!response || !response.headers) {
        return false;
    }

    const cType = contentType(response.headers[CONTENT_TYPE_HEADER_NAME]);
    const version = getDataServiceVersion(response) || '';
    const body = response.body;

    if (!body) {
        return false;
    }

    if (jsonMediaType.indexOf(cType.mediaType) >= 0) {
        const readContext = createReadWriteContext(cType, version, context, handler);
        readContext.response = response;
        response.data = typeof body === 'string' ? JSON.parse(body) : body;
        return response.data !== undefined;
    }

    return false;
};

const maxVersion = (left, right) => {
    /// <summary>Compares to version strings and returns the higher one.</summary>
    /// <param name="left" type="String">Version string in the form "major.minor.rev"</param>
    /// <param name="right" type="String">Version string in the form "major.minor.rev"</param>
    /// <returns type="String">The higher version string.</returns>

    if (left === right) {
        return left;
    }

    const leftParts = left.split('.');
    const rightParts = right.split('.');

    const len = leftParts.length >= rightParts.length ? leftParts.length : rightParts.length;

    for (let i = 0; i < len; i++) {
        const leftVersion = leftParts[i] && parseInt(leftParts[i], 10);
        const rightVersion = rightParts[i] && parseInt(rightParts[i], 10);
        if (leftVersion > rightVersion) {
            return left;
        }
        if (leftVersion < rightVersion) {
            return right;
        }
    }
};

const handlerWrite = (handler, request, context) => {
    /// <summary>Invokes the serializer associated with a handler for generating the payload of a HTTP request.</summary>
    /// <param name="handler">Handler object that is processing the request.</param>
    /// <param name="serializeCallback" type="Function">Serializer function that will generate the request payload.</param>
    /// <param name="response">HTTP request whose payload is going to be generated.</param>
    /// <param name="context">Object used as the context for serializing the request.</param>
    /// <returns type="Boolean">True if the handler serialized the request payload and the request.body property was set; false otherwise.</returns>
    if (!request || !request.headers) {
        return false;
    }

    const cType = contentType(request.headers[CONTENT_TYPE_HEADER_NAME]);
    const version = getDataServiceVersion(request.headers[ODATA_VERSION]);

    if (!cType || jsonMediaType.indexOf(cType.mediaType)) {
        const writeContext = createReadWriteContext(cType, version, context, handler);
        writeContext.request = request;
        request.body = request.data;

        if (request.body !== undefined) {
            request.headers[ODATA_VERSION] = version ? maxVersion(version, '4.0') : '4.0';
            request.headers.ContentType = request.headers[CONTENT_TYPE_HEADER_NAME] || contentTypeToString(writeContext.contentType);
            request.headers[ODATA_MAX_VERSION] = request.headers[ODATA_MAX_VERSION] || handler.maxDataServiceVersion;
            return true;
        }
    }

    return false;
};

export const jsonHandler = {
    accept: jsonMediaType,
    maxDataServiceVersion: MAX_DATA_SERVICE_VERSION,
    read(response, context) {
        return handlerRead(this, response, context);
    },

    write(request, context) {
        return handlerWrite(this, request, context);
    }
};

/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

const EDM = 'Edm.';
const EDM_BOOLEAN = EDM + 'Boolean';
const EDM_BYTE = EDM + 'Byte';
const EDM_DATETIME = EDM + 'DateTime';
const EDM_DATETIMEOFFSET = EDM + 'DateTimeOffset';
const EDM_DECIMAL = EDM + 'Decimal';
const EDM_DOUBLE = EDM + 'Double';
const EDM_INT16 = EDM + 'Int16';
const EDM_INT32 = EDM + 'Int32';
const EDM_INT64 = EDM + 'Int64';
const EDM_SBYTE = EDM + 'SByte';
const EDM_SINGLE = EDM + 'Single';
const EDM_TIME = EDM + 'Time';

const parseBool = propertyValue => {
    /// <summary>Parses a string into a boolean value.</summary>
    /// <param name="propertyValue">Value to parse.</param>
    /// <returns type="Boolean">true if the property value is 'true'; false otherwise.</returns>

    if (typeof propertyValue === 'boolean') {
        return propertyValue;
    }

    return typeof propertyValue === 'string' && propertyValue.toLowerCase() === 'true';
};

const formatNumberWidth = (value, width, append) => {
    /// <summary>Formats the specified value to the given width.</summary>
    /// <param name="value" type="Number">Number to format (non-negative).</param>
    /// <param name="width" type="Number">Minimum width for number.</param>
    /// <param name="append" type="Boolean">Flag indicating if the value is padded at the beginning (false) or at the end (true).</param>
    /// <returns type="String">Text representation.</returns>
    let result = value.toString(10);
    while (result.length < width) {
        if (append) {
            result += '0';
        } else {
            result = '0' + result;
        }
    }

    return result;
};

const parseTimezone = timezone => {
    /// <summary>Parses a timezone description in (+|-)nn:nn format.</summary>
    /// <param name="timezone" type="String">Timezone offset.</param>
    /// <returns type="Object">
    /// An object with a (d)irection property of 1 for + and -1 for -,
    /// offset (h)ours and offset (m)inutes.
    /// </returns>

    let direction = timezone.substring(0, 1);
    direction = direction === '+' ? 1 : -1;

    const offsetHours = parseInt(timezone.substring(1), 10);
    const offsetMinutes = parseInt(timezone.substring(timezone.indexOf(':') + 1), 10);
    return { d: direction, h: offsetHours, m: offsetMinutes };
};

// The captured indices for this expression are:
// 0       - complete input
// 1       - direction
// 2,3,4   - years, months, days
// 5,6,7,8 - hours, minutes, seconds, miliseconds
const parseTimeRE = /^([+-])?P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)(?:\.(\d+))?S)?)?/;

// The captured indices for this expression are:
// 0     - complete input
// 1,2,3 - year with optional minus sign, month, day
// 4,5,6 - hours, minutes, seconds
// 7     - optional milliseconds
// 8     - everything else (presumably offset information)
const parseDateTimeRE = /^(-?\d{4,})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(.*)$/;

const getCanonicalTimezone = timezone => {
    /// <summary>Gets the canonical timezone representation.</summary>
    /// <param name="timezone" type="String">Timezone representation.</param>
    /// <returns type="String">An 'Z' string if the timezone is absent or 0; the timezone otherwise.</returns>

    return !timezone || timezone === 'Z' || timezone === '+00:00' || timezone === '-00:00' ? 'Z' : timezone;
};

const parseDuration = duration => {
    /// <summary>Parses a string in xsd:duration format.</summary>
    /// <param name="duration" type="String">Duration value.</param>
    /// <remarks>
    /// This method will throw an exception if the input string has a year or a month component.
    /// </remarks>
    /// <returns type="Object">Object representing the time</returns>

    const parts = parseTimeRE.exec(duration);

    if (parts === null) {
        throw { message: 'Invalid duration value.' };
    }

    const years = parts[2] || '0';
    const months = parts[3] || '0';
    const days = parseInt(parts[4], 10) || 0;
    const hours = parseInt(parts[5], 10) || 0;
    const minutes = parseInt(parts[6], 10) || 0;
    const seconds = parseFloat(parts[7]) || 0;

    if (years !== '0' || months !== '0') {
        throw { message: 'Unsupported duration value.' };
    }

    let ms: any = parts[8];
    let ns: any = 0;
    if (!ms) {
        ms = 0;
    } else {
        if (ms.length > 7) {
            throw { message: 'Cannot parse duration value to given precision.' };
        }

        ns = formatNumberWidth(ms.substring(3), 4, true);
        ms = formatNumberWidth(ms.substring(0, 3), 3, true);

        ms = parseInt(ms, 10);
        ns = parseInt(ns, 10);
    }

    ms += seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;

    if (parts[1] === '-') {
        ms = -ms;
    }

    const result: any = { ms, __edmType: 'Edm.Time' };

    if (ns) {
        result.ns = ns;
    }
    return result;
};

const parseDateTimeOffset = (value, withOffset, nullOnError) => {
    /// <summary>Parses a string into a DateTime value.</summary>
    /// <param name="value" type="String">Value to parse.</param>
    /// <param name="withOffset" type="Boolean">Whether offset is expected.</param>
    /// <returns type="Date">The parsed value.</returns>

    // We cannot parse this in cases of failure to match or if offset information is specified.
    const parts = parseDateTimeRE.exec(value);
    const offset = parts ? getCanonicalTimezone(parts[8]) : null;

    if (!parts || (!withOffset && offset !== 'Z')) {
        if (nullOnError) {
            return null;
        }
        throw { message: 'Invalid date/time value' };
    }

    // Pre-parse years, account for year '0' being invalid in dateTime.
    let year = parseInt(parts[1], 10);
    if (year <= 0) {
        year++;
    }

    // Pre-parse optional milliseconds, fill in default. Fail if value is too precise.
    let ms: any = parts[7];
    let ns: any = 0;
    if (!ms) {
        ms = 0;
    } else {
        if (ms.length > 7) {
            if (nullOnError) {
                return null;
            }
            throw { message: 'Cannot parse date/time value to given precision.' };
        }

        ns = formatNumberWidth(ms.substring(3), 4, true);
        ms = formatNumberWidth(ms.substring(0, 3), 3, true);

        ms = parseInt(ms, 10);
        ns = parseInt(ns, 10);
    }

    // Pre-parse other time components and offset them if necessary.
    let hours = parseInt(parts[4], 10);
    let minutes = parseInt(parts[5], 10);
    const seconds = parseInt(parts[6], 10);
    if (offset !== 'Z') {
        // The offset is reversed to get back the UTC date, which is
        // what the API will eventually have.
        const timezone = parseTimezone(offset);
        const direction = -timezone.d;
        hours += timezone.h * direction;
        minutes += timezone.m * direction;
    }

    // Set the date and time separately with setFullYear, so years 0-99 aren't biased like in Date.UTC.
    const result: any = new Date();
    result.setUTCFullYear(
        year, // Year.
        parseInt(parts[2], 10) - 1, // Month (zero-based for Date.UTC and setFullYear).
        parseInt(parts[3], 10) // Date.
    );
    result.setUTCHours(hours, minutes, seconds, ms);

    if (isNaN(result.valueOf())) {
        if (nullOnError) {
            return null;
        }
        throw { message: 'Invalid date/time value' };
    }

    if (withOffset) {
        result.__edmType = 'Edm.DateTimeOffset';
        result.__offset = offset;
    }

    if (ns) {
        result.__ns = ns;
    }

    return result;
};

export const jsonLightReadStringPropertyValue = (value, propertyType, recognizeDates) => {
    /// <summary>Convertes the value of a string property in a JSON light object to its library representation.</summary>
    /// <param name="value" type="String">String value to convert.</param>
    /// <param name="propertyType" type="String">Type name of the property.</param>
    /// <param name="recognizeDates" type="Boolean" optional="true">Flag indicating whether datetime literal strings should be converted to JavaScript Date objects.</param>
    /// <returns>String property value in its library representation.</returns>

    switch (propertyType) {
        case EDM_BOOLEAN:
            return parseBool(value);
        case EDM_BYTE:
        case EDM_INT16:
        case EDM_INT32:
        case EDM_INT64:
        case EDM_SBYTE:
            return parseInt(value, 10);
        case EDM_DOUBLE:
        case EDM_SINGLE:
        case EDM_DECIMAL:
            return parseFloat(value);
        case EDM_TIME:
            return parseDuration(value);
        case EDM_DATETIME:
            const dateStr = value || '';
            const time = dateStr.substring(dateStr.indexOf('T') + 1);
            const timezoneOffsetIndex = time.indexOf('-');
            timezoneOffsetIndex === -1 ? time.indexOf('+') : timezoneOffsetIndex;

            if (timezoneOffsetIndex !== -1) {
                return parseDateTimeOffset(value, true, /* nullOnError */ false);
            } else {
                return parseDateTimeOffset(value, false, /* nullOnError */ false);
            }
        case EDM_DATETIMEOFFSET:
            return parseDateTimeOffset(value, true, /* nullOnError */ false);
    }

    if (recognizeDates) {
        return (
            parseDateTimeOffset(value, false, /* nullOnError */ true) || parseDateTimeOffset(value, true, /* nullOnError */ true) || value
        );
    }
    return value;
};

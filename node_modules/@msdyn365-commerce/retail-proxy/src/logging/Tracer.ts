/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import { ProxyError } from '../exceptions';
import { EMPTY, format } from '../extensions/StringExtensions';
import { DebuggingConsoleSink } from './ConsoleEventWriter';
import { attachLoggingSink, RetailLogger } from './RetailLogger';

/**
 * The tracer class allows information to be logged on the device for Information, Warning or Error
 * The same method call can be used for each type
 * Example:
 *         Commerce.Proxy.Tracer.Information("Message {0} {1}", ["Arg1", "Arg2"]);     // With parameters to be formatted
 *         Commerce.Proxy.Tracer.Information("Message");                               // Without parameters
 *
 * Example of different tracer logs
 *   Dynamics-Information: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 *   Dynamics-Warning: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 *   Dynamics-Error: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 */

export class Tracer {
    private static TracerDynamics: string = 'Dynamics-';
    private static TracerDynamicsError: string = 'Error: ';

    private static TracingOn: boolean = true;

    private static Counters: any[] = new Array();
    private static Timers: any[] = new Array();

    public static init(): boolean {
        attachLoggingSink(new DebuggingConsoleSink());
        return true;
    }

    public static _initialized: boolean = Tracer.init();

    /**
     * Traces an informational message in the specified format.
     */
    public static Information(informationformat: string, ...args: any[]): void {
        if (Tracer.TracingOn) {
            RetailLogger.genericInfo(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, informationformat, ...args]));
        }
    }

    /**
     * Traces a warning message in the specified format.
     */
    public static Warning(warningFormat: string, ...args: any[]): void {
        if (Tracer.TracingOn) {
            RetailLogger.genericWarning(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, warningFormat, ...args]));
        }
    }

    /**
     * Traces an error message in the specified format.
     */
    public static Error(errorFormat: string, ...args: any[]): void {
        if (Tracer.TracingOn) {
            RetailLogger.genericError(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, errorFormat, ...args]));
        }
    }

    /**
     * Traces an error message in the specified format.
     */
    public static Errors(errors: ProxyError[], formatString: string, ...args: any[]): void {
        if (Tracer.TracingOn && errors !== null && errors.length > 0) {
            let errorMessage: string = '';
            let errorCode: string = '';
            let errorString: string = '';

            errors.forEach(error => {
                errorMessage = error.ErrorMessage || EMPTY;
                errorCode = error.ErrorCode || EMPTY;
                errorString = JSON.stringify(error);
                Tracer.Error(
                    formatString +
                        ' ' +
                        format(' \n ErrorMessage: {0}; \n ErrorCode: {1}; \n ErrorObject: \'{2}\'', errorMessage, errorCode, errorString),
                    args
                );
            });
        }
    }

    public static StartCounter(uniqueFunctionName: string): void {
        let counter;
        if (Tracer.Counters[uniqueFunctionName] === undefined) {
            counter = new PerformanceCounters();
            counter.Name = uniqueFunctionName;
        } else {
            counter = Tracer.Counters[uniqueFunctionName];
        }
        counter.Count += 1;
        Tracer.Counters[uniqueFunctionName] = counter;
        const now = new Date().getTime();
        Tracer.Timers.push(now);
    }

    public static EndCounter(uniqueFunctionName: string): void {
        const now = new Date().getTime();
        const startTime = Tracer.Timers.pop();
        const counter = Tracer.Counters[uniqueFunctionName];
        counter.TotalTime += now - startTime;
    }

    public static DumpCounters() {
        for (const item in Tracer.Counters) {
            if (Tracer.Counters.hasOwnProperty(item)) {
                Tracer.Information(
                    'Method = {0} Number of calls = {1} TotalTime = {2}mS Avg = {3}mS',
                    Tracer.Counters[item].Name,
                    Tracer.Counters[item].Count,
                    Tracer.Counters[item].TotalTime,
                    Tracer.Counters[item].TotalTime / Tracer.Counters[item].Count
                );
            }
        }
    }

    private static GetMessage(type: string, formatString: string, ...args: any[]) {
        const now = '' + new Date().getTime() + 'mS';
        if (Tracer.TracingOn) {
            if (!args) {
                return Tracer.TracerDynamics + type + '\t' + formatString + '\t' + now;
            } else {
                return (
                    Tracer.TracerDynamics + type + '\t' + format.apply(null, [formatString, Array.prototype.slice.call(args)]) + '\t' + now
                );
            }
        }
    }
}

class PerformanceCounters {
    public Name: string;
    public Count: number = 0;
    public TotalTime: number = 0;
}

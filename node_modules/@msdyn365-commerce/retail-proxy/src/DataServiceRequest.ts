/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

// tslint:disable:no-any
import { toJS } from 'mobx';

import { ApiVersion, EntityIdentifier, SortColumn } from './Entities/CommerceTypes.g';

import { AsyncResult, isAsyncResult } from './async-result';

import { BypassCache, CacheType, ICache, ICacheSource, ICallerContext, IDataServiceQueryInternal, IDataServiceRequest } from './Interfaces';
import { RetailLogger, Tracer, Utils } from './logging';

import { ProxyError } from './exceptions';
import { ErrorParser } from './exceptions/ErrorParser';
import {
    convertToString,
    EMPTY,
    format,
    hasElements,
    isEmpty,
    isNullOrWhitespace,
    isObjectNotEmptyOrNull
} from './extensions/StringExtensions';

import { IODataRequest, ODataHttpRequest } from './externals/DataJS.New';
import { ITelemetry, LogLevel } from './interfaces/ITelemetry';

export const ODATA_TOTAL_COUNT_PROPERTY = '@odata.count';
export const ODATA_HAS_NEXT_PAGE_PROPERTY = '@odata.nextLink';
export const GET: string = 'GET';
export const POST: string = 'POST';
export const PATCH: string = 'PATCH';
export const DELETE: string = 'DELETE';
export const GET_FROM_RETURNIDENTIFIER: string = '___GET__FROM__RETURNIDENTIIER___';

const ApiTimeoutInMilliSecond = 10000;
const OPERATINGUNITNUMBER_HEADERNAME = 'OUN';
const AUTHORIZATION_HEADERNAME = 'Authorization';
const ACCEPT_LANGUAGE = 'Accept-Language';
const REQUEST_ID = 'RequestId';
const DEFAULT_HEADER: { [headerName: string]: string } = {
    Prefer: 'return=representation'
};

/***
 * Parses the odata result returned from server.
 *
 * @param {any} data The result returned from server.
 * @param {any} resultType The entity type to parse the result as.
 */
export function parseOdataResult(data: any, resultType: any): any {
    if (!data) {
        return data;
    }

    if (!data.value) {
        return resultType ? new resultType(data) : data;
    }

    const resultSet = data.value;

    if (resultType) {
        if (Object.prototype.toString.call(resultSet) === '[object Array]') {
            for (let i = 0; i < resultSet.length; i++) {
                resultSet[i] = new resultType(resultSet[i]);
            }
        }
    }

    // hasNextPage only apply to array which is typeof 'object'
    (typeof resultSet === 'object') ? resultSet.hasNextPage = !(data[ODATA_HAS_NEXT_PAGE_PROPERTY] === undefined) : null;
    return resultSet;
}

/**
 * Represents a data service request object.
 */
export class DataServiceRequest implements IDataServiceRequest {
    private get batchRequestUri(): string {
        return this._callerContext.requestContext.apiSettings.baseUrl + '/$batch';
    }

    /**
     * Gets Locale for the current data service factory instance.
     */
    public get locale(): string {
        return this._callerContext.requestContext.locale;
    }

    /**
     * Sets Locale for the current data service factory instance.
     */
    public set locale(locale: string) {
        this._callerContext.requestContext.locale = locale;
    }

    /**
     * Gets query parameters for data service request.
     */
    public queryParams<T>(): T {
        return this._query.data.parameters as T;
    }

    private _actionId: string;
    private _cacheObjectType: string;
    private _cacheKeyFromInput: string;
    private _cacheKeyFromReturnType: string[] = [];
    private _cacheKeyIdentifierFromReturnType: string;

    private _query: IDataServiceQueryInternal;
    private _callerContext: ICallerContext;
    private _requestUri: string;
    private _method: string;
    private _id: number;
    private _hasOperationName: boolean;
    private _totalCount: number;

    private static buildBatchRequest(batchRequestUri: string, requests: DataServiceRequest[]): IODataRequest {
        let requestId = 1;

        // Creates an empty batch request.
        const odataBatchRequest: IODataRequest = {
            requestUri: batchRequestUri,
            method: POST,
            data: { __batchRequests: [] }
        };

        const batchRequests = odataBatchRequest.data.__batchRequests;
        let changeRequests: IODataRequest[];

        requests.forEach(request => {
            request._id = requestId++;

            const odataRequest: IODataRequest = {
                requestUri: request._requestUri,
                method: request._method,
                data: DataServiceRequest.toJson(request._query.data),
                headers: { 'Content-ID': request.id(), Prefer: 'return=representation' }
            };

            if (request._method === GET) {
                batchRequests.push(odataRequest);
            } else {
                if (!changeRequests) {
                    changeRequests = [];
                    batchRequests.push({ __changeRequests: changeRequests });
                }
                changeRequests.push(odataRequest);
            }
        });

        return odataBatchRequest;
    }

    /**
     * Parse the batch responses.
     * @param {any[]} batchResponses The server responses.
     * @param {any[]} requests The request objects.
     * @param {any[]} responses The responses passed down to the success callback.
     */
    private static parseBatchResponses(batchResponses: any[], requests: any[], responses: any[]): ProxyError[] {
        let errors: ProxyError[] = new Array();

        batchResponses.forEach(response => {
            if (response.__changeResponses) {
                errors = errors.concat(DataServiceRequest.parseBatchResponses(response.__changeResponses, requests, responses));
            } else {
                if (!response.message) {
                    const requestId = parseInt(response.headers['Content-ID'], 10);

                    responses[requestId] = parseOdataResult(response.data, requests[requestId - 1]._query.returnType);
                } else {
                    errors = errors.concat(ErrorParser.parseErrorMessage(response));
                }
            }
        });

        return errors;
    }

    /**
     * TODO - check if below function can be replaced with JSON.stringify.
     * Helper function to convert data into a stringified JSON object.
     * @param {any} parent The container of the element.
     * @param {any} data The data to be converted to a stringified JSON object.
     * @param {boolean} [modifyDataInPlace] Whether the object passed should be modified in place. If not, a clone is created instead.
     */
    private static toJson(data: any, parent?: any, modifyDataInPlace?: boolean): string {
        let clone = data;

        if (data === null) {
            return null;
        } else if (typeof data !== 'object') {
            // if data type is primitive type, no need to process further
            // as calling jquery extend or calling foreach prop on string type
            // will transform string to array of chars which will be incorrect result.
            return data;
        }

        if (data && data.parameters) {
            data = data.parameters;
            parent = null;
        } else {
            parent = data;
        }

        // clones the data object instead of changing it, if no modifications in place
        if (!modifyDataInPlace) {
            clone = { ...data };
        }

        for (const prop in clone) {
            if (clone.hasOwnProperty(prop)) {
                const property = clone[prop];

                // only non-undefined properties are added to the object
                if (typeof property !== 'undefined') {
                    let value;
                    if (property === null) {
                        value = null;
                    } else if (typeof property === 'object') {
                        if (property instanceof Array) {
                            value = DataServiceRequest.arrayToJson(property, parent, modifyDataInPlace);
                        } else if (property instanceof Date) {
                            value = DataServiceRequest.toDateTimeOffset(property);
                        } else {
                            // recursively stringifies objects
                            value = DataServiceRequest.toJson(property, clone, modifyDataInPlace);
                        }
                    } else {
                        value = property;
                    }

                    clone[prop] = value;
                }
            }
        }

        return clone;
    }

    /**
     * Helper function to convert array into a stringified JSON object following OData specifications.
     * @param {Array} array The data to be converted to a stringified JSON object.
     * @param {any} parent The container of the array.
     * @param {boolean} [modifyDataInPlace] Whether the object passed should be modified in place. If not, a clone is created instead.
     */
    private static arrayToJson(array: any[], parent: any, modifyDataInPlace?: boolean): any {
        const data = [];
        for (let i = 0; i < array.length; i++) {
            data[i] = DataServiceRequest.toJson(array[i], array, modifyDataInPlace);
        }

        // if array is not a top level data on an action
        return data;
    }

    /**
     * Add offset fields to Date object for serialization purposes.
     * @param {Date} dateTime The date.
     * @return {Date} The date with __edmType and __offset fields injected.
     */
    private static toDateTimeOffset(dateTime: Date): Date {
        // @ts-ignore
        if (!dateTime.__edmType || !dateTime.__offset) {
            const pad: (val: number) => string = (val: number) => (val < 10 ? '0' + val : val.toString());
            const sign: string = dateTime.getTimezoneOffset() > 0 ? '-' : '+';
            const offset: number = Math.abs(dateTime.getTimezoneOffset());
            const hours: string = pad(Math.floor(offset / 60));
            const minutes: string = pad(offset % 60);

            // @ts-ignore
            dateTime.__edmType = 'Edm.DateTimeOffset';
            // @ts-ignore
            dateTime.__offset = sign + hours + ':' + minutes;
        }

        return dateTime;
    }

    /**
     * Formats entity key(s) in request Uri.
     * @param {any} key The key dictionary.
     * @return {string} The formated string of the key(s).
     */
    private static formatKey(key: any): string {
        let result: string = EMPTY;

        if (key) {
            const formattedKey = [];
            let propertyName: string = EMPTY;

            for (const property in key) {
                if (key.hasOwnProperty(property)) {
                    propertyName = property;
                    if (typeof key[propertyName] === 'string') {
                        formattedKey.push(propertyName + `='${key[propertyName]}'`);
                    } else {
                        formattedKey.push(propertyName + '=' + key[propertyName]);
                    }
                }
            }

            if (formattedKey.length === 1) {
                if (typeof key[propertyName] === 'string') {
                    result = `'${key[propertyName]}'`;
                } else {
                    result = key[propertyName];
                }
            } else {
                result = formattedKey.join();
            }
        }

        return result;
    }

    /**
     * Formats function parameters in request Uri.
     * @param {any} parameters The parameter dictionary.
     * @return {string} The formated and encoded string of the parameters.
     */
    private static formatFunctionParameter(parameters: any): string {
        let result: string = EMPTY;

        if (parameters) {
            for (const parameter in parameters) {
                if (parameters.hasOwnProperty(parameter)) {
                    const paramValue = parameters[parameter];

                    if (!isEmpty(result)) {
                        result += ',';
                    }

                    if (paramValue === undefined) {
                        // handles undefined value
                        continue;
                    } else if (typeof paramValue === 'string') {
                        // handles string type value
                        result += parameter + `='${encodeURIComponent(paramValue)}'`;
                    } else {
                        // handles null and other types value
                        result += parameter + '=' + encodeURIComponent(paramValue);
                    }
                }
            }
        }

        return result;
    }

    // TODO - use node url api for url parsing
    private static addParameter(requestUri: string, key: string, value: any): string {
        if (value) {
            let parameterSeparator = '?';

            if (requestUri.indexOf(parameterSeparator) > 0) {
                parameterSeparator = '&';
            }

            return requestUri + parameterSeparator + key + '=' + value;
        } else {
            return requestUri;
        }
    }

    private static getActionIdFromInput(query: IDataServiceQueryInternal) {
        return `@msdyn365-commerce/retail-proxy/${query.entitySet}/${query.action}`;
    }

    private static getCacheObjectValueFromReturnType(returnType: any): string {
        // return type can be actual class itself like CategoryClass instead of string 'CategoryClass'
        const cacheObjectTypeValue = typeof returnType === 'function' ? returnType.name : returnType;
        return cacheObjectTypeValue.replace('Class', '');
    }

    private static buildCacheFromInput(query: IDataServiceQueryInternal, cacheKeyIdentifierFromReturnType: string): string {
        // TODO if return type have distinct primary key (and not a collection), cache key for action will be computed primary key

        let cacheKey = {};
        // if query have key like { RecordId: 56873008 }
        query.key && (cacheKey = { ...query.key });
        // parameters are input to function like query.createDataServiceRequestForOperation('GetCategories', true, CategoryClass, 'true', { channelId })
        //     => {channelId} is parameters.
        query.data && query.data.parameters && (cacheKey = { ...cacheKey, ...(query.data.parameters as {}) });
        query.resultSettings &&
            (cacheKey = {
                ...cacheKey,
                ...query.resultSettings.Paging,
                ...query.resultSettings.Sorting
            });
        query.filterSettings && (cacheKey['filter'] = query.filterSettings);
        isObjectNotEmptyOrNull(query.tokens) && (cacheKey['token'] = query.tokens);
        // TODO - add OUN in cache key
        const cacheKeyValue =
            convertToString(cacheKey) ||
            (cacheKeyIdentifierFromReturnType ? GET_FROM_RETURNIDENTIFIER : `${query.entitySet}|${query.entityType}|NOKEY`);
        Tracer.Information(`{CacheKey - CacheValue} : ${cacheKey} - ${cacheKeyValue}`);
        return cacheKeyValue;
    }

    private static getDataCacheType(query: IDataServiceQueryInternal): CacheType {
        // cache all result in request cacheisObjectNotEmptyOrNull
        //
        // Follow following rule for app cache
        // -------------------------------------------------------------------------------------
        //        scenario                                 app cache
        // -------------------------------------------------------------------------------------
        // 1. if returnType is  -                             true
        //          a. Category
        //          b. Product
        //          c. OrgUnit
        //          d. ProductCatalog
        //          e. Warehouse
        if (query.entitySet === 'Carts' && query.action === 'GetMaxLoyaltyPointsToRedeemForTransactionBalance') {
            return 'none';
        }

        return query.options.bypassCache === 'get' || query.options.bypassCache === 'getAndPut' ? 'none' : 'request';
    }

    constructor(query: IDataServiceQueryInternal) {
        Tracer.Information('DataServiceRequest.constructor()');
        this._query = toJS(query, { recurseEverything: true });
        this._hasOperationName = false;

        switch (query.action) {
            case 'Read':
            case 'ReadAll':
                this._method = GET;
                break;

            case 'Create':
                this._method = POST;
                break;

            case 'Update':
                this._method = PATCH;
                break;

            case 'Delete':
                this._method = DELETE;
                break;

            default:
                if (query.isAction) {
                    // Sets the HTTP method to be POST for actions
                    this._method = POST;
                } else {
                    // Sets the HTTP method to be GET for functions
                    this._method = GET;
                }

                this._hasOperationName = true;
        }

        this._actionId = DataServiceRequest.getActionIdFromInput(query);

        this._cacheObjectType = DataServiceRequest.getCacheObjectValueFromReturnType(query.options.returnEntity);
        // TODO - handle Key when it is array like SHIFT case
        const entityIdentifier = this._cacheObjectType === 'SimpleProduct' ? 'Product' : this._cacheObjectType;
        this._cacheKeyIdentifierFromReturnType = EntityIdentifier[entityIdentifier] && EntityIdentifier[entityIdentifier].Key;

        this._cacheKeyFromInput = DataServiceRequest.buildCacheFromInput(this._query, this._cacheKeyIdentifierFromReturnType);
    }

    /**
     * Gets the Request Identifier.
     * Auto-generated unique identifier if executed in batch. Used to fetch the response from batch result array.
     */
    public id(): number {
        return this._id;
    }

    public getActionId = () => this._actionId;

    public getCacheObjectType = () => this._cacheObjectType;

    public getCacheKey = () => this._cacheKeyFromInput;

    public dataCacheType = () => DataServiceRequest.getDataCacheType(this._query);

    public shouldCacheOutput = () => true;

    public overrideCacheType = (bypassCache: BypassCache) => {
        bypassCache && (this._query.options.bypassCache = bypassCache);
    }

    public saveCacheEntries(
        data: AsyncResult<any> | any,
        requestCache: ICache,
        appCache: ICache,
        isCacheTypeApplication: boolean
    ): { [cacheKey: string]: any } | undefined {
        // if return Entity is collection
        //        if entity type has identifier/primary key
        //              1. cache array of primay key value of returned entity collection on input cache key
        //              2. cache individual entity on primary key
        //        else
        //              1. cache output on input cache key
        //
        // else  if entity type has identifier/primary key
        //           2. cache output entity on primary key

        if (!data || (!this._cacheKeyFromInput && !this._cacheKeyIdentifierFromReturnType)) {
            return;
        }

        if (data instanceof AsyncResult) {
            // For a loading Promise, cache based on input cachekey, and then cache output again once complete
            if (data.status === 'LOADING') {
                data.then(result => {
                    if (this._totalCount !== undefined) {
                        data.metadata.count = this._totalCount;
                    }

                    this._saveEntityToCache(result, requestCache, appCache, isCacheTypeApplication);
                    return result;
                });

                requestCache.put({ typeName: this._cacheObjectType, key: this._cacheKeyFromInput }, { item: data });

                if (appCache && isCacheTypeApplication) {
                    appCache.put({ typeName: this._cacheObjectType, key: this._cacheKeyFromInput }, { item: data });
                }
                // For a completed promise, save the action results to the cache
            } else {
                if (this._totalCount !== undefined) {
                    data.metadata.count = this._totalCount;
                }

                this._saveEntityToCache(data.result, requestCache, appCache, isCacheTypeApplication);
                return data.result;
            }
        } else {
            return this._saveEntityToCache(data, requestCache, appCache, isCacheTypeApplication);
        }
    }

    private _saveEntityToCache(
        data: any,
        requestCache: ICache,
        appCache: ICache,
        isCacheTypeApplication: boolean
    ): { [cacheKey: string]: any } | undefined {
        if (!data || (!this._cacheKeyFromInput && !this._cacheKeyIdentifierFromReturnType)) {
            return;
        }

        const cacheEntries = {};
        const results = data;

        // using Object.prototype instead of Array.isArray because results can be Observable Array which cann't be detected with Array.isArray
        if (!this._query.isReturnTypeACollection || Object.prototype.toString.call(results) !== '[object Array]') {
            if (this._cacheKeyIdentifierFromReturnType) {
                const key = `${this._cacheKeyIdentifierFromReturnType}-${results[this._cacheKeyIdentifierFromReturnType]}`;
                cacheEntries[key] = results;

                if (this._cacheKeyFromInput) {
                    let existingCacheItem = requestCache.get({ typeName: this._cacheObjectType, key: this._cacheKeyFromInput });
                    if (existingCacheItem) {
                        existingCacheItem = { ...existingCacheItem };
                    }
                    if (
                        existingCacheItem &&
                        existingCacheItem.item &&
                        (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&
                        (typeof existingCacheItem.item !== 'object' || existingCacheItem.item['$ref'] !== true)
                    ) {
                        cacheEntries[this._cacheKeyFromInput] = results;
                    } else {
                        cacheEntries[this._cacheKeyFromInput] = {
                            $ref: true,
                            type: this._cacheObjectType,
                            identifier: this._cacheKeyIdentifierFromReturnType,
                            key: [key],
                            count: this._totalCount
                        };
                    }
                }
            } else {
                cacheEntries[this._cacheKeyFromInput] = results;
            }
        } else if (!this._cacheKeyIdentifierFromReturnType) {
            cacheEntries[this._cacheKeyFromInput] = results;
        } else {
            const cacheValue = results
                .map(result => {
                    const identifierValue = result[this._cacheKeyIdentifierFromReturnType];
                    if (identifierValue) {
                        const key = `${this._cacheKeyIdentifierFromReturnType}-${identifierValue}`;
                        cacheEntries[key] = result;
                        return key;
                    }
                })
                .filter(Boolean);

            let existingCacheItem = requestCache.get({ typeName: this._cacheObjectType, key: this._cacheKeyFromInput });
            if (existingCacheItem) {
                existingCacheItem = { ...existingCacheItem };
            }
            if (
                existingCacheItem.item &&
                (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&
                (typeof existingCacheItem.item !== 'object' || existingCacheItem.item['$ref'] !== true)
            ) {
                cacheEntries[this._cacheKeyFromInput] = results;
            } else {
                cacheEntries[this._cacheKeyFromInput] = {
                    $ref: true,
                    type: this._cacheObjectType,
                    identifier: this._cacheKeyIdentifierFromReturnType,
                    isCollection: this._query.isReturnTypeACollection,
                    key: cacheValue,
                    count: this._totalCount
                };
            }
        }

        if (cacheEntries) {
            Object.keys(cacheEntries).map(entryKey => {
                requestCache.put({ typeName: this._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });

                if (appCache && isCacheTypeApplication) {
                    appCache.put({ typeName: this._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });
                }
            });
        }

        return cacheEntries;
    }

    public readCacheEntries(requestCache: ICache, appCache: ICache, shouldReadFromAppCache?: boolean, telemetry?: ITelemetry): any {
        if (!requestCache || (!this._cacheKeyFromInput && this._cacheKeyFromReturnType.length === 0)) {
            return;
        }

        if (
            this._cacheKeyFromInput === GET_FROM_RETURNIDENTIFIER ||
            (this._cacheKeyIdentifierFromReturnType && this._cacheKeyFromReturnType.length !== 0)
        ) {
            const entries = this.readCacheEntriesBasedOnCacheKeyFromReturnType(requestCache, appCache, shouldReadFromAppCache, telemetry);
            if (entries) {
                return entries;
            }
        }

        const cacheKey = { typeName: this._cacheObjectType, key: this._cacheKeyFromInput };
        let cachedValueBasedOnInput = requestCache.get(cacheKey);
        if (cachedValueBasedOnInput) {
            cachedValueBasedOnInput = { ...cachedValueBasedOnInput };
        } else if (shouldReadFromAppCache && appCache) {
            cachedValueBasedOnInput = appCache.copyTo(cacheKey, requestCache);
        }

        if (!cachedValueBasedOnInput || cachedValueBasedOnInput.shouldRefresh) {
            return this.readCacheEntriesBasedOnCacheKeyFromReturnType(requestCache, appCache, shouldReadFromAppCache, telemetry);
        }

        if (cachedValueBasedOnInput.item instanceof AsyncResult) {
            if (cachedValueBasedOnInput.item.status !== 'LOADING') {
                cachedValueBasedOnInput.item = cachedValueBasedOnInput.item.result || cachedValueBasedOnInput.item.error;
            } else {
                const asyncResult = cachedValueBasedOnInput.item.then(result => {
                    if (typeof result !== 'object' || result['$ref'] !== true) {
                        return result;
                    }

                    return this._resolveCacheEntryReference(result, requestCache, appCache, shouldReadFromAppCache);
                });
                return asyncResult;
            }
        }

        if (typeof cachedValueBasedOnInput.item !== 'object' || cachedValueBasedOnInput.item['$ref'] !== true) {
            return cachedValueBasedOnInput.item;
        }

        return this._resolveCacheEntryReference(
            cachedValueBasedOnInput.item,
            requestCache,
            appCache,
            shouldReadFromAppCache,
            isAsyncResult(cachedValueBasedOnInput.item)
        );
    }

    private _resolveCacheEntryReference(
        item: any,
        requestCache: ICache,
        appCache: ICache,
        shouldReadFromAppCache?: boolean,
        isWrappingPromise?: boolean
    ) {
        const cacheValueAsArray = (item['key'] as string[])
            .map(key => {
                const value = requestCache.get({ typeName: this._cacheObjectType, key });

                if (!value && shouldReadFromAppCache && appCache) {
                    appCache.copyTo({ typeName: this._cacheObjectType, key }, requestCache);
                }

                if (!value || !value.item || value.shouldRefresh) {
                    return undefined;
                }

                if (isAsyncResult(value.item)) {
                    return value.item.result;
                }

                return value.item;
            })
            .filter(data => data !== undefined && data !== null);

        if ((item['key'] as string[]).length > cacheValueAsArray.length) {
            return;
        }

        // If we are returning a Promise that represents a future collection, we need to unwrap it
        return cacheValueAsArray && cacheValueAsArray.length > 0
            ? this._query.isReturnTypeACollection && !isWrappingPromise
                ? cacheValueAsArray
                : cacheValueAsArray[0]
            : undefined;
    }

    private readCacheEntriesBasedOnCacheKeyFromReturnType(
        requestCache: ICache,
        appCache: ICache,
        shouldReadFromAppCache: boolean,
        telemetry?: ITelemetry
    ): any {
        if (this._cacheKeyFromReturnType.length === 0) {
            return null;
        }

        const cacheEntries = this._cacheKeyFromReturnType
            .map(entry => {
                const key = `${this._cacheKeyIdentifierFromReturnType}-${entry}`;
                let cacheValue = requestCache.get({ typeName: this._cacheObjectType, key });

                if (!cacheValue && shouldReadFromAppCache && appCache) {
                    cacheValue = appCache.copyTo({ typeName: this._cacheObjectType, key }, requestCache);
                }

                if (!cacheValue || !cacheValue.item || cacheValue.shouldRefresh) {
                    return null;
                }
                switch (cacheValue.s!) {
                    case ICacheSource.AppCache: {
                        telemetry &&
                            telemetry.log(LogLevel.Information, 'dataAction: {actionInput.typename}\tsource: {cacheSource}', {
                                values: [this._cacheObjectType, 'AppCache']
                            });
                        break;
                    }
                    case ICacheSource.RequestCache: {
                        telemetry &&
                            telemetry.log(LogLevel.Information, 'dataAction: {actionInput.typename}\tsource: {cacheSource}', {
                                values: [this._cacheObjectType, 'RequestCache']
                            });
                        break;
                    }
                    default: {
                        telemetry &&
                            telemetry.log(LogLevel.Information, 'dataAction: {actionInput.typename}\tsource: {cacheSource}', {
                                values: [this._cacheObjectType, 'Undefined']
                            });
                        break;
                    }
                }

                return cacheValue.item;
            })
            .filter(Boolean);

        return cacheEntries && cacheEntries.length > 0 ? (this._query.isReturnTypeACollection ? cacheEntries : cacheEntries[0]) : null;
    }

    /**
     * Executes the request.
     * @param {any} callerContext The caller context.
     * @return {IAsyncResult<T>} The async result.
     */
    public execute<T>(callerContext: ICallerContext): Promise<T> {
        if (
            !callerContext.requestContext ||
            !callerContext.requestContext.apiSettings ||
            !callerContext.requestContext.apiSettings.oun ||
            !callerContext.requestContext.apiSettings.baseUrl
        ) {
            throw new Error(`CallerContext missing required request parameters - [${JSON.stringify(callerContext.requestContext)}]`);
        }

        if (!callerContext.requestContext.locale) {
            throw new Error(`CallerContext missing locale - [${JSON.stringify(callerContext.requestContext)}]`);
        }

        this._callerContext = callerContext;
        this._requestUri = this.getRequestUri();
        let result: Promise<T>;
        const headers: { [headerName: string]: string } = this.buildQueryHeader();

        if (
            !this._query.isReturnTypeACollection ||
            (this._query.resultSettings &&
                this._query.resultSettings.Paging &&
                this._query.resultSettings.Paging.Top &&
                this._query.resultSettings.Paging.Top >= 0)
        ) {
            result = this.loadPage<T>(headers);
        } else {
            result = this.getAllPages<T>(headers, 0);
        }

        return result;
    }

    // Need to build batch handler ----------- PENDING
    /**
     * Executes the batch requests.
     * @param {DataServiceRequest[]} requests The collection of requests to execute.
     * @param {any} [callerContext] The caller context.
     * @return {IAsyncResult<Array>} The async result.  Responses at index I correlates to request with identifier I.
     */
    public executeBatch(requests: DataServiceRequest[], callerContext?: ICallerContext): Promise<any[]> {
        if (
            !callerContext.requestContext ||
            !callerContext.requestContext.apiSettings ||
            !callerContext.requestContext.apiSettings.oun ||
            !callerContext.requestContext.apiSettings.baseUrl
        ) {
            throw new Error(`CallerContext missing required request parameters - [${JSON.stringify(callerContext.requestContext)}]`);
        }

        if (!callerContext.requestContext.locale) {
            throw new Error(`CallerContext missing locale - [${JSON.stringify(callerContext.requestContext)}]`);
        }

        this._callerContext = callerContext;
        this._requestUri = this.getRequestUri();

        return new Promise((resolve, reject) => {
            ODataHttpRequest(
                DataServiceRequest.buildBatchRequest(this.batchRequestUri, requests),
                (data: any) => {
                    const responses: any[] = new Array();
                    const errors: ProxyError[] = DataServiceRequest.parseBatchResponses(data.__batchResponses, requests, responses);

                    if (errors.length === 0) {
                        Tracer.Information(this.batchRequestUri + ' success');
                        resolve(responses);
                    } else {
                        Tracer.Errors(errors, this.batchRequestUri + ' failed.');
                        reject(errors);
                    }
                },
                (error: any) => {
                    Tracer.Error(this.batchRequestUri + ' failed');
                    reject(ErrorParser.parseErrorMessage(error));
                }
            );
        });
    }

    /**
     * Gets the Request Uri.
     */
    private getRequestUri(): string {
        let requestUri: string = this._callerContext.requestContext.apiSettings.baseUrl + 'Commerce';
        if (this._query.entitySet) {
            requestUri = `${requestUri}/${this._query.entitySet}`;

            if (this._query.key) {
                requestUri = `${requestUri}(${DataServiceRequest.formatKey(this._query.key)})`;
            } else if (this._query.entitySet === 'Customers' && this._query.key !== null && this._query.key !== undefined) {
                requestUri = `${requestUri}('')`;
            }
        }

        // Appends the action (POST) or function (GET) name to the Uri
        if (this._hasOperationName) {
            requestUri += '/' + this._query.action;

            // Construct OData function Url with parameters. [e.g. Func(), Func(param1='',param2='')]
            if (!this._query.isAction && this._query.data && this._query.data.parameters) {
                requestUri += '(' + DataServiceRequest.formatFunctionParameter(this._query.data.parameters) + ')';
            }
        }

        if (this._query.isReturnTypeACollection) {
            requestUri = DataServiceRequest.addParameter(
                requestUri,
                '$top',
                this._query.resultSettings && this._query.resultSettings.Paging
                    ? this._query.resultSettings.Paging.Top
                    : ApiTimeoutInMilliSecond
            ); // Config.defaultPageSize);
            requestUri = DataServiceRequest.addParameter(
                requestUri,
                '$skip',
                this._query.resultSettings && this._query.resultSettings.Paging ? this._query.resultSettings.Paging.Skip : 0
            );
            requestUri = DataServiceRequest.addParameter(requestUri, '$inlinecount', this._query.inlineCount ? 'allpages' : null);

            if (this._query.resultSettings.count) {
                requestUri = DataServiceRequest.addParameter(requestUri, '$count', 'true');
            }

            requestUri = DataServiceRequest.addParameter(
                requestUri,
                '$filter',
                this._query.filterSettings ? this._query.filterSettings : 0
            );

            if (this._query.resultSettings && this._query.resultSettings.Sorting && this._query.resultSettings.Sorting.Columns) {
                this._query.resultSettings.Sorting.Columns.forEach((column: SortColumn) => {
                    if (!isNullOrWhitespace(column.ColumnName || EMPTY)) {
                        const orderByColumn: string = format('{0}%20{1}', column.ColumnName, column.IsDescending ? 'desc' : 'asc');

                        requestUri = DataServiceRequest.addParameter(requestUri, '$orderby', orderByColumn);
                    }
                });
            }
        }

        if (this._query.expands && hasElements(this._query.expands)) {
            requestUri = DataServiceRequest.addParameter(requestUri, '$expand', this._query.expands.join());
        }

        if (!isNullOrWhitespace(ApiVersion)) {
            requestUri = DataServiceRequest.addParameter(requestUri, 'api-version', ApiVersion);
        }

        return requestUri;
    }

    /**
     * Executes paginated requests for all entities.
     * @param {AsyncResult{T}} asyncResult The async result.
     * @param {{ [headerName: string]: string }} headerName the headers for the request.
     * @param {number} skip The offset.
     * @param {Array<T>} The array result.
     */
    private getAllPages<T>(headers: { [headerName: string]: string }, skip: number, results?: T[]): Promise<T> {
        skip = skip || 0;
        const top = 1000; // Config.defaultPageSize;
        this._query.resultSettings = this._query.resultSettings || {};
        this._query.resultSettings.Paging = this._query.resultSettings.Paging || {};
        this._query.resultSettings.Paging.Top = top;
        results = results || [];

        return this.loadPage<T>(headers, skip)
            .then((loadPageResults: T) => {
                if (loadPageResults) {
                    if (typeof (loadPageResults as any).length === 'number') {
                        results = results.concat(loadPageResults);

                        if ((loadPageResults as any).length < top) {
                            // This page contains less items than top
                            if ((loadPageResults as any).hasNextPage) {
                                // This means the pagesize defined on server side is smaller than the top
                                skip += (loadPageResults as any).length;
                                return this.getAllPages<T>(headers, skip, results); // Try to fetch the next page
                            } else {
                                // No more pages need to fetch
                                return Promise.resolve((results as any) as T);
                            }
                        } else {
                            // This page contains exact amount of item as the top, should not contain more
                            skip += top;
                            return this.getAllPages<T>(headers, skip, results); // Try to fetch the next page
                        }
                    } else {
                        // The pageResult is a single item
                        results.push((loadPageResults as unknown) as T);
                        return Promise.resolve((results as unknown) as T);
                    }
                }
            })
            .catch(error => {
                return Promise.reject(error);
            });
    }

    /**
     * Builds the header to be sent as part of the request.
     * @returns {{ [headerName: string]: string }} a key value pair collection of header names and header values.
     */
    private buildQueryHeader(): { [headerName: string]: string } {
        const headers: { [headerName: string]: string } = {};
        headers['from-keystone'] = 'true';

        // copy default values from default header
        for (const headerName in DEFAULT_HEADER) {
            if (DEFAULT_HEADER.hasOwnProperty(headerName)) {
                headers[headerName] = DEFAULT_HEADER[headerName];
            }
        }

        // Copy operating unit number if present for C2 (if an operation is done by a customer or by anonymous user) scenarios.
        if (!isNullOrWhitespace(this._callerContext.requestContext.apiSettings.oun)) {
            headers[OPERATINGUNITNUMBER_HEADERNAME] = this._callerContext.requestContext.apiSettings.oun;
        }

        // Add accept-language header to send user preferred locale to server.
        headers[ACCEPT_LANGUAGE] = this._callerContext.requestContext.locale;

        // Add custom AppInsights headers
        headers[REQUEST_ID] = this._callerContext.requestContext.operationId;

        // add any tokens as part of the header
        for (const tokenName in this._query.tokens) {
            if (this._query.tokens.hasOwnProperty(tokenName)) {
                const tokenValue: string = this._query.tokens[tokenName];

                if (!isNullOrWhitespace(tokenValue)) {
                    headers[tokenName] = tokenValue;
                }
            }
        }

        // Now check whether authentication token is present or not, if present it will be added into Authorization header.
        if (
            this._callerContext &&
            this._callerContext.requestContext.user &&
            !isNullOrWhitespace(this._callerContext.requestContext.user.token)
        ) {
            headers[AUTHORIZATION_HEADERNAME] = `id_token ${this._callerContext.requestContext.user.token}`;
        }

        // Check if an Bearer access token is being provided. If present it will be added into Authorization header
        if (
            this._callerContext &&
            this._callerContext.requestContext &&
            !isNullOrWhitespace(this._callerContext.requestContext.accessToken)
        ) {
            headers[AUTHORIZATION_HEADERNAME] = `Bearer ${this._callerContext.requestContext.accessToken}`;
        }

        return headers;
    }

    /**
     * Executes request for one page.
     * @param {AsyncResult<T>} The async result.
     * @param {{ [headerName: string]: string }} headerName the headers for the request.
     */
    private loadPage<T>(headers: { [headerName: string]: string }, skip?: number): Promise<T> {
        if (skip) {
            this._query.resultSettings = this._query.resultSettings || {};
            this._query.resultSettings.Paging = this._query.resultSettings.Paging || {};
            this._query.resultSettings.Paging.Skip = skip;
        }

        const requestId = Utils.generateGuid();
        RetailLogger.modelManagersRetailServerRequestStarted(requestId, this._requestUri);

        return new Promise((resolve, reject) => {
            // This is the pipe for all OData API calls.
            ODataHttpRequest(
                {
                    requestUri: this.getRequestUri(),
                    method: this._method,
                    data: DataServiceRequest.toJson(this._query.data),
                    headers
                },
                (data: any) => {
                    RetailLogger.modelManagersRetailServerRequestFinished(requestId, this._requestUri);
                    const resultSet = parseOdataResult(data, this._query.returnType);

                    // Set the total count on the DataServiceRequest
                    if (data && data[ODATA_TOTAL_COUNT_PROPERTY]) {
                        this._totalCount = data[ODATA_TOTAL_COUNT_PROPERTY];
                    }

                    if (this._cacheKeyIdentifierFromReturnType) {
                        if (Object.prototype.toString.call(resultSet) === '[object Array]') {
                            this._cacheKeyFromReturnType.concat(
                                resultSet.map(result => result[this._cacheKeyIdentifierFromReturnType]).filter(Boolean)
                            );
                        } else if (typeof resultSet === 'object') {
                            this._cacheKeyFromReturnType.push(resultSet[this._cacheKeyIdentifierFromReturnType]);
                        }
                    }

                    resolve(resultSet);
                },
                (error: any) => {
                    RetailLogger.modelManagersRetailServerRequestError(requestId, this._requestUri, error.message);
                    reject(ErrorParser.parseErrorMessage(error));
                }
            );
        });
    }
}

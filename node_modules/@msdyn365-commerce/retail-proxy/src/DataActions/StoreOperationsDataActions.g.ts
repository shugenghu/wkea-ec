    // <auto-generated />
    import { AsyncResult } from '../async-result';
    import { DataServiceQuery } from '../DataServiceQuery';
    import { ReasonCodeLine, PaymentMerchantInformation, StoreSafe, ShiftReconciliationLineRetrievalCriteria, ShiftReconciliationLine, ReceiptMask, SearchSuggestionCriteria, SearchSuggestion, DeviceActivationResult, CreateHardwareStationTokenResult, ValidateHardwareStationTokenResult, Barcode, ButtonGrid, GetButtonGridsByIdsCriteria, CardTypeInfo, CityInfo, CountryRegionInfo, CountyInfo, CreditMemo, TerminalDataDownloadRequestInfo, DataDownloadParameters, TerminalDataUploadRequestInfo, DataUploadParameters, DownloadSession, NumberSequenceSeedData, ReceiptNumberResetInfo, LoyaltyRewardPointActivity, CurrencyRequest, CurrencyAmount, DiscountCode, DistrictInfo, HardwareStationProfile, HardwareProfile, LocalizedString, OperationPermission, ReasonCode, CommerceProperty, ReportDataSet, IncomeExpenseAccount, StateProvinceInfo, ZipCodeInfo, KitTransaction, LoyaltyCard, LoyaltyCardTransaction, TransactionSearchCriteria, Transaction, GiftCard, NonSalesTransaction, DropAndDeclareTransaction, TaxOverride, CustomerBalances, NameValuePair, LinkToExistingCustomerResult, OfflineSyncStatsLine, StorageAccessToken, Framework, TaskGuidesSearchResult, Recording, AttributeDefinitionCriteria, AttributeDefinition, AttributeGroupDefinitionCriteria, AttributeGroupDefinition, FiscalTransaction, SalesOrder, AuditEvent, InventoryAvailableToPromise, NotificationItem, FiscalIntegrationDocumentRetrievalCriteria, FiscalIntegrationDocument, FiscalIntegrationRegistrationResult, FiscalIntegrationRegistrationProcess, FiscalIntegrationSupportedEvents, FiscalIntegrationTechnicalProfile, FiscalIntegrationTechnicalProfileSearchCriteria, FiscalIntegrationServiceInfo, FiscalIntegrationServiceStatus, FiscalIntegrationServiceCommunicationResult, FeatureState, FiscalIntegrationSequentialSignatureData, DiscountsSearchCriteria, Promotion, CashDeclaration, CustomerGroup, DeliveryOption, ChannelIdentity, EnvironmentConfiguration, SearchConfiguration, ExtensionPackageDefinition, ExtensionProfile, DeviceConfiguration, VisualProfile, SupportedLanguage, Affiliation, SalesTaxGroup, TenderType, UnitOfMeasure, Currency, CommissionSalesGroup, ChannelInventoryConfiguration, Device, UserDefinedSecretCertificateResult, MediaBlob, ExtensibleEnumerationContainer, AddressPurpose, ReturnPolicy, } from '../Entities/CommerceTypes.g';
    import { ReceiptMaskClass, PaymentMerchantInformationClass, StoreSafeClass, ShiftReconciliationLineClass, SearchSuggestionClass, DeviceActivationResultClass, CreateHardwareStationTokenResultClass, ValidateHardwareStationTokenResultClass, BarcodeClass, ButtonGridClass, CardTypeInfoClass, CityInfoClass, CountryRegionInfoClass, CountyInfoClass, CreditMemoClass, DataDownloadParametersClass, DataUploadParametersClass, DownloadSessionClass, NumberSequenceSeedDataClass, ReceiptNumberResetInfoClass, LoyaltyRewardPointActivityClass, CurrencyAmountClass, DiscountCodeClass, DistrictInfoClass, HardwareStationProfileClass, HardwareProfileClass, LocalizedStringClass, OperationPermissionClass, ReasonCodeClass, ReportDataSetClass, IncomeExpenseAccountClass, StateProvinceInfoClass, ZipCodeInfoClass, KitTransactionClass, LoyaltyCardClass, LoyaltyCardTransactionClass, TransactionClass, GiftCardClass, NonSalesTransactionClass, DropAndDeclareTransactionClass, TaxOverrideClass, CustomerBalancesClass, LinkToExistingCustomerResultClass, OfflineSyncStatsLineClass, StorageAccessTokenClass, FrameworkClass, TaskGuidesSearchResultClass, RecordingClass, AttributeDefinitionClass, AttributeGroupDefinitionClass, AuditEventClass, InventoryAvailableToPromiseClass, SalesOrderClass, NotificationItemClass, FiscalIntegrationDocumentClass, FiscalIntegrationRegistrationProcessClass, FiscalIntegrationSupportedEventsClass, FiscalIntegrationTechnicalProfileClass, FiscalIntegrationServiceStatusClass, FiscalIntegrationServiceCommunicationResultClass, FeatureStateClass, FiscalIntegrationSequentialSignatureDataClass, PromotionClass, FiscalTransactionClass, CashDeclarationClass, CustomerGroupClass, DeliveryOptionClass, ChannelIdentityClass, EnvironmentConfigurationClass, SearchConfigurationClass, ExtensionPackageDefinitionClass, ExtensionProfileClass, DeviceConfigurationClass, VisualProfileClass, SupportedLanguageClass, AffiliationClass, SalesTaxGroupClass, TenderTypeClass, UnitOfMeasureClass, CurrencyClass, CommissionSalesGroupClass, ChannelInventoryConfigurationClass, DeviceClass, UserDefinedSecretCertificateResultClass, MediaBlobClass, ExtensibleEnumerationContainerClass, AddressPurposeClass, ReturnPolicyClass } from '../Entities/CommerceModels.g';
    import { IContext, IDataServiceRequest, IQueryResultSettings, NullResult } from '../Interfaces';
    import { executeAction } from '../retail-action';
    function storeQuery(): DataServiceQuery {
    return new DataServiceQuery();
    }
    
      export function createRoundAmountByTenderTypeInput(amount: number, tenderTypeId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('RoundAmountByTenderType', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {amount: amount, tenderTypeId: tenderTypeId });
      }
      export function roundAmountByTenderTypeAsync(context: IContext, amount: number, tenderTypeId: string | null):AsyncResult<number> {
        const request = createRoundAmountByTenderTypeInput(amount, tenderTypeId, );
        return executeAction<number>(request, context);
      }
  
      export function createVoidSuspendedTransactionsInput(suspendedCartIds: string[] | null, shiftId: number | null, shiftTerminalId: string | null, reasonCodeLines: ReasonCodeLine[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('VoidSuspendedTransactions', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {suspendedCartIds: suspendedCartIds, shiftId: shiftId, shiftTerminalId: shiftTerminalId, reasonCodeLines: reasonCodeLines });
      }
      export function voidSuspendedTransactionsAsync(context: IContext, suspendedCartIds: string[] | null, shiftId: number | null, shiftTerminalId: string | null, reasonCodeLines: ReasonCodeLine[] | null):AsyncResult<NullResult> {
        const request = createVoidSuspendedTransactionsInput(suspendedCartIds, shiftId, shiftTerminalId, reasonCodeLines, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetMerchantPropertiesByServiceAccountIdInput(queryResultSettings: IQueryResultSettings, serviceAccountIds: string[] | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetMerchantPropertiesByServiceAccountId', true, PaymentMerchantInformationClass, 'true', {  bypassCache: 'none', returnEntity: 'PaymentMerchantInformation'}, {serviceAccountIds: serviceAccountIds });
      }
      export function getMerchantPropertiesByServiceAccountIdAsync(context: IContext, serviceAccountIds: string[] | null):AsyncResult<PaymentMerchantInformation[]> {
        const request = createGetMerchantPropertiesByServiceAccountIdInput(context.queryResultSettings, serviceAccountIds, );
        return executeAction<PaymentMerchantInformation[]>(request, context);
      }
  
      export function createGetStoreSafesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetStoreSafes', true, StoreSafeClass, 'true', {  bypassCache: 'none', returnEntity: 'StoreSafe'}, { });
      }
      export function getStoreSafesAsync(context: IContext):AsyncResult<StoreSafe[]> {
        const request = createGetStoreSafesInput(context.queryResultSettings, );
        return executeAction<StoreSafe[]>(request, context);
      }
  
      export function createGetShiftReconciliationLinesInput(queryResultSettings: IQueryResultSettings, shiftReconciliationLineRetrievalCriteria: ShiftReconciliationLineRetrievalCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetShiftReconciliationLines', true, ShiftReconciliationLineClass, 'true', {  bypassCache: 'none', returnEntity: 'ShiftReconciliationLine'}, {shiftReconciliationLineRetrievalCriteria: shiftReconciliationLineRetrievalCriteria });
      }
      export function getShiftReconciliationLinesAsync(context: IContext, shiftReconciliationLineRetrievalCriteria: ShiftReconciliationLineRetrievalCriteria | null):AsyncResult<ShiftReconciliationLine[]> {
        const request = createGetShiftReconciliationLinesInput(context.queryResultSettings, shiftReconciliationLineRetrievalCriteria, );
        return executeAction<ShiftReconciliationLine[]>(request, context);
      }
  
      export function createReconcileLinesInput(shiftReconciliationLines: ShiftReconciliationLine[] | null, description: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('ReconcileLines', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {shiftReconciliationLines: shiftReconciliationLines, Description: description });
      }
      export function reconcileLinesAsync(context: IContext, shiftReconciliationLines: ShiftReconciliationLine[] | null, description: string | null):AsyncResult<NullResult> {
        const request = createReconcileLinesInput(shiftReconciliationLines, description, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createUndoReconciliationInput(shiftReconciliationLines: ShiftReconciliationLine[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('UndoReconciliation', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {shiftReconciliationLines: shiftReconciliationLines });
      }
      export function undoReconciliationAsync(context: IContext, shiftReconciliationLines: ShiftReconciliationLine[] | null):AsyncResult<NullResult> {
        const request = createUndoReconciliationInput(shiftReconciliationLines, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetReceiptMasksInput(queryResultSettings: IQueryResultSettings, receiptTransactionType: number | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetReceiptMasks', true, ReceiptMaskClass, 'true', {  bypassCache: 'none', returnEntity: 'ReceiptMask'}, {receiptTransactionType: receiptTransactionType });
      }
      export function getReceiptMasksAsync(context: IContext, receiptTransactionType: number | null):AsyncResult<ReceiptMask[]> {
        const request = createGetReceiptMasksInput(context.queryResultSettings, receiptTransactionType, );
        return executeAction<ReceiptMask[]>(request, context);
      }
  
      export function createGetSearchSuggestionsInput(queryResultSettings: IQueryResultSettings, searchSuggestionCriteria: SearchSuggestionCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSearchSuggestions', true, SearchSuggestionClass, 'true', {  bypassCache: 'none', returnEntity: 'SearchSuggestion'}, {searchSuggestionCriteria: searchSuggestionCriteria });
      }
      export function getSearchSuggestionsAsync(context: IContext, searchSuggestionCriteria: SearchSuggestionCriteria | null):AsyncResult<SearchSuggestion[]> {
        const request = createGetSearchSuggestionsInput(context.queryResultSettings, searchSuggestionCriteria, );
        return executeAction<SearchSuggestion[]>(request, context);
      }
  
      export function createStartSessionInput(transactionId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('StartSession', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {transactionId: transactionId });
      }
      export function startSessionAsync(context: IContext, transactionId: string | null):AsyncResult<NullResult> {
        const request = createStartSessionInput(transactionId, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createEndSessionInput(transactionId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('EndSession', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {transactionId: transactionId });
      }
      export function endSessionAsync(context: IContext, transactionId: string | null):AsyncResult<NullResult> {
        const request = createEndSessionInput(transactionId, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createActivateDeviceInput(deviceNumber: string | null, terminalId: string | null, deviceId: string | null, forceActivate: boolean, deviceType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('ActivateDevice', true, DeviceActivationResultClass, 'false', {  bypassCache: 'get', returnEntity: 'DeviceActivationResult'}, {deviceNumber: deviceNumber, terminalId: terminalId, deviceId: deviceId, forceActivate: forceActivate, deviceType: deviceType });
      }
      export function activateDeviceAsync(context: IContext, deviceNumber: string | null, terminalId: string | null, deviceId: string | null, forceActivate: boolean, deviceType: number | null):AsyncResult<DeviceActivationResult> {
        const request = createActivateDeviceInput(deviceNumber, terminalId, deviceId, forceActivate, deviceType, );
        return executeAction<DeviceActivationResult>(request, context);
      }
  
      export function createMassActivateDeviceInput(deviceNumber: string | null, terminalId: string | null, deviceId: string | null, deviceType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('MassActivateDevice', true, DeviceActivationResultClass, 'false', {  bypassCache: 'get', returnEntity: 'DeviceActivationResult'}, {deviceNumber: deviceNumber, terminalId: terminalId, deviceId: deviceId, deviceType: deviceType });
      }
      export function massActivateDeviceAsync(context: IContext, deviceNumber: string | null, terminalId: string | null, deviceId: string | null, deviceType: number | null):AsyncResult<DeviceActivationResult> {
        const request = createMassActivateDeviceInput(deviceNumber, terminalId, deviceId, deviceType, );
        return executeAction<DeviceActivationResult>(request, context);
      }
  
      export function createDeactivateDeviceInput(transactionId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('DeactivateDevice', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {transactionId: transactionId });
      }
      export function deactivateDeviceAsync(context: IContext, transactionId: string | null):AsyncResult<NullResult> {
        const request = createDeactivateDeviceInput(transactionId, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createCreateHardwareStationTokenInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('CreateHardwareStationToken', true, CreateHardwareStationTokenResultClass, 'false', {  bypassCache: 'get', returnEntity: 'CreateHardwareStationTokenResult'}, { });
      }
      export function createHardwareStationTokenAsync(context: IContext):AsyncResult<CreateHardwareStationTokenResult> {
        const request = createCreateHardwareStationTokenInput();
        return executeAction<CreateHardwareStationTokenResult>(request, context);
      }
  
      export function createValidateHardwareStationTokenInput(deviceNumber: string | null, hardwareStationToken: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('ValidateHardwareStationToken', true, ValidateHardwareStationTokenResultClass, 'false', {  bypassCache: 'get', returnEntity: 'ValidateHardwareStationTokenResult'}, {deviceNumber: deviceNumber, hardwareStationToken: hardwareStationToken });
      }
      export function validateHardwareStationTokenAsync(context: IContext, deviceNumber: string | null, hardwareStationToken: string | null):AsyncResult<ValidateHardwareStationTokenResult> {
        const request = createValidateHardwareStationTokenInput(deviceNumber, hardwareStationToken, );
        return executeAction<ValidateHardwareStationTokenResult>(request, context);
      }
  
      export function createGetBarcodeByIdInput(barcodeId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetBarcodeById', true, BarcodeClass, 'false', {  bypassCache: 'none', returnEntity: 'Barcode'}, {barcodeId: barcodeId });
      }
      export function getBarcodeByIdAsync(context: IContext, barcodeId: string | null):AsyncResult<Barcode> {
        const request = createGetBarcodeByIdInput(barcodeId, );
        return executeAction<Barcode>(request, context);
      }
  
      export function createGetButtonGridByIdInput(buttonGridId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetButtonGridById', true, ButtonGridClass, 'false', {  bypassCache: 'none', returnEntity: 'ButtonGrid'}, {buttonGridId: buttonGridId });
      }
      export function getButtonGridByIdAsync(context: IContext, buttonGridId: string | null):AsyncResult<ButtonGrid> {
        const request = createGetButtonGridByIdInput(buttonGridId, );
        return executeAction<ButtonGrid>(request, context);
      }
  
      export function createGetButtonGridsByIdsInput(queryResultSettings: IQueryResultSettings, getButtonGridsByIdsCriteria: GetButtonGridsByIdsCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetButtonGridsByIds', true, ButtonGridClass, 'true', {  bypassCache: 'none', returnEntity: 'ButtonGrid'}, {getButtonGridsByIdsCriteria: getButtonGridsByIdsCriteria });
      }
      export function getButtonGridsByIdsAsync(context: IContext, getButtonGridsByIdsCriteria: GetButtonGridsByIdsCriteria | null):AsyncResult<ButtonGrid[]> {
        const request = createGetButtonGridsByIdsInput(context.queryResultSettings, getButtonGridsByIdsCriteria, );
        return executeAction<ButtonGrid[]>(request, context);
      }
  
      export function createGetCardTypesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCardTypes', true, CardTypeInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CardTypeInfo'}, { });
      }
      export function getCardTypesAsync(context: IContext):AsyncResult<CardTypeInfo[]> {
        const request = createGetCardTypesInput(context.queryResultSettings, );
        return executeAction<CardTypeInfo[]>(request, context);
      }
  
      export function createResolveCardTypesInput(queryResultSettings: IQueryResultSettings, cardNumberPrefix: string | null, cardType: number | null, paymentToken?: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('ResolveCardTypes', true, CardTypeInfoClass, 'true', {  bypassCache: 'get', returnEntity: 'CardTypeInfo'}, {cardNumberPrefix: cardNumberPrefix, cardType: cardType, paymentToken: paymentToken });
      }
      export function resolveCardTypesAsync(context: IContext, cardNumberPrefix: string | null, cardType: number | null, paymentToken?: string | null):AsyncResult<CardTypeInfo[]> {
        const request = createResolveCardTypesInput(context.queryResultSettings, cardNumberPrefix, cardType, paymentToken, );
        return executeAction<CardTypeInfo[]>(request, context);
      }
  
      export function createGetSupportedPaymentCardTypesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSupportedPaymentCardTypes', true, '', 'true', {  bypassCache: 'none', returnEntity: ''}, { });
      }
      export function getSupportedPaymentCardTypesAsync(context: IContext):AsyncResult<string[]> {
        const request = createGetSupportedPaymentCardTypesInput(context.queryResultSettings, );
        return executeAction<string[]>(request, context);
      }
  
      export function createGetCitiesInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCities', true, CityInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CityInfo'}, {countryRegionId: countryRegionId, stateProvinceId: stateProvinceId, countyId: countyId });
      }
      export function getCitiesAsync(context: IContext, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null):AsyncResult<CityInfo[]> {
        const request = createGetCitiesInput(context.queryResultSettings, countryRegionId, stateProvinceId, countyId, );
        return executeAction<CityInfo[]>(request, context);
      }
  
      export function createGetCountryRegionsForShippingInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCountryRegionsForShipping', false, CountryRegionInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CountryRegionInfo'}, { });
      }
      export function getCountryRegionsForShippingAsync(context: IContext):AsyncResult<CountryRegionInfo[]> {
        const request = createGetCountryRegionsForShippingInput(context.queryResultSettings, );
        return executeAction<CountryRegionInfo[]>(request, context);
      }
  
      export function createGetCountryRegionsByLanguageIdInput(queryResultSettings: IQueryResultSettings, languageId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCountryRegionsByLanguageId', true, CountryRegionInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CountryRegionInfo'}, {languageId: languageId });
      }
      export function getCountryRegionsByLanguageIdAsync(context: IContext, languageId: string | null):AsyncResult<CountryRegionInfo[]> {
        const request = createGetCountryRegionsByLanguageIdInput(context.queryResultSettings, languageId, );
        return executeAction<CountryRegionInfo[]>(request, context);
      }
  
      export function createGetCountiesInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null, stateProvinceId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCounties', true, CountyInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CountyInfo'}, {countryRegionId: countryRegionId, stateProvinceId: stateProvinceId });
      }
      export function getCountiesAsync(context: IContext, countryRegionId: string | null, stateProvinceId: string | null):AsyncResult<CountyInfo[]> {
        const request = createGetCountiesInput(context.queryResultSettings, countryRegionId, stateProvinceId, );
        return executeAction<CountyInfo[]>(request, context);
      }
  
      export function createGetCreditMemoByIdInput(creditMemoId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetCreditMemoById', true, CreditMemoClass, 'false', {  bypassCache: 'none', returnEntity: 'CreditMemo'}, {creditMemoId: creditMemoId });
      }
      export function getCreditMemoByIdAsync(context: IContext, creditMemoId: string | null):AsyncResult<CreditMemo> {
        const request = createGetCreditMemoByIdInput(creditMemoId, );
        return executeAction<CreditMemo>(request, context);
      }
  
      export function createGetDownloadIntervalInput(dataStoreName: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDownloadInterval', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {dataStoreName: dataStoreName });
      }
      export function getDownloadIntervalAsync(context: IContext, dataStoreName: string | null):AsyncResult<string> {
        const request = createGetDownloadIntervalInput(dataStoreName, );
        return executeAction<string>(request, context);
      }
  
      export function createGetTerminalDataStoreNameInput(terminalId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetTerminalDataStoreName', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {terminalId: terminalId });
      }
      export function getTerminalDataStoreNameAsync(context: IContext, terminalId: string | null):AsyncResult<string> {
        const request = createGetTerminalDataStoreNameInput(terminalId, );
        return executeAction<string>(request, context);
      }
  
      export function createGetDownloadLinkInput(dataStoreName: string | null, downloadSessionId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDownloadLink', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {dataStoreName: dataStoreName, downloadSessionId: downloadSessionId });
      }
      export function getDownloadLinkAsync(context: IContext, dataStoreName: string | null, downloadSessionId: number):AsyncResult<string> {
        const request = createGetDownloadLinkInput(dataStoreName, downloadSessionId, );
        return executeAction<string>(request, context);
      }
  
      export function createGetDataDownloadParametersByTerminalInput(terminalDataDownloadRequestInfo: TerminalDataDownloadRequestInfo | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDataDownloadParametersByTerminal', true, DataDownloadParametersClass, 'false', {  bypassCache: 'none', returnEntity: 'DataDownloadParameters'}, {TerminalDataDownloadRequestInfo: terminalDataDownloadRequestInfo });
      }
      export function getDataDownloadParametersByTerminalAsync(context: IContext, terminalDataDownloadRequestInfo: TerminalDataDownloadRequestInfo | null):AsyncResult<DataDownloadParameters> {
        const request = createGetDataDownloadParametersByTerminalInput(terminalDataDownloadRequestInfo, );
        return executeAction<DataDownloadParameters>(request, context);
      }
  
      export function createGetDataUploadParametersByTerminalInput(terminalDataUploadRequestInfo: TerminalDataUploadRequestInfo | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDataUploadParametersByTerminal', true, DataUploadParametersClass, 'false', {  bypassCache: 'none', returnEntity: 'DataUploadParameters'}, {TerminalDataUploadRequestInfo: terminalDataUploadRequestInfo });
      }
      export function getDataUploadParametersByTerminalAsync(context: IContext, terminalDataUploadRequestInfo: TerminalDataUploadRequestInfo | null):AsyncResult<DataUploadParameters> {
        const request = createGetDataUploadParametersByTerminalInput(terminalDataUploadRequestInfo, );
        return executeAction<DataUploadParameters>(request, context);
      }
  
      export function createGetDownloadSessionsInput(queryResultSettings: IQueryResultSettings, dataStoreName: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDownloadSessions', true, DownloadSessionClass, 'true', {  bypassCache: 'none', returnEntity: 'DownloadSession'}, {dataStoreName: dataStoreName });
      }
      export function getDownloadSessionsAsync(context: IContext, dataStoreName: string | null):AsyncResult<DownloadSession[]> {
        const request = createGetDownloadSessionsInput(context.queryResultSettings, dataStoreName, );
        return executeAction<DownloadSession[]>(request, context);
      }
  
      export function createGetInitialDownloadSessionsInput(queryResultSettings: IQueryResultSettings, dataStoreName: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetInitialDownloadSessions', true, DownloadSessionClass, 'true', {  bypassCache: 'none', returnEntity: 'DownloadSession'}, {dataStoreName: dataStoreName });
      }
      export function getInitialDownloadSessionsAsync(context: IContext, dataStoreName: string | null):AsyncResult<DownloadSession[]> {
        const request = createGetInitialDownloadSessionsInput(context.queryResultSettings, dataStoreName, );
        return executeAction<DownloadSession[]>(request, context);
      }
  
      export function createGetUploadJobDefinitionsInput(queryResultSettings: IQueryResultSettings, dataStoreName: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetUploadJobDefinitions', true, '', 'true', {  bypassCache: 'none', returnEntity: ''}, {dataStoreName: dataStoreName });
      }
      export function getUploadJobDefinitionsAsync(context: IContext, dataStoreName: string | null):AsyncResult<string[]> {
        const request = createGetUploadJobDefinitionsInput(context.queryResultSettings, dataStoreName, );
        return executeAction<string[]>(request, context);
      }
  
      export function createGetUploadIntervalInput(dataStoreName: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetUploadInterval', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {dataStoreName: dataStoreName });
      }
      export function getUploadIntervalAsync(context: IContext, dataStoreName: string | null):AsyncResult<string> {
        const request = createGetUploadIntervalInput(dataStoreName, );
        return executeAction<string>(request, context);
      }
  
      export function createPostOfflineTransactionsInput(offlineTransactionForMPOS: string[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('PostOfflineTransactions', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {offlineTransactionForMPOS: offlineTransactionForMPOS });
      }
      export function postOfflineTransactionsAsync(context: IContext, offlineTransactionForMPOS: string[] | null):AsyncResult<boolean> {
        const request = createPostOfflineTransactionsInput(offlineTransactionForMPOS, );
        return executeAction<boolean>(request, context);
      }
  
      export function createGetRetailTrialPlanOfferInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetRetailTrialPlanOffer', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, { });
      }
      export function getRetailTrialPlanOfferAsync(context: IContext):AsyncResult<boolean> {
        const request = createGetRetailTrialPlanOfferInput();
        return executeAction<boolean>(request, context);
      }
  
      export function createGetLatestNumberSequenceInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLatestNumberSequence', true, NumberSequenceSeedDataClass, 'true', {  bypassCache: 'none', returnEntity: 'NumberSequenceSeedData'}, { });
      }
      export function getLatestNumberSequenceAsync(context: IContext):AsyncResult<NumberSequenceSeedData[]> {
        const request = createGetLatestNumberSequenceInput(context.queryResultSettings, );
        return executeAction<NumberSequenceSeedData[]>(request, context);
      }
  
      export function createGetReceiptNumberResetInfoInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetReceiptNumberResetInfo', true, ReceiptNumberResetInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'ReceiptNumberResetInfo'}, { });
      }
      export function getReceiptNumberResetInfoAsync(context: IContext):AsyncResult<ReceiptNumberResetInfo[]> {
        const request = createGetReceiptNumberResetInfoInput(context.queryResultSettings, );
        return executeAction<ReceiptNumberResetInfo[]>(request, context);
      }
  
      export function createGetLoyaltyRewardPointActivityTimelineInput(queryResultSettings: IQueryResultSettings, cardNumber: string | null, rewardPointId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLoyaltyRewardPointActivityTimeline', true, LoyaltyRewardPointActivityClass, 'true', {  bypassCache: 'none', returnEntity: 'LoyaltyRewardPointActivity'}, {cardNumber: cardNumber, rewardPointId: rewardPointId });
      }
      export function getLoyaltyRewardPointActivityTimelineAsync(context: IContext, cardNumber: string | null, rewardPointId: string | null):AsyncResult<LoyaltyRewardPointActivity[]> {
        const request = createGetLoyaltyRewardPointActivityTimelineInput(context.queryResultSettings, cardNumber, rewardPointId, );
        return executeAction<LoyaltyRewardPointActivity[]>(request, context);
      }
  
      export function createGetLoyaltyRewardPointActivityTimelineForExpiredPointsInput(queryResultSettings: IQueryResultSettings, cardNumber: string | null, rewardPointId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLoyaltyRewardPointActivityTimelineForExpiredPoints', true, LoyaltyRewardPointActivityClass, 'true', {  bypassCache: 'none', returnEntity: 'LoyaltyRewardPointActivity'}, {cardNumber: cardNumber, rewardPointId: rewardPointId });
      }
      export function getLoyaltyRewardPointActivityTimelineForExpiredPointsAsync(context: IContext, cardNumber: string | null, rewardPointId: string | null):AsyncResult<LoyaltyRewardPointActivity[]> {
        const request = createGetLoyaltyRewardPointActivityTimelineForExpiredPointsInput(context.queryResultSettings, cardNumber, rewardPointId, );
        return executeAction<LoyaltyRewardPointActivity[]>(request, context);
      }
  
      export function createCalculateTotalCurrencyAmountInput(currenciesAmount: CurrencyRequest[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('CalculateTotalCurrencyAmount', true, CurrencyAmountClass, 'false', {  bypassCache: 'get', returnEntity: 'CurrencyAmount'}, {currenciesAmount: currenciesAmount });
      }
      export function calculateTotalCurrencyAmountAsync(context: IContext, currenciesAmount: CurrencyRequest[] | null):AsyncResult<CurrencyAmount> {
        const request = createCalculateTotalCurrencyAmountInput(currenciesAmount, );
        return executeAction<CurrencyAmount>(request, context);
      }
  
      export function createGetDiscountCodeInput(discountCode: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDiscountCode', true, DiscountCodeClass, 'false', {  bypassCache: 'none', returnEntity: 'DiscountCode'}, {discountCode: discountCode });
      }
      export function getDiscountCodeAsync(context: IContext, discountCode: string | null):AsyncResult<DiscountCode> {
        const request = createGetDiscountCodeInput(discountCode, );
        return executeAction<DiscountCode>(request, context);
      }
  
      export function createGetDiscountCodesByOfferIdInput(queryResultSettings: IQueryResultSettings, offerId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDiscountCodesByOfferId', true, DiscountCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'DiscountCode'}, {offerId: offerId });
      }
      export function getDiscountCodesByOfferIdAsync(context: IContext, offerId: string | null):AsyncResult<DiscountCode[]> {
        const request = createGetDiscountCodesByOfferIdInput(context.queryResultSettings, offerId, );
        return executeAction<DiscountCode[]>(request, context);
      }
  
      export function createGetDiscountCodesByKeywordInput(queryResultSettings: IQueryResultSettings, keyword: string | null, activeDate: Date): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDiscountCodesByKeyword', true, DiscountCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'DiscountCode'}, {keyword: keyword, activeDate: activeDate });
      }
      export function getDiscountCodesByKeywordAsync(context: IContext, keyword: string | null, activeDate: Date):AsyncResult<DiscountCode[]> {
        const request = createGetDiscountCodesByKeywordInput(context.queryResultSettings, keyword, activeDate, );
        return executeAction<DiscountCode[]>(request, context);
      }
  
      export function createGetDistrictsInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null, cityName: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDistricts', true, DistrictInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'DistrictInfo'}, {countryRegionId: countryRegionId, stateProvinceId: stateProvinceId, countyId: countyId, cityName: cityName });
      }
      export function getDistrictsAsync(context: IContext, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null, cityName: string | null):AsyncResult<DistrictInfo[]> {
        const request = createGetDistrictsInput(context.queryResultSettings, countryRegionId, stateProvinceId, countyId, cityName, );
        return executeAction<DistrictInfo[]>(request, context);
      }
  
      export function createGetHardwareStationProfilesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetHardwareStationProfiles', true, HardwareStationProfileClass, 'true', {  bypassCache: 'none', returnEntity: 'HardwareStationProfile'}, { });
      }
      export function getHardwareStationProfilesAsync(context: IContext):AsyncResult<HardwareStationProfile[]> {
        const request = createGetHardwareStationProfilesInput(context.queryResultSettings, );
        return executeAction<HardwareStationProfile[]>(request, context);
      }
  
      export function createGetHardwareProfileByIdInput(hardwareProfileId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetHardwareProfileById', true, HardwareProfileClass, 'false', {  bypassCache: 'none', returnEntity: 'HardwareProfile'}, {hardwareProfileId: hardwareProfileId });
      }
      export function getHardwareProfileByIdAsync(context: IContext, hardwareProfileId: string | null):AsyncResult<HardwareProfile> {
        const request = createGetHardwareProfileByIdInput(hardwareProfileId, );
        return executeAction<HardwareProfile>(request, context);
      }
  
      export function createGetLocalizedStringsInput(queryResultSettings: IQueryResultSettings, languageId: string | null, textId: number | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLocalizedStrings', true, LocalizedStringClass, 'true', {  bypassCache: 'none', returnEntity: 'LocalizedString'}, {languageId: languageId, textId: textId });
      }
      export function getLocalizedStringsAsync(context: IContext, languageId: string | null, textId: number | null):AsyncResult<LocalizedString[]> {
        const request = createGetLocalizedStringsInput(context.queryResultSettings, languageId, textId, );
        return executeAction<LocalizedString[]>(request, context);
      }
  
      export function createGetOperationPermissionByIdInput(operationId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetOperationPermissionById', true, OperationPermissionClass, 'false', {  bypassCache: 'none', returnEntity: 'OperationPermission'}, {operationId: operationId });
      }
      export function getOperationPermissionByIdAsync(context: IContext, operationId: number):AsyncResult<OperationPermission> {
        const request = createGetOperationPermissionByIdInput(operationId, );
        return executeAction<OperationPermission>(request, context);
      }
  
      export function createGetReasonCodesByIdInput(queryResultSettings: IQueryResultSettings, reasonCodeGroupId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetReasonCodesById', true, ReasonCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'ReasonCode'}, {reasonCodeGroupId: reasonCodeGroupId });
      }
      export function getReasonCodesByIdAsync(context: IContext, reasonCodeGroupId: string | null):AsyncResult<ReasonCode[]> {
        const request = createGetReasonCodesByIdInput(context.queryResultSettings, reasonCodeGroupId, );
        return executeAction<ReasonCode[]>(request, context);
      }
  
      export function createSearchReportDataSetInput(reportId: string | null, parameters: CommerceProperty[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('SearchReportDataSet', true, ReportDataSetClass, 'false', {  bypassCache: 'none', returnEntity: 'ReportDataSet'}, {reportId: reportId, parameters: parameters });
      }
      export function searchReportDataSetAsync(context: IContext, reportId: string | null, parameters: CommerceProperty[] | null):AsyncResult<ReportDataSet> {
        const request = createSearchReportDataSetInput(reportId, parameters, );
        return executeAction<ReportDataSet>(request, context);
      }
  
      export function createGetReportDataSetByIdInput(reportId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetReportDataSetById', true, ReportDataSetClass, 'false', {  bypassCache: 'none', returnEntity: 'ReportDataSet'}, {reportId: reportId });
      }
      export function getReportDataSetByIdAsync(context: IContext, reportId: string | null):AsyncResult<ReportDataSet> {
        const request = createGetReportDataSetByIdInput(reportId, );
        return executeAction<ReportDataSet>(request, context);
      }
  
      export function createGetSrsReportDataSetInput(reportId: string | null, parameters: CommerceProperty[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetSrsReportDataSet', true, ReportDataSetClass, 'false', {  bypassCache: 'none', returnEntity: 'ReportDataSet'}, {reportId: reportId, parameters: parameters });
      }
      export function getSrsReportDataSetAsync(context: IContext, reportId: string | null, parameters: CommerceProperty[] | null):AsyncResult<ReportDataSet> {
        const request = createGetSrsReportDataSetInput(reportId, parameters, );
        return executeAction<ReportDataSet>(request, context);
      }
  
      export function createGetIncomeExpenseAccountsInput(queryResultSettings: IQueryResultSettings, incomeExpenseAccountType: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetIncomeExpenseAccounts', true, IncomeExpenseAccountClass, 'true', {  bypassCache: 'none', returnEntity: 'IncomeExpenseAccount'}, {incomeExpenseAccountType: incomeExpenseAccountType });
      }
      export function getIncomeExpenseAccountsAsync(context: IContext, incomeExpenseAccountType: number):AsyncResult<IncomeExpenseAccount[]> {
        const request = createGetIncomeExpenseAccountsInput(context.queryResultSettings, incomeExpenseAccountType, );
        return executeAction<IncomeExpenseAccount[]>(request, context);
      }
  
      export function createGetStateProvincesInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetStateProvinces', true, StateProvinceInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'StateProvinceInfo'}, {countryRegionId: countryRegionId });
      }
      export function getStateProvincesAsync(context: IContext, countryRegionId: string | null):AsyncResult<StateProvinceInfo[]> {
        const request = createGetStateProvincesInput(context.queryResultSettings, countryRegionId, );
        return executeAction<StateProvinceInfo[]>(request, context);
      }
  
      export function createGetZipCodesInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null, cityName: string | null, district: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetZipCodes', true, ZipCodeInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'ZipCodeInfo'}, {countryRegionId: countryRegionId, stateProvinceId: stateProvinceId, countyId: countyId, cityName: cityName, district: district });
      }
      export function getZipCodesAsync(context: IContext, countryRegionId: string | null, stateProvinceId: string | null, countyId: string | null, cityName: string | null, district: string | null):AsyncResult<ZipCodeInfo[]> {
        const request = createGetZipCodesInput(context.queryResultSettings, countryRegionId, stateProvinceId, countyId, cityName, district, );
        return executeAction<ZipCodeInfo[]>(request, context);
      }
  
      export function createGetAddressFromZipCodeInput(queryResultSettings: IQueryResultSettings, countryRegionId: string | null, zipPostalCode: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAddressFromZipCode', true, ZipCodeInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'ZipCodeInfo'}, {countryRegionId: countryRegionId, zipPostalCode: zipPostalCode });
      }
      export function getAddressFromZipCodeAsync(context: IContext, countryRegionId: string | null, zipPostalCode: string | null):AsyncResult<ZipCodeInfo[]> {
        const request = createGetAddressFromZipCodeInput(context.queryResultSettings, countryRegionId, zipPostalCode, );
        return executeAction<ZipCodeInfo[]>(request, context);
      }
  
      export function createDisassembleKitTransactionsInput(kitTransaction: KitTransaction | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('DisassembleKitTransactions', true, KitTransactionClass, 'false', {  bypassCache: 'get', returnEntity: 'KitTransaction'}, {kitTransaction: kitTransaction });
      }
      export function disassembleKitTransactionsAsync(context: IContext, kitTransaction: KitTransaction | null):AsyncResult<KitTransaction> {
        const request = createDisassembleKitTransactionsInput(kitTransaction, );
        return executeAction<KitTransaction>(request, context);
      }
  
      export function createIssueLoyaltyCardInput(loyaltyCard: LoyaltyCard | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('IssueLoyaltyCard', true, LoyaltyCardClass, 'false', {  bypassCache: 'get', returnEntity: 'LoyaltyCard'}, {loyaltyCard: loyaltyCard });
      }
      export function issueLoyaltyCardAsync(context: IContext, loyaltyCard: LoyaltyCard | null):AsyncResult<LoyaltyCard> {
        const request = createIssueLoyaltyCardInput(loyaltyCard, );
        return executeAction<LoyaltyCard>(request, context);
      }
  
      export function createGetLoyaltyCardInput(cardNumber: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetLoyaltyCard', true, LoyaltyCardClass, 'false', {  bypassCache: 'none', returnEntity: 'LoyaltyCard'}, {cardNumber: cardNumber });
      }
      export function getLoyaltyCardAsync(context: IContext, cardNumber: string | null):AsyncResult<LoyaltyCard> {
        const request = createGetLoyaltyCardInput(cardNumber, );
        return executeAction<LoyaltyCard>(request, context);
      }
  
      export function createGetCustomerLoyaltyCardsInput(queryResultSettings: IQueryResultSettings, accountNumber: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCustomerLoyaltyCards', true, LoyaltyCardClass, 'true', {  bypassCache: 'none', returnEntity: 'LoyaltyCard'}, {accountNumber: accountNumber });
      }
      export function getCustomerLoyaltyCardsAsync(context: IContext, accountNumber: string | null):AsyncResult<LoyaltyCard[]> {
        const request = createGetCustomerLoyaltyCardsInput(context.queryResultSettings, accountNumber, );
        return executeAction<LoyaltyCard[]>(request, context);
      }
  
      export function createGetLoyaltyCardTransactionsInput(queryResultSettings: IQueryResultSettings, cardNumber: string | null, rewardPointId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLoyaltyCardTransactions', true, LoyaltyCardTransactionClass, 'true', {  bypassCache: 'none', returnEntity: 'LoyaltyCardTransaction'}, {cardNumber: cardNumber, rewardPointId: rewardPointId });
      }
      export function getLoyaltyCardTransactionsAsync(context: IContext, cardNumber: string | null, rewardPointId: string | null):AsyncResult<LoyaltyCardTransaction[]> {
        const request = createGetLoyaltyCardTransactionsInput(context.queryResultSettings, cardNumber, rewardPointId, );
        return executeAction<LoyaltyCardTransaction[]>(request, context);
      }
  
      export function createGetLoyaltyRewardPointsExpiringSoonInput(queryResultSettings: IQueryResultSettings, cardNumber: string | null, rewardPointId: string | null, daysToExpiry: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLoyaltyRewardPointsExpiringSoon', true, LoyaltyRewardPointActivityClass, 'true', {  bypassCache: 'none', returnEntity: 'LoyaltyRewardPointActivity'}, {cardNumber: cardNumber, rewardPointId: rewardPointId, daysToExpiry: daysToExpiry });
      }
      export function getLoyaltyRewardPointsExpiringSoonAsync(context: IContext, cardNumber: string | null, rewardPointId: string | null, daysToExpiry: number):AsyncResult<LoyaltyRewardPointActivity[]> {
        const request = createGetLoyaltyRewardPointsExpiringSoonInput(context.queryResultSettings, cardNumber, rewardPointId, daysToExpiry, );
        return executeAction<LoyaltyRewardPointActivity[]>(request, context);
      }
  
      export function createSearchJournalTransactionsInput(queryResultSettings: IQueryResultSettings, searchCriteria: TransactionSearchCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchJournalTransactions', true, TransactionClass, 'true', {  bypassCache: 'none', returnEntity: 'Transaction'}, {searchCriteria: searchCriteria });
      }
      export function searchJournalTransactionsAsync(context: IContext, searchCriteria: TransactionSearchCriteria | null):AsyncResult<Transaction[]> {
        const request = createSearchJournalTransactionsInput(context.queryResultSettings, searchCriteria, );
        return executeAction<Transaction[]>(request, context);
      }
  
      export function createGetGiftCardInput(giftCardId: string | null, tenderTypeId: string | null, pin: string | null, expirationMonth: number | null, expirationYear: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetGiftCard', true, GiftCardClass, 'false', {  bypassCache: 'none', returnEntity: 'GiftCard'}, {giftCardId: giftCardId, tenderTypeId: tenderTypeId, pin: pin, expirationMonth: expirationMonth, expirationYear: expirationYear });
      }
      export function getGiftCardAsync(context: IContext, giftCardId: string | null, tenderTypeId: string | null, pin: string | null, expirationMonth: number | null, expirationYear: number | null):AsyncResult<GiftCard> {
        const request = createGetGiftCardInput(giftCardId, tenderTypeId, pin, expirationMonth, expirationYear, );
        return executeAction<GiftCard>(request, context);
      }
  
      export function createGetGiftCardInquiryInput(giftCardId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetGiftCardInquiry', true, GiftCardClass, 'false', {  bypassCache: 'none', returnEntity: 'GiftCard'}, {giftCardId: giftCardId });
      }
      export function getGiftCardInquiryAsync(context: IContext, giftCardId: string | null):AsyncResult<GiftCard> {
        const request = createGetGiftCardInquiryInput(giftCardId, );
        return executeAction<GiftCard>(request, context);
      }
  
      export function createGetNonSalesTransactionsInput(queryResultSettings: IQueryResultSettings, shiftId: string | null, shiftTerminalId: string | null, nonSalesTenderTypeValue: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetNonSalesTransactions', true, NonSalesTransactionClass, 'true', {  bypassCache: 'none', returnEntity: 'NonSalesTransaction'}, {shiftId: shiftId, shiftTerminalId: shiftTerminalId, nonSalesTenderTypeValue: nonSalesTenderTypeValue });
      }
      export function getNonSalesTransactionsAsync(context: IContext, shiftId: string | null, shiftTerminalId: string | null, nonSalesTenderTypeValue: number):AsyncResult<NonSalesTransaction[]> {
        const request = createGetNonSalesTransactionsInput(context.queryResultSettings, shiftId, shiftTerminalId, nonSalesTenderTypeValue, );
        return executeAction<NonSalesTransaction[]>(request, context);
      }
  
      export function createCreateNonSalesTransactionInput(nonSalesTransaction: NonSalesTransaction | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('CreateNonSalesTransaction', true, NonSalesTransactionClass, 'false', {  bypassCache: 'get', returnEntity: 'NonSalesTransaction'}, {nonSalesTransaction: nonSalesTransaction });
      }
      export function createNonSalesTransactionAsync(context: IContext, nonSalesTransaction: NonSalesTransaction | null):AsyncResult<NonSalesTransaction> {
        const request = createCreateNonSalesTransactionInput(nonSalesTransaction, );
        return executeAction<NonSalesTransaction>(request, context);
      }
  
      export function createCreateDropAndDeclareTransactionInput(dropAndDeclareTransaction: DropAndDeclareTransaction | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('CreateDropAndDeclareTransaction', true, DropAndDeclareTransactionClass, 'false', {  bypassCache: 'get', returnEntity: 'DropAndDeclareTransaction'}, {dropAndDeclareTransaction: dropAndDeclareTransaction });
      }
      export function createDropAndDeclareTransactionAsync(context: IContext, dropAndDeclareTransaction: DropAndDeclareTransaction | null):AsyncResult<DropAndDeclareTransaction> {
        const request = createCreateDropAndDeclareTransactionInput(dropAndDeclareTransaction, );
        return executeAction<DropAndDeclareTransaction>(request, context);
      }
  
      export function createGetTaxOverridesInput(queryResultSettings: IQueryResultSettings, overrideBy: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetTaxOverrides', true, TaxOverrideClass, 'true', {  bypassCache: 'none', returnEntity: 'TaxOverride'}, {overrideBy: overrideBy });
      }
      export function getTaxOverridesAsync(context: IContext, overrideBy: string | null):AsyncResult<TaxOverride[]> {
        const request = createGetTaxOverridesInput(context.queryResultSettings, overrideBy, );
        return executeAction<TaxOverride[]>(request, context);
      }
  
      export function createGetCustomerBalanceInput(accountNumber: string | null, invoiceAccountNumber: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetCustomerBalance', true, CustomerBalancesClass, 'false', {  bypassCache: 'none', returnEntity: 'CustomerBalances'}, {accountNumber: accountNumber, invoiceAccountNumber: invoiceAccountNumber });
      }
      export function getCustomerBalanceAsync(context: IContext, accountNumber: string | null, invoiceAccountNumber: string | null):AsyncResult<CustomerBalances> {
        const request = createGetCustomerBalanceInput(accountNumber, invoiceAccountNumber, );
        return executeAction<CustomerBalances>(request, context);
      }
  
      export function createInitiateLinkToExistingCustomerInput(email: string | null, activationToken: string | null, emailTemplateId: string | null, emailProperties: NameValuePair[] | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('InitiateLinkToExistingCustomer', true, LinkToExistingCustomerResultClass, 'false', {  bypassCache: 'get', returnEntity: 'LinkToExistingCustomerResult'}, {email: email, ActivationToken: activationToken, emailTemplateId: emailTemplateId, emailProperties: emailProperties });
      }
      export function initiateLinkToExistingCustomerAsync(context: IContext, email: string | null, activationToken: string | null, emailTemplateId: string | null, emailProperties: NameValuePair[] | null):AsyncResult<LinkToExistingCustomerResult> {
        const request = createInitiateLinkToExistingCustomerInput(email, activationToken, emailTemplateId, emailProperties, );
        return executeAction<LinkToExistingCustomerResult>(request, context);
      }
  
      export function createFinalizeLinkToExistingCustomerInput(email: string | null, activationToken: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('FinalizeLinkToExistingCustomer', true, LinkToExistingCustomerResultClass, 'false', {  bypassCache: 'get', returnEntity: 'LinkToExistingCustomerResult'}, {email: email, ActivationToken: activationToken });
      }
      export function finalizeLinkToExistingCustomerAsync(context: IContext, email: string | null, activationToken: string | null):AsyncResult<LinkToExistingCustomerResult> {
        const request = createFinalizeLinkToExistingCustomerInput(email, activationToken, );
        return executeAction<LinkToExistingCustomerResult>(request, context);
      }
  
      export function createUnlinkFromExistingCustomerInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('UnlinkFromExistingCustomer', true, '', '', {  bypassCache: 'get', returnEntity: ''}, { });
      }
      export function unlinkFromExistingCustomerAsync(context: IContext):AsyncResult<NullResult> {
        const request = createUnlinkFromExistingCustomerInput();
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetOfflineSyncStatusInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetOfflineSyncStatus', true, OfflineSyncStatsLineClass, 'true', {  bypassCache: 'none', returnEntity: 'OfflineSyncStatsLine'}, { });
      }
      export function getOfflineSyncStatusAsync(context: IContext):AsyncResult<OfflineSyncStatsLine[]> {
        const request = createGetOfflineSyncStatusInput(context.queryResultSettings, );
        return executeAction<OfflineSyncStatsLine[]>(request, context);
      }
  
      export function createGetOfflinePendingTransactionCountInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetOfflinePendingTransactionCount', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, { });
      }
      export function getOfflinePendingTransactionCountAsync(context: IContext):AsyncResult<number> {
        const request = createGetOfflinePendingTransactionCountInput();
        return executeAction<number>(request, context);
      }
  
      export function createGetOfflinePendingTransactionCountByShiftInput(shiftId: number, shiftTerminalId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetOfflinePendingTransactionCountByShift', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {shiftId: shiftId, shiftTerminalId: shiftTerminalId });
      }
      export function getOfflinePendingTransactionCountByShiftAsync(context: IContext, shiftId: number, shiftTerminalId: string | null):AsyncResult<number> {
        const request = createGetOfflinePendingTransactionCountByShiftInput(shiftId, shiftTerminalId, );
        return executeAction<number>(request, context);
      }
  
      export function createUpdateDownloadSessionInput(downloadSession: DownloadSession | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('UpdateDownloadSession', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {downloadSession: downloadSession });
      }
      export function updateDownloadSessionAsync(context: IContext, downloadSession: DownloadSession | null):AsyncResult<boolean> {
        const request = createUpdateDownloadSessionInput(downloadSession, );
        return executeAction<boolean>(request, context);
      }
  
      export function createUpdateApplicationVersionInput(appVersion: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('UpdateApplicationVersion', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {appVersion: appVersion });
      }
      export function updateApplicationVersionAsync(context: IContext, appVersion: string | null):AsyncResult<NullResult> {
        const request = createUpdateApplicationVersionInput(appVersion, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetStorageAccessTokenForUploadInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetStorageAccessTokenForUpload', true, StorageAccessTokenClass, 'false', {  bypassCache: 'none', returnEntity: 'StorageAccessToken'}, { });
      }
      export function getStorageAccessTokenForUploadAsync(context: IContext):AsyncResult<StorageAccessToken> {
        const request = createGetStorageAccessTokenForUploadInput();
        return executeAction<StorageAccessToken>(request, context);
      }
  
      export function createGetBusinessProcessModelLibrariesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetBusinessProcessModelLibraries', true, FrameworkClass, 'true', {  bypassCache: 'none', returnEntity: 'Framework'}, { });
      }
      export function getBusinessProcessModelLibrariesAsync(context: IContext):AsyncResult<Framework[]> {
        const request = createGetBusinessProcessModelLibrariesInput(context.queryResultSettings, );
        return executeAction<Framework[]>(request, context);
      }
  
      export function createGetBusinessProcessModelLibraryInput(businessProcessModelFrameworkLineId: number, hierarchyDepth: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetBusinessProcessModelLibrary', true, FrameworkClass, 'false', {  bypassCache: 'none', returnEntity: 'Framework'}, {businessProcessModelFrameworkLineId: businessProcessModelFrameworkLineId, hierarchyDepth: hierarchyDepth });
      }
      export function getBusinessProcessModelLibraryAsync(context: IContext, businessProcessModelFrameworkLineId: number, hierarchyDepth: number):AsyncResult<Framework> {
        const request = createGetBusinessProcessModelLibraryInput(businessProcessModelFrameworkLineId, hierarchyDepth, );
        return executeAction<Framework>(request, context);
      }
  
      export function createSearchTaskGuidesByTitleInput(queryResultSettings: IQueryResultSettings, businessProcessModelFrameworkLineId: number, taskGuideSearchText: string | null, queryTypeValue: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchTaskGuidesByTitle', true, TaskGuidesSearchResultClass, 'true', {  bypassCache: 'none', returnEntity: 'TaskGuidesSearchResult'}, {businessProcessModelFrameworkLineId: businessProcessModelFrameworkLineId, taskGuideSearchText: taskGuideSearchText, queryTypeValue: queryTypeValue });
      }
      export function searchTaskGuidesByTitleAsync(context: IContext, businessProcessModelFrameworkLineId: number, taskGuideSearchText: string | null, queryTypeValue: number):AsyncResult<TaskGuidesSearchResult[]> {
        const request = createSearchTaskGuidesByTitleInput(context.queryResultSettings, businessProcessModelFrameworkLineId, taskGuideSearchText, queryTypeValue, );
        return executeAction<TaskGuidesSearchResult[]>(request, context);
      }
  
      export function createGenerateBusinessProcessModelPackageInput(taskRecording: Recording | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GenerateBusinessProcessModelPackage', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {taskRecording: taskRecording });
      }
      export function generateBusinessProcessModelPackageAsync(context: IContext, taskRecording: Recording | null):AsyncResult<string> {
        const request = createGenerateBusinessProcessModelPackageInput(taskRecording, );
        return executeAction<string>(request, context);
      }
  
      export function createDownloadRecordingInput(businessProcessModelLineId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('DownloadRecording', true, RecordingClass, 'false', {  bypassCache: 'get', returnEntity: 'Recording'}, {businessProcessModelLineId: businessProcessModelLineId });
      }
      export function downloadRecordingAsync(context: IContext, businessProcessModelLineId: number):AsyncResult<Recording> {
        const request = createDownloadRecordingInput(businessProcessModelLineId, );
        return executeAction<Recording>(request, context);
      }
  
      export function createLoadRecordingFromFileInput(recordingUrl: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('LoadRecordingFromFile', true, RecordingClass, 'false', {  bypassCache: 'get', returnEntity: 'Recording'}, {recordingUrl: recordingUrl });
      }
      export function loadRecordingFromFileAsync(context: IContext, recordingUrl: string | null):AsyncResult<Recording> {
        const request = createLoadRecordingFromFileInput(recordingUrl, );
        return executeAction<Recording>(request, context);
      }
  
      export function createGenerateRecordingFileInput(taskRecording: Recording | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GenerateRecordingFile', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {taskRecording: taskRecording });
      }
      export function generateRecordingFileAsync(context: IContext, taskRecording: Recording | null):AsyncResult<string> {
        const request = createGenerateRecordingFileInput(taskRecording, );
        return executeAction<string>(request, context);
      }
  
      export function createGenerateTrainingDocumentInput(taskRecording: Recording | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GenerateTrainingDocument', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {taskRecording: taskRecording });
      }
      export function generateTrainingDocumentAsync(context: IContext, taskRecording: Recording | null):AsyncResult<string> {
        const request = createGenerateTrainingDocumentInput(taskRecording, );
        return executeAction<string>(request, context);
      }
  
      export function createGenerateRecordingBundleInput(taskRecording: Recording | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GenerateRecordingBundle', true, '', 'false', {  bypassCache: 'get', returnEntity: ''}, {taskRecording: taskRecording });
      }
      export function generateRecordingBundleAsync(context: IContext, taskRecording: Recording | null):AsyncResult<string> {
        const request = createGenerateRecordingBundleInput(taskRecording, );
        return executeAction<string>(request, context);
      }
  
      export function createUploadRecordingInput(taskRecording: Recording | null, businessProcessModelLineId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('UploadRecording', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {taskRecording: taskRecording, businessProcessModelLineId: businessProcessModelLineId });
      }
      export function uploadRecordingAsync(context: IContext, taskRecording: Recording | null, businessProcessModelLineId: number):AsyncResult<NullResult> {
        const request = createUploadRecordingInput(taskRecording, businessProcessModelLineId, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetAttributeDefinitionsInput(queryResultSettings: IQueryResultSettings, attributeDefinitionCriteria: AttributeDefinitionCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAttributeDefinitions', true, AttributeDefinitionClass, 'true', {  bypassCache: 'none', returnEntity: 'AttributeDefinition'}, {attributeDefinitionCriteria: attributeDefinitionCriteria });
      }
      export function getAttributeDefinitionsAsync(context: IContext, attributeDefinitionCriteria: AttributeDefinitionCriteria | null):AsyncResult<AttributeDefinition[]> {
        const request = createGetAttributeDefinitionsInput(context.queryResultSettings, attributeDefinitionCriteria, );
        return executeAction<AttributeDefinition[]>(request, context);
      }
  
      export function createGetAttributeGroupDefinitionsInput(queryResultSettings: IQueryResultSettings, attributeGroupDefinitionCriteria: AttributeGroupDefinitionCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAttributeGroupDefinitions', true, AttributeGroupDefinitionClass, 'true', {  bypassCache: 'none', returnEntity: 'AttributeGroupDefinition'}, {attributeGroupDefinitionCriteria: attributeGroupDefinitionCriteria });
      }
      export function getAttributeGroupDefinitionsAsync(context: IContext, attributeGroupDefinitionCriteria: AttributeGroupDefinitionCriteria | null):AsyncResult<AttributeGroupDefinition[]> {
        const request = createGetAttributeGroupDefinitionsInput(context.queryResultSettings, attributeGroupDefinitionCriteria, );
        return executeAction<AttributeGroupDefinition[]>(request, context);
      }
  
      export function createSaveFiscalTransactionInput(fiscalTransaction: FiscalTransaction | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('SaveFiscalTransaction', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {fiscalTransaction: fiscalTransaction });
      }
      export function saveFiscalTransactionAsync(context: IContext, fiscalTransaction: FiscalTransaction | null):AsyncResult<NullResult> {
        const request = createSaveFiscalTransactionInput(fiscalTransaction, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createValidatePrintReceiptCopyAllowedInput(salesOrderToPrint: SalesOrder | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('ValidatePrintReceiptCopyAllowed', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {salesOrderToPrint: salesOrderToPrint });
      }
      export function validatePrintReceiptCopyAllowedAsync(context: IContext, salesOrderToPrint: SalesOrder | null):AsyncResult<NullResult> {
        const request = createValidatePrintReceiptCopyAllowedInput(salesOrderToPrint, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createRegisterAuditEventInput(auditEvent: AuditEvent | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('RegisterAuditEvent', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {auditEvent: auditEvent });
      }
      export function registerAuditEventAsync(context: IContext, auditEvent: AuditEvent | null):AsyncResult<NullResult> {
        const request = createRegisterAuditEventInput(auditEvent, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createRegisterAndGetAuditEventInput(auditEvent: AuditEvent | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('RegisterAndGetAuditEvent', true, AuditEventClass, 'false', {  bypassCache: 'get', returnEntity: 'AuditEvent'}, {auditEvent: auditEvent });
      }
      export function registerAndGetAuditEventAsync(context: IContext, auditEvent: AuditEvent | null):AsyncResult<AuditEvent> {
        const request = createRegisterAndGetAuditEventInput(auditEvent, );
        return executeAction<AuditEvent>(request, context);
      }
  
      export function createGetInventoryAvailableToPromiseInput(queryResultSettings: IQueryResultSettings, productId: number, itemId: string | null, inventLocationId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetInventoryAvailableToPromise', true, InventoryAvailableToPromiseClass, 'true', {  bypassCache: 'none', returnEntity: 'InventoryAvailableToPromise'}, {productId: productId, itemId: itemId, inventLocationId: inventLocationId });
      }
      export function getInventoryAvailableToPromiseAsync(context: IContext, productId: number, itemId: string | null, inventLocationId: string | null):AsyncResult<InventoryAvailableToPromise[]> {
        const request = createGetInventoryAvailableToPromiseInput(context.queryResultSettings, productId, itemId, inventLocationId, );
        return executeAction<InventoryAvailableToPromise[]>(request, context);
      }
  
      export function createGetSalesOrdersWithNoFiscalTransactionsInput(queryResultSettings: IQueryResultSettings, storeNumber: string | null, terminalId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSalesOrdersWithNoFiscalTransactions', true, SalesOrderClass, 'true', {  bypassCache: 'none', returnEntity: 'SalesOrder'}, {storeNumber: storeNumber, terminalId: terminalId });
      }
      export function getSalesOrdersWithNoFiscalTransactionsAsync(context: IContext, storeNumber: string | null, terminalId: string | null):AsyncResult<SalesOrder[]> {
        const request = createGetSalesOrdersWithNoFiscalTransactionsInput(context.queryResultSettings, storeNumber, terminalId, );
        return executeAction<SalesOrder[]>(request, context);
      }
  
      export function createGetNotificationsInput(queryResultSettings: IQueryResultSettings, subscribedOperations: number[]): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetNotifications', true, NotificationItemClass, 'true', {  bypassCache: 'none', returnEntity: 'NotificationItem'}, {subscribedOperations: subscribedOperations });
      }
      export function getNotificationsAsync(context: IContext, subscribedOperations: number[]):AsyncResult<NotificationItem[]> {
        const request = createGetNotificationsInput(context.queryResultSettings, subscribedOperations, );
        return executeAction<NotificationItem[]>(request, context);
      }
  
      export function createAcknowledgeNotificationsInput(lastPullDateTime: Date): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('AcknowledgeNotifications', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {lastPullDateTime: lastPullDateTime });
      }
      export function acknowledgeNotificationsAsync(context: IContext, lastPullDateTime: Date):AsyncResult<NullResult> {
        const request = createAcknowledgeNotificationsInput(lastPullDateTime, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetFiscalIntegrationFiscalDocumentInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, fiscalIntegrationDocumentRetrievalCriteria: FiscalIntegrationDocumentRetrievalCriteria | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationFiscalDocument', true, FiscalIntegrationDocumentClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationDocument'}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, fiscalIntegrationDocumentRetrievalCriteria: fiscalIntegrationDocumentRetrievalCriteria, connectorType: connectorType });
      }
      export function getFiscalIntegrationFiscalDocumentAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, fiscalIntegrationDocumentRetrievalCriteria: FiscalIntegrationDocumentRetrievalCriteria | null, connectorType: number | null):AsyncResult<FiscalIntegrationDocument> {
        const request = createGetFiscalIntegrationFiscalDocumentInput(hardwareProfileId, functionalityProfileGroupId, fiscalIntegrationDocumentRetrievalCriteria, connectorType, );
        return executeAction<FiscalIntegrationDocument>(request, context);
      }
  
      export function createGetFiscalIntegrationNonFiscalDocumentInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, fiscalIntegrationDocumentRetrievalCriteria: FiscalIntegrationDocumentRetrievalCriteria | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationNonFiscalDocument', true, FiscalIntegrationDocumentClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationDocument'}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, fiscalIntegrationDocumentRetrievalCriteria: fiscalIntegrationDocumentRetrievalCriteria, connectorType: connectorType });
      }
      export function getFiscalIntegrationNonFiscalDocumentAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, fiscalIntegrationDocumentRetrievalCriteria: FiscalIntegrationDocumentRetrievalCriteria | null, connectorType: number | null):AsyncResult<FiscalIntegrationDocument> {
        const request = createGetFiscalIntegrationNonFiscalDocumentInput(hardwareProfileId, functionalityProfileGroupId, fiscalIntegrationDocumentRetrievalCriteria, connectorType, );
        return executeAction<FiscalIntegrationDocument>(request, context);
      }
  
      export function createGetFiscalIntegrationFiscalServiceSetupDocumentInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationFiscalServiceSetupDocument', true, FiscalIntegrationDocumentClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationDocument'}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, connectorType: connectorType });
      }
      export function getFiscalIntegrationFiscalServiceSetupDocumentAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, connectorType: number | null):AsyncResult<FiscalIntegrationDocument> {
        const request = createGetFiscalIntegrationFiscalServiceSetupDocumentInput(hardwareProfileId, functionalityProfileGroupId, connectorType, );
        return executeAction<FiscalIntegrationDocument>(request, context);
      }
  
      export function createGetFiscalIntegrationFiscalServiceReadDataDocumentInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationFiscalServiceReadDataDocument', true, FiscalIntegrationDocumentClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationDocument'}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, connectorType: connectorType });
      }
      export function getFiscalIntegrationFiscalServiceReadDataDocumentAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, connectorType: number | null):AsyncResult<FiscalIntegrationDocument> {
        const request = createGetFiscalIntegrationFiscalServiceReadDataDocumentInput(hardwareProfileId, functionalityProfileGroupId, connectorType, );
        return executeAction<FiscalIntegrationDocument>(request, context);
      }
  
      export function createProcessFiscalIntegrationFiscalServiceReadDataResultInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, documentToProcess: string | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('ProcessFiscalIntegrationFiscalServiceReadDataResult', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, documentToProcess: documentToProcess, connectorType: connectorType });
      }
      export function processFiscalIntegrationFiscalServiceReadDataResultAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, documentToProcess: string | null, connectorType: number | null):AsyncResult<NullResult> {
        const request = createProcessFiscalIntegrationFiscalServiceReadDataResultInput(hardwareProfileId, functionalityProfileGroupId, documentToProcess, connectorType, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createSaveFiscalIntegrationRegistrationResultInput(hardwareProfileId: string | null, functionalityProfileGroupId: string | null, registrationResult: FiscalIntegrationRegistrationResult | null, connectorType: number | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('SaveFiscalIntegrationRegistrationResult', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId, registrationResult: registrationResult, connectorType: connectorType });
      }
      export function saveFiscalIntegrationRegistrationResultAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string | null, registrationResult: FiscalIntegrationRegistrationResult | null, connectorType: number | null):AsyncResult<NullResult> {
        const request = createSaveFiscalIntegrationRegistrationResultInput(hardwareProfileId, functionalityProfileGroupId, registrationResult, connectorType, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetFiscalIntegrationRegistrationProcessInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationRegistrationProcess', true, FiscalIntegrationRegistrationProcessClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationRegistrationProcess'}, { });
      }
      export function getFiscalIntegrationRegistrationProcessAsync(context: IContext):AsyncResult<FiscalIntegrationRegistrationProcess> {
        const request = createGetFiscalIntegrationRegistrationProcessInput();
        return executeAction<FiscalIntegrationRegistrationProcess>(request, context);
      }
  
      export function createGetChannelSupportedFiscalIntegrationEventsByGroupInput(functionalityProfileGroupId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetChannelSupportedFiscalIntegrationEventsByGroup', true, FiscalIntegrationSupportedEventsClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationSupportedEvents'}, {functionalityProfileGroupId: functionalityProfileGroupId });
      }
      export function getChannelSupportedFiscalIntegrationEventsByGroupAsync(context: IContext, functionalityProfileGroupId: string | null):AsyncResult<FiscalIntegrationSupportedEvents> {
        const request = createGetChannelSupportedFiscalIntegrationEventsByGroupInput(functionalityProfileGroupId, );
        return executeAction<FiscalIntegrationSupportedEvents>(request, context);
      }
  
      export function createGetFiscalIntegrationTechnicalProfilesInput(queryResultSettings: IQueryResultSettings, hardwareProfileId: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationTechnicalProfiles', true, FiscalIntegrationTechnicalProfileClass, 'true', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationTechnicalProfile'}, {hardwareProfileId: hardwareProfileId });
      }
      export function getFiscalIntegrationTechnicalProfilesAsync(context: IContext, hardwareProfileId: string | null):AsyncResult<FiscalIntegrationTechnicalProfile[]> {
        const request = createGetFiscalIntegrationTechnicalProfilesInput(context.queryResultSettings, hardwareProfileId, );
        return executeAction<FiscalIntegrationTechnicalProfile[]>(request, context);
      }
  
      export function createGetFiscalIntegrationTechnicalProfilesByFunctionalityGroupIdsInput(queryResultSettings: IQueryResultSettings, hardwareProfileId: string | null, functionalityProfileGroupId: string[] | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationTechnicalProfilesByFunctionalityGroupIds', true, FiscalIntegrationTechnicalProfileClass, 'true', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationTechnicalProfile'}, {hardwareProfileId: hardwareProfileId, functionalityProfileGroupId: functionalityProfileGroupId });
      }
      export function getFiscalIntegrationTechnicalProfilesByFunctionalityGroupIdsAsync(context: IContext, hardwareProfileId: string | null, functionalityProfileGroupId: string[] | null):AsyncResult<FiscalIntegrationTechnicalProfile[]> {
        const request = createGetFiscalIntegrationTechnicalProfilesByFunctionalityGroupIdsInput(context.queryResultSettings, hardwareProfileId, functionalityProfileGroupId, );
        return executeAction<FiscalIntegrationTechnicalProfile[]>(request, context);
      }
  
      export function createBackupFiscalRegistrationProcessContextInput(terminalId: string | null, storeNumber: string | null, channelId: number, fiscalProcessCompleted: boolean, fiscalIntegrationSerializedContext: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('BackupFiscalRegistrationProcessContext', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {terminalId: terminalId, storeNumber: storeNumber, channelId: channelId, fiscalProcessCompleted: fiscalProcessCompleted, fiscalIntegrationSerializedContext: fiscalIntegrationSerializedContext });
      }
      export function backupFiscalRegistrationProcessContextAsync(context: IContext, terminalId: string | null, storeNumber: string | null, channelId: number, fiscalProcessCompleted: boolean, fiscalIntegrationSerializedContext: string | null):AsyncResult<NullResult> {
        const request = createBackupFiscalRegistrationProcessContextInput(terminalId, storeNumber, channelId, fiscalProcessCompleted, fiscalIntegrationSerializedContext, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetActiveFiscalRegistrationProcessContextBackupInput(terminalId: string | null, storeNumber: string | null, channelId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetActiveFiscalRegistrationProcessContextBackup', true, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {terminalId: terminalId, storeNumber: storeNumber, channelId: channelId });
      }
      export function getActiveFiscalRegistrationProcessContextBackupAsync(context: IContext, terminalId: string | null, storeNumber: string | null, channelId: number):AsyncResult<string> {
        const request = createGetActiveFiscalRegistrationProcessContextBackupInput(terminalId, storeNumber, channelId, );
        return executeAction<string>(request, context);
      }
  
      export function createGetFiscalIntegrationTechnicalProfilesBySearchCriteriaInput(queryResultSettings: IQueryResultSettings, hardwareProfileId: string | null, fiscalIntegrationTechnicalProfileSearchCriteria: FiscalIntegrationTechnicalProfileSearchCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationTechnicalProfilesBySearchCriteria', true, FiscalIntegrationTechnicalProfileClass, 'true', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationTechnicalProfile'}, {hardwareProfileId: hardwareProfileId, fiscalIntegrationTechnicalProfileSearchCriteria: fiscalIntegrationTechnicalProfileSearchCriteria });
      }
      export function getFiscalIntegrationTechnicalProfilesBySearchCriteriaAsync(context: IContext, hardwareProfileId: string | null, fiscalIntegrationTechnicalProfileSearchCriteria: FiscalIntegrationTechnicalProfileSearchCriteria | null):AsyncResult<FiscalIntegrationTechnicalProfile[]> {
        const request = createGetFiscalIntegrationTechnicalProfilesBySearchCriteriaInput(context.queryResultSettings, hardwareProfileId, fiscalIntegrationTechnicalProfileSearchCriteria, );
        return executeAction<FiscalIntegrationTechnicalProfile[]>(request, context);
      }
  
      export function createGetFiscalIntegrationServiceStatusInput(fiscalIntegrationServiceInfo: FiscalIntegrationServiceInfo | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetFiscalIntegrationServiceStatus', true, FiscalIntegrationServiceStatusClass, 'false', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationServiceStatus'}, {fiscalIntegrationServiceInfo: fiscalIntegrationServiceInfo });
      }
      export function getFiscalIntegrationServiceStatusAsync(context: IContext, fiscalIntegrationServiceInfo: FiscalIntegrationServiceInfo | null):AsyncResult<FiscalIntegrationServiceStatus> {
        const request = createGetFiscalIntegrationServiceStatusInput(fiscalIntegrationServiceInfo, );
        return executeAction<FiscalIntegrationServiceStatus>(request, context);
      }
  
      export function createSubmitFiscalIntegrationDocumentInput(documentToSubmit: string | null, fiscalIntegrationServiceInfo: FiscalIntegrationServiceInfo | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('SubmitFiscalIntegrationDocument', true, FiscalIntegrationServiceCommunicationResultClass, 'false', {  bypassCache: 'get', returnEntity: 'FiscalIntegrationServiceCommunicationResult'}, {documentToSubmit: documentToSubmit, fiscalIntegrationServiceInfo: fiscalIntegrationServiceInfo });
      }
      export function submitFiscalIntegrationDocumentAsync(context: IContext, documentToSubmit: string | null, fiscalIntegrationServiceInfo: FiscalIntegrationServiceInfo | null):AsyncResult<FiscalIntegrationServiceCommunicationResult> {
        const request = createSubmitFiscalIntegrationDocumentInput(documentToSubmit, fiscalIntegrationServiceInfo, );
        return executeAction<FiscalIntegrationServiceCommunicationResult>(request, context);
      }
  
      export function createGetFeatureStatesInput(queryResultSettings: IQueryResultSettings, featureNames: string[] | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetFeatureStates', true, FeatureStateClass, 'true', {  bypassCache: 'none', returnEntity: 'FeatureState'}, {featureNames: featureNames });
      }
      export function getFeatureStatesAsync(context: IContext, featureNames: string[] | null):AsyncResult<FeatureState[]> {
        const request = createGetFeatureStatesInput(context.queryResultSettings, featureNames, );
        return executeAction<FeatureState[]>(request, context);
      }
  
      export function createGetLastFiscalIntegrationSequentialSignaturesInput(queryResultSettings: IQueryResultSettings, sequentialKeys: string[] | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLastFiscalIntegrationSequentialSignatures', true, FiscalIntegrationSequentialSignatureDataClass, 'true', {  bypassCache: 'none', returnEntity: 'FiscalIntegrationSequentialSignatureData'}, {sequentialKeys: sequentialKeys });
      }
      export function getLastFiscalIntegrationSequentialSignaturesAsync(context: IContext, sequentialKeys: string[] | null):AsyncResult<FiscalIntegrationSequentialSignatureData[]> {
        const request = createGetLastFiscalIntegrationSequentialSignaturesInput(context.queryResultSettings, sequentialKeys, );
        return executeAction<FiscalIntegrationSequentialSignatureData[]>(request, context);
      }
  
      export function createGetAvailablePromotionsInput(queryResultSettings: IQueryResultSettings, searchCriteria: DiscountsSearchCriteria | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAvailablePromotions', true, PromotionClass, 'true', {  bypassCache: 'none', returnEntity: 'Promotion'}, {searchCriteria: searchCriteria });
      }
      export function getAvailablePromotionsAsync(context: IContext, searchCriteria: DiscountsSearchCriteria | null):AsyncResult<Promotion[]> {
        const request = createGetAvailablePromotionsInput(context.queryResultSettings, searchCriteria, );
        return executeAction<Promotion[]>(request, context);
      }
  
      export function createCreateFiscalTransactionInput(functionalityProfileGroupId: string | null, registrationResult: FiscalIntegrationRegistrationResult | null, connectorType: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('CreateFiscalTransaction', true, FiscalTransactionClass, 'false', {  bypassCache: 'get', returnEntity: 'FiscalTransaction'}, {functionalityProfileGroupId: functionalityProfileGroupId, registrationResult: registrationResult, connectorType: connectorType });
      }
      export function createFiscalTransactionAsync(context: IContext, functionalityProfileGroupId: string | null, registrationResult: FiscalIntegrationRegistrationResult | null, connectorType: number):AsyncResult<FiscalTransaction> {
        const request = createCreateFiscalTransactionInput(functionalityProfileGroupId, registrationResult, connectorType, );
        return executeAction<FiscalTransaction>(request, context);
      }
  
      export function createGetButtonGridsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetButtonGrids', false, ButtonGridClass, 'true', {  bypassCache: 'none', returnEntity: 'ButtonGrid'}, { });
      }
      export function getButtonGridsAsync(context: IContext):AsyncResult<ButtonGrid[]> {
        const request = createGetButtonGridsInput(context.queryResultSettings, );
        return executeAction<ButtonGrid[]>(request, context);
      }
  
      export function createGetButtonGridsByScreenSizeInput(queryResultSettings: IQueryResultSettings, height: number, width: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetButtonGridsByScreenSize', false, ButtonGridClass, 'true', {  bypassCache: 'none', returnEntity: 'ButtonGrid'}, {height: height, width: width });
      }
      export function getButtonGridsByScreenSizeAsync(context: IContext, height: number, width: number):AsyncResult<ButtonGrid[]> {
        const request = createGetButtonGridsByScreenSizeInput(context.queryResultSettings, height, width, );
        return executeAction<ButtonGrid[]>(request, context);
      }
  
      export function createGetCashDeclarationsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCashDeclarations', false, CashDeclarationClass, 'true', {  bypassCache: 'none', returnEntity: 'CashDeclaration'}, { });
      }
      export function getCashDeclarationsAsync(context: IContext):AsyncResult<CashDeclaration[]> {
        const request = createGetCashDeclarationsInput(context.queryResultSettings, );
        return executeAction<CashDeclaration[]>(request, context);
      }
  
      export function createGetCountryRegionsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCountryRegions', false, CountryRegionInfoClass, 'true', {  bypassCache: 'none', returnEntity: 'CountryRegionInfo'}, { });
      }
      export function getCountryRegionsAsync(context: IContext):AsyncResult<CountryRegionInfo[]> {
        const request = createGetCountryRegionsInput(context.queryResultSettings, );
        return executeAction<CountryRegionInfo[]>(request, context);
      }
  
      export function createGetCustomerGroupsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCustomerGroups', false, CustomerGroupClass, 'true', {  bypassCache: 'none', returnEntity: 'CustomerGroup'}, { });
      }
      export function getCustomerGroupsAsync(context: IContext):AsyncResult<CustomerGroup[]> {
        const request = createGetCustomerGroupsInput(context.queryResultSettings, );
        return executeAction<CustomerGroup[]>(request, context);
      }
  
      export function createGetDeliveryOptionsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDeliveryOptions', false, DeliveryOptionClass, 'true', {  bypassCache: 'none', returnEntity: 'DeliveryOption'}, { });
      }
      export function getDeliveryOptionsAsync(context: IContext):AsyncResult<DeliveryOption[]> {
        const request = createGetDeliveryOptionsInput(context.queryResultSettings, );
        return executeAction<DeliveryOption[]>(request, context);
      }
  
      export function createGetChannelsByTypeInput(queryResultSettings: IQueryResultSettings, channelType: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetChannelsByType', false, ChannelIdentityClass, 'true', {  bypassCache: 'none', returnEntity: 'ChannelIdentity'}, {channelType: channelType });
      }
      export function getChannelsByTypeAsync(context: IContext, channelType: string | null):AsyncResult<ChannelIdentity[]> {
        const request = createGetChannelsByTypeInput(context.queryResultSettings, channelType, );
        return executeAction<ChannelIdentity[]>(request, context);
      }
  
      export function createGetChannelsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetChannels', false, ChannelIdentityClass, 'true', {  bypassCache: 'none', returnEntity: 'ChannelIdentity'}, { });
      }
      export function getChannelsAsync(context: IContext):AsyncResult<ChannelIdentity[]> {
        const request = createGetChannelsInput(context.queryResultSettings, );
        return executeAction<ChannelIdentity[]>(request, context);
      }
  
      export function createGetEnvironmentConfigurationInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetEnvironmentConfiguration', false, EnvironmentConfigurationClass, 'false', {  bypassCache: 'none', returnEntity: 'EnvironmentConfiguration'}, { });
      }
      export function getEnvironmentConfigurationAsync(context: IContext):AsyncResult<EnvironmentConfiguration> {
        const request = createGetEnvironmentConfigurationInput();
        return executeAction<EnvironmentConfiguration>(request, context);
      }
  
      export function createGetSearchConfigurationInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetSearchConfiguration', false, SearchConfigurationClass, 'false', {  bypassCache: 'none', returnEntity: 'SearchConfiguration'}, { });
      }
      export function getSearchConfigurationAsync(context: IContext):AsyncResult<SearchConfiguration> {
        const request = createGetSearchConfigurationInput();
        return executeAction<SearchConfiguration>(request, context);
      }
  
      export function createGetExtensionPackageDefinitionsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetExtensionPackageDefinitions', false, ExtensionPackageDefinitionClass, 'true', {  bypassCache: 'none', returnEntity: 'ExtensionPackageDefinition'}, { });
      }
      export function getExtensionPackageDefinitionsAsync(context: IContext):AsyncResult<ExtensionPackageDefinition[]> {
        const request = createGetExtensionPackageDefinitionsInput(context.queryResultSettings, );
        return executeAction<ExtensionPackageDefinition[]>(request, context);
      }
  
      export function createGetExtensionProfileInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetExtensionProfile', false, ExtensionProfileClass, 'false', {  bypassCache: 'none', returnEntity: 'ExtensionProfile'}, { });
      }
      export function getExtensionProfileAsync(context: IContext):AsyncResult<ExtensionProfile> {
        const request = createGetExtensionProfileInput();
        return executeAction<ExtensionProfile>(request, context);
      }
  
      export function createGetDeviceConfigurationInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetDeviceConfiguration', false, DeviceConfigurationClass, 'false', {  bypassCache: 'none', returnEntity: 'DeviceConfiguration'}, { });
      }
      export function getDeviceConfigurationAsync(context: IContext):AsyncResult<DeviceConfiguration> {
        const request = createGetDeviceConfigurationInput();
        return executeAction<DeviceConfiguration>(request, context);
      }
  
      export function createGetVisualProfileInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetVisualProfile', false, VisualProfileClass, 'false', {  bypassCache: 'none', returnEntity: 'VisualProfile'}, { });
      }
      export function getVisualProfileAsync(context: IContext):AsyncResult<VisualProfile> {
        const request = createGetVisualProfileInput();
        return executeAction<VisualProfile>(request, context);
      }
  
      export function createGetLanguagesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetLanguages', false, SupportedLanguageClass, 'true', {  bypassCache: 'none', returnEntity: 'SupportedLanguage'}, { });
      }
      export function getLanguagesAsync(context: IContext):AsyncResult<SupportedLanguage[]> {
        const request = createGetLanguagesInput(context.queryResultSettings, );
        return executeAction<SupportedLanguage[]>(request, context);
      }
  
      export function createGetAffiliationsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAffiliations', false, AffiliationClass, 'true', {  bypassCache: 'none', returnEntity: 'Affiliation'}, { });
      }
      export function getAffiliationsAsync(context: IContext):AsyncResult<Affiliation[]> {
        const request = createGetAffiliationsInput(context.queryResultSettings, );
        return executeAction<Affiliation[]>(request, context);
      }
  
      export function createGetOperationPermissionsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetOperationPermissions', false, OperationPermissionClass, 'true', {  bypassCache: 'none', returnEntity: 'OperationPermission'}, { });
      }
      export function getOperationPermissionsAsync(context: IContext):AsyncResult<OperationPermission[]> {
        const request = createGetOperationPermissionsInput(context.queryResultSettings, );
        return executeAction<OperationPermission[]>(request, context);
      }
  
      export function createGetReasonCodesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetReasonCodes', false, ReasonCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'ReasonCode'}, { });
      }
      export function getReasonCodesAsync(context: IContext):AsyncResult<ReasonCode[]> {
        const request = createGetReasonCodesInput(context.queryResultSettings, );
        return executeAction<ReasonCode[]>(request, context);
      }
  
      export function createGetReturnOrderReasonCodesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetReturnOrderReasonCodes', false, ReasonCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'ReasonCode'}, { });
      }
      export function getReturnOrderReasonCodesAsync(context: IContext):AsyncResult<ReasonCode[]> {
        const request = createGetReturnOrderReasonCodesInput(context.queryResultSettings, );
        return executeAction<ReasonCode[]>(request, context);
      }
  
      export function createGetSalesTaxGroupsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSalesTaxGroups', false, SalesTaxGroupClass, 'true', {  bypassCache: 'none', returnEntity: 'SalesTaxGroup'}, { });
      }
      export function getSalesTaxGroupsAsync(context: IContext):AsyncResult<SalesTaxGroup[]> {
        const request = createGetSalesTaxGroupsInput(context.queryResultSettings, );
        return executeAction<SalesTaxGroup[]>(request, context);
      }
  
      export function createGetTenderTypesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetTenderTypes', false, TenderTypeClass, 'true', {  bypassCache: 'none', returnEntity: 'TenderType'}, { });
      }
      export function getTenderTypesAsync(context: IContext):AsyncResult<TenderType[]> {
        const request = createGetTenderTypesInput(context.queryResultSettings, );
        return executeAction<TenderType[]>(request, context);
      }
  
      export function createGetUnitsOfMeasureInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetUnitsOfMeasure', false, UnitOfMeasureClass, 'true', {  bypassCache: 'none', returnEntity: 'UnitOfMeasure'}, { });
      }
      export function getUnitsOfMeasureAsync(context: IContext):AsyncResult<UnitOfMeasure[]> {
        const request = createGetUnitsOfMeasureInput(context.queryResultSettings, );
        return executeAction<UnitOfMeasure[]>(request, context);
      }
  
      export function createGetDiscountCodesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDiscountCodes', false, DiscountCodeClass, 'true', {  bypassCache: 'none', returnEntity: 'DiscountCode'}, { });
      }
      export function getDiscountCodesAsync(context: IContext):AsyncResult<DiscountCode[]> {
        const request = createGetDiscountCodesInput(context.queryResultSettings, );
        return executeAction<DiscountCode[]>(request, context);
      }
  
      export function createGetCurrenciesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCurrencies', false, CurrencyClass, 'true', {  bypassCache: 'none', returnEntity: 'Currency'}, { });
      }
      export function getCurrenciesAsync(context: IContext):AsyncResult<Currency[]> {
        const request = createGetCurrenciesInput(context.queryResultSettings, );
        return executeAction<Currency[]>(request, context);
      }
  
      export function createGetCurrenciesAmountInput(queryResultSettings: IQueryResultSettings, currencyCode: string | null, amount: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCurrenciesAmount', false, CurrencyAmountClass, 'true', {  bypassCache: 'none', returnEntity: 'CurrencyAmount'}, {currencyCode: currencyCode, amount: amount });
      }
      export function getCurrenciesAmountAsync(context: IContext, currencyCode: string | null, amount: number):AsyncResult<CurrencyAmount[]> {
        const request = createGetCurrenciesAmountInput(context.queryResultSettings, currencyCode, amount, );
        return executeAction<CurrencyAmount[]>(request, context);
      }
  
      export function createGetCommissionSalesGroupsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCommissionSalesGroups', false, CommissionSalesGroupClass, 'true', {  bypassCache: 'none', returnEntity: 'CommissionSalesGroup'}, { });
      }
      export function getCommissionSalesGroupsAsync(context: IContext):AsyncResult<CommissionSalesGroup[]> {
        const request = createGetCommissionSalesGroupsInput(context.queryResultSettings, );
        return executeAction<CommissionSalesGroup[]>(request, context);
      }
  
      export function createSearchCommissionSalesGroupsInput(queryResultSettings: IQueryResultSettings, searchText: string | null): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchCommissionSalesGroups', false, CommissionSalesGroupClass, 'true', {  bypassCache: 'none', returnEntity: 'CommissionSalesGroup'}, {searchText: searchText });
      }
      export function searchCommissionSalesGroupsAsync(context: IContext, searchText: string | null):AsyncResult<CommissionSalesGroup[]> {
        const request = createSearchCommissionSalesGroupsInput(context.queryResultSettings, searchText, );
        return executeAction<CommissionSalesGroup[]>(request, context);
      }
  
      export function createGetPaymentMerchantInformationInput(hardwareProfileId: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetPaymentMerchantInformation', false, PaymentMerchantInformationClass, 'false', {  bypassCache: 'none', returnEntity: 'PaymentMerchantInformation'}, {hardwareProfileId: hardwareProfileId });
      }
      export function getPaymentMerchantInformationAsync(context: IContext, hardwareProfileId: string | null):AsyncResult<PaymentMerchantInformation> {
        const request = createGetPaymentMerchantInformationInput(hardwareProfileId, );
        return executeAction<PaymentMerchantInformation>(request, context);
      }
  
      export function createGetPaymentPropertiesIfModifiedInput(hardwareProfileId: string | null, merchantInformationHash: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetPaymentPropertiesIfModified', false, PaymentMerchantInformationClass, 'false', {  bypassCache: 'none', returnEntity: 'PaymentMerchantInformation'}, {hardwareProfileId: hardwareProfileId, merchantInformationHash: merchantInformationHash });
      }
      export function getPaymentPropertiesIfModifiedAsync(context: IContext, hardwareProfileId: string | null, merchantInformationHash: string | null):AsyncResult<PaymentMerchantInformation> {
        const request = createGetPaymentPropertiesIfModifiedInput(hardwareProfileId, merchantInformationHash, );
        return executeAction<PaymentMerchantInformation>(request, context);
      }
  
      export function createGetOnlineChannelPublishStatusInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetOnlineChannelPublishStatus', false, '', 'false', {  bypassCache: 'none', returnEntity: ''}, { });
      }
      export function getOnlineChannelPublishStatusAsync(context: IContext):AsyncResult<number> {
        const request = createGetOnlineChannelPublishStatusInput();
        return executeAction<number>(request, context);
      }
  
      export function createSetOnlineChannelPublishStatusInput(publishingStatus: number, statusMessage: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('SetOnlineChannelPublishStatus', true, '', '', {  bypassCache: 'get', returnEntity: ''}, {publishingStatus: publishingStatus, statusMessage: statusMessage });
      }
      export function setOnlineChannelPublishStatusAsync(context: IContext, publishingStatus: number, statusMessage: string | null):AsyncResult<NullResult> {
        const request = createSetOnlineChannelPublishStatusInput(publishingStatus, statusMessage, );
        return executeAction<NullResult>(request, context);
      }
  
      export function createGetInventoryConfigurationInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetInventoryConfiguration', false, ChannelInventoryConfigurationClass, 'false', {  bypassCache: 'none', returnEntity: 'ChannelInventoryConfiguration'}, { });
      }
      export function getInventoryConfigurationAsync(context: IContext):AsyncResult<ChannelInventoryConfiguration> {
        const request = createGetInventoryConfigurationInput();
        return executeAction<ChannelInventoryConfiguration>(request, context);
      }
  
      export function createGetAvailableDevicesInput(queryResultSettings: IQueryResultSettings, deviceType: number): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAvailableDevices', false, DeviceClass, 'true', {  bypassCache: 'none', returnEntity: 'Device'}, {deviceType: deviceType });
      }
      export function getAvailableDevicesAsync(context: IContext, deviceType: number):AsyncResult<Device[]> {
        const request = createGetAvailableDevicesInput(context.queryResultSettings, deviceType, );
        return executeAction<Device[]>(request, context);
      }
  
      export function createGetUserDefinedSecretStringInput(secretName: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetUserDefinedSecretString', false, '', 'false', {  bypassCache: 'none', returnEntity: ''}, {secretName: secretName });
      }
      export function getUserDefinedSecretStringAsync(context: IContext, secretName: string | null):AsyncResult<string> {
        const request = createGetUserDefinedSecretStringInput(secretName, );
        return executeAction<string>(request, context);
      }
  
      export function createGetUserDefinedSecretCertificateInput(secretName: string | null): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetUserDefinedSecretCertificate', false, UserDefinedSecretCertificateResultClass, 'false', {  bypassCache: 'none', returnEntity: 'UserDefinedSecretCertificateResult'}, {secretName: secretName });
      }
      export function getUserDefinedSecretCertificateAsync(context: IContext, secretName: string | null):AsyncResult<UserDefinedSecretCertificateResult> {
        const request = createGetUserDefinedSecretCertificateInput(secretName, );
        return executeAction<UserDefinedSecretCertificateResult>(request, context);
      }
  
      export function createGetImageBlobInput(imageId: number): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetImageBlob', false, MediaBlobClass, 'false', {  bypassCache: 'none', returnEntity: 'MediaBlob'}, {imageId: imageId });
      }
      export function getImageBlobAsync(context: IContext, imageId: number):AsyncResult<MediaBlob> {
        const request = createGetImageBlobInput(imageId, );
        return executeAction<MediaBlob>(request, context);
      }
  
      export function createGetExtensibleEnumerationsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetExtensibleEnumerations', false, ExtensibleEnumerationContainerClass, 'true', {  bypassCache: 'none', returnEntity: 'ExtensibleEnumerationContainer'}, { });
      }
      export function getExtensibleEnumerationsAsync(context: IContext):AsyncResult<ExtensibleEnumerationContainer[]> {
        const request = createGetExtensibleEnumerationsInput(context.queryResultSettings, );
        return executeAction<ExtensibleEnumerationContainer[]>(request, context);
      }
  
      export function createGetAddressPurposesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        const query = storeQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAddressPurposes', false, AddressPurposeClass, 'true', {  bypassCache: 'none', returnEntity: 'AddressPurpose'}, { });
      }
      export function getAddressPurposesAsync(context: IContext):AsyncResult<AddressPurpose[]> {
        const request = createGetAddressPurposesInput(context.queryResultSettings, );
        return executeAction<AddressPurpose[]>(request, context);
      }
  
      export function createGetReturnPolicyInput(): IDataServiceRequest {
        const query = storeQuery();
        return query.createDataServiceRequestForOperation('GetReturnPolicy', false, ReturnPolicyClass, 'false', {  bypassCache: 'none', returnEntity: 'ReturnPolicy'}, { });
      }
      export function getReturnPolicyAsync(context: IContext):AsyncResult<ReturnPolicy> {
        const request = createGetReturnPolicyInput();
        return executeAction<ReturnPolicy>(request, context);
      }
  
    
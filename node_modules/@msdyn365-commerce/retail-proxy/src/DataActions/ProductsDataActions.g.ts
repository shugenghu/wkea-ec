    // <auto-generated />
    import { AsyncResult } from '../async-result';
    import { DataServiceQuery } from '../DataServiceQuery';
    import { Product, ProductDimension, ProductVariantResolutionOnKitSelectionContext, ProductDimensionValue, SimpleProduct, ComponentInSlotRelation, ProductComparisonLine, ProductSearchResult, ProductRefinerValue, ProductSearchCriteria, ProductRefiner, ChangedProductsSearchCriteria, ReadChangedProductsSession, DeletedListingsResult, ProductRating, ProductAssortmentInterval, Address, ProductDeliveryOptions, ListingPublishStatus, ProductPrice, ProductAvailableQuantity, ProjectionDomain, AffiliationLoyaltyTier, ProductComponent, CategoryPathLookup, CategoryPathResult, ProductLookupClause, SearchSuggestion, AttributeProduct, AttributeValue, MediaLocation, MediaBlob, ProductRelationType, UnitOfMeasure, ProductWarrantiesMapping, ProductWarehouse, ProductWarehouseInventoryInformation, InventoryAvailabilitySearchCriteria } from '../Entities/CommerceTypes.g';
    import { ProductClass, ProductDimensionValueClass, SimpleProductClass, ProductComparisonLineClass, ProductSearchResultClass, ProductRefinerClass, ReadChangedProductsSessionClass, DeletedListingsResultClass, ProductRatingClass, ProductAssortmentIntervalClass, ProductDeliveryOptionsClass, ProductPriceClass, ProductAvailableQuantityClass, ProductComponentClass, CategoryPathResultClass, SearchSuggestionClass, ProductRefinerValueClass, AttributeProductClass, AttributeValueClass, MediaLocationClass, MediaBlobClass, ProductRelationTypeClass, UnitOfMeasureClass, ProductWarrantiesMappingClass, ProductWarehouseInventoryInformationClass } from '../Entities/CommerceModels.g';
    import { IContext, IDataServiceRequest, IQueryResultSettings, NullResult } from '../Interfaces';
    import { executeAction } from '../retail-action';
    
    
    function productsQuery(recordId?: number): DataServiceQuery {
      var key = (recordId) ? { RecordId: recordId } : null;
      return new DataServiceQuery("Products", "Product", ProductClass, key);
    }
    
    export function createCreateInput(entity: Product): IDataServiceRequest {
        return productsQuery().create(entity);
    }
    export function createProductAsync(context: IContext, entity: Product): AsyncResult<Product> {
        const request = createCreateInput(entity, );
        return executeAction<Product>(request, context);
    }
    export function createUpdateInput(entity: Product): IDataServiceRequest {
        return productsQuery(entity.RecordId).update(entity);
    }
    export function updateAsync(context: IContext, entity: Product): AsyncResult<Product> {
        const request = createUpdateInput(entity, );
        return executeAction<Product>(request, context);
    }
    export function createDeleteAsync(entity: Product): IDataServiceRequest {
        return productsQuery(entity.RecordId).delete();
    }
    export function deleteAsync(context: IContext, entity: Product): AsyncResult<NullResult> {
        const request = createDeleteAsync(entity, );
        return executeAction<NullResult>(request, context);
    }
    export function createReadAsync(recordId: number): IDataServiceRequest {
        return productsQuery(recordId).read();
    }
    export function readAsync(context: IContext, recordId: number): AsyncResult<Product> {
        const request = createReadAsync(recordId, );
        return executeAction<Product>(request, context);
    }
    export function createReadAllAsync(queryResultSettings: IQueryResultSettings): IDataServiceRequest {
        return productsQuery().resultSettings(queryResultSettings).read();
    }
    export function readAllAsync(context: IContext): AsyncResult<Product[]> {
        const request = createReadAllAsync(context.queryResultSettings, );
        return executeAction<Product[]>(request, context);
    }
    
    export function createGetDimensionValuesInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, dimension: number, matchingDimensionValues: ProductDimension[] | null, kitVariantResolutionContext: ProductVariantResolutionOnKitSelectionContext | null): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDimensionValues', true, ProductDimensionValueClass, 'true', { bypassCache: 'none', returnEntity: 'ProductDimensionValue'}, {channelId: channelId, dimension: dimension, matchingDimensionValues: matchingDimensionValues, kitVariantResolutionContext: kitVariantResolutionContext });
    }    
    
    export function getDimensionValuesAsync(context: IContext, recordId: number, channelId: number, dimension: number, matchingDimensionValues: ProductDimension[] | null, kitVariantResolutionContext: ProductVariantResolutionOnKitSelectionContext | null):AsyncResult<ProductDimensionValue[]> {
        const request = createGetDimensionValuesInput(context.queryResultSettings, recordId, channelId, dimension, matchingDimensionValues, kitVariantResolutionContext, );
        return executeAction<ProductDimensionValue[]>(request, context);
    }          
          
    export function createGetVariantsByDimensionValuesInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, matchingDimensionValues: ProductDimension[] | null): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetVariantsByDimensionValues', true, SimpleProductClass, 'true', { bypassCache: 'none', returnEntity: 'SimpleProduct'}, {channelId: channelId, matchingDimensionValues: matchingDimensionValues });
    }    
    
    export function getVariantsByDimensionValuesAsync(context: IContext, recordId: number, channelId: number, matchingDimensionValues: ProductDimension[] | null):AsyncResult<SimpleProduct[]> {
        const request = createGetVariantsByDimensionValuesInput(context.queryResultSettings, recordId, channelId, matchingDimensionValues, );
        return executeAction<SimpleProduct[]>(request, context);
    }          
          
    export function createGetVariantsByComponentsInSlotsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, matchingSlotToComponentRelationship: ComponentInSlotRelation[] | null): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetVariantsByComponentsInSlots', true, SimpleProductClass, 'true', { bypassCache: 'none', returnEntity: 'SimpleProduct'}, {channelId: channelId, matchingSlotToComponentRelationship: matchingSlotToComponentRelationship });
    }    
    
    export function getVariantsByComponentsInSlotsAsync(context: IContext, recordId: number, channelId: number, matchingSlotToComponentRelationship: ComponentInSlotRelation[] | null):AsyncResult<SimpleProduct[]> {
        const request = createGetVariantsByComponentsInSlotsInput(context.queryResultSettings, recordId, channelId, matchingSlotToComponentRelationship, );
        return executeAction<SimpleProduct[]>(request, context);
    }          
          
    export function createGetByIdsInput(queryResultSettings: IQueryResultSettings, channelId: number, productIds: number[]): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetByIds', true, SimpleProductClass, 'true', { bypassCache: 'none', returnEntity: 'SimpleProduct'}, {channelId: channelId, productIds: productIds });
    }    
    
    export function getByIdsAsync(context: IContext, channelId: number, productIds: number[]):AsyncResult<SimpleProduct[]> {
        const request = createGetByIdsInput(context.queryResultSettings, channelId, productIds, );
        return executeAction<SimpleProduct[]>(request, context);
    }          
          
    export function createCompareInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, productIds: number[]): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('Compare', true, ProductComparisonLineClass, 'true', { bypassCache: 'get', returnEntity: 'ProductComparisonLine'}, {channelId: channelId, catalogId: catalogId, productIds: productIds });
    }    
    
    export function compareAsync(context: IContext, channelId: number, catalogId: number, productIds: number[]):AsyncResult<ProductComparisonLine[]> {
        const request = createCompareInput(context.queryResultSettings, channelId, catalogId, productIds, );
        return executeAction<ProductComparisonLine[]>(request, context);
    }          
          
    export function createGetRecommendedProductsInput(queryResultSettings: IQueryResultSettings, productIds: number[], customerId: string | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRecommendedProducts', true, ProductSearchResultClass, 'true', { bypassCache: 'none', returnEntity: 'ProductSearchResult'}, {productIds: productIds, customerId: customerId });
    }    
    
    export function getRecommendedProductsAsync(context: IContext, productIds: number[], customerId: string | null):AsyncResult<ProductSearchResult[]> {
        const request = createGetRecommendedProductsInput(context.queryResultSettings, productIds, customerId, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createRefineSearchByCategoryInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, categoryId: number, refinementCriteria: ProductRefinerValue[] | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('RefineSearchByCategory', true, ProductSearchResultClass, 'true', { bypassCache: 'get', returnEntity: 'ProductSearchResult'}, {channelId: channelId, catalogId: catalogId, categoryId: categoryId, refinementCriteria: refinementCriteria });
    }    
    
    export function refineSearchByCategoryAsync(context: IContext, channelId: number, catalogId: number, categoryId: number, refinementCriteria: ProductRefinerValue[] | null):AsyncResult<ProductSearchResult[]> {
        const request = createRefineSearchByCategoryInput(context.queryResultSettings, channelId, catalogId, categoryId, refinementCriteria, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createRefineSearchByTextInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, searchText: string | null, refinementCriteria: ProductRefinerValue[] | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('RefineSearchByText', true, ProductSearchResultClass, 'true', { bypassCache: 'get', returnEntity: 'ProductSearchResult'}, {channelId: channelId, catalogId: catalogId, searchText: searchText, refinementCriteria: refinementCriteria });
    }    
    
    export function refineSearchByTextAsync(context: IContext, channelId: number, catalogId: number, searchText: string | null, refinementCriteria: ProductRefinerValue[] | null):AsyncResult<ProductSearchResult[]> {
        const request = createRefineSearchByTextInput(context.queryResultSettings, channelId, catalogId, searchText, refinementCriteria, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createGetProductSearchRefinersInput(queryResultSettings: IQueryResultSettings, searchCriteria: ProductSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetProductSearchRefiners', true, ProductRefinerClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefiner'}, {searchCriteria: searchCriteria });
    }    
    
    export function getProductSearchRefinersAsync(context: IContext, searchCriteria: ProductSearchCriteria | null):AsyncResult<ProductRefiner[]> {
        const request = createGetProductSearchRefinersInput(context.queryResultSettings, searchCriteria, );
        return executeAction<ProductRefiner[]>(request, context);
    }          
          
    export function createSearchInput(queryResultSettings: IQueryResultSettings, productSearchCriteria: ProductSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('Search', true, ProductClass, 'true', { bypassCache: 'none', returnEntity: 'Product'}, {productSearchCriteria: productSearchCriteria });
    }    
    
    export function searchAsync(context: IContext, productSearchCriteria: ProductSearchCriteria | null):AsyncResult<Product[]> {
        const request = createSearchInput(context.queryResultSettings, productSearchCriteria, );
        return executeAction<Product[]>(request, context);
    }          
          
    export function createGetRefinersInput(queryResultSettings: IQueryResultSettings, productSearchCriteria: ProductSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRefiners', true, ProductRefinerClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefiner'}, {productSearchCriteria: productSearchCriteria });
    }    
    
    export function getRefinersAsync(context: IContext, productSearchCriteria: ProductSearchCriteria | null):AsyncResult<ProductRefiner[]> {
        const request = createGetRefinersInput(context.queryResultSettings, productSearchCriteria, );
        return executeAction<ProductRefiner[]>(request, context);
    }          
          
    export function createChangesInput(queryResultSettings: IQueryResultSettings, productSearchCriteria: ChangedProductsSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('Changes', true, ProductClass, 'true', { bypassCache: 'get', returnEntity: 'Product'}, {productSearchCriteria: productSearchCriteria });
    }    
    
    export function changesAsync(context: IContext, productSearchCriteria: ChangedProductsSearchCriteria | null):AsyncResult<Product[]> {
        const request = createChangesInput(context.queryResultSettings, productSearchCriteria, );
        return executeAction<Product[]>(request, context);
    }          
          
    export function createBeginReadChangedProductsInput(changedProductSearchCriteria: ChangedProductsSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('BeginReadChangedProducts', true, ReadChangedProductsSessionClass, 'false', { bypassCache: 'get', returnEntity: 'ReadChangedProductsSession'}, {changedProductSearchCriteria: changedProductSearchCriteria });
    }    
    
    export function beginReadChangedProductsAsync(context: IContext, changedProductSearchCriteria: ChangedProductsSearchCriteria | null):AsyncResult<ReadChangedProductsSession> {
        const request = createBeginReadChangedProductsInput(changedProductSearchCriteria, );
        return executeAction<ReadChangedProductsSession>(request, context);
    }          
          
    export function createReadChangedProductsInput(queryResultSettings: IQueryResultSettings, productSearchCriteria: ChangedProductsSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('ReadChangedProducts', true, ProductClass, 'true', { bypassCache: 'none', returnEntity: 'Product'}, {productSearchCriteria: productSearchCriteria });
    }    
    
    export function readChangedProductsAsync(context: IContext, productSearchCriteria: ChangedProductsSearchCriteria | null):AsyncResult<Product[]> {
        const request = createReadChangedProductsInput(context.queryResultSettings, productSearchCriteria, );
        return executeAction<Product[]>(request, context);
    }          
          
    export function createGetDeletedListingsInput(catalogId: number, skip: number, top: number): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('GetDeletedListings', true, DeletedListingsResultClass, 'false', { bypassCache: 'none', returnEntity: 'DeletedListingsResult'}, {catalogId: catalogId, skip: skip, top: top });
    }    
    
    export function getDeletedListingsAsync(context: IContext, catalogId: number, skip: number, top: number):AsyncResult<DeletedListingsResult> {
        const request = createGetDeletedListingsInput(catalogId, skip, top, );
        return executeAction<DeletedListingsResult>(request, context);
    }          
          
    export function createGetDeletedCatalogsInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDeletedCatalogs', false, '', 'true', { bypassCache: 'none', returnEntity: ''}, { });
    }    
    
    export function getDeletedCatalogsAsync(context: IContext):AsyncResult<number[]> {
        const request = createGetDeletedCatalogsInput(context.queryResultSettings, );
        return executeAction<number[]>(request, context);
    }          
          
    export function createGetDeletedLanguagesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDeletedLanguages', false, '', 'true', { bypassCache: 'none', returnEntity: ''}, { });
    }    
    
    export function getDeletedLanguagesAsync(context: IContext):AsyncResult<string[]> {
        const request = createGetDeletedLanguagesInput(context.queryResultSettings, );
        return executeAction<string[]>(request, context);
    }          
          
    export function createGetProductRatingsInput(queryResultSettings: IQueryResultSettings, productIds: number[]): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetProductRatings', true, ProductRatingClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRating'}, {productIds: productIds });
    }    
    
    export function getProductRatingsAsync(context: IContext, productIds: number[]):AsyncResult<ProductRating[]> {
        const request = createGetProductRatingsInput(context.queryResultSettings, productIds, );
        return executeAction<ProductRating[]>(request, context);
    }          
          
    export function createGetProductAssortmentIntervalsInput(queryResultSettings: IQueryResultSettings, productIds: number[]): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetProductAssortmentIntervals', true, ProductAssortmentIntervalClass, 'true', { bypassCache: 'none', returnEntity: 'ProductAssortmentInterval'}, {productIds: productIds });
    }    
    
    export function getProductAssortmentIntervalsAsync(context: IContext, productIds: number[]):AsyncResult<ProductAssortmentInterval[]> {
        const request = createGetProductAssortmentIntervalsInput(context.queryResultSettings, productIds, );
        return executeAction<ProductAssortmentInterval[]>(request, context);
    }          
          
    export function createGetDeliveryOptionsInput(queryResultSettings: IQueryResultSettings, productIds: number[], address: Address | null, filterOption: number | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDeliveryOptions', true, ProductDeliveryOptionsClass, 'true', { bypassCache: 'none', returnEntity: 'ProductDeliveryOptions'}, {productIds: productIds, address: address, filterOption: filterOption });
    }    
    
    export function getDeliveryOptionsAsync(context: IContext, productIds: number[], address: Address | null, filterOption: number | null):AsyncResult<ProductDeliveryOptions[]> {
        const request = createGetDeliveryOptionsInput(context.queryResultSettings, productIds, address, filterOption, );
        return executeAction<ProductDeliveryOptions[]>(request, context);
    }          
          
    export function createDeleteListingsByCatalogsInput(catalogIds: number[]): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('DeleteListingsByCatalogs', true, '', '', { bypassCache: 'get', returnEntity: ''}, {catalogIds: catalogIds });
    }    
    
    export function deleteListingsByCatalogsAsync(context: IContext, catalogIds: number[]):AsyncResult<NullResult> {
        const request = createDeleteListingsByCatalogsInput(catalogIds, );
        return executeAction<NullResult>(request, context);
    }          
          
    export function createDeleteListingsByLanguagesInput(languages: string[] | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('DeleteListingsByLanguages', true, '', '', { bypassCache: 'get', returnEntity: ''}, {languages: languages });
    }    
    
    export function deleteListingsByLanguagesAsync(context: IContext, languages: string[] | null):AsyncResult<NullResult> {
        const request = createDeleteListingsByLanguagesInput(languages, );
        return executeAction<NullResult>(request, context);
    }          
          
    export function createEndReadChangedProductsInput(session: ReadChangedProductsSession | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('EndReadChangedProducts', true, '', '', { bypassCache: 'get', returnEntity: ''}, {session: session });
    }    
    
    export function endReadChangedProductsAsync(context: IContext, session: ReadChangedProductsSession | null):AsyncResult<NullResult> {
        const request = createEndReadChangedProductsInput(session, );
        return executeAction<NullResult>(request, context);
    }          
          
    export function createUpdateListingPublishingStatusInput(publishingStatuses: ListingPublishStatus[] | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('UpdateListingPublishingStatus', true, '', '', { bypassCache: 'get', returnEntity: ''}, {publishingStatuses: publishingStatuses });
    }    
    
    export function updateListingPublishingStatusAsync(context: IContext, publishingStatuses: ListingPublishStatus[] | null):AsyncResult<NullResult> {
        const request = createUpdateListingPublishingStatusInput(publishingStatuses, );
        return executeAction<NullResult>(request, context);
    }          
          
    export function createGetPricesInput(queryResultSettings: IQueryResultSettings, itemId: string | null, inventoryDimensionId: string | null, barcode: string | null, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null, quantity: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetPrices', true, ProductPriceClass, 'true', { bypassCache: 'none', returnEntity: 'ProductPrice'}, {itemId: itemId, inventoryDimensionId: inventoryDimensionId, barcode: barcode, customerAccountNumber: customerAccountNumber, unitOfMeasureSymbol: unitOfMeasureSymbol, quantity: quantity });
    }    
    
    export function getPricesAsync(context: IContext, itemId: string | null, inventoryDimensionId: string | null, barcode: string | null, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null, quantity: number):AsyncResult<ProductPrice[]> {
        const request = createGetPricesInput(context.queryResultSettings, itemId, inventoryDimensionId, barcode, customerAccountNumber, unitOfMeasureSymbol, quantity, );
        return executeAction<ProductPrice[]>(request, context);
    }          
          
    export function createGetProductAvailabilitiesInput(queryResultSettings: IQueryResultSettings, itemIds: number[], channelId: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetProductAvailabilities', true, ProductAvailableQuantityClass, 'true', { bypassCache: 'none', returnEntity: 'ProductAvailableQuantity'}, {itemIds: itemIds, channelId: channelId });
    }    
    
    export function getProductAvailabilitiesAsync(context: IContext, itemIds: number[], channelId: number):AsyncResult<ProductAvailableQuantity[]> {
        const request = createGetProductAvailabilitiesInput(context.queryResultSettings, itemIds, channelId, );
        return executeAction<ProductAvailableQuantity[]>(request, context);
    }          
          
    export function createGetActivePricesInput(queryResultSettings: IQueryResultSettings, projectDomain: ProjectionDomain | null, productIds: number[], activeDate: Date, customerId: string | null, affiliationLoyaltyTiers: AffiliationLoyaltyTier[] | null, includeSimpleDiscountsInContextualPrice: boolean | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetActivePrices', true, ProductPriceClass, 'true', { bypassCache: 'none', returnEntity: 'ProductPrice'}, {projectDomain: projectDomain, productIds: productIds, activeDate: activeDate, customerId: customerId, affiliationLoyaltyTiers: affiliationLoyaltyTiers, includeSimpleDiscountsInContextualPrice: includeSimpleDiscountsInContextualPrice });
    }    
    
    export function getActivePricesAsync(context: IContext, projectDomain: ProjectionDomain | null, productIds: number[], activeDate: Date, customerId: string | null, affiliationLoyaltyTiers: AffiliationLoyaltyTier[] | null, includeSimpleDiscountsInContextualPrice: boolean | null):AsyncResult<ProductPrice[]> {
        const request = createGetActivePricesInput(context.queryResultSettings, projectDomain, productIds, activeDate, customerId, affiliationLoyaltyTiers, includeSimpleDiscountsInContextualPrice, );
        return executeAction<ProductPrice[]>(request, context);
    }          
          
    export function createGetFilteredSlotComponentsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, slotId: number, selectedComponents: ComponentInSlotRelation[] | null): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetFilteredSlotComponents', true, ProductComponentClass, 'true', { bypassCache: 'none', returnEntity: 'ProductComponent'}, {channelId: channelId, slotId: slotId, selectedComponents: selectedComponents });
    }    
    
    export function getFilteredSlotComponentsAsync(context: IContext, recordId: number, channelId: number, slotId: number, selectedComponents: ComponentInSlotRelation[] | null):AsyncResult<ProductComponent[]> {
        const request = createGetFilteredSlotComponentsInput(context.queryResultSettings, recordId, channelId, slotId, selectedComponents, );
        return executeAction<ProductComponent[]>(request, context);
    }          
          
    export function createGetComponentByProductSlotRelationInput(channelId: number, componentRelation: ComponentInSlotRelation | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('GetComponentByProductSlotRelation', true, ProductComponentClass, 'false', { bypassCache: 'none', returnEntity: 'ProductComponent'}, {channelId: channelId, componentRelation: componentRelation });
    }    
    
    export function getComponentByProductSlotRelationAsync(context: IContext, channelId: number, componentRelation: ComponentInSlotRelation | null):AsyncResult<ProductComponent> {
        const request = createGetComponentByProductSlotRelationInput(channelId, componentRelation, );
        return executeAction<ProductComponent>(request, context);
    }          
          
    export function createGetCategoryPathsInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, categoryPathLookups: CategoryPathLookup[] | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetCategoryPaths', true, CategoryPathResultClass, 'true', { bypassCache: 'none', returnEntity: 'CategoryPathResult'}, {channelId: channelId, catalogId: catalogId, CategoryPathLookups: categoryPathLookups });
    }    
    
    export function getCategoryPathsAsync(context: IContext, channelId: number, catalogId: number, categoryPathLookups: CategoryPathLookup[] | null):AsyncResult<CategoryPathResult[]> {
        const request = createGetCategoryPathsInput(context.queryResultSettings, channelId, catalogId, categoryPathLookups, );
        return executeAction<CategoryPathResult[]>(request, context);
    }          
          
    export function createSearchByCategoryInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, categoryId: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchByCategory', false, ProductSearchResultClass, 'true', { bypassCache: 'none', returnEntity: 'ProductSearchResult'}, {channelId: channelId, catalogId: catalogId, categoryId: categoryId });
    }    
    
    export function searchByCategoryAsync(context: IContext, channelId: number, catalogId: number, categoryId: number):AsyncResult<ProductSearchResult[]> {
        const request = createSearchByCategoryInput(context.queryResultSettings, channelId, catalogId, categoryId, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createSearchByTextInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, searchText: string | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchByText', false, ProductSearchResultClass, 'true', { bypassCache: 'none', returnEntity: 'ProductSearchResult'}, {channelId: channelId, catalogId: catalogId, searchText: searchText });
    }    
    
    export function searchByTextAsync(context: IContext, channelId: number, catalogId: number, searchText: string | null):AsyncResult<ProductSearchResult[]> {
        const request = createSearchByTextInput(context.queryResultSettings, channelId, catalogId, searchText, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createSearchByCriteriaInput(queryResultSettings: IQueryResultSettings, searchCriteria: ProductSearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('SearchByCriteria', true, ProductSearchResultClass, 'true', { bypassCache: 'none', returnEntity: 'ProductSearchResult'}, {searchCriteria: searchCriteria });
    }    
    
    export function searchByCriteriaAsync(context: IContext, searchCriteria: ProductSearchCriteria | null):AsyncResult<ProductSearchResult[]> {
        const request = createSearchByCriteriaInput(context.queryResultSettings, searchCriteria, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createGetByLookupClausesInput(queryResultSettings: IQueryResultSettings, channelId: number, productLookupClauses: ProductLookupClause[] | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetByLookupClauses', true, SimpleProductClass, 'true', { bypassCache: 'none', returnEntity: 'SimpleProduct'}, {channelId: channelId, productLookupClauses: productLookupClauses });
    }    
    
    export function getByLookupClausesAsync(context: IContext, channelId: number, productLookupClauses: ProductLookupClause[] | null):AsyncResult<SimpleProduct[]> {
        const request = createGetByLookupClausesInput(context.queryResultSettings, channelId, productLookupClauses, );
        return executeAction<SimpleProduct[]>(request, context);
    }          
          
    export function createGetSearchSuggestionsInput(queryResultSettings: IQueryResultSettings, channelId: number, catalogId: number, searchText: string | null, hitPrefix: string | null, hitSuffix: string | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSearchSuggestions', false, SearchSuggestionClass, 'true', { bypassCache: 'none', returnEntity: 'SearchSuggestion'}, {channelId: channelId, catalogId: catalogId, searchText: searchText, hitPrefix: hitPrefix, hitSuffix: hitSuffix });
    }    
    
    export function getSearchSuggestionsAsync(context: IContext, channelId: number, catalogId: number, searchText: string | null, hitPrefix: string | null, hitSuffix: string | null):AsyncResult<SearchSuggestion[]> {
        const request = createGetSearchSuggestionsInput(context.queryResultSettings, channelId, catalogId, searchText, hitPrefix, hitSuffix, );
        return executeAction<SearchSuggestion[]>(request, context);
    }          
          
    export function createGetRefinersByCategoryInput(queryResultSettings: IQueryResultSettings, catalogId: number, categoryId: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRefinersByCategory', false, ProductRefinerClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefiner'}, {catalogId: catalogId, categoryId: categoryId });
    }    
    
    export function getRefinersByCategoryAsync(context: IContext, catalogId: number, categoryId: number):AsyncResult<ProductRefiner[]> {
        const request = createGetRefinersByCategoryInput(context.queryResultSettings, catalogId, categoryId, );
        return executeAction<ProductRefiner[]>(request, context);
    }          
          
    export function createGetRefinersByTextInput(queryResultSettings: IQueryResultSettings, catalogId: number, searchText: string | null): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRefinersByText', false, ProductRefinerClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefiner'}, {catalogId: catalogId, searchText: searchText });
    }    
    
    export function getRefinersByTextAsync(context: IContext, catalogId: number, searchText: string | null):AsyncResult<ProductRefiner[]> {
        const request = createGetRefinersByTextInput(context.queryResultSettings, catalogId, searchText, );
        return executeAction<ProductRefiner[]>(request, context);
    }          
          
    export function createGetRefinerValuesByCategoryInput(queryResultSettings: IQueryResultSettings, catalogId: number, categoryId: number, refinerId: number, refinerSourceValue: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRefinerValuesByCategory', false, ProductRefinerValueClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefinerValue'}, {catalogId: catalogId, categoryId: categoryId, refinerId: refinerId, refinerSourceValue: refinerSourceValue });
    }    
    
    export function getRefinerValuesByCategoryAsync(context: IContext, catalogId: number, categoryId: number, refinerId: number, refinerSourceValue: number):AsyncResult<ProductRefinerValue[]> {
        const request = createGetRefinerValuesByCategoryInput(context.queryResultSettings, catalogId, categoryId, refinerId, refinerSourceValue, );
        return executeAction<ProductRefinerValue[]>(request, context);
    }          
          
    export function createGetRefinerValuesByTextInput(queryResultSettings: IQueryResultSettings, catalogId: number, searchText: string | null, refinerId: number, refinerSourceValue: number): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRefinerValuesByText', false, ProductRefinerValueClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRefinerValue'}, {catalogId: catalogId, searchText: searchText, refinerId: refinerId, refinerSourceValue: refinerSourceValue });
    }    
    
    export function getRefinerValuesByTextAsync(context: IContext, catalogId: number, searchText: string | null, refinerId: number, refinerSourceValue: number):AsyncResult<ProductRefinerValue[]> {
        const request = createGetRefinerValuesByTextInput(context.queryResultSettings, catalogId, searchText, refinerId, refinerSourceValue, );
        return executeAction<ProductRefinerValue[]>(request, context);
    }          
          
    export function createGetChannelProductAttributesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetChannelProductAttributes', false, AttributeProductClass, 'true', { bypassCache: 'none', returnEntity: 'AttributeProduct'}, { });
    }    
    
    export function getChannelProductAttributesAsync(context: IContext):AsyncResult<AttributeProduct[]> {
        const request = createGetChannelProductAttributesInput(context.queryResultSettings, );
        return executeAction<AttributeProduct[]>(request, context);
    }          
          
    export function createGetByIdInput(recordId: number, channelId: number): IDataServiceRequest {      
        const query = productsQuery(recordId);
        return query.createDataServiceRequestForOperation('GetById', false, SimpleProductClass, 'false', { bypassCache: 'none', returnEntity: 'SimpleProduct'}, {channelId: channelId });
    }    
    
    export function getByIdAsync(context: IContext, recordId: number, channelId: number):AsyncResult<SimpleProduct> {
        const request = createGetByIdInput(recordId, channelId, );
        return executeAction<SimpleProduct>(request, context);
    }          
          
    export function createGetAttributeValuesInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, catalogId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAttributeValues', false, AttributeValueClass, 'true', { bypassCache: 'none', returnEntity: 'AttributeValue'}, {channelId: channelId, catalogId: catalogId });
    }    
    
    export function getAttributeValuesAsync(context: IContext, recordId: number, channelId: number, catalogId: number):AsyncResult<AttributeValue[]> {
        const request = createGetAttributeValuesInput(context.queryResultSettings, recordId, channelId, catalogId, );
        return executeAction<AttributeValue[]>(request, context);
    }          
          
    export function createGetMediaLocationsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, catalogId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetMediaLocations', false, MediaLocationClass, 'true', { bypassCache: 'none', returnEntity: 'MediaLocation'}, {channelId: channelId, catalogId: catalogId });
    }    
    
    export function getMediaLocationsAsync(context: IContext, recordId: number, channelId: number, catalogId: number):AsyncResult<MediaLocation[]> {
        const request = createGetMediaLocationsInput(context.queryResultSettings, recordId, channelId, catalogId, );
        return executeAction<MediaLocation[]>(request, context);
    }          
          
    export function createGetMediaBlobsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, catalogId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetMediaBlobs', false, MediaBlobClass, 'true', { bypassCache: 'none', returnEntity: 'MediaBlob'}, {channelId: channelId, catalogId: catalogId });
    }    
    
    export function getMediaBlobsAsync(context: IContext, recordId: number, channelId: number, catalogId: number):AsyncResult<MediaBlob[]> {
        const request = createGetMediaBlobsInput(context.queryResultSettings, recordId, channelId, catalogId, );
        return executeAction<MediaBlob[]>(request, context);
    }          
          
    export function createGetDefaultComponentsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetDefaultComponents', false, ProductComponentClass, 'true', { bypassCache: 'none', returnEntity: 'ProductComponent'}, {channelId: channelId });
    }    
    
    export function getDefaultComponentsAsync(context: IContext, recordId: number, channelId: number):AsyncResult<ProductComponent[]> {
        const request = createGetDefaultComponentsInput(context.queryResultSettings, recordId, channelId, );
        return executeAction<ProductComponent[]>(request, context);
    }          
          
    export function createGetSlotComponentsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, slotId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetSlotComponents', false, ProductComponentClass, 'true', { bypassCache: 'none', returnEntity: 'ProductComponent'}, {channelId: channelId, slotId: slotId });
    }    
    
    export function getSlotComponentsAsync(context: IContext, recordId: number, channelId: number, slotId: number):AsyncResult<ProductComponent[]> {
        const request = createGetSlotComponentsInput(context.queryResultSettings, recordId, channelId, slotId, );
        return executeAction<ProductComponent[]>(request, context);
    }          
          
    export function createGetAllRelationTypesInput(queryResultSettings: IQueryResultSettings): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetAllRelationTypes', false, ProductRelationTypeClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRelationType'}, { });
    }    
    
    export function getAllRelationTypesAsync(context: IContext):AsyncResult<ProductRelationType[]> {
        const request = createGetAllRelationTypesInput(context.queryResultSettings, );
        return executeAction<ProductRelationType[]>(request, context);
    }          
          
    export function createGetRelationTypesInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, catalogId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRelationTypes', false, ProductRelationTypeClass, 'true', { bypassCache: 'none', returnEntity: 'ProductRelationType'}, {channelId: channelId, catalogId: catalogId });
    }    
    
    export function getRelationTypesAsync(context: IContext, recordId: number, channelId: number, catalogId: number):AsyncResult<ProductRelationType[]> {
        const request = createGetRelationTypesInput(context.queryResultSettings, recordId, channelId, catalogId, );
        return executeAction<ProductRelationType[]>(request, context);
    }          
          
    export function createGetRelatedProductsInput(queryResultSettings: IQueryResultSettings, recordId: number, channelId: number, catalogId: number, relationTypeId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetRelatedProducts', false, ProductSearchResultClass, 'true', { bypassCache: 'none', returnEntity: 'ProductSearchResult'}, {channelId: channelId, catalogId: catalogId, relationTypeId: relationTypeId });
    }    
    
    export function getRelatedProductsAsync(context: IContext, recordId: number, channelId: number, catalogId: number, relationTypeId: number):AsyncResult<ProductSearchResult[]> {
        const request = createGetRelatedProductsInput(context.queryResultSettings, recordId, channelId, catalogId, relationTypeId, );
        return executeAction<ProductSearchResult[]>(request, context);
    }          
          
    export function createGetUnitsOfMeasureInput(queryResultSettings: IQueryResultSettings, recordId: number): IDataServiceRequest {      
        const query = productsQuery(recordId).resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetUnitsOfMeasure', false, UnitOfMeasureClass, 'true', { bypassCache: 'none', returnEntity: 'UnitOfMeasure'}, { });
    }    
    
    export function getUnitsOfMeasureAsync(context: IContext, recordId: number):AsyncResult<UnitOfMeasure[]> {
        const request = createGetUnitsOfMeasureInput(context.queryResultSettings, recordId, );
        return executeAction<UnitOfMeasure[]>(request, context);
    }          
          
    export function createGetApplicableWarrantiesInput(queryResultSettings: IQueryResultSettings, catalogId: number, warrantableProductIds: number[]): IDataServiceRequest {      
        const query = productsQuery().resultSettings(queryResultSettings);
        return query.createDataServiceRequestForOperation('GetApplicableWarranties', true, ProductWarrantiesMappingClass, 'true', { bypassCache: 'none', returnEntity: 'ProductWarrantiesMapping'}, {catalogId: catalogId, warrantableProductIds: warrantableProductIds });
    }    
    
    export function getApplicableWarrantiesAsync(context: IContext, catalogId: number, warrantableProductIds: number[]):AsyncResult<ProductWarrantiesMapping[]> {
        const request = createGetApplicableWarrantiesInput(context.queryResultSettings, catalogId, warrantableProductIds, );
        return executeAction<ProductWarrantiesMapping[]>(request, context);
    }          
          
    export function createGetPriceInput(recordId: number, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null): IDataServiceRequest {      
        const query = productsQuery(recordId);
        return query.createDataServiceRequestForOperation('GetPrice', false, ProductPriceClass, 'false', { bypassCache: 'none', returnEntity: 'ProductPrice'}, {customerAccountNumber: customerAccountNumber, unitOfMeasureSymbol: unitOfMeasureSymbol });
    }    
    
    export function getPriceAsync(context: IContext, recordId: number, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null):AsyncResult<ProductPrice> {
        const request = createGetPriceInput(recordId, customerAccountNumber, unitOfMeasureSymbol, );
        return executeAction<ProductPrice>(request, context);
    }          
          
    export function createCalculateProductPriceInput(recordId: number, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null, loyaltyCardId: string | null, affiliationLoyaltyTiers: AffiliationLoyaltyTier[] | null): IDataServiceRequest {      
        const query = productsQuery(recordId);
        return query.createDataServiceRequestForOperation('CalculateProductPrice', true, ProductPriceClass, 'false', { bypassCache: 'get', returnEntity: 'ProductPrice'}, {customerAccountNumber: customerAccountNumber, unitOfMeasureSymbol: unitOfMeasureSymbol, loyaltyCardId: loyaltyCardId, affiliationLoyaltyTiers: affiliationLoyaltyTiers });
    }    
    
    export function calculateProductPriceAsync(context: IContext, recordId: number, customerAccountNumber: string | null, unitOfMeasureSymbol: string | null, loyaltyCardId: string | null, affiliationLoyaltyTiers: AffiliationLoyaltyTier[] | null):AsyncResult<ProductPrice> {
        const request = createCalculateProductPriceInput(recordId, customerAccountNumber, unitOfMeasureSymbol, loyaltyCardId, affiliationLoyaltyTiers, );
        return executeAction<ProductPrice>(request, context);
    }          
          
    export function createGetEstimatedProductWarehouseAvailabilityInput(productWarehouses: ProductWarehouse[] | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('GetEstimatedProductWarehouseAvailability', true, ProductWarehouseInventoryInformationClass, 'false', { bypassCache: 'none', returnEntity: 'ProductWarehouseInventoryInformation'}, {productWarehouses: productWarehouses });
    }    
    
    export function getEstimatedProductWarehouseAvailabilityAsync(context: IContext, productWarehouses: ProductWarehouse[] | null):AsyncResult<ProductWarehouseInventoryInformation> {
        const request = createGetEstimatedProductWarehouseAvailabilityInput(productWarehouses, );
        return executeAction<ProductWarehouseInventoryInformation>(request, context);
    }          
          
    export function createGetEstimatedAvailabilityInput(searchCriteria: InventoryAvailabilitySearchCriteria | null): IDataServiceRequest {      
        const query = productsQuery();
        return query.createDataServiceRequestForOperation('GetEstimatedAvailability', true, ProductWarehouseInventoryInformationClass, 'false', { bypassCache: 'none', returnEntity: 'ProductWarehouseInventoryInformation'}, {searchCriteria: searchCriteria });
    }    
    
    export function getEstimatedAvailabilityAsync(context: IContext, searchCriteria: InventoryAvailabilitySearchCriteria | null):AsyncResult<ProductWarehouseInventoryInformation> {
        const request = createGetEstimatedAvailabilityInput(searchCriteria, );
        return executeAction<ProductWarehouseInventoryInformation>(request, context);
    }          
          
    
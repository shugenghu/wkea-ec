/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

// TODO - refactor to incorporate inbuilt JS extension method
// TODO - integrate Trace.error

export const EMPTY = '';

export function convertToString(obj: any, accumulator: string[] = [], depth: number = 0): string {
    if (!obj) {
        return null;
    }

    if (typeof obj === 'string') {
        return obj;
    }

    if (typeof obj !== 'object') {
        return obj.toString();
    }

    for (const prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            const value = obj[prop];
            const stringifyValue = convertToString(value, accumulator, depth + 1);
            if (stringifyValue) {
                if (accumulator.length > 0 && depth === 0) {
                    accumulator.push('&');
                }
                accumulator.push(prop);
                accumulator.push(typeof value === 'object' ? '.' : ':');
                accumulator.push(stringifyValue);
            }
        }
    }

    if (depth === 0) {
        return accumulator.join(EMPTY);
    }
}

/**
 * Verifies whether the object array has elements.
 *
 * @param {any[]} array The array.
 * @return {boolean} True if the object has elements, false otherwise.
 */
export function hasElements(array?: any[]): boolean {
    return !!array && array.length > 0;
}

/**
 * Verifies whether the string is empty or whitespace, but not null.
 *
 * @param {string} object The object.
 * @return {boolean} True if the object is empty or whitespace, false otherwise.
 */
export function isObjectNotEmptyOrNull(value: object): boolean {
    return value && typeof value === 'object' && Object.keys(value).length > 0;
}

/**
 * Verifies whether the string is empty, but not null.
 *
 * @param {string} object The object.
 * @return {boolean} True if the object is empty, false otherwise.
 */
export function isEmpty(object: string): boolean {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.isEmpty() has received input parameter not of type string.");
    }
    return object != null && object.length === 0;
}

/**
 * Verifies whether the string is empty or whitespace, but not null.
 *
 * @param {string} object The object.
 * @return {boolean} True if the object is empty or whitespace, false otherwise.
 */
export function isEmptyOrWhitespace(object: string): boolean {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.isEmptyOrWhitespace() has received input parameter not of type string.");
    }
    if (object) {
        // Make sure object is of type string
        object = object.toString();

        return typeof object.trim === 'function' && (object.trim() || '').length === 0;
    }
    return false;
}

/**
 * Verifies whether the string is null or whitespace.
 *
 * @param {string} object The object.
 * @return {boolean} True if the object is null or whitespace, false otherwise.
 */
export function isNullOrWhitespace(object: string): boolean {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.isNullOrWhitespace() has received input parameter not of type string.");
    }
    let returnValue = true;
    try {
        returnValue = !object;
        if (!returnValue) {
            // Make sure object is of type string
            object = object.toString();
            returnValue = object.trim().length === 0;
        }
    } catch (err) {
        // Commerce.Proxy.Tracer.Error("StringExtensions.isNullOrWhitespace() caught exception = {0}", err.message);
    }

    return returnValue;
}

/**
 * Pad left with padString until the required length is reached.
 */
export function padLeft(object: string, padString: string, length: number): string {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.padLeft() has received input parameter not of type string.");
    }

    if (!padString || !object) {
        return object;
    }

    while (object.length < length) {
        object = padString + object;
    }
    return object;
}

/**
 * Pad right with padString until the required length is reached.
 */
export function padRight(object: string, padString: string, length: number): string {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.padRight() has received input parameter not of type string.");
    }

    if (!padString || !object) {
        return object;
    }

    while (object.length < length) {
        object += padString;
    }
    return object;
}

/**
 * Basic C# like string format function.
 */
export function format(object: string, ...params: any[]): string {
    if (object && typeof object !== 'string') {
        // Tracer.Error("StringExtensions.isEmptyOrWhitespace has received input parameter not of type string.");
    }

    if (isNullOrWhitespace(object)) {
        return object;
    }

    if (params == null) {
        throw new Error('StringExtensions::format Invalid parameter (params) cannot be null.');
    }

    for (let index = 0; index < params.length; index++) {
        if (params[index] == null) {
            throw new Error('StringExtensions::format Invalid parameter (at index ' + index + ') cannot be null or undefined.');
        }

        // escape '$' to avoid '$0' issue, '$$$$' means '$$' escaped
        const param = params[index].toString().replace(/\$/gi, '$$$$');
        const regexp = new RegExp('\\{' + index + '\\}', 'gi');
        object = object.replace(regexp, param);
    }

    return object;
}

/**
 * Returns an ordinal to indicate the ordering of the strings
 * -1: This object is less than comparison object
 * 0: This object is equal to the comparison object
 * 1: This object is greater than the comparison object
 */
export function compare(object: string, comparisonObject: string, ignoreCase?: boolean): number {
    if (!object && !comparisonObject) {
        return 0;
    } else if (!object) {
        return -1;
    } else if (!comparisonObject) {
        return 1;
    }

    const val1: string = ignoreCase ? object.toLowerCase() : object;
    const val2: string = ignoreCase ? comparisonObject.toLowerCase() : comparisonObject;

    return val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
}

/**
 * Replaces new line character with <br /> for display.
 */
export function replaceNewLineWithBr(text: string) {
    if (text) {
        return replaceAll(text, '\n', '<br />');
    }

    return text;
}

/**
 * Replaces all instances of @txtToReplace
 */
export function replaceAll(txt, txtToReplace, valueToReplaceWith) {
    return txt.replace(new RegExp(txtToReplace, 'g'), valueToReplaceWith);
}

/**
 * Escapes single quote to be send as part of URLs.
 */
export function escapeSingleQuote(text: string) {
    return text.replace(/(')/g, '\'$1');
}

/**
 * Removes the trailing slashes from the URI.
 *
 * @param {string} uri The URI to clean.
 * @return {string} The uri without trailing slashes.
 */
export function CleanUri(uri: string): string {
    if (isNullOrWhitespace(uri)) {
        return EMPTY;
    }

    // the cutoff index for the string
    let cutoffIndex = uri.length - 1;

    while (cutoffIndex >= 0 && (uri[cutoffIndex] === '/' || uri[cutoffIndex] === '\\')) {
        --cutoffIndex;
    }

    // if it ever becomes negative, cutoffIndex + 1 = 0
    return uri.substr(0, cutoffIndex + 1);
}

/**
 * Determines whether the end of string matches a specified string.
 *
 * @param {string} str: The string to search in.
 * @param {string} suffix: The string to compare to the substring at the end of str.
 * @param {boolean} caseSensitive: Determines if the comparison case sensitive (false, by default)
 * @return {boolean} true if suffix matches the end of str; otherwise, false.
 */
export function endsWith(str: string, suffix: string, caseSensitive: boolean = false): boolean {
    if (!str || !suffix) {
        return false;
    }
    if (suffix.length > str.length) {
        return false;
    }

    const originalString: string = caseSensitive ? str : str.toLowerCase();
    const subString: string = caseSensitive ? suffix : suffix.toLowerCase();
    return originalString.indexOf(subString, originalString.length - subString.length) !== -1;
}

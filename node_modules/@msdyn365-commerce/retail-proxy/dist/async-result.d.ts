/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { IODataMetadata } from './interfaces/IODataMetadata';
export declare type AsyncResultStatus = 'LOADING' | 'SUCCESS' | 'FAILED';
export declare const isAsyncResult: (item: {
    toString(): string;
}) => item is AsyncResult<unknown>;
declare type Resolve<T> = (value?: T | PromiseLike<T>) => void;
declare type Reject = (value?: any) => void;
/**
 * AsyncResult Class
 * Promise-style class which allows for observation of the status of the promise
 * and it's result during and after is execution.
 */
export declare class AsyncResult<T> implements Promise<T> {
    result?: T;
    status: AsyncResultStatus;
    error?: Error;
    metadata: IODataMetadata;
    private _type;
    private _handlers;
    static resolve<U = any>(value?: U | PromiseLike<U>): AsyncResult<U>;
    static reject<U>(reason?: any): AsyncResult<U>;
    /**
     * Class constructor, which starts running the passed executor
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    constructor(executor: (resolve: Resolve<T>, reject: Reject) => void);
    /**
     * Method that allows for an executor to be passed to the promise after inital execution,
     * essentially "rerunning" the promise.
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    run(executor: (resolve: Resolve<T>, reject: Reject) => void): void;
    /**
     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult
     * @param onSuccess Callback to be run on successful completion of executor
     * @param onFail Callback to be run when executor cannot be successfully completed
     */
    then<TResult1 = T, TResult2 = never>(onSuccess?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onFail?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): AsyncResult<TResult1 | TResult2>;
    /**
     * Hook to allow callback on the unsuccessful run of an executor
     * @param onFail Callback to run when executor fails
     */
    catch<TResult = never>(onFail?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): AsyncResult<T | TResult>;
    /**
     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor
     * @param callback Callback to be run after original AsyncResult is completed
     */
    finally(onfinally?: (() => void) | undefined | null): AsyncResult<T>;
    toString(): string;
    get [Symbol.toStringTag](): string;
    private _attachHandler;
    private _executeHandlers;
    private _resolve;
    private _reject;
    private _updateStatus;
}
export {};

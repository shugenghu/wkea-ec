/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { __decorate, __metadata } from "tslib";
// NOTE: no-any is disabled intentionally, as promises require valid use of the any type
// tslint:disable:no-any
import { observable } from 'mobx';
export const isAsyncResult = (item) => {
    return item && item.toString && typeof item.toString === 'function' && item.toString() === `[object AsyncResult]`;
};
/**
 * Utility Methods For AsyncResult
 */
const isThenable = (obj) => obj && typeof obj === 'object' && typeof obj.then === 'function';
/**
 * AsyncResult Class
 * Promise-style class which allows for observation of the status of the promise
 * and it's result during and after is execution.
 */
export class AsyncResult {
    /**
     * Class constructor, which starts running the passed executor
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    constructor(executor) {
        this.status = 'LOADING';
        this.metadata = {};
        // @ts-ignore
        this._type = 'AsyncResult';
        this._handlers = [];
        this._attachHandler = (handler) => {
            this._handlers.push(handler);
            this._executeHandlers();
        };
        this._executeHandlers = () => {
            if (this.status === 'LOADING') {
                return;
            }
            for (const handler of this._handlers) {
                if (this.status === 'FAILED') {
                    handler.onFail(this.error);
                }
                else {
                    handler.onSuccess(this.result);
                }
            }
            this._handlers = [];
        };
        this._resolve = (value) => {
            return this._updateStatus(value, 'SUCCESS');
        };
        this._reject = (reason) => {
            return this._updateStatus(reason, 'FAILED', true);
        };
        try {
            executor(this._resolve, this._reject);
        }
        catch (e) {
            this._reject(e);
        }
    }
    static resolve(value) {
        return new AsyncResult(resolve => {
            return resolve(value);
        });
    }
    static reject(reason) {
        return new AsyncResult((resolve, reject) => {
            return reject(reason);
        });
    }
    /**
     * Method that allows for an executor to be passed to the promise after inital execution,
     * essentially "rerunning" the promise.
     * @param executor Passed function to be executed, resulting in resolution/rejection
     */
    run(executor) {
        this.status = 'LOADING';
        this.error = undefined;
        try {
            executor(this._resolve, this._reject);
        }
        catch (e) {
            this._reject(e);
        }
    }
    /**
     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult
     * @param onSuccess Callback to be run on successful completion of executor
     * @param onFail Callback to be run when executor cannot be successfully completed
     */
    then(onSuccess, onFail) {
        const asyncResult = new AsyncResult((resolve, reject) => {
            return this._attachHandler({
                onSuccess: result => {
                    if (!onSuccess) {
                        // @ts-ignore: Type overlap issue
                        return resolve(result);
                    }
                    try {
                        return resolve(onSuccess(result));
                    }
                    catch (e) {
                        return reject(e);
                    }
                },
                onFail: reason => {
                    if (!onFail) {
                        return reject(reason);
                    }
                    try {
                        return resolve(onFail(reason));
                    }
                    catch (e) {
                        return reject(e);
                    }
                }
            });
        });
        // Always pass the metadata on a then
        asyncResult.metadata = this.metadata;
        return asyncResult;
    }
    /**
     * Hook to allow callback on the unsuccessful run of an executor
     * @param onFail Callback to run when executor fails
     */
    catch(onFail) {
        const defaultThen = (value) => value;
        return this.then(defaultThen, onFail);
    }
    /**
     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor
     * @param callback Callback to be run after original AsyncResult is completed
     */
    finally(onfinally) {
        return new AsyncResult((resolve, reject) => {
            let value;
            let failed = false;
            return this.then(result => {
                value = result;
                return onfinally();
            }, reason => {
                failed = true;
                value = reason;
                return onfinally();
            }).then(() => {
                if (failed) {
                    return reject(value);
                }
                return resolve(value);
            });
        });
    }
    toString() {
        return `[object AsyncResult]`;
    }
    get [Symbol.toStringTag]() {
        return '[object AsyncResult]';
    }
    _updateStatus(result, newStatus, isError = false) {
        // Wrap in setTimeout to ensure fully synchronous handlers
        // are still returned AFTER initial class construction
        setTimeout(() => {
            if (this.status !== 'LOADING') {
                return null;
            }
            if (isThenable(result)) {
                return result.then(this._resolve, this._reject);
            }
            if (isError) {
                this.error = result;
            }
            else {
                this.result = result;
            }
            this.status = newStatus;
            return this._executeHandlers();
        }, 0);
    }
}
__decorate([
    observable,
    __metadata("design:type", Object)
], AsyncResult.prototype, "result", void 0);
__decorate([
    observable,
    __metadata("design:type", String)
], AsyncResult.prototype, "status", void 0);
__decorate([
    observable,
    __metadata("design:type", Error)
], AsyncResult.prototype, "error", void 0);
__decorate([
    observable,
    __metadata("design:type", Object)
], AsyncResult.prototype, "metadata", void 0);
//# sourceMappingURL=async-result.js.map
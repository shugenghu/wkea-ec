{"version":3,"file":"ErrorParser.js","sourceRoot":"","sources":["../../src/exceptions/ErrorParser.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { CommerceException, DataValidationException, DataValidationFailure } from '../Entities/CommerceTypes.g';\nimport { EMPTY, hasElements } from '../extensions/StringExtensions';\nimport { RetailLogger, Tracer } from '../logging';\nimport { ErrorHelper, ErrorTypeEnum } from './ErrorHelper';\nimport { ProxyError } from './ProxyError';\n\n/**\n * Error parser class.\n */\nexport class ErrorParser {\n    private static DataValidationExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.DataValidationException';\n    private static CartValidationExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.CartValidationException';\n    private static StorageExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.StorageException';\n\n    /**\n     * Parses an error message.\n     *\n     * @param {any} error The error message.\n     * @return {ProxyError[]} The collection of error messages.\n     */\n    public static parseErrorMessage(error: any): ProxyError[] {\n        const response = error.response;\n        let errors: ProxyError[] = [];\n        if (response) {\n            let handled = true;\n            Tracer.Information(`Server response status code is '${response.statusCode}'`);\n            switch (response.statusCode) {\n                case 306: // Custom - Redirection\n                    const redirectUrl = response.headers['Location'];\n                    error.redirectUrl = redirectUrl;\n                    errors = [new ProxyError(ErrorTypeEnum.RETAIL_SERVER_REDIRECT_ERROR, response.statusText, EMPTY, false, error)];\n                    break;\n\n                case 401: // Unauthorized (Generally Expired Token)\n                    if (process.env.CURRENT_ENVIRONMENT === 'web') {\n                        const redirectCountQueryString = 'rdc';\n                        const noRedirectQueryString = 'noredirect';\n                        try {\n                            const currentUrl = new URL(location.href);\n                            if (currentUrl.searchParams.get(noRedirectQueryString)) {\n                                break;\n                            }\n                            const rdc = parseInt(currentUrl.searchParams.get(redirectCountQueryString), 10) || 0;\n                            if (rdc && rdc >= 3) {\n                                break;\n                            }\n                            currentUrl.searchParams.set(redirectCountQueryString, `${rdc + 1}`);\n                            location.href = currentUrl.href;\n                        } catch (e) {\n                            break;\n                        }\n                    }\n\n                    break;\n\n                case 408: // Request Timeout\n                    errors = [new ProxyError(ErrorTypeEnum.SERVER_TIMEOUT, response.statusText, EMPTY, false, error)];\n                    break;\n\n                case 0: // WWAHost reports status code as 0, If server is unreachable.\n                case 502: // Bad Gateway\n                case 503: // Service Unavailable\n                case 504: // Gateway timeout\n                    errors = [new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, response.statusText, EMPTY, false, error)];\n                    break;\n\n                default:\n                    handled = false;\n            }\n\n            if (!handled) {\n                errors = ErrorParser.parseError(error);\n            }\n        }\n\n        // If we couldn't create any error object from error message, add error parsing failure\n        if (!errors || !errors.length) {\n            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];\n        }\n\n        return errors;\n    }\n\n    /**\n     * Parses an error message sent from Hardware station.\n     *\n     * @param {any} error The error message.\n     * @retunrs {ProxyError[]} The collection of error messages.\n     */\n    public static parseHardwareStationErrorMessage(error: any): ProxyError[] {\n        let errors: ProxyError[] = [];\n\n        if (error) {\n            try {\n                const response = error.responseText;\n\n                if (response) {\n                    const jsonResponse = JSON.parse(response);\n\n                    // Parse errors in json format\n                    if (jsonResponse) {\n                        errors = [\n                            new ProxyError(\n                                jsonResponse.ErrorResourceId ? jsonResponse.ErrorResourceId : ErrorTypeEnum.SERVER_ERROR,\n                                jsonResponse.Message || '',\n                                EMPTY,\n                                false,\n                                error\n                            )\n                        ];\n                    } else {\n                        // If not in json, we cannot parse it\n                        errors = [\n                            new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'The value of Content-Type on server response is not supported.', EMPTY, false, error)\n                        ];\n                    }\n                } else {\n                    // In case we don't have a body, we don't know the error message but from http status\n                    errors = [ErrorHelper.MapResponseStatusCodeToError(error.statusText, error.status, error)];\n                }\n            } catch (ex) {\n                const errorMessage: string = `parseHardwareStationErrorMessage: Failed parse error message '${ex.message}'.`;\n                Tracer.Error(errorMessage, ex);\n            }\n        }\n\n        // If we couldn't create any error object from error message, add error parsing failure\n        if (!errors || !errors.length) {\n            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];\n        }\n\n        return errors;\n    }\n\n    public static parseJSONError(errorString: string, errorResponse?: any): ProxyError[] {\n        let commerceErrors: ProxyError[] = [];\n\n        try {\n            const odataError: any = JSON.parse(errorString);\n            odataError.CorrelationId = errorResponse.data.CorrelationId;\n\n            // assign parsed data to errorResponse\n            errorResponse.data = odataError;\n\n            // due to odata json format limitation, a collection of errors is provided in the message field\n            const localizedMessage: string = odataError.LocalizedMessage;\n            const exceptionType: string = odataError.ErrorResourceId;\n\n            if (exceptionType === ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR) {\n                commerceErrors = [\n                    new ProxyError(\n                        ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR,\n                        localizedMessage || 'Server failed with uncaught exception. Please report this failure.',\n                        localizedMessage,\n                        false,\n                        errorResponse\n                    )\n                ];\n            } else if (localizedMessage != null && exceptionType != null) {\n                commerceErrors = ErrorParser.convertExceptionToErrors(odataError, exceptionType, errorResponse);\n            } else {\n                throw new Error('Server exception is not in expected format.');\n            }\n        } catch (ex) {\n            const errorMessage: string =\n                'DataServiceRequest::parseJSONError: Invalid json format from server. It was not possible to parse error message. {0}';\n            Tracer.Error(errorMessage, ex);\n        }\n\n        if (!hasElements(commerceErrors)) {\n            commerceErrors = [\n                new ProxyError(\n                    ErrorTypeEnum.GENERICERRORMESSAGE,\n                    'Could not parse error message from server. Possible invalid OData request, please check your request.',\n                    EMPTY,\n                    false,\n                    errorResponse\n                )\n            ];\n        }\n\n        return commerceErrors;\n    }\n\n    private static convertExceptionToErrors(serverException: CommerceException, exceptionType: string, errorResponse: any): ProxyError[] {\n        let errors: ProxyError[] = [];\n\n        switch (exceptionType) {\n            // CartValidationExceptionType extends DataValidationExceptionType\n            case ErrorParser.DataValidationExceptionType:\n            case ErrorParser.CartValidationExceptionType:\n                const dataValidation: DataValidationException = serverException as DataValidationException;\n                // json is in odata format, array has elements inside result member\n                errors = ErrorParser.getErrorsFromDataValidationFailures(dataValidation.ValidationResults as any);\n                errors.push(\n                    new ProxyError(dataValidation.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, EMPTY, dataValidation.LocalizedMessage, false, errorResponse)\n                );\n                break;\n\n            case ErrorParser.StorageExceptionType:\n                errors.push(new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, EMPTY, serverException.LocalizedMessage, false, errorResponse));\n                break;\n        }\n\n        if (errors.length === 0) {\n            const error: ProxyError = new ProxyError(\n                serverException.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR,\n                EMPTY,\n                serverException.LocalizedMessage,\n                false,\n                errorResponse\n            );\n            error.commerceException = serverException;\n            errors.push(error);\n        }\n\n        return errors;\n    }\n\n    private static getErrorsFromDataValidationFailures(failures: DataValidationFailure[]): ProxyError[] {\n        const errors: ProxyError[] = [];\n        failures = failures || [];\n\n        for (const failure of failures) {\n            errors.push(\n                new ProxyError(failure.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, failure.ErrorContext || '', failure.LocalizedMessage, false, {})\n            );\n        }\n\n        return errors;\n    }\n\n    /**\n     * Parses an error to get the error code and error message.\n     *\n     * @param {any} error The error message.\n     * @retunrs {ProxyError[]} The collection of error messages.\n     */\n    private static parseError(error: any): ProxyError[] {\n        const response = error.response;\n        let errors: ProxyError[] = [];\n        if (response.body && response.data) {\n            // If we have a response body\n            const contentType: string = (response.headers && (response.headers['Content-Type'] || response.headers['content-type'])) || '';\n            const bodyString: string = response.data.Exception;\n            // Parse errors in json format\n            if (contentType.toLowerCase().indexOf('application/json') !== -1) {\n                errors = ErrorParser.parseJSONError(bodyString, error.response);\n            } else {\n                const message: string = `Server error has been received with unsupported content type: '${contentType}'.`;\n                RetailLogger.genericWarning(message);\n            }\n        }\n        // if we couldn't parse the errors from the body, we can only rely on status text and status code\n        if (!hasElements(errors)) {\n            // In case we don't have a body, we don't know the error message but from http status code\n            errors = [ErrorHelper.MapResponseStatusCodeToError(response.statusText, response.statusCode, error)];\n        }\n        return errors;\n    }\n}\n"]}
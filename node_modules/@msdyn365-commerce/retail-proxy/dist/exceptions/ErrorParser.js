/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { EMPTY, hasElements } from '../extensions/StringExtensions';
import { RetailLogger, Tracer } from '../logging';
import { ErrorHelper, ErrorTypeEnum } from './ErrorHelper';
import { ProxyError } from './ProxyError';
/**
 * Error parser class.
 */
export class ErrorParser {
    /**
     * Parses an error message.
     *
     * @param {any} error The error message.
     * @return {ProxyError[]} The collection of error messages.
     */
    static parseErrorMessage(error) {
        const response = error.response;
        let errors = [];
        if (response) {
            let handled = true;
            Tracer.Information(`Server response status code is '${response.statusCode}'`);
            switch (response.statusCode) {
                case 306: // Custom - Redirection
                    const redirectUrl = response.headers['Location'];
                    error.redirectUrl = redirectUrl;
                    errors = [new ProxyError(ErrorTypeEnum.RETAIL_SERVER_REDIRECT_ERROR, response.statusText, EMPTY, false, error)];
                    break;
                case 401: // Unauthorized (Generally Expired Token)
                    if (process.env.CURRENT_ENVIRONMENT === 'web') {
                        const redirectCountQueryString = 'rdc';
                        const noRedirectQueryString = 'noredirect';
                        try {
                            const currentUrl = new URL(location.href);
                            if (currentUrl.searchParams.get(noRedirectQueryString)) {
                                break;
                            }
                            const rdc = parseInt(currentUrl.searchParams.get(redirectCountQueryString), 10) || 0;
                            if (rdc && rdc >= 3) {
                                break;
                            }
                            currentUrl.searchParams.set(redirectCountQueryString, `${rdc + 1}`);
                            location.href = currentUrl.href;
                        }
                        catch (e) {
                            break;
                        }
                    }
                    break;
                case 408: // Request Timeout
                    errors = [new ProxyError(ErrorTypeEnum.SERVER_TIMEOUT, response.statusText, EMPTY, false, error)];
                    break;
                case 0: // WWAHost reports status code as 0, If server is unreachable.
                case 502: // Bad Gateway
                case 503: // Service Unavailable
                case 504: // Gateway timeout
                    errors = [new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, response.statusText, EMPTY, false, error)];
                    break;
                default:
                    handled = false;
            }
            if (!handled) {
                errors = ErrorParser.parseError(error);
            }
        }
        // If we couldn't create any error object from error message, add error parsing failure
        if (!errors || !errors.length) {
            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];
        }
        return errors;
    }
    /**
     * Parses an error message sent from Hardware station.
     *
     * @param {any} error The error message.
     * @retunrs {ProxyError[]} The collection of error messages.
     */
    static parseHardwareStationErrorMessage(error) {
        let errors = [];
        if (error) {
            try {
                const response = error.responseText;
                if (response) {
                    const jsonResponse = JSON.parse(response);
                    // Parse errors in json format
                    if (jsonResponse) {
                        errors = [
                            new ProxyError(jsonResponse.ErrorResourceId ? jsonResponse.ErrorResourceId : ErrorTypeEnum.SERVER_ERROR, jsonResponse.Message || '', EMPTY, false, error)
                        ];
                    }
                    else {
                        // If not in json, we cannot parse it
                        errors = [
                            new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'The value of Content-Type on server response is not supported.', EMPTY, false, error)
                        ];
                    }
                }
                else {
                    // In case we don't have a body, we don't know the error message but from http status
                    errors = [ErrorHelper.MapResponseStatusCodeToError(error.statusText, error.status, error)];
                }
            }
            catch (ex) {
                const errorMessage = `parseHardwareStationErrorMessage: Failed parse error message '${ex.message}'.`;
                Tracer.Error(errorMessage, ex);
            }
        }
        // If we couldn't create any error object from error message, add error parsing failure
        if (!errors || !errors.length) {
            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];
        }
        return errors;
    }
    static parseJSONError(errorString, errorResponse) {
        let commerceErrors = [];
        try {
            const odataError = JSON.parse(errorString);
            odataError.CorrelationId = errorResponse.data.CorrelationId;
            // assign parsed data to errorResponse
            errorResponse.data = odataError;
            // due to odata json format limitation, a collection of errors is provided in the message field
            const localizedMessage = odataError.LocalizedMessage;
            const exceptionType = odataError.ErrorResourceId;
            if (exceptionType === ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR) {
                commerceErrors = [
                    new ProxyError(ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR, localizedMessage || 'Server failed with uncaught exception. Please report this failure.', localizedMessage, false, errorResponse)
                ];
            }
            else if (localizedMessage != null && exceptionType != null) {
                commerceErrors = ErrorParser.convertExceptionToErrors(odataError, exceptionType, errorResponse);
            }
            else {
                throw new Error('Server exception is not in expected format.');
            }
        }
        catch (ex) {
            const errorMessage = 'DataServiceRequest::parseJSONError: Invalid json format from server. It was not possible to parse error message. {0}';
            Tracer.Error(errorMessage, ex);
        }
        if (!hasElements(commerceErrors)) {
            commerceErrors = [
                new ProxyError(ErrorTypeEnum.GENERICERRORMESSAGE, 'Could not parse error message from server. Possible invalid OData request, please check your request.', EMPTY, false, errorResponse)
            ];
        }
        return commerceErrors;
    }
    static convertExceptionToErrors(serverException, exceptionType, errorResponse) {
        let errors = [];
        switch (exceptionType) {
            // CartValidationExceptionType extends DataValidationExceptionType
            case ErrorParser.DataValidationExceptionType:
            case ErrorParser.CartValidationExceptionType:
                const dataValidation = serverException;
                // json is in odata format, array has elements inside result member
                errors = ErrorParser.getErrorsFromDataValidationFailures(dataValidation.ValidationResults);
                errors.push(new ProxyError(dataValidation.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, EMPTY, dataValidation.LocalizedMessage, false, errorResponse));
                break;
            case ErrorParser.StorageExceptionType:
                errors.push(new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, EMPTY, serverException.LocalizedMessage, false, errorResponse));
                break;
        }
        if (errors.length === 0) {
            const error = new ProxyError(serverException.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, EMPTY, serverException.LocalizedMessage, false, errorResponse);
            error.commerceException = serverException;
            errors.push(error);
        }
        return errors;
    }
    static getErrorsFromDataValidationFailures(failures) {
        const errors = [];
        failures = failures || [];
        for (const failure of failures) {
            errors.push(new ProxyError(failure.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, failure.ErrorContext || '', failure.LocalizedMessage, false, {}));
        }
        return errors;
    }
    /**
     * Parses an error to get the error code and error message.
     *
     * @param {any} error The error message.
     * @retunrs {ProxyError[]} The collection of error messages.
     */
    static parseError(error) {
        const response = error.response;
        let errors = [];
        if (response.body && response.data) {
            // If we have a response body
            const contentType = (response.headers && (response.headers['Content-Type'] || response.headers['content-type'])) || '';
            const bodyString = response.data.Exception;
            // Parse errors in json format
            if (contentType.toLowerCase().indexOf('application/json') !== -1) {
                errors = ErrorParser.parseJSONError(bodyString, error.response);
            }
            else {
                const message = `Server error has been received with unsupported content type: '${contentType}'.`;
                RetailLogger.genericWarning(message);
            }
        }
        // if we couldn't parse the errors from the body, we can only rely on status text and status code
        if (!hasElements(errors)) {
            // In case we don't have a body, we don't know the error message but from http status code
            errors = [ErrorHelper.MapResponseStatusCodeToError(response.statusText, response.statusCode, error)];
        }
        return errors;
    }
}
ErrorParser.DataValidationExceptionType = 'Microsoft.Dynamics.Commerce.Runtime.DataValidationException';
ErrorParser.CartValidationExceptionType = 'Microsoft.Dynamics.Commerce.Runtime.CartValidationException';
ErrorParser.StorageExceptionType = 'Microsoft.Dynamics.Commerce.Runtime.StorageException';
//# sourceMappingURL=ErrorParser.js.map
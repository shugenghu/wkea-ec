import { DataServiceQuery } from '../DataServiceQuery';
import { InventoryInboundOutboundDocumentClass, InventoryInboundOutboundDocumentUpdateLinesByCriteriaResultClass, InventoryInboundOutboundDocumentLineClass, InventoryDocumentSerialNumberLineClass, InventoryDocumentValidationResultSummaryClass, InventoryDocumentValidationResultLineClass, InventoryInboundOutboundDocumentLinesSummaryClass, InventoryDocumentSerialNumberLinesSummaryClass } from '../Entities/CommerceModels.g';
import { executeAction } from '../retail-action';
function inventoryInboundOutboundDocumentsQuery(workDocumentId) {
    var key = (workDocumentId) ? { WorkDocumentId: workDocumentId } : null;
    return new DataServiceQuery("InventoryInboundOutboundDocuments", "InventoryInboundOutboundDocument", InventoryInboundOutboundDocumentClass, key);
}
export function createCreateInput(entity) {
    return inventoryInboundOutboundDocumentsQuery().create(entity);
}
export function createInventoryInboundOutboundDocumentAsync(context, entity) {
    const request = createCreateInput(entity);
    return executeAction(request, context);
}
export function createUpdateInput(entity) {
    return inventoryInboundOutboundDocumentsQuery(entity.WorkDocumentId).update(entity);
}
export function updateAsync(context, entity) {
    const request = createUpdateInput(entity);
    return executeAction(request, context);
}
export function createDeleteAsync(entity) {
    return inventoryInboundOutboundDocumentsQuery(entity.WorkDocumentId).delete();
}
export function deleteAsync(context, entity) {
    const request = createDeleteAsync(entity);
    return executeAction(request, context);
}
export function createReadAsync(workDocumentId) {
    return inventoryInboundOutboundDocumentsQuery(workDocumentId).read();
}
export function readAsync(context, workDocumentId) {
    const request = createReadAsync(workDocumentId);
    return executeAction(request, context);
}
export function createReadAllAsync(queryResultSettings) {
    return inventoryInboundOutboundDocumentsQuery().resultSettings(queryResultSettings).read();
}
export function readAllAsync(context) {
    const request = createReadAllAsync(context.queryResultSettings);
    return executeAction(request, context);
}
export function createUpdateStatusInput(workDocumentId, documentStatus, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateStatus', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { documentStatus: documentStatus, documentVersion: documentVersion });
}
export function updateStatusAsync(context, workDocumentId, documentStatus, documentVersion) {
    const request = createUpdateStatusInput(workDocumentId, documentStatus, documentVersion);
    return executeAction(request, context);
}
export function createUpdateLinesByCriteriaInput(workDocumentId, filterCriteria, updateLinesAction, returnUpdatedLinesPolicy) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateLinesByCriteria', true, InventoryInboundOutboundDocumentUpdateLinesByCriteriaResultClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocumentUpdateLinesByCriteriaResult' }, { filterCriteria: filterCriteria, updateLinesAction: updateLinesAction, returnUpdatedLinesPolicy: returnUpdatedLinesPolicy });
}
export function updateLinesByCriteriaAsync(context, workDocumentId, filterCriteria, updateLinesAction, returnUpdatedLinesPolicy) {
    const request = createUpdateLinesByCriteriaInput(workDocumentId, filterCriteria, updateLinesAction, returnUpdatedLinesPolicy);
    return executeAction(request, context);
}
export function createUpdateLineInput(workDocumentId, documentLine) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateLine', true, InventoryInboundOutboundDocumentLineClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocumentLine' }, { documentLine: documentLine });
}
export function updateLineAsync(context, workDocumentId, documentLine) {
    const request = createUpdateLineInput(workDocumentId, documentLine);
    return executeAction(request, context);
}
export function createUpdateWorkingTerminalInput(workDocumentId, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateWorkingTerminal', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { documentVersion: documentVersion });
}
export function updateWorkingTerminalAsync(context, workDocumentId, documentVersion) {
    const request = createUpdateWorkingTerminalInput(workDocumentId, documentVersion);
    return executeAction(request, context);
}
export function createUpdateNoteInput(workDocumentId, documentNote, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateNote', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { documentNote: documentNote, documentVersion: documentVersion });
}
export function updateNoteAsync(context, workDocumentId, documentNote, documentVersion) {
    const request = createUpdateNoteInput(workDocumentId, documentNote, documentVersion);
    return executeAction(request, context);
}
export function createUpdateReceiptIdInput(workDocumentId, documentReceiptId, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateReceiptId', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { documentReceiptId: documentReceiptId, documentVersion: documentVersion });
}
export function updateReceiptIdAsync(context, workDocumentId, documentReceiptId, documentVersion) {
    const request = createUpdateReceiptIdInput(workDocumentId, documentReceiptId, documentVersion);
    return executeAction(request, context);
}
export function createCommitInput(workDocumentId, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('Commit', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { documentVersion: documentVersion });
}
export function commitAsync(context, workDocumentId, documentVersion) {
    const request = createCommitInput(workDocumentId, documentVersion);
    return executeAction(request, context);
}
export function createRefreshOperationStatusInput(workDocumentId) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('RefreshOperationStatus', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, {});
}
export function refreshOperationStatusAsync(context, workDocumentId) {
    const request = createRefreshOperationStatusInput(workDocumentId);
    return executeAction(request, context);
}
export function createStartInput(sourceDocumentId, sourceDocumentType) {
    const query = inventoryInboundOutboundDocumentsQuery();
    return query.createDataServiceRequestForOperation('Start', true, InventoryInboundOutboundDocumentClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocument' }, { sourceDocumentId: sourceDocumentId, sourceDocumentType: sourceDocumentType });
}
export function startAsync(context, sourceDocumentId, sourceDocumentType) {
    const request = createStartInput(sourceDocumentId, sourceDocumentType);
    return executeAction(request, context);
}
export function createAddLineInput(workDocumentId, documentLine) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('AddLine', true, InventoryInboundOutboundDocumentLineClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryInboundOutboundDocumentLine' }, { documentLine: documentLine });
}
export function addLineAsync(context, workDocumentId, documentLine) {
    const request = createAddLineInput(workDocumentId, documentLine);
    return executeAction(request, context);
}
export function createDeleteLineInput(workDocumentId, documentLineId, documentLineVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('DeleteLine', true, '', '', { bypassCache: 'get', returnEntity: '' }, { documentLineId: documentLineId, documentLineVersion: documentLineVersion });
}
export function deleteLineAsync(context, workDocumentId, documentLineId, documentLineVersion) {
    const request = createDeleteLineInput(workDocumentId, documentLineId, documentLineVersion);
    return executeAction(request, context);
}
export function createSearchSerialNumberLinesInput(queryResultSettings, workDocumentId, searchCriteria) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId).resultSettings(queryResultSettings);
    return query.createDataServiceRequestForOperation('SearchSerialNumberLines', true, InventoryDocumentSerialNumberLineClass, 'true', { bypassCache: 'none', returnEntity: 'InventoryDocumentSerialNumberLine' }, { searchCriteria: searchCriteria });
}
export function searchSerialNumberLinesAsync(context, workDocumentId, searchCriteria) {
    const request = createSearchSerialNumberLinesInput(context.queryResultSettings, workDocumentId, searchCriteria);
    return executeAction(request, context);
}
export function createValidateInput(workDocumentId, documentVersion) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('Validate', true, InventoryDocumentValidationResultSummaryClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryDocumentValidationResultSummary' }, { documentVersion: documentVersion });
}
export function validateAsync(context, workDocumentId, documentVersion) {
    const request = createValidateInput(workDocumentId, documentVersion);
    return executeAction(request, context);
}
export function createSearchValidationResultLinesInput(queryResultSettings, searchCriteria) {
    const query = inventoryInboundOutboundDocumentsQuery().resultSettings(queryResultSettings);
    return query.createDataServiceRequestForOperation('SearchValidationResultLines', true, InventoryDocumentValidationResultLineClass, 'true', { bypassCache: 'none', returnEntity: 'InventoryDocumentValidationResultLine' }, { searchCriteria: searchCriteria });
}
export function searchValidationResultLinesAsync(context, searchCriteria) {
    const request = createSearchValidationResultLinesInput(context.queryResultSettings, searchCriteria);
    return executeAction(request, context);
}
export function createSyncSourceDocumentInput(sourceDocumentId, sourceDocumentType) {
    const query = inventoryInboundOutboundDocumentsQuery();
    return query.createDataServiceRequestForOperation('SyncSourceDocument', true, '', '', { bypassCache: 'get', returnEntity: '' }, { sourceDocumentId: sourceDocumentId, sourceDocumentType: sourceDocumentType });
}
export function syncSourceDocumentAsync(context, sourceDocumentId, sourceDocumentType) {
    const request = createSyncSourceDocumentInput(sourceDocumentId, sourceDocumentType);
    return executeAction(request, context);
}
export function createSearchInboundDocumentsInput(queryResultSettings, searchCriteria) {
    const query = inventoryInboundOutboundDocumentsQuery().resultSettings(queryResultSettings);
    return query.createDataServiceRequestForOperation('SearchInboundDocuments', true, InventoryInboundOutboundDocumentClass, 'true', { bypassCache: 'none', returnEntity: 'InventoryInboundOutboundDocument' }, { searchCriteria: searchCriteria });
}
export function searchInboundDocumentsAsync(context, searchCriteria) {
    const request = createSearchInboundDocumentsInput(context.queryResultSettings, searchCriteria);
    return executeAction(request, context);
}
export function createSearchOutboundDocumentsInput(queryResultSettings, searchCriteria) {
    const query = inventoryInboundOutboundDocumentsQuery().resultSettings(queryResultSettings);
    return query.createDataServiceRequestForOperation('SearchOutboundDocuments', true, InventoryInboundOutboundDocumentClass, 'true', { bypassCache: 'none', returnEntity: 'InventoryInboundOutboundDocument' }, { searchCriteria: searchCriteria });
}
export function searchOutboundDocumentsAsync(context, searchCriteria) {
    const request = createSearchOutboundDocumentsInput(context.queryResultSettings, searchCriteria);
    return executeAction(request, context);
}
export function createSearchLinesInput(queryResultSettings, searchCriteria) {
    const query = inventoryInboundOutboundDocumentsQuery().resultSettings(queryResultSettings);
    return query.createDataServiceRequestForOperation('SearchLines', true, InventoryInboundOutboundDocumentLineClass, 'true', { bypassCache: 'none', returnEntity: 'InventoryInboundOutboundDocumentLine' }, { searchCriteria: searchCriteria });
}
export function searchLinesAsync(context, searchCriteria) {
    const request = createSearchLinesInput(context.queryResultSettings, searchCriteria);
    return executeAction(request, context);
}
export function createResetSerialNumberLineInput(workDocumentId, resetSerialNumberLineAction) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('ResetSerialNumberLine', true, InventoryDocumentSerialNumberLineClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryDocumentSerialNumberLine' }, { resetSerialNumberLineAction: resetSerialNumberLineAction });
}
export function resetSerialNumberLineAsync(context, workDocumentId, resetSerialNumberLineAction) {
    const request = createResetSerialNumberLineInput(workDocumentId, resetSerialNumberLineAction);
    return executeAction(request, context);
}
export function createUpdateSerialNumberLineInput(workDocumentId, updateSerialNumberLineAction) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('UpdateSerialNumberLine', true, InventoryDocumentSerialNumberLineClass, 'false', { bypassCache: 'get', returnEntity: 'InventoryDocumentSerialNumberLine' }, { updateSerialNumberLineAction: updateSerialNumberLineAction });
}
export function updateSerialNumberLineAsync(context, workDocumentId, updateSerialNumberLineAction) {
    const request = createUpdateSerialNumberLineInput(workDocumentId, updateSerialNumberLineAction);
    return executeAction(request, context);
}
export function createGetLinesSummaryInput(workDocumentId) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('GetLinesSummary', false, InventoryInboundOutboundDocumentLinesSummaryClass, 'false', { bypassCache: 'none', returnEntity: 'InventoryInboundOutboundDocumentLinesSummary' }, {});
}
export function getLinesSummaryAsync(context, workDocumentId) {
    const request = createGetLinesSummaryInput(workDocumentId);
    return executeAction(request, context);
}
export function createGetSerialNumberLinesSummaryInput(workDocumentId, documentLineId) {
    const query = inventoryInboundOutboundDocumentsQuery(workDocumentId);
    return query.createDataServiceRequestForOperation('GetSerialNumberLinesSummary', false, InventoryDocumentSerialNumberLinesSummaryClass, 'false', { bypassCache: 'none', returnEntity: 'InventoryDocumentSerialNumberLinesSummary' }, { documentLineId: documentLineId });
}
export function getSerialNumberLinesSummaryAsync(context, workDocumentId, documentLineId) {
    const request = createGetSerialNumberLinesSummaryInput(workDocumentId, documentLineId);
    return executeAction(request, context);
}
//# sourceMappingURL=InventoryInboundOutboundDocumentsDataActions.g.js.map
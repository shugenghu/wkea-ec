/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { EMPTY, format } from '../extensions/StringExtensions';
import { DebuggingConsoleSink } from './ConsoleEventWriter';
import { attachLoggingSink, RetailLogger } from './RetailLogger';
/**
 * The tracer class allows information to be logged on the device for Information, Warning or Error
 * The same method call can be used for each type
 * Example:
 *         Commerce.Proxy.Tracer.Information("Message {0} {1}", ["Arg1", "Arg2"]);     // With parameters to be formatted
 *         Commerce.Proxy.Tracer.Information("Message");                               // Without parameters
 *
 * Example of different tracer logs
 *   Dynamics-Information: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 *   Dynamics-Warning: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 *   Dynamics-Error: <<Formatted message>> <<number of milliseconds since 1970/01/01>>
 */
export class Tracer {
    static init() {
        attachLoggingSink(new DebuggingConsoleSink());
        return true;
    }
    /**
     * Traces an informational message in the specified format.
     */
    static Information(informationformat, ...args) {
        if (Tracer.TracingOn) {
            RetailLogger.genericInfo(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, informationformat, ...args]));
        }
    }
    /**
     * Traces a warning message in the specified format.
     */
    static Warning(warningFormat, ...args) {
        if (Tracer.TracingOn) {
            RetailLogger.genericWarning(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, warningFormat, ...args]));
        }
    }
    /**
     * Traces an error message in the specified format.
     */
    static Error(errorFormat, ...args) {
        if (Tracer.TracingOn) {
            RetailLogger.genericError(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, errorFormat, ...args]));
        }
    }
    /**
     * Traces an error message in the specified format.
     */
    static Errors(errors, formatString, ...args) {
        if (Tracer.TracingOn && errors !== null && errors.length > 0) {
            let errorMessage = '';
            let errorCode = '';
            let errorString = '';
            errors.forEach(error => {
                errorMessage = error.ErrorMessage || EMPTY;
                errorCode = error.ErrorCode || EMPTY;
                errorString = JSON.stringify(error);
                Tracer.Error(formatString +
                    ' ' +
                    format(' \n ErrorMessage: {0}; \n ErrorCode: {1}; \n ErrorObject: \'{2}\'', errorMessage, errorCode, errorString), args);
            });
        }
    }
    static StartCounter(uniqueFunctionName) {
        let counter;
        if (Tracer.Counters[uniqueFunctionName] === undefined) {
            counter = new PerformanceCounters();
            counter.Name = uniqueFunctionName;
        }
        else {
            counter = Tracer.Counters[uniqueFunctionName];
        }
        counter.Count += 1;
        Tracer.Counters[uniqueFunctionName] = counter;
        const now = new Date().getTime();
        Tracer.Timers.push(now);
    }
    static EndCounter(uniqueFunctionName) {
        const now = new Date().getTime();
        const startTime = Tracer.Timers.pop();
        const counter = Tracer.Counters[uniqueFunctionName];
        counter.TotalTime += now - startTime;
    }
    static DumpCounters() {
        for (const item in Tracer.Counters) {
            if (Tracer.Counters.hasOwnProperty(item)) {
                Tracer.Information('Method = {0} Number of calls = {1} TotalTime = {2}mS Avg = {3}mS', Tracer.Counters[item].Name, Tracer.Counters[item].Count, Tracer.Counters[item].TotalTime, Tracer.Counters[item].TotalTime / Tracer.Counters[item].Count);
            }
        }
    }
    static GetMessage(type, formatString, ...args) {
        const now = '' + new Date().getTime() + 'mS';
        if (Tracer.TracingOn) {
            if (!args) {
                return Tracer.TracerDynamics + type + '\t' + formatString + '\t' + now;
            }
            else {
                return (Tracer.TracerDynamics + type + '\t' + format.apply(null, [formatString, Array.prototype.slice.call(args)]) + '\t' + now);
            }
        }
    }
}
Tracer.TracerDynamics = 'Dynamics-';
Tracer.TracerDynamicsError = 'Error: ';
Tracer.TracingOn = true;
Tracer.Counters = new Array();
Tracer.Timers = new Array();
Tracer._initialized = Tracer.init();
class PerformanceCounters {
    constructor() {
        this.Count = 0;
        this.TotalTime = 0;
    }
}
//# sourceMappingURL=Tracer.js.map
{"version":3,"file":"helper.js","sourceRoot":"","sources":["../../src/externals/helper.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nconst EDM = 'Edm.';\nconst EDM_BOOLEAN = EDM + 'Boolean';\nconst EDM_BYTE = EDM + 'Byte';\nconst EDM_DATETIME = EDM + 'DateTime';\nconst EDM_DATETIMEOFFSET = EDM + 'DateTimeOffset';\nconst EDM_DECIMAL = EDM + 'Decimal';\nconst EDM_DOUBLE = EDM + 'Double';\nconst EDM_INT16 = EDM + 'Int16';\nconst EDM_INT32 = EDM + 'Int32';\nconst EDM_INT64 = EDM + 'Int64';\nconst EDM_SBYTE = EDM + 'SByte';\nconst EDM_SINGLE = EDM + 'Single';\nconst EDM_TIME = EDM + 'Time';\n\nconst parseBool = propertyValue => {\n    /// <summary>Parses a string into a boolean value.</summary>\n    /// <param name=\"propertyValue\">Value to parse.</param>\n    /// <returns type=\"Boolean\">true if the property value is 'true'; false otherwise.</returns>\n\n    if (typeof propertyValue === 'boolean') {\n        return propertyValue;\n    }\n\n    return typeof propertyValue === 'string' && propertyValue.toLowerCase() === 'true';\n};\n\nconst formatNumberWidth = (value, width, append) => {\n    /// <summary>Formats the specified value to the given width.</summary>\n    /// <param name=\"value\" type=\"Number\">Number to format (non-negative).</param>\n    /// <param name=\"width\" type=\"Number\">Minimum width for number.</param>\n    /// <param name=\"append\" type=\"Boolean\">Flag indicating if the value is padded at the beginning (false) or at the end (true).</param>\n    /// <returns type=\"String\">Text representation.</returns>\n    let result = value.toString(10);\n    while (result.length < width) {\n        if (append) {\n            result += '0';\n        } else {\n            result = '0' + result;\n        }\n    }\n\n    return result;\n};\n\nconst parseTimezone = timezone => {\n    /// <summary>Parses a timezone description in (+|-)nn:nn format.</summary>\n    /// <param name=\"timezone\" type=\"String\">Timezone offset.</param>\n    /// <returns type=\"Object\">\n    /// An object with a (d)irection property of 1 for + and -1 for -,\n    /// offset (h)ours and offset (m)inutes.\n    /// </returns>\n\n    let direction = timezone.substring(0, 1);\n    direction = direction === '+' ? 1 : -1;\n\n    const offsetHours = parseInt(timezone.substring(1), 10);\n    const offsetMinutes = parseInt(timezone.substring(timezone.indexOf(':') + 1), 10);\n    return { d: direction, h: offsetHours, m: offsetMinutes };\n};\n\n// The captured indices for this expression are:\n// 0       - complete input\n// 1       - direction\n// 2,3,4   - years, months, days\n// 5,6,7,8 - hours, minutes, seconds, miliseconds\nconst parseTimeRE = /^([+-])?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d+))?S)?)?/;\n\n// The captured indices for this expression are:\n// 0     - complete input\n// 1,2,3 - year with optional minus sign, month, day\n// 4,5,6 - hours, minutes, seconds\n// 7     - optional milliseconds\n// 8     - everything else (presumably offset information)\nconst parseDateTimeRE = /^(-?\\d{4,})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(.*)$/;\n\nconst getCanonicalTimezone = timezone => {\n    /// <summary>Gets the canonical timezone representation.</summary>\n    /// <param name=\"timezone\" type=\"String\">Timezone representation.</param>\n    /// <returns type=\"String\">An 'Z' string if the timezone is absent or 0; the timezone otherwise.</returns>\n\n    return !timezone || timezone === 'Z' || timezone === '+00:00' || timezone === '-00:00' ? 'Z' : timezone;\n};\n\nconst parseDuration = duration => {\n    /// <summary>Parses a string in xsd:duration format.</summary>\n    /// <param name=\"duration\" type=\"String\">Duration value.</param>\n    /// <remarks>\n    /// This method will throw an exception if the input string has a year or a month component.\n    /// </remarks>\n    /// <returns type=\"Object\">Object representing the time</returns>\n\n    const parts = parseTimeRE.exec(duration);\n\n    if (parts === null) {\n        throw { message: 'Invalid duration value.' };\n    }\n\n    const years = parts[2] || '0';\n    const months = parts[3] || '0';\n    const days = parseInt(parts[4], 10) || 0;\n    const hours = parseInt(parts[5], 10) || 0;\n    const minutes = parseInt(parts[6], 10) || 0;\n    const seconds = parseFloat(parts[7]) || 0;\n\n    if (years !== '0' || months !== '0') {\n        throw { message: 'Unsupported duration value.' };\n    }\n\n    let ms: any = parts[8];\n    let ns: any = 0;\n    if (!ms) {\n        ms = 0;\n    } else {\n        if (ms.length > 7) {\n            throw { message: 'Cannot parse duration value to given precision.' };\n        }\n\n        ns = formatNumberWidth(ms.substring(3), 4, true);\n        ms = formatNumberWidth(ms.substring(0, 3), 3, true);\n\n        ms = parseInt(ms, 10);\n        ns = parseInt(ns, 10);\n    }\n\n    ms += seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;\n\n    if (parts[1] === '-') {\n        ms = -ms;\n    }\n\n    const result: any = { ms, __edmType: 'Edm.Time' };\n\n    if (ns) {\n        result.ns = ns;\n    }\n    return result;\n};\n\nconst parseDateTimeOffset = (value, withOffset, nullOnError) => {\n    /// <summary>Parses a string into a DateTime value.</summary>\n    /// <param name=\"value\" type=\"String\">Value to parse.</param>\n    /// <param name=\"withOffset\" type=\"Boolean\">Whether offset is expected.</param>\n    /// <returns type=\"Date\">The parsed value.</returns>\n\n    // We cannot parse this in cases of failure to match or if offset information is specified.\n    const parts = parseDateTimeRE.exec(value);\n    const offset = parts ? getCanonicalTimezone(parts[8]) : null;\n\n    if (!parts || (!withOffset && offset !== 'Z')) {\n        if (nullOnError) {\n            return null;\n        }\n        throw { message: 'Invalid date/time value' };\n    }\n\n    // Pre-parse years, account for year '0' being invalid in dateTime.\n    let year = parseInt(parts[1], 10);\n    if (year <= 0) {\n        year++;\n    }\n\n    // Pre-parse optional milliseconds, fill in default. Fail if value is too precise.\n    let ms: any = parts[7];\n    let ns: any = 0;\n    if (!ms) {\n        ms = 0;\n    } else {\n        if (ms.length > 7) {\n            if (nullOnError) {\n                return null;\n            }\n            throw { message: 'Cannot parse date/time value to given precision.' };\n        }\n\n        ns = formatNumberWidth(ms.substring(3), 4, true);\n        ms = formatNumberWidth(ms.substring(0, 3), 3, true);\n\n        ms = parseInt(ms, 10);\n        ns = parseInt(ns, 10);\n    }\n\n    // Pre-parse other time components and offset them if necessary.\n    let hours = parseInt(parts[4], 10);\n    let minutes = parseInt(parts[5], 10);\n    const seconds = parseInt(parts[6], 10);\n    if (offset !== 'Z') {\n        // The offset is reversed to get back the UTC date, which is\n        // what the API will eventually have.\n        const timezone = parseTimezone(offset);\n        const direction = -timezone.d;\n        hours += timezone.h * direction;\n        minutes += timezone.m * direction;\n    }\n\n    // Set the date and time separately with setFullYear, so years 0-99 aren't biased like in Date.UTC.\n    const result: any = new Date();\n    result.setUTCFullYear(\n        year, // Year.\n        parseInt(parts[2], 10) - 1, // Month (zero-based for Date.UTC and setFullYear).\n        parseInt(parts[3], 10) // Date.\n    );\n    result.setUTCHours(hours, minutes, seconds, ms);\n\n    if (isNaN(result.valueOf())) {\n        if (nullOnError) {\n            return null;\n        }\n        throw { message: 'Invalid date/time value' };\n    }\n\n    if (withOffset) {\n        result.__edmType = 'Edm.DateTimeOffset';\n        result.__offset = offset;\n    }\n\n    if (ns) {\n        result.__ns = ns;\n    }\n\n    return result;\n};\n\nexport const jsonLightReadStringPropertyValue = (value, propertyType, recognizeDates) => {\n    /// <summary>Convertes the value of a string property in a JSON light object to its library representation.</summary>\n    /// <param name=\"value\" type=\"String\">String value to convert.</param>\n    /// <param name=\"propertyType\" type=\"String\">Type name of the property.</param>\n    /// <param name=\"recognizeDates\" type=\"Boolean\" optional=\"true\">Flag indicating whether datetime literal strings should be converted to JavaScript Date objects.</param>\n    /// <returns>String property value in its library representation.</returns>\n\n    switch (propertyType) {\n        case EDM_BOOLEAN:\n            return parseBool(value);\n        case EDM_BYTE:\n        case EDM_INT16:\n        case EDM_INT32:\n        case EDM_INT64:\n        case EDM_SBYTE:\n            return parseInt(value, 10);\n        case EDM_DOUBLE:\n        case EDM_SINGLE:\n        case EDM_DECIMAL:\n            return parseFloat(value);\n        case EDM_TIME:\n            return parseDuration(value);\n        case EDM_DATETIME:\n            const dateStr = value || '';\n            const time = dateStr.substring(dateStr.indexOf('T') + 1);\n            const timezoneOffsetIndex = time.indexOf('-');\n            timezoneOffsetIndex === -1 ? time.indexOf('+') : timezoneOffsetIndex;\n\n            if (timezoneOffsetIndex !== -1) {\n                return parseDateTimeOffset(value, true, /* nullOnError */ false);\n            } else {\n                return parseDateTimeOffset(value, false, /* nullOnError */ false);\n            }\n        case EDM_DATETIMEOFFSET:\n            return parseDateTimeOffset(value, true, /* nullOnError */ false);\n    }\n\n    if (recognizeDates) {\n        return (\n            parseDateTimeOffset(value, false, /* nullOnError */ true) || parseDateTimeOffset(value, true, /* nullOnError */ true) || value\n        );\n    }\n    return value;\n};\n"]}
{"version":3,"file":"handler.js","sourceRoot":"","sources":["../../src/externals/handler.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nexport const MAX_DATA_SERVICE_VERSION = '4.0';\nexport const jsonMediaType = 'application/json';\n\nconst CONTENT_TYPE_HEADER_NAME = 'Content-Type';\nconst ODATA_VERSION = 'OData-Version';\nconst ODATA_MAX_VERSION = 'OData-MaxVersion';\n\nconst contentType = str => {\n    /// <summary>Parses a string into an object with media type and properties.</summary>\n    /// <param name=\"str\" type=\"String\">String with media type to parse.</param>\n    /// <returns>null if the string is empty; an object with 'mediaType' and a 'properties' dictionary otherwise.</returns>\n\n    if (!str) {\n        return null;\n    }\n\n    const contentTypeParts = str.split(';');\n    const properties = {};\n\n    let i;\n    let len;\n    for (i = 1, len = contentTypeParts.length; i < len; i++) {\n        const contentTypeParams = contentTypeParts[i].split('=');\n        properties[contentTypeParams[0].trim()] = contentTypeParams[1];\n    }\n\n    return { mediaType: contentTypeParts[0].trim(), properties };\n};\n\nexport const jsonContentType = contentType(jsonMediaType);\n\nconst contentTypeToString = contentTypeObj => {\n    /// <summary>Serializes an object with media type and properties dictionary into a string.</summary>\n    /// <param name=\"contentType\">Object with media type and properties dictionary to serialize.</param>\n    /// <returns>String representation of the media type object; undefined if contentType is null or undefined.</returns>\n\n    if (!contentTypeObj) {\n        return undefined;\n    }\n\n    let result = contentTypeObj.mediaType;\n    for (const property in contentTypeObj.properties) {\n        if (contentTypeObj.properties.hasOwnProperty(property)) {\n            result += ';' + property + '=' + contentTypeObj.properties[property];\n        }\n    }\n    return result;\n};\n\nconst createReadWriteContext = (contentTypeStr, dataServiceVersion, context, handler) => {\n    /// <summary>Creates an object that is going to be used as the context for the handler's parser and serializer.</summary>\n    /// <param name=\"contentType\">Object with media type and properties dictionary.</param>\n    /// <param name=\"dataServiceVersion\" type=\"String\">String indicating the version of the protocol to use.</param>\n    /// <param name=\"context\">Operation context.</param>\n    /// <param name=\"handler\">Handler object that is processing a resquest or response.</param>\n    /// <returns>Context object.</returns>\n\n    // First create a clone\n    const rwContext = { ...context };\n\n    // And then override with provided parameters\n    rwContext['contentType'] = contentTypeStr || jsonContentType;\n    rwContext['dataServiceVersion'] = dataServiceVersion;\n    rwContext['handler'] = handler;\n\n    return rwContext;\n};\n\nconst versionRE = /^\\s?(\\d+\\.\\d+);?.*$/;\nconst getDataServiceVersion = headerVersion => {\n    /// <summary>Gets the value of the OData-Version header from a request or response.</summary>\n    /// <param name=\"requestOrResponse\">Object representing a request or a response.</param>\n    /// <returns type=\"String\">Data service version; undefined if the header cannot be found.</returns>\n\n    if (headerVersion) {\n        const matches = versionRE.exec(headerVersion);\n        if (matches && matches.length) {\n            return matches[1];\n        }\n    }\n};\n\nconst handlerRead = (handler, response, context) => {\n    /// <summary>Invokes the parser associated with a handler for reading the payload of a HTTP response.</summary>\n    /// <param name=\"handler\">Handler object that is processing the response.</param>\n    /// <param name=\"parseCallback\" type=\"Function\">Parser function that will process the response payload.</param>\n    /// <param name=\"response\">HTTP response whose payload is going to be processed.</param>\n    /// <param name=\"context\">Object used as the context for processing the response.</param>\n    /// <returns type=\"Boolean\">True if the handler processed the response payload and the response.data property was set; false otherwise.</returns>\n\n    if (!response || !response.headers) {\n        return false;\n    }\n\n    const cType = contentType(response.headers[CONTENT_TYPE_HEADER_NAME]);\n    const version = getDataServiceVersion(response) || '';\n    const body = response.body;\n\n    if (!body) {\n        return false;\n    }\n\n    if (jsonMediaType.indexOf(cType.mediaType) >= 0) {\n        const readContext = createReadWriteContext(cType, version, context, handler);\n        readContext.response = response;\n        response.data = typeof body === 'string' ? JSON.parse(body) : body;\n        return response.data !== undefined;\n    }\n\n    return false;\n};\n\nconst maxVersion = (left, right) => {\n    /// <summary>Compares to version strings and returns the higher one.</summary>\n    /// <param name=\"left\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n    /// <param name=\"right\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n    /// <returns type=\"String\">The higher version string.</returns>\n\n    if (left === right) {\n        return left;\n    }\n\n    const leftParts = left.split('.');\n    const rightParts = right.split('.');\n\n    const len = leftParts.length >= rightParts.length ? leftParts.length : rightParts.length;\n\n    for (let i = 0; i < len; i++) {\n        const leftVersion = leftParts[i] && parseInt(leftParts[i], 10);\n        const rightVersion = rightParts[i] && parseInt(rightParts[i], 10);\n        if (leftVersion > rightVersion) {\n            return left;\n        }\n        if (leftVersion < rightVersion) {\n            return right;\n        }\n    }\n};\n\nconst handlerWrite = (handler, request, context) => {\n    /// <summary>Invokes the serializer associated with a handler for generating the payload of a HTTP request.</summary>\n    /// <param name=\"handler\">Handler object that is processing the request.</param>\n    /// <param name=\"serializeCallback\" type=\"Function\">Serializer function that will generate the request payload.</param>\n    /// <param name=\"response\">HTTP request whose payload is going to be generated.</param>\n    /// <param name=\"context\">Object used as the context for serializing the request.</param>\n    /// <returns type=\"Boolean\">True if the handler serialized the request payload and the request.body property was set; false otherwise.</returns>\n    if (!request || !request.headers) {\n        return false;\n    }\n\n    const cType = contentType(request.headers[CONTENT_TYPE_HEADER_NAME]);\n    const version = getDataServiceVersion(request.headers[ODATA_VERSION]);\n\n    if (!cType || jsonMediaType.indexOf(cType.mediaType)) {\n        const writeContext = createReadWriteContext(cType, version, context, handler);\n        writeContext.request = request;\n        request.body = request.data;\n\n        if (request.body !== undefined) {\n            request.headers[ODATA_VERSION] = version ? maxVersion(version, '4.0') : '4.0';\n            request.headers.ContentType = request.headers[CONTENT_TYPE_HEADER_NAME] || contentTypeToString(writeContext.contentType);\n            request.headers[ODATA_MAX_VERSION] = request.headers[ODATA_MAX_VERSION] || handler.maxDataServiceVersion;\n            return true;\n        }\n    }\n\n    return false;\n};\n\nexport const jsonHandler = {\n    accept: jsonMediaType,\n    maxDataServiceVersion: MAX_DATA_SERVICE_VERSION,\n    read(response, context) {\n        return handlerRead(this, response, context);\n    },\n\n    write(request, context) {\n        return handlerWrite(this, request, context);\n    }\n};\n"]}
{"version":3,"file":"DataJS.New.js","sourceRoot":"","sources":["../../src/externals/DataJS.New.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport axios from 'axios';\nimport { jsonHandler } from './handler';\n\n/**\n * OData request interface.\n */\nexport interface IODataRequest {\n    /**\n     * OData endpoint URI\n     */\n    requestUri: string;\n\n    /**\n     * HTTP method (GET, POST, PUT, DELETE)\n     */\n    method: string;\n\n    /**\n     * Payload of the request (in intermediate format)\n     */\n    data: any;\n\n    /**\n     * Object that contains HTTP headers as name value pairs\n     */\n    headers?: Object;\n\n    /**\n     * (Optional) Username to send for BASIC authentication\n     */\n    user?: string;\n\n    /**\n     * (Optional) Password to send for BASIC authentication\n     */\n    password?: string;\n\n    /**\n     * (Optional) Whether or not to use cross domain cookies.\n     */\n    useCrossDomainCookies?: boolean;\n}\n\nconst normalHeaders = {\n    accept: 'Accept',\n    'content-type': 'Content-Type',\n    'odata-version': 'OData-Version',\n    'odata-maxversion': 'OData-MaxVersion'\n};\n\nconst isAbsoluteUrl = url => {\n    /// <summary>Checks whether the specified URL is an absolute URL.</summary>\n    /// <param name=\"url\" type=\"String\">URL to check.</param>\n    /// <returns type=\"Boolean\">true if the url is an absolute URL; false otherwise.</returns>\n\n    return url.indexOf('http://') === 0 || url.indexOf('https://') === 0 || url.indexOf('file://') === 0;\n};\n\nconst normalizeHeaders = headers => {\n    /// <summary>Normalizes headers so they can be found with consistent casing.</summary>\n    /// <param name=\"headers\" type=\"Object\">Dictionary of name/value pairs.</param>\n\n    for (const name in headers) {\n        if (headers.hasOwnProperty(name)) {\n            const lowerName = name.toLowerCase();\n            const normalName = normalHeaders[lowerName];\n            if (normalName && name !== normalName) {\n                const val = headers[name];\n                delete headers[name];\n                headers[normalName] = val;\n            }\n        }\n    }\n};\n\nconst defaultHttpClient = {\n    callbackParameterName: '$callback',\n    formatQueryString: '$format=json',\n    enableJsonpCallback: false,\n\n    request(request, success, error) {\n        /// <summary>Performs a network request.</summary>\n        /// <param name=\"request\" type=\"Object\">Request description.</request>\n        /// <param name=\"success\" type=\"Function\">Success callback with the response object.</param>\n        /// <param name=\"error\" type=\"Function\">Error callback with an error object.</param>\n        /// <returns type=\"Object\">Object with an 'abort' method for the operation.</returns>\n        const result = { abort: null, handleTimeout: null };\n\n        const cancelToken = axios.CancelToken.source();\n\n        let done = false;\n        result.abort = () => {\n            if (done) {\n                return;\n            }\n            done = true;\n            cancelToken.cancel('Request aborted');\n            error({ message: 'Request aborted' });\n        };\n\n        request.handleTimeout = () => {\n            if (!done) {\n                done = true;\n                cancelToken.cancel('Request aborted');\n                error({ message: 'Request timed out' });\n            }\n        };\n\n        const url = request.requestUri;\n        const enableJsonpCallback = request.enableJsonpCallback || false;\n        if (!enableJsonpCallback || !isAbsoluteUrl(url)) {\n            let authenticationCreds;\n            if (request.user) {\n                authenticationCreds = {\n                    username: request.user,\n                    password: request.password || ''\n                };\n            }\n            // console.log('\\r\\nDataServiceRequest - \\r\\n\\n', request);\n            axios\n                .request({\n                    method: request.method || 'get',\n                    url,\n                    data: request.body,\n                    auth: authenticationCreds,\n                    headers: request.headers || {},\n                    timeout: request.timeoutMS || 10000,\n                    cancelToken: cancelToken.token\n                })\n                .then(axiosResponse => {\n                    const response = {\n                        requestUri: url,\n                        statusCode: axiosResponse.status,\n                        statusText: axiosResponse.statusText,\n                        headers: axiosResponse.headers,\n                        body: axiosResponse.data\n                    };\n                    done = true;\n                    success(response);\n                })\n                .catch(axiosError => {\n                    const response = {\n                        requestUri: url,\n                        statusCode: axiosError.response ? parseInt(axiosError.response.status, 10) : 0,\n                        statusText: axiosError.name,\n                        body: axiosError.message,\n                        data: axiosError.response ? axiosError.response.data : {},\n                        headers: axiosError.response ? axiosError.response.headers : {}\n                    };\n                    error({ message: 'HTTP request failed', request, response });\n                });\n        } else {\n            error({\n                message: 'Only requests to non-absolute urls are supported at this time without JSONP callback'\n            });\n        }\n        return result;\n    }\n};\n\nconst prepareRequest = (request, handler, context) => {\n    /// <summary>Prepares a request object so that it can be sent through the network.</summary>\n    /// <param name=\"request\">Object that represents the request to be sent.</param>\n    /// <param name=\"handler\">Handler for data serialization</param>\n    /// <param name=\"context\">Context used for preparing the request</param>\n\n    // Default to GET if no method has been specified.\n    if (!request.method) {\n        request.method = 'GET';\n    }\n\n    if (!request.headers) {\n        request.headers = {};\n    } else {\n        normalizeHeaders(request.headers);\n    }\n\n    if (request.headers.Accept === undefined) {\n        request.headers.Accept = handler.accept;\n    }\n\n    if (request.data && request.body === undefined) {\n        handler.write(request, context);\n    }\n\n    if (!request.headers['OData-MaxVersion']) {\n        request.headers['OData-MaxVersion'] = handler.maxDataServiceVersion || '4.0';\n    }\n};\n\nconst invokeRequest = (request, success, error, handler, httpClient, context) => {\n    /// <summary>Sends a request containing OData payload to a server.</summary>\n    /// <param name=\"request\">Object that represents the request to be sent..</param>\n    /// <param name=\"success\">Callback for a successful read operation.</param>\n    /// <param name=\"error\">Callback for handling errors.</param>\n    /// <param name=\"handler\">Handler for data serialization.</param>\n    /// <param name=\"httpClient\">HTTP client layer.</param>\n    /// <param name=\"context\">Context used for processing the request</param>\n\n    return httpClient.request(\n        request,\n        response => {\n            try {\n                if (response.headers) {\n                    normalizeHeaders(response.headers);\n                }\n\n                if (response.data === undefined && response.statusCode !== 204) {\n                    if (!handler.read(response, context)) {\n                        throw { message: 'Handler could not parse response.' };\n                    }\n                }\n            } catch (err) {\n                if (err.request === undefined) {\n                    err.request = request;\n                }\n                if (err.response === undefined) {\n                    err.response = response;\n                }\n                error(err);\n                return;\n            }\n\n            success(response.data, response);\n        },\n        error\n    );\n};\n\nexport const ODataHttpRequest = (request, success, error) => {\n    /// <summary>Sends a request containing OData payload to a server.</summary>\n    /// <param name=\"request\" type=\"Object\">Object that represents the request to be sent.</param>\n    /// <param name=\"success\" type=\"Function\" optional=\"true\">Callback for a successful read operation.</param>\n    /// <param name=\"error\" type=\"Function\" optional=\"true\">Callback for handling errors.</param>\n    /// <param name=\"handler\" type=\"Object\" optional=\"true\">Handler for data serialization.</param>\n    /// <param name=\"httpClient\" type=\"Object\" optional=\"true\">HTTP client layer.</param>\n    /// <param name=\"metadata\" type=\"Object\" optional=\"true\">Conceptual metadata for this request.</param>\n\n    success = success || (data => process.env.NODE_ENV !== 'production' && console.log(JSON.stringify(data)));\n    error =\n        error ||\n        (err => {\n            throw err;\n        });\n\n    // Augment the request with additional defaults.\n    request.recognizeDates = request.recognizeDates || false;\n    request.useJsonLight = request.useJsonLight || false;\n    request.inferJsonLightFeedAsObject = request.inferJsonLightFeedAsObject || false;\n    request.callbackParameterName = request.callbackParameterName || defaultHttpClient.callbackParameterName;\n    request.formatQueryString = request.formatQueryString || defaultHttpClient.formatQueryString;\n    request.enableJsonpCallback = request.enableJsonpCallback || defaultHttpClient.enableJsonpCallback;\n\n    // Create the base context for read/write operations, also specifying complete settings.\n    const context = {\n        recognizeDates: request.recognizeDates,\n        callbackParameterName: request.callbackParameterName,\n        formatQueryString: request.formatQueryString,\n        enableJsonpCallback: request.enableJsonpCallback,\n        useJsonLight: request.useJsonLight,\n        inferJsonLightFeedAsObject: request.inferJsonLightFeedAsObject\n    };\n\n    try {\n        prepareRequest(request, jsonHandler, context);\n        return invokeRequest(request, success, error, jsonHandler, defaultHttpClient, context);\n    } catch (err) {\n        error(err);\n    }\n};\n"]}
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import 'jest';
import * as tm from 'typemoq';
import { DataServiceRequest, ODATA_HAS_NEXT_PAGE_PROPERTY, parseOdataResult } from '../DataServiceRequest';
describe('odata parsing', () => {
    const MockClass = class MockClassName {
        constructor(data) {
            this.data = data;
        }
    };
    it('returns null back', () => {
        // arrange
        // act
        const result = parseOdataResult(null, undefined);
        // assert
        expect(result).toBe(null);
    });
    it('coerces value to, with type', () => {
        // arrange
        const input = { foo: 'bar' };
        // act
        const result = parseOdataResult(input, MockClass);
        // assert
        expect(result).not.toBe(null);
        expect(result.data).toEqual(input);
    });
    it('coerces value to, without type', () => {
        // arrange
        const input = { foo: 'bar' };
        // act
        const result = parseOdataResult(input, undefined);
        // assert
        expect(result).not.toBe(null);
        expect(result).toEqual(input);
    });
    [true, false].forEach(hasNextPage => {
        it(`can set totalCount, nextPage: ${hasNextPage}`, () => {
            // arrange
            const input = {
                value: { foo: 'bar' },
                [ODATA_HAS_NEXT_PAGE_PROPERTY]: hasNextPage ? true : undefined
            };
            // act
            const result = parseOdataResult(input, MockClass);
            // assert
            expect(result).not.toBe(null);
            expect(result.hasNextPage).toBe(hasNextPage);
        });
    });
    it('can handle array types', () => {
        // arrange
        const values = [0, 1, 2, 3, 4];
        const input = {
            value: [...values]
        };
        // act
        const result = parseOdataResult(input, MockClass);
        // assert
        expect(result).not.toBe(null);
        expect(result.length).toBe(values.length);
        values.forEach(value => {
            expect(result[value].data).toBe(value);
        });
    });
});
describe('DataServiceRequest', () => {
    describe('static functions', () => {
        const buildBatchRequest = DataServiceRequest['buildBatchRequest'];
        ['GET', 'POST'].forEach(method => {
            it(`can buildBatchRequest, ${method};`, () => {
                // arrange
                const [r1, r2] = [tm.Mock.ofType(), tm.Mock.ofType()];
                const [_q1, _q2] = [tm.Mock.ofType(), tm.Mock.ofType()];
                _q1.setup(_ => _.data).returns(() => ({
                    parameters: 'data1'
                }));
                _q2.setup(_ => _.data).returns(() => ({
                    parameters: 'data2'
                }));
                r1.setup(r => r['_query']).returns(() => _q1.object);
                r1.setup(r => r['_method']).returns(() => method);
                r2.setup(r => r['_query']).returns(() => _q2.object);
                r2.setup(r => r['_method']).returns(() => method);
                // return _id
                r1.setup(r => r.id()).returns(() => r1.target['_id']);
                r2.setup(r => r.id()).returns(() => r2.target['_id']);
                const requests = [r1.object, r2.object];
                // act
                const result = buildBatchRequest('uri', requests);
                // assert
                expect(result).toMatchSnapshot();
                // different ids should be assigned at batch
                expect(r1.target.id()).not.toBe(r2.target.id());
            });
        });
        describe('toJson', () => {
            const toJson = DataServiceRequest['toJson'];
            it('null data', () => {
                expect(toJson(null)).toBeNull();
            });
            it('primitives', () => {
                expect(toJson(4)).toMatchSnapshot();
                expect(toJson('string')).toMatchSnapshot();
            });
            [true, false].forEach(isClone => {
                it(`handles object, clone:${isClone}`, () => {
                    // arrange
                    const input = {
                        nullValue: null,
                        stringArrayValue: ['a', 'b', 'c'],
                        numberArrayValue: [1, 2, 3],
                        dateValue: new Date(1560987187377),
                        stringValue: 'foobar',
                        // hardcode one nested object
                        objectValue: {
                            nullValue: null,
                            stringArrayValue: ['a', 'b', 'c'],
                            numberArrayValue: [1, 2, 3],
                            dateValue: new Date(1560987187377),
                            stringValue: 'foobar'
                        }
                    };
                    // act
                    const result = toJson(input, undefined, isClone);
                    // assert
                    expect(result).toMatchSnapshot();
                });
            });
        });
    });
});
//# sourceMappingURL=DataServiceRequest.test.js.map
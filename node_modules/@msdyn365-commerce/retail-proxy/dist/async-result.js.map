{"version":3,"file":"async-result.js","sourceRoot":"","sources":["../src/async-result.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// NOTE: no-any is disabled intentionally, as promises require valid use of the any type\n// tslint:disable:no-any\nimport { observable } from 'mobx';\nimport { IODataMetadata } from './interfaces/IODataMetadata';\n\nexport type AsyncResultStatus = 'LOADING' | 'SUCCESS' | 'FAILED';\n\nexport const isAsyncResult = (item: { toString(): string }): item is AsyncResult<unknown> => {\n    return item && item.toString && typeof item.toString === 'function' && item.toString() === `[object AsyncResult]`;\n};\n\n/**\n * Utility Methods For AsyncResult\n */\nconst isThenable = (obj: any) => obj && typeof obj === 'object' && typeof obj.then === 'function';\n\n/**\n * TYPES & INTERFACES\n */\ninterface IHandler<TIn, TOut> {\n    onSuccess: HandlerOnSuccess<TIn, TOut>;\n    onFail: HandlerOnFail<TOut>;\n}\n\ntype HandlerOnSuccess<TIn, TOut> = (value: TIn) => TOut | PromiseLike<TOut>;\ntype HandlerOnFail<TOut = never> = (reason: any) => TOut | PromiseLike<TOut>;\n\ntype Resolve<T> = (value?: T | PromiseLike<T>) => void;\ntype Reject = (value?: any) => void;\n\n/**\n * AsyncResult Class\n * Promise-style class which allows for observation of the status of the promise\n * and it's result during and after is execution.\n */\nexport class AsyncResult<T> implements Promise<T> {\n    @observable public result?: T;\n\n    @observable public status: AsyncResultStatus = 'LOADING';\n\n    @observable public error?: Error;\n\n    @observable public metadata: IODataMetadata = {};\n\n    // @ts-ignore\n    private _type: string = 'AsyncResult';\n\n    private _handlers: Array<IHandler<T, any>> = [];\n\n    public static resolve<U = any>(value?: U | PromiseLike<U>): AsyncResult<U> {\n        return new AsyncResult<U>(resolve => {\n            return resolve(value);\n        });\n    }\n\n    public static reject<U>(reason?: any): AsyncResult<U> {\n        return new AsyncResult<U>((resolve, reject) => {\n            return reject(reason);\n        });\n    }\n\n    /**\n     * Class constructor, which starts running the passed executor\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    constructor(executor: (resolve: Resolve<T>, reject: Reject) => void) {\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method that allows for an executor to be passed to the promise after inital execution,\n     * essentially \"rerunning\" the promise.\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    public run(executor: (resolve: Resolve<T>, reject: Reject) => void): void {\n        this.status = 'LOADING';\n        this.error = undefined;\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult\n     * @param onSuccess Callback to be run on successful completion of executor\n     * @param onFail Callback to be run when executor cannot be successfully completed\n     */\n    public then<TResult1 = T, TResult2 = never>(\n        onSuccess?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onFail?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n    ): AsyncResult<TResult1 | TResult2> {\n        const asyncResult = new AsyncResult<TResult1 | TResult2>((resolve, reject) => {\n            return this._attachHandler({\n                onSuccess: result => {\n                    if (!onSuccess) {\n                        // @ts-ignore: Type overlap issue\n                        return resolve(result);\n                    }\n\n                    try {\n                        return resolve(onSuccess(result));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                },\n                onFail: reason => {\n                    if (!onFail) {\n                        return reject(reason);\n                    }\n\n                    try {\n                        return resolve(onFail(reason));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                }\n            });\n        });\n\n        // Always pass the metadata on a then\n        asyncResult.metadata = this.metadata;\n\n        return asyncResult;\n    }\n\n    /**\n     * Hook to allow callback on the unsuccessful run of an executor\n     * @param onFail Callback to run when executor fails\n     */\n    public catch<TResult = never>(onFail?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): AsyncResult<T | TResult> {\n        const defaultThen = (value: any) => value;\n        return this.then(defaultThen, onFail);\n    }\n\n    /**\n     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor\n     * @param callback Callback to be run after original AsyncResult is completed\n     */\n    public finally(onfinally?: (() => void) | undefined | null): AsyncResult<T> {\n        return new AsyncResult((resolve, reject) => {\n            let value: T | any;\n            let failed: Boolean = false;\n\n            return this.then(\n                result => {\n                    value = result;\n                    return onfinally();\n                },\n                reason => {\n                    failed = true;\n                    value = reason;\n                    return onfinally();\n                }\n            ).then(() => {\n                if (failed) {\n                    return reject(value);\n                }\n\n                return resolve(value);\n            });\n        });\n    }\n\n    public toString(): string {\n        return `[object AsyncResult]`;\n    }\n\n    get [Symbol.toStringTag](): string {\n        return '[object AsyncResult]';\n    }\n\n    private _attachHandler = (handler: IHandler<T, any>) => {\n        this._handlers.push(handler);\n\n        this._executeHandlers();\n    }\n\n    private _executeHandlers = () => {\n        if (this.status === 'LOADING') {\n            return;\n        }\n\n        for (const handler of this._handlers) {\n            if (this.status === 'FAILED') {\n                handler.onFail(this.error);\n            } else {\n                handler.onSuccess(this.result as T);\n            }\n        }\n\n        this._handlers = [];\n    }\n\n    private _resolve = (value?: T | PromiseLike<T>) => {\n        return this._updateStatus(value, 'SUCCESS');\n    }\n\n    private _reject = (reason: any) => {\n        return this._updateStatus(reason, 'FAILED', true);\n    }\n\n    private _updateStatus(result: T | any, newStatus: AsyncResultStatus, isError: Boolean = false): void {\n        // Wrap in setTimeout to ensure fully synchronous handlers\n        // are still returned AFTER initial class construction\n        setTimeout(() => {\n            if (this.status !== 'LOADING') {\n                return null;\n            }\n\n            if (isThenable(result)) {\n                return (result as PromiseLike<T>).then(this._resolve, this._reject);\n            }\n\n            if (isError) {\n                this.error = result;\n            } else {\n                this.result = result;\n            }\n\n            this.status = newStatus;\n\n            return this._executeHandlers();\n        }, 0);\n    }\n}\n"]}
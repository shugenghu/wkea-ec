/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ICacheSource } from '@msdyn365-commerce/cache-internal';
import { msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { LogLevel } from '@msdyn365-commerce/telemetry-internal';
const GET_FROM_RETURNIDENTIFIER = '___GET__FROM__RETURNIDENTIIER___';
export const addLocaleInformation = (inputs, locale) => {
    const isArray = Array.isArray(inputs);
    if (isArray) {
        // @ts-ignore
        (inputs || []).forEach(input => {
            if (input instanceof DataServiceRequest && !input.getCacheKey().endsWith(`-${locale}`)) {
                // @ts-ignore
                const tmp = input._cacheKeyFromInput;
                // @ts-ignore
                input._cacheKeyFromInput = `${tmp}-${locale}`;
            }
        });
    }
    else {
        if (inputs instanceof DataServiceRequest && !inputs.getCacheKey().endsWith(`-${locale}`)) {
            // @ts-ignore
            const tmp = inputs._cacheKeyFromInput;
            // @ts-ignore
            inputs._cacheKeyFromInput = `${tmp}-${locale}`;
        }
    }
};
// tslint:disable
const _resolveCacheEntryReference = (dataServiceRequest, item, requestCache, appCache, shouldReadFromAppCache, isWrappingPromise) => {
    const cacheValueAsArray = item['key']
        .map(key => {
        // @ts-ignore
        const value = requestCache.get({ typeName: dataServiceRequest._cacheObjectType, key });
        if (!value && shouldReadFromAppCache && appCache) {
            // @ts-ignore
            appCache.copyTo({ typeName: dataServiceRequest._cacheObjectType, key }, requestCache);
        }
        if (!value || !value.item) {
            return undefined;
        }
        // @ts-ignore
        if (isAsyncResult(value.item)) {
            return value.item.result;
        }
        return value.item;
    })
        .filter(data => data !== undefined && data !== null);
    if (item['key'].length > cacheValueAsArray.length) {
        return;
    }
    // If we are returning a Promise that represents a future collection, we need to unwrap it
    // @ts-ignore
    const isReturnTypeACollection = dataServiceRequest._query.isReturnTypeACollection;
    return cacheValueAsArray && cacheValueAsArray.length > 0
        ? isReturnTypeACollection && !isWrappingPromise
            ? cacheValueAsArray
            : cacheValueAsArray[0]
        : undefined;
};
const logTelemetrySource = (cacheValue, dataServiceRequest, cacheKey, telemetry) => {
    if (!telemetry) {
        return;
    }
    if (!msdyn365Commerce.isBrowser) {
        switch (cacheValue.s) {
            case ICacheSource.AppCache: {
                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                    values: [
                        // @ts-ignore
                        dataServiceRequest._cacheObjectType || 'none',
                        cacheKey,
                        'AppCache'
                    ]
                });
                break;
            }
            case ICacheSource.RequestCache: {
                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                    values: [
                        // @ts-ignore
                        dataServiceRequest._cacheObjectType || 'none',
                        cacheKey,
                        'RequestCache'
                    ]
                });
                break;
            }
            default: {
                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                    values: [
                        // @ts-ignore
                        dataServiceRequest._cacheObjectType || 'none',
                        cacheKey,
                        'Default'
                    ]
                });
                break;
            }
        }
    }
};
const readCacheEntriesBasedOnCacheKeyFromReturnType = (dataServiceRequest, requestCache, appCache, shouldReadFromAppCache, telemetry) => {
    // @ts-ignore
    if (dataServiceRequest._cacheKeyFromReturnType.length === 0) {
        return { entry: null, shouldRefresh: false };
    }
    let shouldRefreshAll = true;
    // @ts-ignore
    const cacheEntries = dataServiceRequest._cacheKeyFromReturnType
        // @ts-ignore
        .map(entry => {
        // @ts-ignore
        const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${entry}`;
        // @ts-ignore
        let cacheValue = requestCache.get({ typeName: dataServiceRequest._cacheObjectType, key });
        if (!cacheValue && shouldReadFromAppCache && appCache) {
            // @ts-ignore
            cacheValue = appCache.copyTo({ typeName: dataServiceRequest._cacheObjectType, key }, requestCache);
        }
        if (!cacheValue || !cacheValue.item) {
            return null;
        }
        // according to the logic, will treat the entries to shouldRefresh when all entries have shouldRefresh.
        if (!cacheValue.shouldRefresh) {
            shouldRefreshAll = false;
        }
        logTelemetrySource(cacheValue, dataServiceRequest, key, telemetry);
        return cacheValue.item;
    })
        .filter(Boolean);
    // @ts-ignore
    const isReturnTypeACollection = dataServiceRequest._query.isReturnTypeACollection;
    const cacheEntriesReturn = cacheEntries && cacheEntries.length > 0 ? (isReturnTypeACollection ? cacheEntries : cacheEntries[0]) : null;
    return { entry: cacheEntriesReturn, shouldRefresh: shouldRefreshAll };
};
export const readCacheEntries = (dataServiceRequest, requestCache, appCache, shouldReadFromAppCache = false, telemetry) => {
    if (!requestCache ||
        // @ts-ignore
        (!dataServiceRequest.getCacheKey() && dataServiceRequest._cacheKeyFromReturnType.length === 0) ||
        // @ts-ignore
        !dataServiceRequest._cacheObjectType) {
        return { entry: null, shouldRefresh: false };
    }
    if (
    // @ts-ignore
    dataServiceRequest._cacheKeyFromInput === GET_FROM_RETURNIDENTIFIER ||
        // @ts-ignore
        (dataServiceRequest._cacheKeyIdentifierFromReturnType && dataServiceRequest._cacheKeyFromReturnType.length !== 0)) {
        const entries = readCacheEntriesBasedOnCacheKeyFromReturnType(dataServiceRequest, requestCache, appCache, shouldReadFromAppCache, telemetry);
        if (entries && entries.entry) {
            return entries;
        }
    }
    // @ts-ignore
    const cacheKey = { typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput };
    let cachedValueBasedOnInput = requestCache.get(cacheKey);
    if (cachedValueBasedOnInput) {
        cachedValueBasedOnInput = { ...cachedValueBasedOnInput };
    }
    else if (shouldReadFromAppCache && appCache) {
        cachedValueBasedOnInput = appCache.copyTo(cacheKey, requestCache);
    }
    if (!cachedValueBasedOnInput) {
        return readCacheEntriesBasedOnCacheKeyFromReturnType(dataServiceRequest, requestCache, appCache, shouldReadFromAppCache, telemetry);
    }
    // @ts-ignore
    logTelemetrySource(cachedValueBasedOnInput, dataServiceRequest, dataServiceRequest._cacheKeyFromInput, telemetry);
    if (cachedValueBasedOnInput.item instanceof AsyncResult) {
        if (cachedValueBasedOnInput.item.status !== 'LOADING') {
            cachedValueBasedOnInput.item = cachedValueBasedOnInput.item.result || cachedValueBasedOnInput.item.error;
        }
        else {
            const asyncResult = cachedValueBasedOnInput.item.then(result => {
                if (typeof result !== 'object' || result['$ref'] !== true) {
                    return result;
                }
                return _resolveCacheEntryReference(dataServiceRequest, result, requestCache, appCache, shouldReadFromAppCache);
            });
            return { entry: asyncResult, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };
        }
    }
    if (typeof cachedValueBasedOnInput.item !== 'object' ||
        // @ts-ignore
        (cachedValueBasedOnInput.item && cachedValueBasedOnInput.item['$ref'] !== true)) {
        return { entry: cachedValueBasedOnInput.item, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };
    }
    const resolvedRef = _resolveCacheEntryReference(dataServiceRequest, cachedValueBasedOnInput.item, requestCache, appCache, shouldReadFromAppCache, 
    // @ts-ignore
    isAsyncResult(cachedValueBasedOnInput.item));
    return { entry: resolvedRef, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };
};
const _saveEntityToCache = (dataServiceRequest, data, requestCache, appCache, isCacheTypeApplication) => {
    // @ts-ignore
    if (!data || (!dataServiceRequest._cacheKeyFromInput && !dataServiceRequest._cacheKeyIdentifierFromReturnType)) {
        return;
    }
    const cacheEntries = {};
    const results = data;
    // using Object.prototype instead of Array.isArray because results can be Observable Array which cann't be detected with Array.isArray
    // @ts-ignore
    if (!dataServiceRequest._query.isReturnTypeACollection || Object.prototype.toString.call(results) !== '[object Array]') {
        // @ts-ignore
        if (dataServiceRequest._cacheKeyIdentifierFromReturnType) {
            // @ts-ignore
            const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${
            // @ts-ignore
            results[dataServiceRequest._cacheKeyIdentifierFromReturnType]}`;
            // @ts-ignore
            cacheEntries[key] = results;
            // @ts-ignore
            if (dataServiceRequest._cacheKeyFromInput) {
                let existingCacheItem = requestCache.get({
                    // @ts-ignore
                    typeName: dataServiceRequest._cacheObjectType,
                    // @ts-ignore
                    key: dataServiceRequest._cacheKeyFromInput
                });
                if (existingCacheItem) {
                    existingCacheItem = { ...existingCacheItem };
                }
                if (existingCacheItem &&
                    existingCacheItem.item &&
                    (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&
                    // @ts-ignore
                    (typeof existingCacheItem.item !== 'object' || (existingCacheItem && existingCacheItem.item['$ref'] !== true))) {
                    // @ts-ignore
                    cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;
                }
                else {
                    // @ts-ignore
                    cacheEntries[dataServiceRequest._cacheKeyFromInput] = {
                        $ref: true,
                        // @ts-ignore
                        type: dataServiceRequest._cacheObjectType,
                        // @ts-ignore
                        identifier: dataServiceRequest._cacheKeyIdentifierFromReturnType,
                        key: [key],
                        // @ts-ignore
                        count: dataServiceRequest._totalCount
                    };
                }
            }
        }
        else {
            // @ts-ignore
            cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;
        }
        // @ts-ignore
    }
    else if (!dataServiceRequest._cacheKeyIdentifierFromReturnType) {
        // @ts-ignore
        cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;
    }
    else {
        const cacheValue = results
            // @ts-ignore
            .map(result => {
            // @ts-ignore
            const identifierValue = result[dataServiceRequest._cacheKeyIdentifierFromReturnType];
            if (identifierValue) {
                // @ts-ignore
                const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${identifierValue}`;
                // @ts-ignore
                cacheEntries[key] = result;
                return key;
            }
        })
            .filter(Boolean);
        let existingCacheItem = requestCache.get({
            // @ts-ignore
            typeName: dataServiceRequest._cacheObjectType,
            // @ts-ignore
            key: dataServiceRequest._cacheKeyFromInput
        });
        if (existingCacheItem) {
            existingCacheItem = { ...existingCacheItem };
        }
        if (existingCacheItem &&
            existingCacheItem.item &&
            (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&
            // @ts-ignore
            (typeof existingCacheItem.item !== 'object' || (existingCacheItem && existingCacheItem.item['$ref'] !== true))) {
            // @ts-ignore
            cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;
        }
        else {
            // @ts-ignore
            cacheEntries[dataServiceRequest._cacheKeyFromInput] = {
                $ref: true,
                // @ts-ignore
                type: existingCacheItem._cacheObjectType,
                // @ts-ignore
                identifier: existingCacheItem._cacheKeyIdentifierFromReturnType,
                // @ts-ignore
                isCollection: existingCacheItem._query.isReturnTypeACollection,
                key: cacheValue,
                // @ts-ignore
                count: existingCacheItem._totalCount
            };
        }
    }
    if (cacheEntries) {
        Object.keys(cacheEntries).map(entryKey => {
            // @ts-ignore
            requestCache.put({ typeName: dataServiceRequest._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });
            if (appCache && isCacheTypeApplication) {
                // @ts-ignore
                appCache.put({ typeName: dataServiceRequest._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });
            }
        });
    }
    return cacheEntries;
};
export const saveCacheEntries = (dataServiceRequest, data, requestCache, appCache, isCacheTypeApplication) => {
    // if return Entity is collection
    //        if entity type has identifier/primary key
    //              1. cache array of primay key value of returned entity collection on input cache key
    //              2. cache individual entity on primary key
    //        else
    //              1. cache output on input cache key
    //
    // else  if entity type has identifier/primary key
    //           2. cache output entity on primary key
    if (!data ||
        // @ts-ignore
        (!dataServiceRequest._cacheKeyFromInput && !dataServiceRequest._cacheKeyIdentifierFromReturnType) ||
        // @ts-ignore
        !dataServiceRequest._cacheObjectType) {
        return;
    }
    if (data instanceof AsyncResult) {
        // For a loading Promise, cache based on input cachekey, and then cache output again once complete
        if (data.status === 'LOADING') {
            data.then(result => {
                // @ts-ignore
                if (dataServiceRequest._totalCount !== undefined) {
                    // @ts-ignore
                    data.metadata.count = dataServiceRequest._totalCount;
                }
                _saveEntityToCache(dataServiceRequest, result, requestCache, appCache, isCacheTypeApplication);
                return result;
            });
            // @ts-ignore
            requestCache.put({ typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput }, { item: data });
            if (appCache && isCacheTypeApplication) {
                // @ts-ignore
                appCache.put({ typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput }, { item: data });
            }
            // For a completed promise, save the action results to the cache
        }
        else {
            // @ts-ignore
            if (dataServiceRequest._totalCount !== undefined) {
                // @ts-ignore
                data.metadata.count = dataServiceRequest._totalCount;
            }
            _saveEntityToCache(dataServiceRequest, data.result, requestCache, appCache, isCacheTypeApplication);
            return data.result;
        }
    }
    else {
        return _saveEntityToCache(dataServiceRequest, data, requestCache, appCache, isCacheTypeApplication);
    }
};
//# sourceMappingURL=retail-cache-helper.js.map
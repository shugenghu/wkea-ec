{"version":3,"file":"action-executor.js","sourceRoot":"","sources":["../../src/action-executor.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,EAA2E,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAC7I,OAAO,EAAE,WAAW,EAAE,kBAAkB,EAAE,aAAa,EAAE,aAAa,EAAE,UAAU,EAAE,MAAM,iCAAiC,CAAC;AAC5H,OAAO,EAAc,QAAQ,EAAE,eAAe,EAAE,MAAM,uCAAuC,CAAC;AAC9F,OAAO,EAAE,GAAG,IAAI,IAAI,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAC/C,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAC5B,OAAO,MAAM,MAAM,SAAS,CAAC;AAC7B,OAAO,EAAE,WAAW,EAAqB,MAAM,gBAAgB,CAAC;AAChE,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAC;AACrD,OAAO,EAAE,cAAc,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,MAAM,wBAAwB,CAAC;AACvG,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,MAAM,6BAA6B,CAAC;AACjF,OAAO,WAAW,MAAM,iBAAiB,CAAC;AAE1C,MAAM,kBAAkB,GAAW,IAAI,CAAC;AACxC,MAAM,sBAAsB,GAAW,IAAI,CAAC;AAE5C,MAAM,KAAK,GAAG,CAAC,WAAmB,EAAE,OAAgB,EAAE,EAAE,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC;AAEzI,MAAM,WAAW,GAAG,CAAC,WAAmB,EAAE,EAAE,CACxC,IAAI,OAAO,CAAC,CAAC,QAAQ,EAAE,MAAM,EAAE,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,0BAA4B,EAAE,WAAW,CAAC,CAAC,CAAC;AAE/G,MAAM,qBAAqB,GAAG,CAAC,WAAmB,EAAE,EAAE,CAClD,IAAI,WAAW,CAAC,CAAC,QAAQ,EAAE,MAAM,EAAE,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,0BAA4B,EAAE,WAAW,CAAC,CAAC,CAAC;AAEnH;;;GAGG;AACH,eAAe;AACf,MAAM,CAAC,OAAO,OAAO,cAAc;IAQ/B;;;OAGG;IACH,YAAY,MAAgB,EAAE,MAAsB,EAAE,SAAqB,EAAE,gBAAoC;QAC7G,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,OAAO,GAAG,MAAM,EAAE,CAAC;QACxB,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,sCAAsC;QACjE,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC;QAE5C,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC;QAElD,iCAAiC;QACjC,MAAM,WAAW,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAE9B,IAAI,WAAW,IAAI,WAAW,CAAC,aAAa,EAAE;YAC1C,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,aAAa,EAAE,CAAC;SAChD;aAAM,IAAI,WAAW,IAAI,WAAW,CAAC,iBAAiB,EAAE;YACrD,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC;YACtE,SAAS,CAAC,KAAK,CAAC,qGAAqG,CAAC,CAAC;SAC1H;aAAM;YACH,IAAI,CAAC,SAAS,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,SAAS,IAAI,MAAM,CAAC;YAC1E,2GAA2G;YAC3G,gFAAgF;YAChF,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAC,EAAE;gBACpB,KAAK,CAAC,aAAa,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC;YAC/C,CAAC,CAAC,CAAC;YACH,SAAS,CAAC,KAAK,CAAC,gGAAgG,CAAC,CAAC;SACrH;IACL,CAAC;IAED;;;OAGG;IACI,SAAS,CAAC,MAAsB;QACnC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;IAChC,CAAC;IAED,0BAA0B;IAC1B,gDAAgD;IACzC,KAAK,CAAC,OAAO,CAChB,OAAuB,EACvB,YAAoB,EACpB,QAAuB,EACvB,cAAwB,EACxB,mBAAmC,EAAE;QAErC,MAAM,MAAM,GACR,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC;YAC3C,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC;YAC1C,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAChB,OAAO,EAAE,CAAC;SACb;QACD,MAAM,kBAAkB,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;QAE3E,iCAAiC;QACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACrD,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC;aAC3C,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;aAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QAExB,uBAAuB;QACvB,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC;aAC7C,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;aAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACxB,MAAM,CAAC,QAAQ,EAAE,YAAY,CAAC,GAAqB,IAAI,CAAC,mBAAmB,CACvE,MAAM,EACN,OAAO,EACP,YAAY,EACZ,QAAQ,EACR,cAAc,EACd,kBAAkB,CACrB,CAAC;QAEF,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YAClB,4DAA4D;YAC5D,MAAM,IAAI,CAAC,+BAA+B,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;YACpF,OAAO,YAAY,CAAC;SACvB;aAAM;YACH,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;YACxE,IAAI,aAAa,CAAC,MAAM,EAAE;gBACtB,mHAAmH;gBACnH,MAAM,IAAI,CAAC,+BAA+B,CAAC,QAAQ,EAAE,aAAa,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;aAC9F;SACJ;QAED,IAAI,OAAO,GAAU,EAAE,CAAC;QAExB,sCAAsC;QACtC,mDAAmD;QACnD,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,CAAC,gCAAgC,CAAC,QAAQ,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAE,kBAAkB,CAAC,CAAC;aACxG;iBAAM;gBACH,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAE,kBAAkB,CAAC,CAAC;aACnG;YACD,OAAO,YAAY,CAAC;SACvB;QAED,IAAI,IAAI,CAAC,SAAS,EAAE;YAChB,6CAA6C;YAC7C,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAE3E,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,EAAE;gBAC/C,aAAa;gBACb,OAAO,CAAC,SAAS,CAAC,GAAG,CACjB,QAAQ,CAAC,KAAK,EACd,yFAAyF,EACzF,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,CAChD,CAAC;aACL;SACJ;aAAM;YACH,OAAO,CAAC,CAAC,CAAC,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,kBAAkB,CAAC,CAAC;SACpF;QAED,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAClC,OAAO,YAAY,CAAC;SACvB;QAED,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;QAC9E,OAAO,YAAY,CAAC;IACxB,CAAC;IAED,4FAA4F;IACpF,6BAA6B,CAAC,KAAmB,EAAE,QAA4B;QACnF,OAAO,CAAC,CAAC,KAAK,YAAY,kBAAkB,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC;IAChE,CAAC;IAEO,KAAK,CAAC,+BAA+B,CACzC,QAAgB,EAChB,MAAsB,EACtB,YAAoB,EACpB,OAAuB;QAEvB,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YAC3B,MAAM,QAAQ,GAAG,EAAE,QAAQ,EAAE,CAAC,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC;YAC5E,6FAA6F;YAC7F,IAAI,SAAS,CAAC;YACd,IAAI,IAAI,CAAC,6BAA6B,CAAC,CAAC,EAAE,QAAQ,CAAC,QAAQ,CAAC,EAAE;gBAC1D,SAAS,GAAG,YAAY,CAAC,GAAG,CAAsB,QAAQ,CAAC,CAAC;aAC/D;YACD,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAChE,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC;aACrD,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;aAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACxB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC;aACvD,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;aAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IACO,iBAAiB,CAAC,MAAsB;QAC5C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,OAAO,MAAM,CAAC;SACjB;QAED,OAAO,QAAQ,CACX,MAAM,EACN,CAAC,MAAoB,EAAE,MAAoB,EAAE,EAAE,CAC3C,MAAM,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC,WAAW,EAAE,IAAI,MAAM,CAAC,kBAAkB,EAAE,KAAK,MAAM,CAAC,kBAAkB,EAAE,CACnH,CAAC;IACN,CAAC;IAEO,sBAAsB,CAAC,MAAqC;QAChE,IAAI,cAAc,CAAC;QACnB,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;YAC3D,IAAI,OAAO,KAAK,CAAC,WAAW,KAAK,UAAU,EAAE;gBACzC,cAAc,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC;aACxC;SACJ;QACD,OAAO,cAAc,IAA0B,IAAI,CAAC,MAAO,CAAC,SAAS,CAAC,EAAE,CAAC;IAC7E,CAAC;IAEO,gBAAgB,CAAC,QAAiB;QACtC,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;QACtB,IAAI,QAAQ,EAAE;YACV,MAAM,YAAY,GAAG,eAAe,CAAC,mBAAmB,CAAC,QAAQ,EAAuB,MAAM,CAAC,CAAC;YAChG,IAAI,YAAY,EAAE;gBACd,MAAM,GAAwB,YAAY,CAAC,MAAM,CAAC;gBAClD,OAAO,eAAe,CAAC,YAAY,CAAsB,MAAM,CAAC,CAAC;aACpE;SACJ;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,EAAU,EAAE,MAAqC,EAAE,OAAuB;QACrG,MAAM,YAAY,GAAG,eAAe,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;QACzD,IAAI,CAAC,YAAY,EAAE;YACf,OAAO;SACV;QAED,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAEhE,MAAM,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACnD,OAAO,iBAAiB,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YAChE,MAAM,YAAY,CAAC;YACnB,IAAI;gBACA,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aAC7D;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,4DAA4D,EAAE;oBAChG,MAAM,EAAE,CAAC,EAAE,IAAI,SAAS,CAAC;oBACzB,SAAS,EAAE,KAAK;iBACnB,CAAC,CAAC;aACN;YACD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,EAA+B,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACvD,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAC7B,EAAU,EACV,MAAqC,EACrC,YAAqB,EACrB,OAAuB;QAEvB,MAAM,eAAe,GAAG,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;QAC/D,IAAI,CAAC,eAAe,EAAE;YAClB,OAAO;SACV;QAED,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAChE,MAAM,oBAAoB,GAAG,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACzD,OAAO,oBAAoB,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YACnE,MAAM,YAAY,CAAC;YACnB,IAAI;gBACA,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aAC3E;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,4DAA4D,EAAE;oBAChG,MAAM,EAAE,CAAC,EAAE,IAAI,SAAS,CAAC;oBACzB,SAAS,EAAE,KAAK;iBACnB,CAAC,CAAC;aACN;YACD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,EAAkC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IAC1D,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,EAAU,EAAE,MAAqC,EAAE,OAAuB;QACvG,MAAM,cAAc,GAAG,eAAe,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;QAC7D,IAAI,CAAC,cAAc,EAAE;YACjB,OAAO;SACV;QAED,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAEhE,MAAM,mBAAmB,GAAG,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QACvD,OAAO,mBAAmB,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YAClE,MAAM,YAAY,CAAC;YACnB,IAAI;gBACA,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aAC7D;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,4DAA4D,EAAE;oBAChG,MAAM,EAAE,CAAC,EAAE,IAAI,SAAS,CAAC;oBACzB,SAAS,EAAE,KAAK;iBACnB,CAAC,CAAC;aACN;YACD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,EAAiC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACzD,CAAC;IAEO,KAAK,CAAC,YAAY,CACtB,EAAU,EACV,MAAqC,EACrC,OAAuB;QAEvB,MAAM,QAAQ,GAAG,eAAe,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QACjD,IAAI,CAAC,QAAQ,EAAE;YACX,OAAO;SACV;QACD,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAEhE,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC3C,OAAO,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YAC5D,MAAM,SAAS,GAAG,MAAM,YAAY,CAAC;YACrC,IAAI,YAAqB,CAAC;YAC1B,IAAI;gBACA,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aAC/E;YAAC,OAAO,KAAK,EAAE;gBACZ,MAAM,KAAK,CAAC;aACf;YACD,IAAI,cAA6C,CAAC;YAClD,cAAc;gBACV,YAAY,qCAAkC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAgC,YAAY,CAAC;YAC9H,OAAO,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;QAC3C,CAAC,EAA2B,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IACzD,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAC3B,EAAU,EACV,MAAqC,EACrC,YAAqB,EACrB,OAAuB;QAEvB,MAAM,SAAS,GAAG,eAAe,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;QACvD,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO;SACV;QAED,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAChE,MAAM,kBAAkB,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACjD,OAAO,kBAAkB,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YACjE,MAAM,YAAY,CAAC;YACnB,IAAI;gBACA,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aAC3E;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,4DAA4D,EAAE;oBAChG,MAAM,EAAE,CAAC,EAAE,IAAI,SAAS,CAAC;oBACzB,SAAS,EAAE,KAAK;iBACnB,CAAC,CAAC;aACN;YACD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,EAAgC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACxD,CAAC;IAEO,KAAK,CAAC,aAAa,CACvB,EAAU,EACV,MAAqC,EACrC,YAAqB,EACrB,OAAuB;QAEvB,MAAM,SAAS,GAAG,eAAe,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;QACnD,IAAI,CAAC,SAAS,EAAE;YACZ,OAAO;SACV;QACD,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,wCAAwC,CAAC,CAAC,IAAI,sBAAsB,CAAC;QAC9G,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,mCAAgC,CAAC;QAChE,MAAM,cAAc,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC7C,OAAO,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,EAAE;YAC7D,MAAM,UAAU,GAAG,MAAM,YAAY,CAAC;YACtC,IAAI,aAAsB,CAAC;YAC3B,IAAI;gBACA,aAAa,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;aACzF;YAAC,OAAO,KAAK,EAAE;gBACZ,MAAM,KAAK,CAAC;aACf;YACD,IAAI,eAAe,CAAC;YACpB,eAAe,GAAG,aAAa,qCAAkC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,aAAa,CAAC;YACjH,OAAO,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QAC5C,CAAC,EAA4B,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;IAChE,CAAC;IAED;;OAEG;IACH,kDAAkD;IAC1C,KAAK,CAAC,cAAc,CAAC,MAAqC,EAAE,OAAuB,EAAE,YAAsB;QAC/G,iDAAiD;QACjD,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACrD,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAE/C,IAAI;YACA,4BAA4B;YAC5B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;YACnE,IAAI,OAAO,EAAE;gBACT,MAAM,GAAG,OAAO,CAAC;aACpB;SACJ;QAAC,OAAO,CAAC,EAAE;YACR,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YACjD,eAAe,CAAC,GAAG,CACf,QAAQ,CAAC,KAAK,EACd,iCACI,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,EAClC,+FAA+F;YAC/F,aAAa;YACb;gBACI,aAAa;gBACb,MAAM,EAAE,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,EAAE,cAAc,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7I,SAAS,EAAE,CAAC;aACf,CACJ,CAAC;YACF,OAAO,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;SAC7B;QACD,IAAI,YAAY,CAAC;QACjB,IAAI;YACA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,oCAAoC,CAAC,CAAC,CAAC;YAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAyB,EAAE,EAAE,CAAC,CAAC;YAC9D,MAAM,cAAc,GAAG,gBAAgB,CAAC,gBAAgB,IAAI,gBAAgB,CAAC,gBAAgB,CAAC,qBAAqB,CAAC;YACpH,IAAI,QAAQ,CAAC;YACb,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,mBAAmB,KAAK,MAAM,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,cAAc,EAAE;gBAC3F,MAAM,YAAY,GAAG,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,kBAAkB,CAAC;gBAChG,QAAQ,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;aAC7H;iBAAM;gBACH,QAAQ,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;aACxC;YACD,sBAAsB;YACtB,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC/C;QAAC,OAAO,CAAC,EAAE;YACR,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YACjD,eAAe,CAAC,GAAG,CACf,QAAQ,CAAC,KAAK,EACd,mBACI,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,EAClC,+FAA+F;YAC/F,aAAa;YACb;gBACI,aAAa;gBACb,MAAM,EAAE,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,EAAE,cAAc,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7I,SAAS,EAAE,CAAC;aACf,CACJ,CAAC;YACF,IAAI,KAAK,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;YAC/B,2EAA2E;YAC3E,IAAI,IAAI,CAAC,YAAY,EAAE;gBACnB,wCAAwC;gBACxC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;oBAClB,KAAK;wBACD,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,KAAK,aAAa,CAAC,mBAAmB;4BACjD,CAAC,CAAC,IAAI,WAAW,gDAAsC;4BACvD,CAAC,CAAC,UAAU,CAAC,OAAO,CAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBAClD;qBAAM;oBACH,KAAK;wBACD,CAAC,CAAC,UAAU,KAAK,aAAa,CAAC,mBAAmB;4BAC9C,CAAC,CAAC,IAAI,WAAW,gDAAsC;4BACvD,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;iBAChC;aACJ;YAED,MAAM,KAAK,CAAC;SACf;QAED,IAAI;YACA,6BAA6B;YAC7B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;YACjF,IAAI,MAAM,EAAE;gBACR,YAAY,GAAG,MAAM,CAAC;aACzB;YACD,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC;iBAC1D,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;iBAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YACxB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC;iBAC5D,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;iBAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;SAC3B;QAAC,OAAO,CAAC,EAAE;YACR,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YACjD,eAAe,CAAC,GAAG,CACf,QAAQ,CAAC,KAAK,EACd,kCACI,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,EAClC,+FAA+F;YAC/F,aAAa;YACb;gBACI,aAAa;gBACb,MAAM,EAAE,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,EAAE,cAAc,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7I,SAAS,EAAE,CAAC;aACf,CACJ,CAAC;SACL;QACD,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,oBAAoB,CACxB,QAAwB,EACxB,OAAc,EACd,OAAuB,EACvB,YAAoB,EACpB,QAAuB;QAEvB,MAAM,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC;QAClC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE;YACxB,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAChD,aAAa;YACb,IAAI,CAAC,YAAY,kBAAkB,IAAI,CAAC,CAAC,CAAC,CAAC,kBAAkB,EAAE,EAAE;gBAC7D,IAAI;oBACA,aAAa;oBACb,gBAAgB,CAAC,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,YAAY,EAAE,QAAQ,EAAE,qBAAqB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;iBACjG;gBAAC,OAAO,CAAC,EAAE;oBACR,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;oBACxB,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,yDAAyD,EAAE;wBAC3E,MAAM,EAAE,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC;wBAC1D,SAAS,EAAE,CAAC;qBACf,CAAC,CAAC;oBACH,OAAO,IAAI,CAAC;iBACf;aACJ;iBAAM;gBACH,MAAM,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;gBACjC,MAAM,UAAU,GAAG,CAAC,CAAC,kBAAkB,EAAE,CAAC;gBAE1C,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,UAAU,EAAE;oBAC5B,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;oBAC3B,MAAM,QAAQ,GAAG,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,EAAE,QAAQ,EAAE,CAAC;oBACzD,IAAI,WAAW,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;wBAClC,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;4BACpC,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAA0B,KAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;yBAC5F;wBACD,kBAAkB;qBACrB;yBAAM;wBACH,IAAI,QAAQ,IAAI,qBAAqB,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;4BAChD,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;yBAC3C;wBACD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;wBACnC,IAAI,CAAC,CAAC,aAAa,IAAI,CAAC,CAAC,aAAa,EAAE,KAAK,UAAU,EAAE;4BACrD,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC,CAAC;yBACvD;wBACD,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;qBAC1C;iBACJ;aACJ;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;OAMG;IACK,gCAAgC,CACpC,QAAwB,EACxB,YAAoB,EACpB,QAAuB,EACvB,OAAuB,EACvB,eAAwB,KAAK;QAE7B,MAAM,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;QAChC,MAAM,cAAc,GAAmB,EAAE,CAAC;QAC1C,4EAA4E;QAC5E,MAAM,YAAY,GAAG,QAAQ;aACxB,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YAClB,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACzB,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAE,MAAW,EAAE,EAAE;gBAC3C,6GAA6G;gBAC7G,IAAI,OAAO,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE,EAAE;oBACtC,MAAM,mBAAmB,GAAG,CAAC,KAAU,EAAE,EAAE;wBACvC,YAAY,CAAK,KAAK,CAAC,CAAC;oBAC5B,CAAC,CAAC;oBAEF,MAAM,wBAAwB,GAAG,GAAG,EAAE;wBAClC,YAAY,EAAE,CAAC;oBACnB,CAAC,CAAC;oBAEF,MAAM,gBAAgB,GAAG,CAAC,KAAU,EAAE,EAAE;wBACpC,WAAW,CAAC,KAAK,CAAC,CAAC;oBACvB,CAAC,CAAC;oBAEF,yBAAyB;oBACzB,WAAW,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,aAAa,KAAK,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,EAAE,mBAAmB,CAAC,CAAC;oBAEhG,4BAA4B;oBAC5B,WAAW,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,mBAAmB,KAAK,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,EAAE,wBAAwB,CAAC,CAAC;oBAE3G,gBAAgB;oBAChB,WAAW,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,UAAU,EAAE,gBAAgB,CAAC,CAAC;gBAChE,CAAC,CAAC;qBACG,IAAI,CAAC,MAAM,CAAC,EAAE;oBACX,WAAW,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,OAAO,aAAa,KAAK,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;oBAC3F,WAAW,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,OAAO,mBAAmB,KAAK,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;oBACjG,OAAO,CAAC,MAAM,CAAC,CAAC;gBACpB,CAAC,CAAC;qBACD,KAAK,CAAC,KAAK,CAAC,EAAE;oBACX,WAAW,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,OAAO,UAAU,CAAC,CAAC;oBAC1D,MAAM,CAAC,KAAK,CAAC,CAAC;gBAClB,CAAC,CAAC,CAAC;YACX,CAAC,CAAC;YAEF,kCAAkC;YAClC,sGAAsG;YACtG,IAAI,aAAa,CAAC;YAClB,IAAI,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,KAAK,CAAC,kBAAkB,EAAE,CAAC,EAAE;gBACvE,aAAa,GAAG,YAAY,CAAC,QAAQ,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC;aAC7G;YACD,IAAI,aAAa,IAAI,aAAa,CAAS,aAAa,CAAC,IAAI,CAAC,YAAY,EAAE;gBACjD,aAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACpD,OAAO;aACV;YAED,4CAA4C;YAC5C,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC3B,OAAO,IAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;QACrC,CAAC,CAAC;aACD,MAAM,CAAC,OAAO,CAAC,CAAC;QAErB,wCAAwC;QACxC,IAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,YAAY,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;QAEzF,wBAAwB;QACxB,iDAAiD;QACjD,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,YAAY,CAAC;aAC/C,IAAI,CAAC,CAAC,aAAwB,EAAE,EAAE;YAC/B,iFAAiF;YACjF,+BAA+B;YAC/B,aAAa,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,KAAK,EAAE,EAAE;gBAC1C,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC5B,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,aAAa,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,EAAE,EAAE,YAAY,CAAC,CAAC;YACzG,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;aACD,KAAK,CAAC,KAAK,CAAC,EAAE;YACX,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,UAAU,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC,CAAC;aACD,OAAO,CAAC,GAAG,EAAE;YACV,uFAAuF;YACvF,aAAa,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;gBACpC,MAAM,KAAK,GAAW,eAAe,CAAC;gBACtC,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,mBAAmB,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACjG,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;;;;OAMG;IACK,wBAAwB,CAC5B,KAAmB,EACnB,YAAoB,EACpB,QAAuB,EACvB,OAAuB,EACvB,eAAwB,KAAK;QAE7B,MAAM,QAAQ,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,kBAAkB,EAAE,EAAE,CAAC;QACpF,MAAM,QAAQ,GAAG,CAAC,OAAY,EAAE,MAAW,EAAE,EAAE;YAC3C,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,EAAE,YAAY,CAAC;iBAC5C,IAAI,CAAC,MAAM,CAAC,EAAE;gBACX,OAAO,CAAC,MAAM,CAAC,CAAC;YACpB,CAAC,CAAC;iBACD,KAAK,CAAC,KAAK,CAAC,EAAE;gBACX,uDAAuD;gBACvD,wDAAwD;gBACxD,IAAI,WAAW,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE;oBAC5E,MAAM,UAAU,GAAG,QAAQ,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;oBAChD,IAAI,UAAU,EAAE;wBACZ,OAAO,OAAO,CAAC,UAAU,CAAC,CAAC;qBAC9B;iBACJ;gBACD,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;YACzB,CAAC,CAAC,CAAC;QACX,CAAC,CAAC;QACF,sGAAsG;QACtG,IAAI,aAAa,CAAC;QAClB,IAAI,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,KAAK,CAAC,kBAAkB,EAAE,CAAC,EAAE;YACvE,aAAa,GAAG,YAAY,CAAC,QAAQ,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC;SAC7G;QACD,2CAA2C;QAC3C,IAAI,aAAa,IAAI,aAAa,CAAS,aAAa,CAAC,IAAI,CAAC,YAAY,EAAE;YACjD,aAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACpD,OAAO;SACV;QAED,8CAA8C;QAC9C,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAI,CAAC,oBAAoB,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,WAAW,CAAC,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;IACvF,CAAC;IAEO,mBAAmB,CACvB,MAAsB,EACtB,OAAuB,EACvB,YAAoB,EACpB,QAAuB,EACvB,cAAwB,EACxB,UAAoB;QAEpB,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,iCAAiC,CAAC,CAAC;QAC9D,MAAM,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC;QAElC,IAAI,IAAI,EAAE;YACN,MAAM,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;SACxE;QAED,6FAA6F;QAC7F,4JAA4J;QAC5J,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,IAAI,UAAU,EAAE;YACzC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SACvB;QAED,MAAM,QAAQ,GAAmB,EAAE,CAAC;QACpC,MAAM,OAAO,GAAmB,EAAE,CAAC;QACnC,oBAAoB;QACpB,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE;YACtB,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,EAAE,QAAQ,EAAE,CAAC,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC;YAC5E,4FAA4F;YAC5F,IAAI,CAAC,YAAY,kBAAkB,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;gBACvD,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACjB,OAAO;aACV;YACD,IAAI,SAAS,GAAgC,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACxE,IAAI,SAAS,IAAI,aAAa,CAAS,SAAS,CAAC,IAAI,CAAC,IAA2B,SAAS,CAAC,IAAK,CAAC,MAAM,KAAK,QAAQ,EAAE;gBAClH,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACpB;iBAAM,IAAI,SAAS,IAAI,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;gBAChH,uGAAuG;gBACvG,oHAAoH;gBACpH,sHAAsH;gBACtH,uFAAuF;gBACvF,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACjB,aAAa;aAChB;iBAAM,IAAI,CAAC,YAAY,kBAAkB,EAAE;gBACxC,IAAI;oBACA,MAAM,YAAY,GAAG,gBAAgB,CACjC,CAAC,EACD,YAAY;oBACZ,aAAa;oBACb,QAAQ,EACR,CAAC,CAAC,CAAC,cAAc,IAAI,sBAAsB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAC3D,CAAC;oBACF,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE;wBACrB,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACpB;oBACD,IAAI,YAAY,IAAI,YAAY,CAAC,aAAa,EAAE;wBAC5C,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACnB;iBACJ;gBAAC,OAAO,CAAC,EAAE;oBACR,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;oBACxB,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,uDAAuD,EAAE;wBACzE,MAAM,EAAE,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC;wBAC1D,SAAS,EAAE,CAAC;qBACf,CAAC,CAAC;oBACH,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACpB;aACJ;iBAAM;gBACH,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,cAAc,IAAI,QAAQ,IAAI,sBAAsB,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;oBACpF,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;oBACpD,IAAI,SAAS,IAAI,SAAS,CAAC,aAAa,EAAE;wBACtC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACnB;iBACJ;gBAED,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;oBAC/B,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACjB,OAAO;iBACV;aACJ;QACL,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACK,uBAAuB,CAAC,MAAsB,EAAE,OAAuB,EAAE,YAAoB;QACjG,MAAM,QAAQ,GAAmB,EAAE,CAAC;QACpC,MAAM,QAAQ,GAAW,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;QAClD,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACf,IAAI,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,YAAY,CAAC,CAAC;YACxF,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE;gBACvB,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,YAAY,CAAC,CAAC;aACzE;YACD,IAAI,YAAY,CAAC;YACjB,IAAI,IAAI,CAAC,6BAA6B,CAAC,CAAC,EAAE,CAAC,CAAC,kBAAkB,EAAE,CAAC,EAAE;gBAC/D,YAAY,GAAG,YAAY,CAAC,GAAG,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;aAC/F;YAED,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,YAAY,EAAE;gBAChD,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnB,YAAY,CAAC,GAAG,CACZ,EAAE,QAAQ,EAAE,CAAC,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,EAC1D,EAAE,IAAI,EAAE,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,CACrD,CAAC;iBACL;qBAAM;oBACH,YAAY,CAAC,GAAG,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC,kBAAkB,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,WAAW,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBAC/G;aACJ;iBAAM;gBACH,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACpB;QACL,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEO,YAAY,CAAC,cAAsB,EAAE,QAAgB,EAAE,YAAoB;QAC/E,OAAO,CACH,YAAY,CAAC,GAAG,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,cAAc,IAAI,QAAQ,EAAE,EAAE,CAAC;YAC9E,YAAY,CAAC,GAAG,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,cAAc,IAAI,EAAE,CAAC,CACvE,CAAC;IACN,CAAC;IAEO,iBAAiB,CAAC,CAAM;QAC5B,gDAAgD;QAChD,iDAAiD;QACjD,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YAClB,MAAM,UAAU,GAAe,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAI,UAAU,CAAC,SAAS,EAAE;gBACtB,OAAO,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;aACzC;SACJ;aAAM,IAAI,CAAC,CAAC,SAAS,EAAE;YACpB,OAAO,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SAChC;QACD,yCAAyC;QACzC,OAAO,IAAI,KAAK,CAAC,CAAC,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;IACtC,CAAC;CACJ","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable:no-any\nimport { ICache, ICacheItem } from '@msdyn365-commerce/cache-internal';\nimport { CacheType, IActionContext, IActionInput, IAnyAction, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, ErrorTypeEnum, isAsyncResult, ProxyError } from '@msdyn365-commerce/retail-proxy';\nimport { ITelemetry, LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { get as _get, uniqWith } from 'lodash';\nimport { toJS } from 'mobx';\nimport uuidv1 from 'uuid/v1';\nimport { ActionError, ActionErrorStatus } from './action-error';\nimport { ActionRegistrar } from './action-registrar';\nimport { isAppCacheData, shouldReadFromAppCache, shouldWriteToAppCache } from './action-runtime-utils';\nimport { readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\nconst defaultTimeoutInMS: number = 4000;\nconst defaultHookTimeoutInMS: number = 1000;\n\nconst Timer = (timeoutInMS: number, message: unknown) => new Promise(resolve => setTimeout(resolve.bind(resolve, message), timeoutInMS));\n\nconst ActionTimer = (timeoutInMS: number) =>\n    new Promise((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\nconst ObservableActionTimer = (timeoutInMS: number) =>\n    new AsyncResult((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\n/**\n * This class contains the logic to batch and de-dupe the actions that can be executed.\n * This class is also responsible for checking and saving the action response to cache.\n */\n/* @internal */\nexport default class ActionExecutor {\n    public readonly action: Function;\n    public readonly cacheType: CacheType;\n    private readonly isBatched: boolean;\n    private readonly eventId: string;\n    private readonly isObservable: boolean;\n\n    private inputs: IActionInput[];\n    /**\n     * @param action the action to execute\n     * @param inputs the action input\n     */\n    constructor(action: Function, inputs: IActionInput[], telemetry: ITelemetry, dataActionOption?:IDataActionOptions) {\n        this.action = action;\n        this.eventId = uuidv1();\n        this.inputs = [...inputs]; // Cloning it DO NOT use the reference\n        this.isBatched = action.prototype.isBatched;\n\n        this.isObservable = action.prototype.isObservable;\n\n        // Cache all the calls on browser\n        const masterInput = inputs[0];\n\n        if (masterInput && masterInput.dataCacheType) {\n            this.cacheType = masterInput.dataCacheType();\n        } else if (masterInput && masterInput.shouldCacheOutput) {\n            this.cacheType = masterInput.shouldCacheOutput() ? 'request' : 'none';\n            telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');\n        } else {\n            this.cacheType = dataActionOption && dataActionOption.cacheType || 'none';\n            // for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.\n            // this is used for later check if the data acton should be read from app cache.\n            inputs.forEach((input)=> {\n                input.dataCacheType = () => this.cacheType;\n            });\n            telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to \"none\"');\n        }\n    }\n\n    /**\n     *\n     * @param inputs add more inputs\n     */\n    public addInputs(inputs: IActionInput[]): void {\n        this.inputs.push(...inputs);\n    }\n\n    /** Execute the action  */\n    // tslint:disable-next-line:max-func-body-length\n    public async execute(\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshingInputs: IActionInput[] = []\n    ): Promise<IActionInput[]> {\n        const unique: IActionInput[] =\n            refreshingInputs && refreshingInputs.length > 0\n                ? this._removeDuplicates(refreshingInputs)\n                : this._removeDuplicates(this.inputs);\n        if (!unique.length) {\n            return [];\n        }\n        const isRefreshingAction = refreshingInputs && refreshingInputs.length > 0;\n\n        // execute readOnly pre hook with\n        const actionId = this._getActionIdFromInputs(unique);\n        this._runPreReadHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n\n        // execte preReaderHook\n        this._runPreReaderHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n        const [uncached, needsRefresh]: IActionInput[][] = this._checkForCachedData(\n            unique,\n            context,\n            requestCache,\n            appCache,\n            bypassAppCache,\n            isRefreshingAction\n        );\n\n        if (!uncached.length) {\n            // excute readOnly post hook with all cached actions ouptput\n            await this._fetchOutputsAndRunPostReadHook(actionId, unique, requestCache, context);\n            return needsRefresh;\n        } else {\n            const cachedActions = unique.filter(value => !uncached.includes(value));\n            if (cachedActions.length) {\n                // fetch the output for all cached data action, and run readOnly hooks. The uncached actions will be excuted later.\n                await this._fetchOutputsAndRunPostReadHook(actionId, cachedActions, requestCache, context);\n            }\n        }\n\n        let outputs: any[] = [];\n\n        // VNext observable promise based flow\n        // Create the AsyncResult and immediately return it\n        if (this.isObservable) {\n            if (this.isBatched) {\n                this._executeBatchedObservableActions(uncached, requestCache, appCache, context, isRefreshingAction);\n            } else {\n                this._executeObservableAction(uncached[0], requestCache, appCache, context, isRefreshingAction);\n            }\n            return needsRefresh;\n        }\n\n        if (this.isBatched) {\n            // TODO: Have a max batch count on the action\n            outputs = await this._actionWrapper(uncached, context, isRefreshingAction);\n\n            if (outputs && outputs.length !== uncached.length) {\n                // TODO Throw\n                context.telemetry.log(\n                    LogLevel.Trace,\n                    'Length of input array {uncached_length} does not meet the output array {outputs_length}',\n                    { values: [uncached.length, outputs.length] }\n                );\n            }\n        } else {\n            outputs[0] = await this._actionWrapper(uncached[0], context, isRefreshingAction);\n        }\n\n        if (!outputs || outputs.length === 0) {\n            return needsRefresh;\n        }\n\n        this._saveResponseToCache(uncached, outputs, context, requestCache, appCache);\n        return needsRefresh;\n    }\n\n    // the retail proxy data actions who do not have return type should not interact with cache.\n    private _checkShouldInteractWithCache(input: IActionInput, typeName: string | undefined): boolean {\n        return !(input instanceof DataServiceRequest) || !!typeName;\n    }\n\n    private async _fetchOutputsAndRunPostReadHook(\n        actionId: string,\n        inputs: IActionInput[],\n        requestCache: ICache,\n        context: IActionContext\n    ): Promise<void> {\n        const outputs = inputs.map(i => {\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail data action does not have return type, we do not read the output from cache.\n            let cacheItem;\n            if (this._checkShouldInteractWithCache(i, cacheKey.typeName)) {\n                cacheItem = requestCache.get<ICacheItem<unknown>>(cacheKey);\n            }\n            return !!cacheItem ? requestCache.getValue(cacheKey) : null;\n        });\n        this._runPostReadHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n        this._runPostReaderHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n    }\n    private _removeDuplicates(inputs: IActionInput[]): IActionInput[] {\n        if (!this.isBatched) {\n            return inputs;\n        }\n\n        return uniqWith(\n            inputs,\n            (inputA: IActionInput, inputB: IActionInput) =>\n                inputA.getCacheKey() === inputB.getCacheKey() && inputA.getCacheObjectType() === inputB.getCacheObjectType()\n        );\n    }\n\n    private _getActionIdFromInputs(inputs: IActionInput | IActionInput[]): string {\n        let inputsActionId;\n        for (const input of Array.isArray(inputs) ? inputs : [inputs]) {\n            if (typeof input.getActionId === 'function') {\n                inputsActionId = input.getActionId();\n            }\n        }\n        return inputsActionId || (<IAnyAction<unknown>>this.action).prototype.id;\n    }\n\n    private _getActionFromId(actionId?: string): Function {\n        let { action } = this;\n        if (actionId) {\n            const registration = ActionRegistrar.resolveRegistration(actionId, <IAnyAction<unknown>>action);\n            if (registration) {\n                action = <IAnyAction<unknown>>registration.action;\n                return ActionRegistrar.unwrapAction(<IAnyAction<unknown>>action);\n            }\n        }\n        return action;\n    }\n\n    private async _runPreReadHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReadHooks = ActionRegistrar.getPreReadHooks(id);\n        if (!preReadHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReadHooksArray = Array.from(preReadHooks);\n        return preReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                              Promise.resolve());\n    }\n\n    private async _runPostReaderHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postReaderHooks = ActionRegistrar.getPostReaderHooks(id);\n        if (!postReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReaderHooksArray = Array.from(postReaderHooks);\n        return postReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                 Promise.resolve());\n    }\n\n    private async _runPreReaderHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReaderHooks = ActionRegistrar.getPreReaderHooks(id);\n        if (!preReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReaderHooksArray = Array.from(preReaderHooks);\n        return preReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                Promise.resolve());\n    }\n\n    private async _runPreHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        context: IActionContext\n    ): Promise<IActionInput | IActionInput[] | void> {\n        const preHooks = ActionRegistrar.getPreHooks(id);\n        if (!preHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preHooksArray = Array.from(preHooks);\n        return preHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevInput = await previousTask;\n            let tmpNextInput: unknown;\n            try {\n                tmpNextInput = await Promise.race([timer, currentTask(prevInput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextInput: IActionInput | IActionInput[];\n            finalNextInput =\n                tmpNextInput === ActionErrorStatus.HookTimeout || !tmpNextInput ? prevInput : <IActionInput | IActionInput[]>tmpNextInput;\n            return Promise.resolve(finalNextInput);\n        },                          Promise.resolve(inputs));\n    }\n\n    private async _runPostReadHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostReadHooks(id);\n        if (!postHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReadHooksArray = Array.from(postHooks);\n        return postReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                               Promise.resolve());\n    }\n\n    private async _runPostHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostHooks(id);\n        if (!postHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postHooksArray = Array.from(postHooks);\n        return postHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevOutput = await previousTask;\n            let tmpNextOutput: unknown;\n            try {\n                tmpNextOutput = await Promise.race([timer, currentTask(inputs, prevOutput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextOutput;\n            finalNextOutput = tmpNextOutput === ActionErrorStatus.HookTimeout || !tmpNextOutput ? prevOutput : tmpNextOutput;\n            return Promise.resolve(finalNextOutput);\n        },                           Promise.resolve(actionResult));\n    }\n\n    /**\n     * Add performance logging before and after calling the action?\n     */\n    // tslint:disable-next-line: cyclomatic-complexity\n    private async _actionWrapper(inputs: IActionInput | IActionInput[], context: IActionContext, isRefreshing?: boolean): Promise<any> {\n        // tslint:disable-next-line: max-func-body-length\n        const actionId = this._getActionIdFromInputs(inputs);\n        const action = this._getActionFromId(actionId);\n\n        try {\n            // Run pre data action hooks\n            const _inputs = await this._runPreHooks(actionId, inputs, context);\n            if (_inputs) {\n                inputs = _inputs;\n            }\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing pre-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            return new ActionError(e);\n        }\n        let actionResult;\n        try {\n            const timeOut = Number(_get(context, 'requestContext.query.actionTimeout'));\n            const features = _get(context, 'requestContext.features', {});\n            const customerTimout = msdyn365Commerce.platformSettings && msdyn365Commerce.platformSettings.dataActionTimeoutInMs;\n            let promises;\n            if ((process.env.CURRENT_ENVIRONMENT === 'node' && features.action_timeout) || customerTimout) {\n                const timeOutValue = (features.action_timeout ? timeOut : customerTimout) || defaultTimeoutInMS;\n                promises = [this.isObservable ? ObservableActionTimer(timeOutValue) : ActionTimer(timeOutValue), action(inputs, context)];\n            } else {\n                promises = [action(inputs, context)];\n            }\n            // run the data action\n            actionResult = await Promise.race(promises);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            let error = new ActionError(e);\n            // For AsyncResult, we need to signal that this was a rejection by throwing\n            if (this.isObservable) {\n                // Proxy Errors come wrapped as an array\n                if (Array.isArray(e)) {\n                    error =\n                        e[0]._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : ProxyError.toError(<ProxyError>e[0]);\n                } else {\n                    error =\n                        e._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : new ActionError(e);\n                }\n            }\n\n            throw error;\n        }\n\n        try {\n            // Run post data action hooks\n            const result = await this._runPostHooks(actionId, inputs, actionResult, context);\n            if (result) {\n                actionResult = result;\n            }\n            this._runPostReadHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n            this._runPostReaderHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing post-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n        }\n        return actionResult;\n    }\n\n    private _saveResponseToCache(\n        uncached: IActionInput[],\n        outputs: any[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null\n    ): void {\n        const { log } = context.telemetry;\n        uncached.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            // @ts-ignore\n            if (i instanceof DataServiceRequest && !!i.getCacheObjectType()) {\n                try {\n                    // @ts-ignore\n                    saveCacheEntries(i, outputs[idx], requestCache, appCache, shouldWriteToAppCache(i, appCache));\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, 'Error execution action \\'{actionName}\\', returning null', {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    return null;\n                }\n            } else {\n                const entityId = i.getCacheKey();\n                const entityType = i.getCacheObjectType();\n\n                if (!!entityId && !!entityType) {\n                    const entry = outputs[idx];\n                    const cacheKey = { typeName: entityType, key: entityId };\n                    if (ActionError.isActionError(entry)) {\n                        if (!ActionError.isTimeoutError(entry)) {\n                            requestCache.put(cacheKey, { item: (<ActionError>(<unknown>entry)).error, error: true });\n                        }\n                        // else do nothing\n                    } else {\n                        if (appCache && shouldWriteToAppCache(i, appCache)) {\n                            appCache.put(cacheKey, { item: entry });\n                        }\n                        const cacheEntry = { item: entry };\n                        if (i.dataCacheType && i.dataCacheType() === 'instance') {\n                            Object.assign(cacheEntry, { instance: 'instance' });\n                        }\n                        requestCache.put(cacheKey, cacheEntry);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Method that executes a set of batchable observable data actions\n     * @param uncached The uncached action inputs\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeBatchedObservableActions(\n        uncached: IActionInput[],\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const unresolvedSet = new Set();\n        const uncachedInputs: IActionInput[] = [];\n        // Create an OP for each input in the batch that does not yet exist in cache\n        const asyncOutputs = uncached\n            .map((input, index) => {\n                unresolvedSet.add(index);\n                const executor = (resolve: any, reject: any) => {\n                    // When the side promise completes, update each individual OP to have it's piece of the entire batched result\n                    new Promise((innerResolve, innerReject) => {\n                        const onEventIdCompletion = (value: any) => {\n                            innerResolve(<{}>value);\n                        };\n\n                        const onEventIdFinalCompletion = () => {\n                            innerResolve();\n                        };\n\n                        const onEventIdFailure = (error: any) => {\n                            innerReject(error);\n                        };\n\n                        // Standard success event\n                        EventHelper.on(`${this.eventId}-complete-${index}-${input.getCacheKey()}`, onEventIdCompletion);\n\n                        // No response closing event\n                        EventHelper.on(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`, onEventIdFinalCompletion);\n\n                        // Failure event\n                        EventHelper.on(`${this.eventId}-failure`, onEventIdFailure);\n                    })\n                        .then(result => {\n                            EventHelper.removeAllListeners(`${this.eventId}-complete-${index}-${input.getCacheKey()}`);\n                            EventHelper.removeAllListeners(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`);\n                            resolve(result);\n                        })\n                        .catch(error => {\n                            EventHelper.removeAllListeners(`${this.eventId}-failure`);\n                            reject(error);\n                        });\n                };\n\n                // Already cached OP logic (rerun)\n                // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n                let cachedPromise;\n                if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n                    cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n                }\n                if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n                    (<AsyncResult<unknown>>cachedPromise).run(executor);\n                    return;\n                }\n\n                // Not yet cached OP logic (initialize, run)\n                uncachedInputs.push(input);\n                return new AsyncResult(executor);\n            })\n            .filter(Boolean);\n\n        // Save never before cached OPs to cache\n        this._saveResponseToCache(uncachedInputs, asyncOutputs, context, requestCache, appCache);\n\n        // Run the actual action\n        // tslint:disable-next-line: no-floating-promises\n        this._actionWrapper(uncached, context, isRefreshing)\n            .then((actionResults: unknown[]) => {\n                // Emit events with the associated result so that each individual OP in the cache\n                // can be updated appropriately\n                actionResults.forEach((actionResult, index) => {\n                    unresolvedSet.delete(index);\n                    EventHelper.emit(`${this.eventId}-complete-${index}-${uncached[index].getCacheKey()}`, actionResult);\n                });\n            })\n            .catch(error => {\n                EventHelper.emit(`${this.eventId}-failure`, error);\n            })\n            .finally(() => {\n                // In the event some inputs do not have results, we need to resolve the promises anyhow\n                unresolvedSet.forEach(unresolvedIndex => {\n                    const index = <number>unresolvedIndex;\n                    EventHelper.emit(`${this.eventId}-final-complete-${index}-${uncached[index].getCacheKey()}`);\n                });\n            });\n    }\n\n    /**\n     * Executes a standard (non-batched) observable data action\n     * @param input The action input\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeObservableAction(\n        input: IActionInput,\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const cacheKey = { key: input.getCacheKey(), typeName: input.getCacheObjectType() };\n        const executor = (resolve: any, reject: any) => {\n            this._actionWrapper(input, context, isRefreshing)\n                .then(result => {\n                    resolve(result);\n                })\n                .catch(error => {\n                    // If error is timeout error, lookup app-cache if there\n                    // is a valid entity for the given cacheKey in app-cache\n                    if (ActionError.isServiceUnavailable(error) && isAppCacheData(input, appCache)) {\n                        const cachedItem = appCache?.getValue(cacheKey);\n                        if (cachedItem) {\n                            return resolve(cachedItem);\n                        }\n                    }\n                    return reject(error);\n                });\n        };\n        // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n        let cachedPromise;\n        if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n            cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n        }\n        // If OP is already in cache, just rerun it\n        if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n            (<AsyncResult<unknown>>cachedPromise).run(executor);\n            return;\n        }\n\n        // Uncached promises need to be saved to cache\n        const asyncOutput = new AsyncResult(executor);\n        this._saveResponseToCache([input], [asyncOutput], context, requestCache, appCache);\n    }\n\n    private _checkForCachedData(\n        inputs: IActionInput[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshing?: boolean\n    ): IActionInput[][] {\n        const mock = _get(context, 'requestContext.query.actionMock');\n        const { log } = context.telemetry;\n\n        if (mock) {\n            inputs = this._interceptCacheForMocks(inputs, context, requestCache);\n        }\n\n        // if the cache type is set a none don't check cache for data and return inputs for execution\n        // lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side\n        if (this.cacheType === 'none' || refreshing) {\n            return [inputs, []];\n        }\n\n        const uncached: IActionInput[] = [];\n        const refresh: IActionInput[] = [];\n        /* tslint:disable */\n        inputs.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail proxy action does not have return type, we do not check if its in the cache\n            if (i instanceof DataServiceRequest && !cacheKey.typeName) {\n                uncached.push(i);\n                return;\n            }\n            let cacheItem: ICacheItem<any> | undefined = requestCache.get(cacheKey);\n            if (cacheItem && isAsyncResult(<object>cacheItem.item) && (<AsyncResult<unknown>>cacheItem.item).status === 'FAILED') {\n                uncached.push(i);\n            } else if (cacheItem && cacheItem.item && cacheItem.item.status === 'LOADING' && cacheItem.item.runOn === 'client') {\n                // Ideally, an action configured to runOn client should never interfere with actions running on server.\n                // However, it is possible that parent action with runon 'server' could be dependent on an action that is configured\n                // by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets\n                // include such actions in the uncached list so that it gets picked and executed later.\n                uncached.push(i);\n                // @ts-ignore\n            } else if (i instanceof DataServiceRequest) {\n                try {\n                    const cacheEntries = readCacheEntries(\n                        i,\n                        requestCache,\n                        // @ts-ignore\n                        appCache,\n                        !!!bypassAppCache && shouldReadFromAppCache(i, appCache)\n                    );\n                    if (!cacheEntries.entry) {\n                        uncached.push(i);\n                    }\n                    if (cacheEntries && cacheEntries.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, \"Error execution action '{actionName}', returning null\", {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    uncached.push(i);\n                }\n            } else {\n                if (!cacheItem && !!!bypassAppCache && appCache && shouldReadFromAppCache(i, appCache)) {\n                    cacheItem = appCache.copyTo(cacheKey, requestCache);\n                    if (cacheItem && cacheItem.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                }\n\n                if (!cacheItem || !cacheItem.item) {\n                    uncached.push(i);\n                    return;\n                }\n            }\n        });\n        return [uncached, refresh];\n    }\n\n    /**\n     * Searches cache for mocks matching the inputs\n     * @param inputs Current action inputs\n     * @param context Current action context\n     * @param requestCache Current request cache\n     */\n    private _interceptCacheForMocks(inputs: IActionInput[], context: IActionContext, requestCache: ICache): IActionInput[] {\n        const uncached: IActionInput[] = [];\n        const actionId: string = this.action.prototype.id;\n        inputs.forEach(i => {\n            let mockItem = this._getMockItem(i.getCacheObjectType(), i.getCacheKey(), requestCache);\n            if (!mockItem && actionId) {\n                mockItem = this._getMockItem(actionId, i.getCacheKey(), requestCache);\n            }\n            let existingItem;\n            if (this._checkShouldInteractWithCache(i, i.getCacheObjectType())) {\n                existingItem = requestCache.get({ typeName: i.getCacheObjectType(), key: i.getCacheKey() });\n            }\n\n            if (!!mockItem && !!mockItem.item && !existingItem) {\n                if (this.isObservable) {\n                    requestCache.put(\n                        { typeName: i.getCacheObjectType(), key: i.getCacheKey() },\n                        { item: AsyncResult.resolve(toJS(mockItem.item)) }\n                    );\n                } else {\n                    requestCache.put({ typeName: i.getCacheObjectType(), key: i.getCacheKey() }, { item: toJS(mockItem.item) });\n                }\n            } else {\n                uncached.push(i);\n            }\n        });\n        return uncached;\n    }\n\n    private _getMockItem(cacheNamespace: string, cacheKey: string, requestCache: ICache): ICacheItem<unknown> | undefined {\n        return (\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:${cacheKey}` }) ||\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:*` })\n        );\n    }\n\n    private _convertToJSError(e: any): Error {\n        // Proxy Error usually comes wrapped in an array\n        // If it is, unbox it and conver to regular Error\n        if (Array.isArray(e)) {\n            const proxyError: ProxyError = e[0];\n            if (proxyError.ErrorCode) {\n                return ProxyError.toError(proxyError);\n            }\n        } else if (e.ErrorCode) {\n            return ProxyError.toError(e);\n        }\n        // Return regular Error if not ProxyError\n        return new Error(e.message || '');\n    }\n}\n"]}
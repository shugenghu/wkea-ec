/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable: no-any
import { ICacheSource, RequestCache } from '@msdyn365-commerce/cache-internal';
import { msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { GenericConsoleLogger, LogLevel, StaticTelemetry, Telemetry } from '@msdyn365-commerce/telemetry-internal';
import uuidv1 from 'uuid/v1';
import ActionExecutor from './action-executor';
import { ActionRegistrar } from './action-registrar';
import { shouldWriteToAppCache } from './action-runtime-utils';
import { addLocaleInformation, readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';
import EventHelper from './event-emitter';
/**
 * This class contains the primary logic which controls the execution flow of the action runtime
 *
 */
/*@internal*/
export class ActionContext {
    /**
     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7
     * @param expectedActionCount: This value specifies the expected number of actions to be queued before
     *                             we kick off execution in the current tier
     */
    constructor(args) {
        this.executionParams = [];
        this.appCache = null;
        this.cacheKeyMap = [];
        /**
         * Whether the current context as executed
         */
        this.hasRun = false;
        /**
         * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count
         */
        this.currentActionsInQueue = 0;
        /**
         * Object to track the next tier number.
         */
        this.nextTierCounter = { next: 0 };
        /**
         * When true will span a new independent action context when an action is executed resetting depth limits
         * Otherwise will invoke the action in the current context.
         */
        this.spawnChildOnExecute = false;
        /**
         * Helper method to log trace using telemetry
         * @param message message to log to console
         */
        this.trace = (message) => {
            this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\tID: {threadId}\tMessage: {message}', {
                values: [this.currentExecutionTier, this.threadId, message]
            });
        };
        /**
         * Helper method to log error using telemetry
         * @param message message to log to console
         */
        this.error = (message) => {
            this.telemetry.log(LogLevel.Error, 'Depth: {currentExecutionTier}\tID: {threadId}\tMessage: {message}', {
                values: [this.currentExecutionTier, this.threadId, message]
            });
        };
        /**
         * Helper method to log debug using telemetry
         * @param message message to log to console
         */
        this.debug = (message) => {
            this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\tID: {threadId}\tMessage: {message}', {
                values: [this.currentExecutionTier, this.threadId, message]
            });
        };
        /**
         * Returns true if current tier has exceeded max depth
         */
        this.isMaxDepthExceeded = () => {
            const maxDepth = (this.requestContext && this.requestContext.app && this.requestContext.app.maxDepth) || ActionContext.maxDepth;
            return this.nextTierCounter.next > maxDepth;
        };
        /**
         * Retrieves item from request cache and fallsback to app cache if not found
         */
        this.getItemFromCache = (cacheKey) => {
            let cachedItem = this.requestCache.get(cacheKey);
            if (cachedItem) {
                return cachedItem.item;
            }
            if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {
                cachedItem = this.appCache.get(cacheKey);
            }
            return cachedItem ? cachedItem.item : undefined;
        };
        /**
         * Signals the end of current tier so actions can return the response
         */
        this._endCurrentTier = () => {
            this.hasRun = true;
            EventHelper.emit(`${this.eventId}:completed`, this.currentExecutionTier);
        };
        const { id, requestContext, requestCache, appCache, currentExecutionTier, expectedActionCount, spawnChildOnExecute, telemetry } = args;
        this.threadId = id;
        this.eventId = uuidv1();
        this.currentExecutionTier = currentExecutionTier || 0;
        if (this.currentExecutionTier === 0) {
            this.nextTierCounter = { next: 0 };
        }
        this.expectedActionsInCurrentTier = expectedActionCount || 0;
        this.requestCache = requestCache;
        this.requestContext = requestContext || {};
        this.spawnChildOnExecute = Boolean(spawnChildOnExecute);
        // If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object
        if (telemetry) {
            this.telemetry = telemetry;
        }
        else {
            // register default console logger
            const moduleTelemetry = new Telemetry();
            const isDebug = requestContext.params && requestContext.params.isDebug;
            // register tracelogger only in development environment or debug is true.
            (process.env.NODE_ENV === 'development' || isDebug) &&
                moduleTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: isDebug } });
            this.telemetry = moduleTelemetry;
        }
        /**
         * @deprecated
         * Trace is an alias for telemetry.log(LogLevel.Trace, message)
         * Use the telemetry object directly.
         */
        this.trace = (message) => {
            this.telemetry.log(LogLevel.Debug, message);
        };
        // enable app cache only if the disable_app_cache feature switch is false
        if (requestContext.features && !!!requestContext.features.disable_app_cache) {
            this.appCache = appCache;
        }
    }
    /**
     * Chains an action method to the current context for execution
     * @param action - action method
     * @param inputs - action input
     */
    // tslint:disable-next-line:max-func-body-length
    chainAction(_action, inputs, actionOption) {
        const action = ActionRegistrar.unwrapAction(_action);
        addLocaleInformation(inputs, this.requestContext.locale);
        if (!action || !inputs) {
            // Decrement the expected actions on this tier since this action was incorrectly configured
            this.expectedActionsInCurrentTier--;
            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {
                return Promise.resolve(null);
            }
            if (!this.hasRun) {
                return this.runAllActionsInQueue().then(() => null);
            }
            return Promise.resolve(null);
        }
        if (this.isMaxDepthExceeded()) {
            this.debug('Max depth exceeded - not running further.');
            return Promise.resolve(null);
        }
        if (this.hasRun) {
            // If the parent action decides to queue another action after the current tier completes execution
            // then set the hasRun to false, so the action can fire right away
            this.hasRun = false;
            this.executionParams.length = 0;
            this.currentActionsInQueue = 0;
        }
        this.currentActionsInQueue++;
        const isBatched = action.prototype.isBatched;
        const inputsArray = (isBatched ? inputs : [inputs]);
        let current = this.executionParams.find(a => a.action === action);
        if (current && isBatched) {
            current.addInputs(inputsArray);
        }
        else {
            const inputIdentifier = `${inputsArray[0].getCacheObjectType()}||${inputsArray[0].getCacheKey()}`;
            if (!this.cacheKeyMap.find(key => key === inputIdentifier)) {
                current = new ActionExecutor(action, inputsArray, this.telemetry, actionOption);
                this.executionParams.push(current);
                this.cacheKeyMap.push(inputIdentifier);
            }
        }
        // @ts-ignore
        // tslint:disable-next-line: max-func-body-length
        const asyncResult = new AsyncResult(async (resolve, reject) => {
            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {
                // Hold the thread until the entire tier is populated
                await new Promise((innerResolve) => {
                    const onEventIdCompletion = (tierNum) => {
                        if (tierNum === this.currentExecutionTier) {
                            innerResolve();
                        }
                    };
                    EventHelper.on(`${this.eventId}:completed`, onEventIdCompletion);
                });
                EventHelper.removeAllListeners(`${this.eventId}:completed`);
            }
            if (!this.hasRun) {
                await this.runAllActionsInQueue();
            }
            const outputs = inputsArray.map(i => {
                if (i instanceof DataServiceRequest) {
                    try {
                        // @ts-ignore
                        const entry = readCacheEntries(i, this.requestCache, this.appCache, false, StaticTelemetry);
                        return entry.entry;
                    }
                    catch (e) {
                        this.debug(`Error execution action type '[${i && i.getCacheObjectType()}' and cache key '[{${i &&
                            i.getCacheKey()}}]', returning null`);
                        return null;
                    }
                }
                else {
                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };
                    const cacheItem = this.requestCache.get(cacheKey);
                    const cacheValue = !!cacheItem ? this.requestCache.getValue(cacheKey) : null;
                    if (cacheItem && !!cacheItem.error) {
                        throw cacheValue;
                    }
                    else {
                        if (cacheItem && !msdyn365Commerce.isBrowser) {
                            switch (cacheItem.s) {
                                case ICacheSource.AppCache: {
                                    StaticTelemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                                        // @ts-ignore
                                        values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'AppCache']
                                    });
                                    break;
                                }
                                case ICacheSource.RequestCache: {
                                    StaticTelemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                                        // @ts-ignore
                                        values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'RequestCache']
                                    });
                                    break;
                                }
                                default: {
                                    StaticTelemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {
                                        // @ts-ignore
                                        values: [i.getCacheObjectType() || 'none', i.getCacheKey, 'Undefined']
                                    });
                                }
                            }
                        }
                        return cacheValue;
                    }
                }
            });
            this.cacheKeyMap.splice(0, this.cacheKeyMap.length);
            // Batched observable actions need to be merged into a single AsyncResult
            if (isBatched && action.prototype.isObservable) {
                resolve(Promise.all(outputs).then(results => {
                    // Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped
                    return results.map(result => {
                        return result && result._type === 'AsyncResult' ? result.result : result;
                    });
                }));
            }
            else {
                // We need to pass along the metadata explicitly to the outer AsyncResult
                if (isAsyncResult(outputs[0]) && !isBatched) {
                    outputs[0].then(() => {
                        asyncResult.metadata = outputs[0].metadata;
                    });
                }
                resolve(isBatched ? outputs : (outputs.length && outputs[0]) || null);
            }
        });
        return asyncResult;
    }
    /**
     * Helper method to update cache
     * @param input The input
     * @param data The data
     */
    update(inputs, data) {
        if (inputs && data) {
            // If an array of actionInputs has been passed, an equal amount of data items must be present
            const dataArray = (Array.isArray(inputs) ? data : [data]);
            const inputArray = Array.isArray(inputs) ? inputs : [inputs];
            if (inputArray.length !== dataArray.length) {
                throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');
            }
            addLocaleInformation(inputArray, this.requestContext.locale);
            inputArray.map((i, idx) => {
                if (i instanceof DataServiceRequest) {
                    try {
                        // @ts-ignore
                        saveCacheEntries(i, dataArray[idx], this.requestCache, this.appCache, shouldWriteToAppCache(i, this.appCache));
                    }
                    catch (e) {
                        this.debug(`Error in updating cache with input '[${i.getCacheObjectType()}]' - '[${i.getCacheKey()}]', returning null`);
                        this.error(e);
                    }
                }
                else {
                    // When updating OPs, only result can be updated, passed OPs will also be unwrapped.
                    if (isAsyncResult(dataArray[idx])) {
                        dataArray[idx] = dataArray[idx].result;
                    }
                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };
                    this.requestCache.put(cacheKey, { item: dataArray[idx] });
                    if (this.appCache && shouldWriteToAppCache(i, this.appCache)) {
                        this.appCache.put(cacheKey, { item: dataArray[idx] });
                    }
                }
            });
            if (Array.isArray(inputs)) {
                return inputs.map(input => {
                    return this.requestCache.getValue({ typeName: input.getCacheObjectType(), key: input.getCacheKey() });
                });
            }
            else {
                return this.requestCache.getValue({ typeName: inputs.getCacheObjectType(), key: inputs.getCacheKey() });
            }
        }
        // For scenarios where data/input was bad, we just return original data
        return data;
    }
    /**
     * Helper method to data cache from cache
     * if cachekey is null or empty, it returns all entries of cacheObjectType
     * @param cacheObjectType entity type that was cached
     * @param cacheKey cache key against which the object is cached
     * @throws if cacheObjecttype is null or empty
     */
    get(cacheObjectType, cacheKey) {
        if (!cacheObjectType) {
            throw new Error('Cannot have null or empty cacheObjectType');
        }
        if (!cacheKey) {
            throw new Error('Cannot have null or empty cacheKey');
        }
        const preparedCacheKey = { typeName: cacheObjectType, key: cacheKey };
        let cachedItem = this.requestCache.get(preparedCacheKey);
        if (process.env.CURRENT_ENVIRONMENT === 'node' && !cachedItem && this.appCache) {
            cachedItem = this.appCache.get(preparedCacheKey);
        }
        if (!cachedItem) {
            return null;
        }
        if (typeof cachedItem.item !== 'object' || cachedItem.item.$ref !== true) {
            return cachedItem.item;
        }
        return Array.isArray(cachedItem.item.key) ? cachedItem.item.key
            .map(key => this.getItemFromCache({ typeName: cacheObjectType, key }))
            .filter(Boolean) : null;
    }
    /**
     * Helper method to data cache from cache
     * if cachekey is null or empty, it returns all entries of cacheObjectType
     * @param input The input
     * @param data The data
     * @throws if cacheObjecttype is null or empty
     */
    getAll(cacheObjectType) {
        if (!cacheObjectType) {
            throw new Error('Cannot have null or empty cacheObjectType');
        }
        let cachedEntries = this.requestCache.getAllItems(cacheObjectType);
        if (!cachedEntries) {
            if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {
                cachedEntries = this.appCache && this.appCache.getAllItems(cacheObjectType);
            }
            if (!cachedEntries) {
                return null;
            }
        }
        return Object.keys(cachedEntries)
            .filter(key => typeof cachedEntries[key].item !== 'object' || cachedEntries[key].item.$ref !== true)
            .map(key => cachedEntries[key].item);
    }
    /**
     * Executes all the actions in the current context in parallel
     */
    // tslint:disable max-func-body-length
    async runAllActionsInQueue() {
        const { threadId, requestContext, requestCache, appCache, nextTierCounter, executionParams } = this;
        if (!executionParams.length) {
            this.trace('No actions to execute - not running further.');
            return;
        }
        // Increment the tier each pass through run all actions
        if (this.isMaxDepthExceeded()) {
            this.trace('Max depth exceeded - not running further.');
            return;
        }
        // When kicking off the next tier,
        // set the max number of chain actions the can be expected from child actions
        // equal to the number of actions that are executing in current tier
        const expectedNumberOfChildThreads = executionParams.length;
        let nextTierStartingDepth;
        if (this.spawnChildOnExecute) {
            nextTierStartingDepth = nextTierCounter.next + 1;
        }
        else {
            nextTierStartingDepth = ++nextTierCounter.next;
        }
        const nextTier = new ActionContext({
            id: threadId,
            requestContext: requestContext,
            requestCache: requestCache,
            appCache: appCache,
            currentExecutionTier: nextTierStartingDepth,
            expectedActionCount: expectedNumberOfChildThreads,
            telemetry: this.telemetry
        });
        const refreshContext = new ActionContext({
            id: 'Refresh Context',
            requestContext: requestContext,
            requestCache: new RequestCache(),
            telemetry: this.telemetry,
            appCache: appCache,
            spawnChildOnExecute: true
        });
        const refreshconfigslocal = new Set();
        nextTier.nextTierCounter = { next: nextTierStartingDepth };
        // DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions
        const promises = executionParams.map(param => {
            // TODO: should we read from input about the cacheability?
            return param
                .execute(nextTier, requestCache, appCache, this.requestContext.query && !!this.requestContext.query.cachebypass, [])
                .then(refreshActions => {
                // refresh the data actions which need to be refreshed.
                if (refreshActions.length) {
                    refreshconfigslocal.add({
                        paramExecutor: param,
                        actionInputs: refreshActions,
                        refreshContext: refreshContext
                    });
                }
                // If the current chain action completes execution
                // decrement the max number of threads that we expect
                // from the next tier
                nextTier.expectedActionsInCurrentTier--;
                if (!nextTier.hasRun) {
                    // First check if the next tier has any actions
                    // then check if the number of thread match expected
                    if (nextTier.currentActionsInQueue > 0 &&
                        nextTier.currentActionsInQueue === nextTier.expectedActionsInCurrentTier) {
                        return nextTier.runAllActionsInQueue();
                    }
                }
            });
        });
        // Wait until all the actions in current tier are run to completion
        return Promise.all(promises)
            .then(() => {
            if (refreshconfigslocal.size > 0 && requestContext.features && !!!requestContext.features.disable_appcache_refresh) {
                refreshconfigslocal.forEach(rf => {
                    const refreshRequestCache = new RequestCache();
                    rf.paramExecutor
                        .execute(rf.refreshContext, refreshRequestCache, this.appCache, this.requestContext.query && !!this.requestContext.query.cachebypass, rf.actionInputs)
                        .then(() => StaticTelemetry.log(LogLevel.Information, `BackgroundRefresh - Executed refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`))
                        .catch(error => {
                        StaticTelemetry.log(LogLevel.Warning, `BackgroundRefresh - Error execution refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`);
                    });
                });
            }
            this._endCurrentTier();
        })
            .catch(error => {
            this._endCurrentTier();
            throw error;
        });
    }
}
ActionContext.maxDepth = 200;
//# sourceMappingURL=action-context.js.map
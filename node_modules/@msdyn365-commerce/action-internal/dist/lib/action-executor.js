/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { AsyncResult, DataServiceRequest, ErrorTypeEnum, isAsyncResult, ProxyError } from '@msdyn365-commerce/retail-proxy';
import { LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { get as _get, uniqWith } from 'lodash';
import { toJS } from 'mobx';
import uuidv1 from 'uuid/v1';
import { ActionError } from './action-error';
import { ActionRegistrar } from './action-registrar';
import { isAppCacheData, shouldReadFromAppCache, shouldWriteToAppCache } from './action-runtime-utils';
import { readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';
import EventHelper from './event-emitter';
const defaultTimeoutInMS = 4000;
const defaultHookTimeoutInMS = 1000;
const Timer = (timeoutInMS, message) => new Promise(resolve => setTimeout(resolve.bind(resolve, message), timeoutInMS));
const ActionTimer = (timeoutInMS) => new Promise((_resolve, reject) => setTimeout(reject.bind(reject, "Timeout" /* Timeout */), timeoutInMS));
const ObservableActionTimer = (timeoutInMS) => new AsyncResult((_resolve, reject) => setTimeout(reject.bind(reject, "Timeout" /* Timeout */), timeoutInMS));
/**
 * This class contains the logic to batch and de-dupe the actions that can be executed.
 * This class is also responsible for checking and saving the action response to cache.
 */
/* @internal */
export default class ActionExecutor {
    /**
     * @param action the action to execute
     * @param inputs the action input
     */
    constructor(action, inputs, telemetry, dataActionOption) {
        this.action = action;
        this.eventId = uuidv1();
        this.inputs = [...inputs]; // Cloning it DO NOT use the reference
        this.isBatched = action.prototype.isBatched;
        this.isObservable = action.prototype.isObservable;
        // Cache all the calls on browser
        const masterInput = inputs[0];
        if (masterInput && masterInput.dataCacheType) {
            this.cacheType = masterInput.dataCacheType();
        }
        else if (masterInput && masterInput.shouldCacheOutput) {
            this.cacheType = masterInput.shouldCacheOutput() ? 'request' : 'none';
            telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');
        }
        else {
            this.cacheType = (dataActionOption && dataActionOption.cacheType) || 'none';
            // for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.
            // this is used for later check if the data acton should be read from app cache.
            inputs.forEach(input => {
                input.dataCacheType = () => this.cacheType;
            });
            telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to "none"');
        }
    }
    /**
     *
     * @param inputs add more inputs
     */
    addInputs(inputs) {
        this.inputs.push(...inputs);
    }
    /** Execute the action  */
    // tslint:disable-next-line:max-func-body-length
    async execute(context, requestCache, appCache, bypassAppCache, refreshingInputs = []) {
        const unique = refreshingInputs && refreshingInputs.length > 0
            ? this._removeDuplicates(refreshingInputs)
            : this._removeDuplicates(this.inputs);
        if (!unique.length) {
            return [];
        }
        const isRefreshingAction = refreshingInputs && refreshingInputs.length > 0;
        // execute readOnly pre hook with
        const actionId = this._getActionIdFromInputs(unique);
        this._runPreReadHooks(actionId, unique, context)
            .then(() => null)
            .catch(err => null);
        // execte preReaderHook
        this._runPreReaderHooks(actionId, unique, context)
            .then(() => null)
            .catch(err => null);
        const [uncached, needsRefresh] = this._checkForCachedData(unique, context, requestCache, appCache, bypassAppCache, isRefreshingAction);
        if (!uncached.length) {
            // excute readOnly post hook with all cached actions ouptput
            await this._fetchOutputsAndRunPostReadHook(actionId, unique, requestCache, context);
            return needsRefresh;
        }
        else {
            const cachedActions = unique.filter(value => !uncached.includes(value));
            if (cachedActions.length) {
                // fetch the output for all cached data action, and run readOnly hooks. The uncached actions will be excuted later.
                await this._fetchOutputsAndRunPostReadHook(actionId, cachedActions, requestCache, context);
            }
        }
        let outputs = [];
        // VNext observable promise based flow
        // Create the AsyncResult and immediately return it
        if (this.isObservable) {
            if (this.isBatched) {
                this._executeBatchedObservableActions(uncached, requestCache, appCache, context, isRefreshingAction);
            }
            else {
                this._executeObservableAction(uncached[0], requestCache, appCache, context, isRefreshingAction);
            }
            return needsRefresh;
        }
        if (this.isBatched) {
            // TODO: Have a max batch count on the action
            outputs = await this._actionWrapper(uncached, context, isRefreshingAction);
            if (outputs && outputs.length !== uncached.length) {
                // TODO Throw
                context.telemetry.log(LogLevel.Trace, 'Length of input array {uncached_length} does not meet the output array {outputs_length}', { values: [uncached.length, outputs.length] });
            }
        }
        else {
            outputs[0] = await this._actionWrapper(uncached[0], context, isRefreshingAction);
        }
        if (!outputs || outputs.length === 0) {
            return needsRefresh;
        }
        this._saveResponseToCache(uncached, outputs, context, requestCache, appCache);
        return needsRefresh;
    }
    // the retail proxy data actions who do not have return type should not interact with cache.
    _checkShouldInteractWithCache(input, typeName) {
        return !(input instanceof DataServiceRequest) || !!typeName;
    }
    async _fetchOutputsAndRunPostReadHook(actionId, inputs, requestCache, context) {
        const outputs = inputs.map(i => {
            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };
            // if the retail data action does not have return type, we do not read the output from cache.
            let cacheItem;
            if (this._checkShouldInteractWithCache(i, cacheKey.typeName)) {
                cacheItem = requestCache.get(cacheKey);
            }
            return !!cacheItem ? requestCache.getValue(cacheKey) : null;
        });
        this._runPostReadHooks(actionId, inputs, outputs, context)
            .then(() => null)
            .catch(err => null);
        this._runPostReaderHooks(actionId, inputs, outputs, context)
            .then(() => null)
            .catch(err => null);
    }
    _removeDuplicates(inputs) {
        if (!this.isBatched) {
            return inputs;
        }
        return uniqWith(inputs, (inputA, inputB) => inputA.getCacheKey() === inputB.getCacheKey() && inputA.getCacheObjectType() === inputB.getCacheObjectType());
    }
    _getActionIdFromInputs(inputs) {
        let inputsActionId;
        for (const input of Array.isArray(inputs) ? inputs : [inputs]) {
            if (typeof input.getActionId === 'function') {
                inputsActionId = input.getActionId();
            }
        }
        return inputsActionId || this.action.prototype.id;
    }
    _getActionFromId(actionId) {
        let { action } = this;
        if (actionId) {
            const registration = ActionRegistrar.resolveRegistration(actionId, action);
            if (registration) {
                action = registration.action;
                return ActionRegistrar.unwrapAction(action);
            }
        }
        return action;
    }
    async _runPreReadHooks(id, inputs, context) {
        const preReadHooks = ActionRegistrar.getPreReadHooks(id);
        if (!preReadHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const preReadHooksArray = Array.from(preReadHooks);
        return preReadHooksArray.reduce(async (previousTask, currentTask) => {
            await previousTask;
            try {
                await Promise.race([timer, currentTask(inputs, context)]);
            }
            catch (error) {
                context.telemetry.log(LogLevel.Trace, "Error execution hook of action_id '{id}', returning null", {
                    values: [id || 'unnamed'],
                    exception: error
                });
            }
            return Promise.resolve();
        }, Promise.resolve());
    }
    async _runPostReaderHooks(id, inputs, actionResult, context) {
        const postReaderHooks = ActionRegistrar.getPostReaderHooks(id);
        if (!postReaderHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const postReaderHooksArray = Array.from(postReaderHooks);
        return postReaderHooksArray.reduce(async (previousTask, currentTask) => {
            await previousTask;
            try {
                await Promise.race([timer, currentTask(inputs, actionResult, context)]);
            }
            catch (error) {
                context.telemetry.log(LogLevel.Trace, "Error execution hook of action_id '{id}', returning null", {
                    values: [id || 'unnamed'],
                    exception: error
                });
            }
            return Promise.resolve();
        }, Promise.resolve());
    }
    async _runPreReaderHooks(id, inputs, context) {
        const preReaderHooks = ActionRegistrar.getPreReaderHooks(id);
        if (!preReaderHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const preReaderHooksArray = Array.from(preReaderHooks);
        return preReaderHooksArray.reduce(async (previousTask, currentTask) => {
            await previousTask;
            try {
                await Promise.race([timer, currentTask(inputs, context)]);
            }
            catch (error) {
                context.telemetry.log(LogLevel.Trace, "Error execution hook of action_id '{id}', returning null", {
                    values: [id || 'unnamed'],
                    exception: error
                });
            }
            return Promise.resolve();
        }, Promise.resolve());
    }
    async _runPreHooks(id, inputs, context) {
        const preHooks = ActionRegistrar.getPreHooks(id);
        if (!preHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const preHooksArray = Array.from(preHooks);
        return preHooksArray.reduce(async (previousTask, currentTask) => {
            const prevInput = await previousTask;
            let tmpNextInput;
            try {
                tmpNextInput = await Promise.race([timer, currentTask(prevInput, context)]);
            }
            catch (error) {
                throw error;
            }
            let finalNextInput;
            finalNextInput =
                tmpNextInput === "Hook Timeout" /* HookTimeout */ || !tmpNextInput ? prevInput : tmpNextInput;
            return Promise.resolve(finalNextInput);
        }, Promise.resolve(inputs));
    }
    async _runPostReadHooks(id, inputs, actionResult, context) {
        const postHooks = ActionRegistrar.getPostReadHooks(id);
        if (!postHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const postReadHooksArray = Array.from(postHooks);
        return postReadHooksArray.reduce(async (previousTask, currentTask) => {
            await previousTask;
            try {
                await Promise.race([timer, currentTask(inputs, actionResult, context)]);
            }
            catch (error) {
                context.telemetry.log(LogLevel.Trace, "Error execution hook of action_id '{id}', returning null", {
                    values: [id || 'unnamed'],
                    exception: error
                });
            }
            return Promise.resolve();
        }, Promise.resolve());
    }
    async _runPostHooks(id, inputs, actionResult, context) {
        const postHooks = ActionRegistrar.getPostHooks(id);
        if (!postHooks) {
            return;
        }
        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;
        const timer = Timer(hookTimeout, "Hook Timeout" /* HookTimeout */);
        const postHooksArray = Array.from(postHooks);
        return postHooksArray.reduce(async (previousTask, currentTask) => {
            const prevOutput = await previousTask;
            let tmpNextOutput;
            try {
                tmpNextOutput = await Promise.race([timer, currentTask(inputs, prevOutput, context)]);
            }
            catch (error) {
                throw error;
            }
            let finalNextOutput;
            finalNextOutput = tmpNextOutput === "Hook Timeout" /* HookTimeout */ || !tmpNextOutput ? prevOutput : tmpNextOutput;
            return Promise.resolve(finalNextOutput);
        }, Promise.resolve(actionResult));
    }
    /**
     * Add performance logging before and after calling the action?
     */
    // tslint:disable-next-line: cyclomatic-complexity
    async _actionWrapper(inputs, context, isRefreshing) {
        // tslint:disable-next-line: max-func-body-length
        const actionId = this._getActionIdFromInputs(inputs);
        const action = this._getActionFromId(actionId);
        try {
            // Run pre data action hooks
            const _inputs = await this._runPreHooks(actionId, inputs, context);
            if (_inputs) {
                inputs = _inputs;
            }
        }
        catch (e) {
            const convertedError = this._convertToJSError(e);
            StaticTelemetry.log(LogLevel.Error, `Error executing pre-hooks for ${isRefreshing ? 'Refreshing' : ''} action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`, {
                values: [
                    actionId || (action && action.name) || 'unnamed',
                    convertedError.name || convertedError.message,
                    convertedError.data ? convertedError.data.CorrelationId : ''
                ],
                exception: e
            });
            return new ActionError(e);
        }
        let actionResult;
        try {
            const timeOut = Number(_get(context, 'requestContext.query.actionTimeout'));
            const features = _get(context, 'requestContext.features', {});
            const customerTimout = msdyn365Commerce.platformSettings && msdyn365Commerce.platformSettings.dataActionTimeoutInMs;
            let promises;
            if ((process.env.CURRENT_ENVIRONMENT === 'node' && features.action_timeout) || customerTimout) {
                const timeOutValue = (features.action_timeout ? timeOut : customerTimout) || defaultTimeoutInMS;
                promises = [this.isObservable ? ObservableActionTimer(timeOutValue) : ActionTimer(timeOutValue), action(inputs, context)];
            }
            else {
                promises = [action(inputs, context)];
            }
            // run the data action
            actionResult = await Promise.race(promises);
        }
        catch (e) {
            const convertedError = this._convertToJSError(e);
            StaticTelemetry.log(LogLevel.Error, `Error executing ${isRefreshing ? 'Refreshing' : ''} action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`, {
                values: [
                    actionId || (action && action.name) || 'unnamed',
                    convertedError.name || convertedError.message,
                    convertedError.data ? convertedError.data.CorrelationId : ''
                ],
                exception: e
            });
            let error = new ActionError(e);
            // For AsyncResult, we need to signal that this was a rejection by throwing
            if (this.isObservable) {
                // Proxy Errors come wrapped as an array
                if (Array.isArray(e)) {
                    error =
                        e[0]._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE
                            ? new ActionError("Service Unavailable" /* ServiceUnavailable */)
                            : ProxyError.toError(e[0]);
                }
                else {
                    error =
                        e._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE
                            ? new ActionError("Service Unavailable" /* ServiceUnavailable */)
                            : new ActionError(e);
                }
            }
            throw error;
        }
        try {
            // Run post data action hooks
            const result = await this._runPostHooks(actionId, inputs, actionResult, context);
            if (result) {
                actionResult = result;
            }
            this._runPostReadHooks(actionId, inputs, actionResult, context)
                .then(() => null)
                .catch(err => null);
            this._runPostReaderHooks(actionId, inputs, actionResult, context)
                .then(() => null)
                .catch(err => null);
        }
        catch (e) {
            const convertedError = this._convertToJSError(e);
            StaticTelemetry.log(LogLevel.Error, `Error executing post-hooks for ${isRefreshing ? 'Refreshing' : ''} action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`, {
                values: [
                    actionId || (action && action.name) || 'unnamed',
                    convertedError.name || convertedError.message,
                    convertedError.data ? convertedError.data.CorrelationId : ''
                ],
                exception: e
            });
        }
        return actionResult;
    }
    _saveResponseToCache(uncached, outputs, context, requestCache, appCache) {
        const { log } = context.telemetry;
        uncached.forEach((i, idx) => {
            const actionId = this._getActionIdFromInputs(i);
            if (i instanceof DataServiceRequest && !!i.getCacheObjectType()) {
                try {
                    const appCacheData = appCache;
                    saveCacheEntries(i, outputs[idx], requestCache, appCacheData, shouldWriteToAppCache(i, appCache));
                }
                catch (e) {
                    const { action } = this;
                    log(LogLevel.Trace, "Error execution action '{actionName}', returning null", {
                        values: [actionId || (action && action.name) || 'unnamed'],
                        exception: e
                    });
                    return null;
                }
            }
            else {
                const entityId = i.getCacheKey();
                const entityType = i.getCacheObjectType();
                if (!!entityId && !!entityType) {
                    const entry = outputs[idx];
                    const cacheKey = { typeName: entityType, key: entityId };
                    if (ActionError.isActionError(entry)) {
                        if (!ActionError.isTimeoutError(entry)) {
                            requestCache.put(cacheKey, { item: entry.error, error: true });
                        }
                        // else do nothing
                    }
                    else {
                        if (appCache && shouldWriteToAppCache(i, appCache)) {
                            appCache.put(cacheKey, { item: entry });
                        }
                        const cacheEntry = { item: entry };
                        if (i.dataCacheType && i.dataCacheType() === 'instance') {
                            Object.assign(cacheEntry, { instance: 'instance' });
                        }
                        requestCache.put(cacheKey, cacheEntry);
                    }
                }
            }
        });
    }
    /**
     * Method that executes a set of batchable observable data actions
     * @param uncached The uncached action inputs
     * @param requestCache The request cache
     * @param appCache The application cache, if available
     * @param context The action context
     */
    _executeBatchedObservableActions(uncached, requestCache, appCache, context, isRefreshing = false) {
        const unresolvedSet = new Set();
        const uncachedInputs = [];
        // Create an OP for each input in the batch that does not yet exist in cache
        const asyncOutputs = uncached
            .map((input, index) => {
            unresolvedSet.add(index);
            const executor = (resolve, reject) => {
                // When the side promise completes, update each individual OP to have it's piece of the entire batched result
                new Promise((innerResolve, innerReject) => {
                    const onEventIdCompletion = (value) => {
                        innerResolve(value);
                    };
                    const onEventIdFinalCompletion = () => {
                        innerResolve();
                    };
                    const onEventIdFailure = (error) => {
                        innerReject(error);
                    };
                    // Standard success event
                    EventHelper.on(`${this.eventId}-complete-${index}-${input.getCacheKey()}`, onEventIdCompletion);
                    // No response closing event
                    EventHelper.on(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`, onEventIdFinalCompletion);
                    // Failure event
                    EventHelper.on(`${this.eventId}-failure`, onEventIdFailure);
                })
                    .then(result => {
                    EventHelper.removeAllListeners(`${this.eventId}-complete-${index}-${input.getCacheKey()}`);
                    EventHelper.removeAllListeners(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`);
                    resolve(result);
                })
                    .catch(error => {
                    EventHelper.removeAllListeners(`${this.eventId}-failure`);
                    reject(error);
                });
            };
            // Already cached OP logic (rerun)
            // we only try to fetch the saved promise from cache when the retail proxy data action has cached type
            let cachedPromise;
            if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {
                cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });
            }
            if (cachedPromise && isAsyncResult(cachedPromise) && !isRefreshing) {
                cachedPromise.run(executor);
                return;
            }
            // Not yet cached OP logic (initialize, run)
            uncachedInputs.push(input);
            return new AsyncResult(executor);
        })
            .filter(Boolean);
        // Save never before cached OPs to cache
        this._saveResponseToCache(uncachedInputs, asyncOutputs, context, requestCache, appCache);
        // Run the actual action
        // tslint:disable-next-line: no-floating-promises
        this._actionWrapper(uncached, context, isRefreshing)
            .then((actionResults) => {
            // Emit events with the associated result so that each individual OP in the cache
            // can be updated appropriately
            actionResults.forEach((actionResult, index) => {
                unresolvedSet.delete(index);
                EventHelper.emit(`${this.eventId}-complete-${index}-${uncached[index].getCacheKey()}`, actionResult);
            });
        })
            .catch(error => {
            EventHelper.emit(`${this.eventId}-failure`, error);
        })
            .finally(() => {
            // In the event some inputs do not have results, we need to resolve the promises anyhow
            unresolvedSet.forEach(unresolvedIndex => {
                const index = unresolvedIndex;
                EventHelper.emit(`${this.eventId}-final-complete-${index}-${uncached[index].getCacheKey()}`);
            });
        });
    }
    /**
     * Executes a standard (non-batched) observable data action
     * @param input The action input
     * @param requestCache The request cache
     * @param appCache The application cache, if available
     * @param context The action context
     */
    _executeObservableAction(input, requestCache, appCache, context, isRefreshing = false) {
        const cacheKey = { key: input.getCacheKey(), typeName: input.getCacheObjectType() };
        const executor = (resolve, reject) => {
            this._actionWrapper(input, context, isRefreshing)
                .then(result => {
                resolve(result);
            })
                .catch(error => {
                // If error is timeout error, lookup app-cache if there
                // is a valid entity for the given cacheKey in app-cache
                if (ActionError.isServiceUnavailable(error) && isAppCacheData(input, appCache)) {
                    const cachedItem = appCache?.getValue(cacheKey);
                    if (cachedItem) {
                        return resolve(cachedItem);
                    }
                }
                return reject(error);
            });
        };
        // we only try to fetch the saved promise from cache when the retail proxy data action has cached type
        let cachedPromise;
        if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {
            cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });
        }
        // If OP is already in cache, just rerun it
        if (cachedPromise && isAsyncResult(cachedPromise) && !isRefreshing) {
            cachedPromise.run(executor);
            return;
        }
        // Uncached promises need to be saved to cache
        const asyncOutput = new AsyncResult(executor);
        this._saveResponseToCache([input], [asyncOutput], context, requestCache, appCache);
    }
    _checkForCachedData(inputs, context, requestCache, appCache, bypassCache, refreshing) {
        const mock = _get(context, 'requestContext.query.actionMock');
        const { log } = context.telemetry;
        if (mock) {
            inputs = this._interceptCacheForMocks(inputs, context, requestCache);
        }
        // if the cache type is set a none don't check cache for data and return inputs for execution
        // lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side
        if (this.cacheType === 'none' || refreshing) {
            return [inputs, []];
        }
        const uncached = [];
        const refresh = [];
        /* tslint:disable */
        inputs.forEach((i, idx) => {
            const actionId = this._getActionIdFromInputs(i);
            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };
            // if the retail proxy action does not have return type, we do not check if its in the cache
            if (i instanceof DataServiceRequest && !cacheKey.typeName) {
                uncached.push(i);
                return;
            }
            let cacheItem = requestCache.get(cacheKey);
            if (cacheItem && isAsyncResult(cacheItem.item) && cacheItem.item.status === 'FAILED') {
                if (!i.runOn || i.runOn !== 'serverOnly') {
                    uncached.push(i);
                }
            }
            else if (cacheItem && cacheItem.item && cacheItem.item.status === 'LOADING' && cacheItem.item.runOn === 'client') {
                // Ideally, an action configured to runOn client should never interfere with actions running on server.
                // However, it is possible that parent action with runon 'server' could be dependent on an action that is configured
                // by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets
                // include such actions in the uncached list so that it gets picked and executed later.
                uncached.push(i);
            }
            else if (i instanceof DataServiceRequest) {
                try {
                    if (bypassCache && context.requestContext.features && !!!context.requestContext.features.disable_bypass_request_cache) {
                        uncached.push(i);
                    }
                    else {
                        const appCacheData = appCache;
                        const cacheEntries = readCacheEntries(i, requestCache, appCacheData, !!!bypassCache && shouldReadFromAppCache(i, appCache));
                        if (!cacheEntries.entry) {
                            uncached.push(i);
                        }
                        if (cacheEntries && cacheEntries.shouldRefresh) {
                            refresh.push(i);
                        }
                    }
                }
                catch (e) {
                    const { action } = this;
                    log(LogLevel.Trace, "Error execution action '{actionName}', returning null", {
                        values: [actionId || (action && action.name) || 'unnamed'],
                        exception: e
                    });
                    uncached.push(i);
                }
            }
            else {
                if (bypassCache && context.requestContext.features && !context.requestContext.features.disable_bypass_request_cache) {
                    uncached.push(i);
                }
                else {
                    if (!cacheItem && !!!bypassCache && appCache && shouldReadFromAppCache(i, appCache)) {
                        cacheItem = appCache.copyTo(cacheKey, requestCache);
                        if (cacheItem && cacheItem.shouldRefresh) {
                            refresh.push(i);
                        }
                    }
                    if (!cacheItem || !cacheItem.item) {
                        uncached.push(i);
                        return;
                    }
                }
            }
        });
        return [uncached, refresh];
    }
    /**
     * Searches cache for mocks matching the inputs
     * @param inputs Current action inputs
     * @param context Current action context
     * @param requestCache Current request cache
     */
    _interceptCacheForMocks(inputs, context, requestCache) {
        const uncached = [];
        const actionId = this.action.prototype.id;
        inputs.forEach(i => {
            let mockItem = this._getMockItem(i.getCacheObjectType(), i.getCacheKey(), requestCache);
            if (!mockItem && actionId) {
                mockItem = this._getMockItem(actionId, i.getCacheKey(), requestCache);
            }
            let existingItem;
            if (this._checkShouldInteractWithCache(i, i.getCacheObjectType())) {
                existingItem = requestCache.get({ typeName: i.getCacheObjectType(), key: i.getCacheKey() });
            }
            if (!!mockItem && !!mockItem.item && !existingItem) {
                if (this.isObservable) {
                    requestCache.put({ typeName: i.getCacheObjectType(), key: i.getCacheKey() }, { item: AsyncResult.resolve(toJS(mockItem.item)) });
                }
                else {
                    requestCache.put({ typeName: i.getCacheObjectType(), key: i.getCacheKey() }, { item: toJS(mockItem.item) });
                }
            }
            else {
                uncached.push(i);
            }
        });
        return uncached;
    }
    _getMockItem(cacheNamespace, cacheKey, requestCache) {
        return (requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:${cacheKey}` }) ||
            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:*` }));
    }
    _convertToJSError(e) {
        // Proxy Error usually comes wrapped in an array
        // If it is, unbox it and conver to regular Error
        if (Array.isArray(e)) {
            const proxyError = e[0];
            if (proxyError.ErrorCode) {
                return ProxyError.toError(proxyError);
            }
        }
        else if (e.ErrorCode) {
            return ProxyError.toError(e);
        }
        // Return regular Error if not ProxyError
        return new Error(e.message || '');
    }
}
//# sourceMappingURL=action-executor.js.map
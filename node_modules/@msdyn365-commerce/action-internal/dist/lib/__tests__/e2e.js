/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { AppCache, RequestCache } from '@msdyn365-commerce/cache-internal';
import 'jest';
import 'jest-extended';
import { ActionContext } from '../action-context';
import { ActionError } from '../action-error';
import getActionTimeout from '../__mocks__/actions/get-action-timeout';
import GetError from '../__mocks__/actions/get-error';
import GetListData, { numberOfTimesGetistDataCalledDuringTest } from '../__mocks__/actions/get-list-data';
import GetLongChain from '../__mocks__/actions/get-long-chain';
import { mockProductRatings } from '../__mocks__/actions/get-product-ratings';
import GetProducts, { mockProducts, numberOfTimesGetProductCalledDuringTest } from '../__mocks__/actions/get-products';
import GetRecoProducts, { mockChannelData } from '../__mocks__/actions/get-recommendation-products';
import getRecursiveChain from '../__mocks__/actions/get-recursive-chain';
import GetRepeatingChain from '../__mocks__/actions/get-repeating-chain';
import observableAction from '../__mocks__/actions/observable-action';
import GetProductByCategory, { productForCategoryIdC103, productForCategoryNameAA3 } from '../__mocks__/actions/get-products-by-category';
import GetCart, { mockGetCart } from '../__mocks__/actions/get-cart';
import GetCartError from '../__mocks__/actions/get-cart-hook-error';
import { beforeCart, afterCart, preReadOnlyCart, postReadOnlyCart, preReadOnlyCartError, postReadOnlyCartError, afterCartError } from '../__mocks__/actions/get-cart-hook';
import { createDataActionHook } from '../create-data-action-hook';
describe('E2E tests for action runtime', () => {
    // Increase timeout for max depth tests
    jest.setTimeout(45000);
    afterAll(() => {
        jest.resetModules();
    });
    test('test error hook', async () => {
        console.log('\n===== Test Case: testhook error =====  ');
        const inputs = [
            [GetCartError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        createDataActionHook({
            actionId: 'TestHookError',
            postHook: afterCartError
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            console.log('err is catched');
            console.log(err);
            expect(err.message).toBe('afterCartHookError');
        }));
        await Promise.all(promises);
    });
    test('test hook', async () => {
        console.log('\n===== Test Case: testhook =====  ');
        const inputs = [[GetCart, {}, {}]];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const mockAfterCart = jest.fn(afterCart);
        const mockBeforeCart = jest.fn(beforeCart);
        const mockPreReadOnlyCart = jest.fn(preReadOnlyCart);
        const mockPostReadOnlyCart = jest.fn(postReadOnlyCart);
        // those error hook function wont afect the code flow
        const MockPreReadOnlyCartError = jest.fn(preReadOnlyCartError);
        const MockPostReadOnlyCartError = jest.fn(postReadOnlyCartError);
        createDataActionHook({
            actionId: 'TestHook',
            postHook: mockAfterCart,
            preHook: mockBeforeCart,
            preReadonlyHook: mockPreReadOnlyCart,
            postReadonlyHook: mockPostReadOnlyCart
        });
        createDataActionHook({
            actionId: 'TestHook',
            preReadonlyHook: MockPreReadOnlyCartError,
            postReadonlyHook: MockPostReadOnlyCartError
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(err.message).toBe('Get Error was called');
        }));
        await Promise.all(promises);
        expect(mockAfterCart).toHaveBeenCalledTimes(1);
        expect(mockBeforeCart).toHaveBeenCalledTimes(1);
        expect(mockPreReadOnlyCart).toHaveBeenCalledTimes(1);
        expect(mockPostReadOnlyCart).toHaveBeenCalledTimes(1);
        expect(mockBeforeCart).toHaveBeenCalledBefore(mockGetCart);
        expect(mockGetCart).toHaveBeenCalledBefore(mockAfterCart);
        // run the dataAction second times, this time, the action should be cached, and only preReadHook and postReadHook should be run
        const promises2 = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(idx).toBe(2);
            expect(err.message).toBe('Get Error was called');
        }));
        await Promise.all(promises2);
        // make sure only readOnly hooks run during the second round
        expect(mockAfterCart).toHaveBeenCalledTimes(1);
        expect(mockBeforeCart).toHaveBeenCalledTimes(1);
        expect(mockPreReadOnlyCart).toHaveBeenCalledTimes(2);
        expect(mockPostReadOnlyCart).toHaveBeenCalledTimes(2);
    });
    test('Batching de-duping work as expected', async () => {
        console.log('\n===== Test Case: General batching and de-duping of actions =====  ');
        // tslint:disable:no-any
        const inputs = [
            [GetProducts, { productIds: ['100'] }, {}],
            [GetProducts, { productIds: ['102'] }, {}],
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }, {}],
            [GetRecoProducts, { channel: 'top-free' }, {}],
            [GetRecoProducts, { channel: 'trending' }, {}],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetLongChain, {}, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(idx).toBe(2);
            expect(err.message).toBe('Get Error was called');
        }));
        const outputs = await Promise.all(promises);
        // Verify response
        compareJson(outputs[0][0], mockProducts['100']);
        expect(outputs[0].length).toBe(1);
        compareJson(outputs[1][0], mockProducts['102']);
        expect(outputs[1].length).toBe(1);
        compareJson(outputs[3], getRecoData('top-free'));
        compareJson(outputs[4], getRecoData('trending'));
        compareJson(outputs[5], getRecoData('top-free'));
        compareJson(outputs[6], getRecoData('top-paid'));
        expect(outputs[7].results).toBe(6);
        // Verify number of times each action was called
        expect(numberOfTimesGetProductCalledDuringTest).toBe(6);
    });
    test('Batched actions work when multiple calls are made', async () => {
        console.log('\n===== Batched action works when split across multiple action calls =====  ');
        // tslint:disable:no-any
        const inputs = [
            [GetProducts, { productIds: ['100'] }, {}],
            [GetProducts, { productIds: ['102'] }, {}],
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }, {}],
            [GetRecoProducts, { channel: 'top-free' }, {}],
            [GetRecoProducts, { channel: 'trending' }, {}],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetLongChain, {}, {}]
        ];
        const inputs2 = [
            [GetProducts, { productIds: ['107'] }, {}],
            [GetProducts, { productIds: ['108'] }, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(idx).toBe(2);
            expect(err.message).toBe('Get Error was called');
        }));
        const promises2 = inputs2.map((i, idx) => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] })));
        const allPromises = promises.concat(promises2);
        const outputs = await Promise.all(allPromises);
        // Verify response
        compareJson(outputs[0][0], mockProducts['100']);
        expect(outputs[0].length).toBe(1);
        compareJson(outputs[1][0], mockProducts['102']);
        expect(outputs[1].length).toBe(1);
        compareJson(outputs[3], getRecoData('top-free'));
        compareJson(outputs[4], getRecoData('trending'));
        compareJson(outputs[5], getRecoData('top-free'));
        compareJson(outputs[6], getRecoData('top-paid'));
        expect(outputs[7].results).toBe(6);
        console.log(outputs);
        compareJson(outputs[8][0], mockProducts['107']);
        expect(outputs[8].length).toBe(1);
        compareJson(outputs[9][0], mockProducts['108']);
        expect(outputs[9].length).toBe(1);
    });
    test('Non-Batched de-duping work as expected', async () => {
        console.log('\n===== Test Case: de-duping of actions =====  ');
        const inputs = [
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetLongChain, {}, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T2',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        // @ts-ignore
        numberOfTimesGetistDataCalledDuringTest = 0;
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] })));
        const outputs = await Promise.all(promises);
        // Verify response
        compareJson(outputs[0], getRecoData('top-free'));
        compareJson(outputs[1], getRecoData('top-paid'));
        compareJson(outputs[2], getRecoData('top-free'));
        compareJson(outputs[3], getRecoData('top-free'));
        // Verify number of times each action was called
        expect(numberOfTimesGetistDataCalledDuringTest).toBe(2);
    });
    test('inner chaining scenario inside an action', async () => {
        console.log('\n===== Test Case: chaining scenario =====  ');
        const inputs = [
            [GetProductByCategory, { categoryName: 'AA3' }],
            [GetProductByCategory, { categoryId: 'C103' }] // have 2-chain action
        ];
        const actionContext = new ActionContext({
            id: 'T0',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map(i => {
            return actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] }));
        });
        const outputs = await Promise.all(promises);
        // Verify response
        compareJson(outputs[0], productForCategoryNameAA3);
        compareJson(outputs[1], productForCategoryIdC103);
    });
    test('inner chaining scenario inside an action with dedupe', async () => {
        console.log('\n===== Test Case: chaining scenario =====  ');
        const inputs = [
            [GetProductByCategory, { categoryName: 'AA3' }, {}],
            [GetProductByCategory, { categoryId: 'C103' }, {}],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetLongChain, {}, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T0',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        // @ts-ignore
        numberOfTimesGetistDataCalledDuringTest = 0;
        const promises = inputs.map(i => {
            return actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }));
        });
        const outputs = await Promise.all(promises);
        // Verify response
        compareJson(outputs[0], productForCategoryNameAA3);
        compareJson(outputs[1], productForCategoryIdC103);
        compareJson(outputs[2], getRecoData('top-free'));
        compareJson(outputs[3], getRecoData('top-paid'));
        compareJson(outputs[4], getRecoData('top-free'));
        compareJson(outputs[5], getRecoData('top-free'));
        // Verify number of times each action was called
        expect(numberOfTimesGetistDataCalledDuringTest).toBe(2);
    });
    test('Verify action execution when broken action in first slot', async () => {
        console.log('\n===== Test Case: Broken action in first slot =====  ');
        const inputs = [
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }],
            [GetProducts, { productIds: ['102'] }],
            [GetRecoProducts, { channel: 'top-free' }]
        ];
        const clientCache = new RequestCache();
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: clientCache,
            appCache: null,
            expectedActionCount: inputs.length
        });
        const assertErrorCaught = jest.fn();
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] }))
            .catch(assertErrorCaught));
        const outputs = await Promise.all(promises);
        expect(clientCache.getValue({ typeName: 'Error', key: 'ERR' }).error).toEqual(
        // @ts-ignore
        new ActionError(new Error('Get Error was called')));
        compareJson(outputs[1][0], mockProducts['102']);
        expect(outputs[1].length).toBe(1);
        compareJson(outputs[2], getRecoData('top-free'));
        // Verify that the tier has ended
        expect(actionContext.hasRun).toBe(true);
    });
    test('Verify action execution when broken action in last slot', async () => {
        console.log('\n===== Test Case: Broken action in last slot ===== ');
        const inputs = [
            [GetProducts, { productIds: ['102'] }],
            [GetRecoProducts, { channel: 'top-free' }],
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] }))
            .catch((e) => {
            console.log('Error in E2E');
            console.log(e);
            expect(idx).toBe(2);
            expect(e.message).toBe('Get Error was called');
        }));
        const outputs = await Promise.all(promises);
        compareJson(outputs[0][0], mockProducts['102']);
        expect(outputs[0].length).toBe(1);
        compareJson(outputs[1], getRecoData('top-free'));
        // Verify that the tier has ended
        expect(actionContext.hasRun).toBe(true);
    });
    test('Verify action execution spawns more children than maximum depth.', async () => {
        const inputs = [];
        for (let i = 0; i < 2000; i++) {
            inputs.push([GetProducts, { productIds: ['102'] }]);
        }
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length,
            spawnChildOnExecute: true
        });
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] })));
        const outputs = await Promise.all(promises);
        compareJson(outputs[0][0], mockProducts['102']);
        expect(outputs.length).toBe(2000);
        compareJson(outputs[outputs.length - 1][0], mockProducts['102']);
    });
    test('Verify action execution stops when child tier recursively exceeds maximum.', async () => {
        const inputs = [[getRecursiveChain, { loopCount: 200 }]];
        const actionContext = new ActionContext({
            id: 'Child-Tier-Max-Test',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length,
            spawnChildOnExecute: true
        });
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] })));
        const outputs = await Promise.all(promises);
        // completed recursions should match max depth
        expect(outputs[0].recursionsComplete).toBe(200);
    });
    test('Verify action execution stops when child tier iteratively exceeds maximum', async () => {
        console.log('\n===== Test Case: Maximum exceeded within a zone ===== ');
        const inputs = [[GetRepeatingChain, { loopCount: 200 }]];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length,
            spawnChildOnExecute: true
        });
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] })));
        const outputs = await Promise.all(promises);
        expect(outputs[0].iterationsCompleted).toBe(200);
    });
    test('Verify action execution stops when tier exceeds maximum inside of a zone.', async () => {
        console.log('\n===== Test Case: Maximum exceeded within a zone ===== ');
        const inputs = [[GetRepeatingChain, { loopCount: 200 }]];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] })));
        const outputs = await Promise.all(promises);
        expect(outputs[0].iterationsCompleted).toBe(200);
    });
    test('Verify action execution stops when child tier iteratively exceeds maximum set in app', async () => {
        console.log('\n===== Test Case: Maximum exceeded within a zone ===== ');
        const inputs = [[GetRepeatingChain, { loopCount: 700 }]];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {
                app: {
                    maxDepth: 250
                }
            },
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length,
            spawnChildOnExecute: true
        });
        const promises = inputs.map(i => actionContext.chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1] })));
        const outputs = await Promise.all(promises);
        expect(outputs[0].iterationsCompleted).toBe(250);
    });
    test('Verify action execution stops when action exceeds timeout.', async () => {
        process.env.CURRENT_ENVIRONMENT = 'node';
        const inputs = [
            [getActionTimeout, { timeout: 2000 }],
            [getActionTimeout, { timeout: 2 }]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {
                query: {
                    actionTimeout: 5
                },
                features: {
                    action_timeout: true
                }
            },
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map(([action, input]) => {
            return actionContext
                .chainAction(action, action.prototype.inputFunc && action.prototype.inputFunc({ config: input }))
                .catch(() => {
                console.log('Catching an error');
            });
        });
        const outputs = await Promise.all(promises);
        expect(outputs[0]).toBeUndefined();
        expect(outputs[1]).toBe(2);
    });
    test('Verify action execution has no timeout in the browser.', async () => {
        process.env.CURRENT_ENVIRONMENT = 'web';
        const inputs = [[getActionTimeout, { timeout: 100 }]];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {
                query: {
                    actionTimeout: 5
                },
                features: {
                    action_timeout: true
                }
            },
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map(([action, input]) => {
            return actionContext.chainAction(action, action.prototype.inputFunc && action.prototype.inputFunc({ config: input }));
        });
        const outputs = await Promise.all(promises);
        expect(outputs[0]).toBe(100);
    });
    test.skip('Verify action retries execution if previous execution times out', async () => {
        process.env.CURRENT_ENVIRONMENT = 'node';
        const inputs = [[getActionTimeout, { timeout: 1000 }]];
        const requestCache = new RequestCache();
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {
                query: {
                    actionTimeout: 1
                },
                features: {
                    action_timeout: true
                }
            },
            requestCache,
            appCache: null,
            expectedActionCount: inputs.length
        });
        const firstOutput = await Promise.all(inputs.map(([action, input]) => {
            return actionContext.chainAction(action, action.prototype.inputFunc && action.prototype.inputFunc({ config: input }));
        }));
        expect(firstOutput[0]).toBeNull();
        const secondContext = new ActionContext({
            id: 'T2',
            requestContext: {
                query: {
                    actionTimeout: 2000
                },
                features: {
                    action_timeout: true
                }
            },
            requestCache,
            appCache: null,
            expectedActionCount: inputs.length
        });
        const secondOutput = await Promise.all(inputs.map(([action, input]) => {
            return secondContext.chainAction(action, action.prototype.inputFunc && action.prototype.inputFunc({ config: input }));
        }));
        expect(secondOutput[0]).toBe(1000);
    });
    test('Verify basic observable action functionality', async () => {
        process.env.CURRENT_ENVIRONMENT = 'node';
        const inputs = [[observableAction, {}]];
        const requestCache = new RequestCache();
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache,
            appCache: null,
            expectedActionCount: inputs.length
        });
        const output = await Promise.all(inputs.map(([action, input]) => {
            return action(action.prototype.inputFunc(input), actionContext);
        }));
        expect(output).toEqual(['foo']);
    });
    test('validating action-context get and getAll from request-cache', async () => {
        console.log('\n===== Test Case: validating action-context get and getAll from request-cache =====  ');
        // tslint:disable:no-any
        const inputs = [
            [GetProducts, { productIds: ['100'] }, {}],
            [GetProducts, { productIds: ['102'] }, {}],
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }, {}],
            [GetRecoProducts, { channel: 'top-free' }, {}],
            [GetRecoProducts, { channel: 'trending' }, {}],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetLongChain, {}, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: inputs.length
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(idx).toBe(2);
            expect(err.message).toBe('Get Error was called');
        }));
        await Promise.all(promises);
        // verify get
        expect(actionContext.get('product', '100')).toEqual(mockProducts['100']);
        // verify get for invalid product type
        expect(actionContext.get('invalid_key', '100')).toBeNull();
        // verify getAll
        expect(actionContext.getAll('product')).toEqual(Object.keys(mockProducts).map(key => mockProducts[key]));
        // verify getAll for invalid product type
        expect(actionContext.getAll('invalid_key')).toBeNull();
    });
    test('validating action-context get and getAll from app-cache', done => {
        console.log('\n===== Test Case: validating action-context get and getAll from app-cache =====  ');
        // tslint:disable:no-any
        const inputs = [
            [GetProducts, { productIds: ['100'] }, {}],
            [GetProducts, { productIds: ['102'] }, {}],
            [GetError, { getCacheKey: () => 'ERR', getCacheObjectType: () => 'Error', shouldCacheOutput: () => false }, {}],
            [GetRecoProducts, { channel: 'top-free' }, {}],
            [GetRecoProducts, { channel: 'trending' }, {}],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-free' } }],
            [GetListData, {}, { list: { $type: 'list', listType: 'Reco', channel: 'top-paid' } }],
            [GetLongChain, {}, {}]
        ];
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {
                features: {
                    disable_app_cache: false
                }
            },
            requestCache: new RequestCache(),
            appCache: new AppCache({
                ttlInSeconds: {
                    PRODUCT: 60
                }
            }),
            expectedActionCount: inputs.length
        });
        const promises = inputs.map((i, idx) => actionContext
            .chainAction(i[0], i[0].prototype.inputFunc && i[0].prototype.inputFunc.call(i, { config: i[1], data: i[2] }))
            .catch((err) => {
            expect(idx).toBe(2);
            expect(err.message).toBe('Get Error was called');
        }));
        // tslint:disable-next-line: no-floating-promises
        Promise.all(promises).then(() => {
            // @ts-ignore
            actionContext.requestCache = new RequestCache();
            // verify get
            expect(actionContext.get('product', '100')).toEqual(mockProducts['100']);
            // verify get for invalid product type
            expect(actionContext.get('invalid_key', '100')).toBeNull();
            // verify getAll
            const items = actionContext.getAll('product');
            // @ts-ignore
            items.map(item => expect(mockProducts[item.Id]).toEqual(item));
            // verify getAll for invalid product type
            expect(actionContext.getAll('invalid_key')).toBeNull();
            done();
        });
    });
});
function getRecoData(id) {
    return {
        responseIds: mockChannelData[id],
        products: mockChannelData[id].map(p => {
            return { product: mockProducts[p], rating: mockProductRatings[p].Rating };
        })
    };
}
function compareJson(actual, expected) {
    actual = JSON.stringify(actual);
    expected = JSON.stringify(expected);
    expect(actual).toBe(expected);
}
//# sourceMappingURL=e2e.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { GenericConsoleLogger, Telemetry } from '@msdyn365-commerce/telemetry-internal';
import 'jest';
import ActionExecutor from '../action-executor';
import * as cacheHelper from '../cache/retail-cache-helper';
import { DataServiceQuery } from '@msdyn365-commerce/retail-proxy';
const StaticTelemetry = new Telemetry();
StaticTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger });
StaticTelemetry.log = jest.fn();
describe('Action Executor', () => {
    describe('Constructor', () => {
        it('Should correctly construct a new Action Executor', () => {
            const mockAction = () => {
                console.log('Action');
            };
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                dataCacheType: () => 'none'
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor).not.toBeNull();
            expect(actionExecutor.action).toBe(mockAction);
            expect(actionExecutor.cacheType).toBe('none');
        });
        it('Should assign cacheType none if shouldCacheOutput is false', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                shouldCacheOutput: () => false
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor.cacheType).toBe('none');
        });
        it('Should assign cache type request if shouldCacheOutput is true', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                shouldCacheOutput: () => true
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor.cacheType).toBe('request');
        });
        it('Should assign cache type none if no cache strategy is set', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey'
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor.cacheType).toBe('none');
        });
        it('Should assign cache type from dataCacheType', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                dataCacheType: () => 'application'
            };
            const mockinputs = [mockInput];
            const trace = jest.fn();
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor.cacheType).toBe('application');
            expect(trace).not.toHaveBeenCalled();
        });
        it('Should create a copy of inputs', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                dataCacheType: () => 'application'
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            expect(actionExecutor.inputs).not.toBe(mockinputs);
            expect(actionExecutor.inputs).toEqual(mockinputs);
        });
    });
    describe('Add Inputs', () => {
        it('Successfully adds inputs', () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockInput = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey',
                dataCacheType: () => 'application'
            };
            const mockInput2 = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey2',
                dataCacheType: () => 'application'
            };
            const mockInput3 = {
                getCacheObjectType: () => 'mockAction',
                getCacheKey: () => 'mockCacheKey3',
                dataCacheType: () => 'application'
            };
            const mockinputs = [mockInput];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            actionExecutor.addInputs([mockInput2, mockInput3]);
            expect(actionExecutor.inputs).toHaveLength(3);
            expect(actionExecutor.inputs[1]).toEqual(mockInput2);
            expect(actionExecutor.inputs[2]).toEqual(mockInput3);
        });
    });
    describe('Execute', () => {
        it('Should not execute if there are no inputs', async () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockinputs = [];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: StaticTelemetry,
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            const mockCache = {
                get: jest.fn(),
                put: jest.fn(),
                getValue: jest.fn(),
                del: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                copyTo: jest.fn()
            };
            const output = await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(output.length).toBe(0);
            expect(mockAction).not.toHaveBeenCalled();
        });
        it('Should not execute if input value is already in cache', async () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockinputs = [
                {
                    getCacheObjectType: () => 'mockAction',
                    getCacheKey: () => 'mockCacheKey',
                    dataCacheType: () => 'application'
                }
            ];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            const mockCache = {
                get: jest.fn(() => ({ item: 'super-secret-string' })),
                put: jest.fn(),
                getValue: jest.fn(),
                del: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                copyTo: jest.fn()
            };
            const output = await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(output.length).toBe(0);
            expect(mockAction).not.toHaveBeenCalled();
        });
        it('Should execute if retail server data action doesnt have cache type', async () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const query = new DataServiceQuery('Tests', 'Test');
            const dataRequest = query.create({});
            dataRequest.getCacheObjectType = () => '';
            dataRequest.getCacheKey = () => 'mockCacheKey';
            // @ts-ignore
            dataRequest.dataCacheType = () => 'request';
            // @ts-ignore
            dataRequest.getActionId = undefined;
            const mockinputs = [dataRequest];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            const mockCache = {
                get: jest.fn(),
                put: jest.fn(),
                getValue: jest.fn(),
                del: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                copyTo: jest.fn()
            };
            const output = await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(output.length).toBe(0);
            expect(mockAction).toHaveBeenCalled();
            expect(mockCache.get).not.toHaveBeenCalled();
        });
        it('should execute an action if cache strategy is none', async () => {
            // arrange
            const mockAction = jest.fn(() => 'super-secret-action');
            mockAction.prototype.isBatched = false;
            const mockinputs = [
                {
                    getCacheObjectType: () => 'mockAction',
                    getCacheKey: () => 'mockCacheKey',
                    dataCacheType: () => 'none'
                }
            ];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            const mockCache = {
                get: jest.fn(() => {
                    return { item: 'super-secret-string' };
                }),
                put: jest.fn(),
                getValue: jest.fn(),
                del: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                copyTo: jest.fn()
            };
            // @ts-ignore -- don't need to mock whole object
            const appCache = {
                get: jest.fn(),
                put: jest.fn(),
                getValue: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                del: jest.fn(),
                copyTo: jest.fn(),
                hasCacheSetting: jest.fn()
            };
            // act
            await actionExecutor.execute(mockContext, mockCache, appCache);
            // assert
            expect(mockCache.put).toBeCalledWith({ typeName: 'mockAction', key: 'mockCacheKey' }, { item: 'super-secret-action' });
        });
        it('Should execute an action if the input is not in the cache and cache strategy is not none', async () => {
            const mockAction = jest.fn(() => 'super-secret-action');
            mockAction.prototype.isBatched = false;
            const mockinputs = [
                {
                    getCacheObjectType: () => 'mockAction',
                    getCacheKey: () => 'mockCacheKey',
                    dataCacheType: () => 'application'
                }
            ];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            const mockCache = {
                get: jest.fn(),
                put: jest.fn(),
                getValue: jest.fn(),
                getAllItems: jest.fn(),
                flushAll: jest.fn(),
                del: jest.fn(),
                copyTo: jest.fn()
            };
            await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(mockCache.put).toBeCalledWith({ typeName: 'mockAction', key: 'mockCacheKey' }, { item: 'super-secret-action' });
        });
        it('Should call respect readCacheEntries results', async () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const readCacheEntriesMock = jest.spyOn(cacheHelper, 'readCacheEntries');
            readCacheEntriesMock.mockReturnValue({ item: 'super-secret-string' });
            const mockinputs = [
                {
                    getCacheObjectType: () => 'mockAction',
                    getCacheKey: () => 'mockCacheKey',
                    dataCacheType: () => 'application',
                    // @ts-ignore
                    readCacheEntries: jest.fn(() => {
                        return { entry: { item: 'super-secret-string' } };
                    })
                }
            ];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            // @ts-ignore -- don't need to mock all values
            const mockCache = {
                get: jest.fn(() => {
                    return { item: 'super-secret-string' };
                }),
                put: jest.fn(),
                getValue: jest.fn()
            };
            const output = await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(output.length).toBe(0);
            expect(mockAction).not.toHaveBeenCalled();
        });
        it('Should not call cache put if action input has saveCacheEntries', async () => {
            const mockAction = jest.fn();
            mockAction.prototype.isBatched = false;
            const mockinputs = [
                {
                    getCacheObjectType: () => 'mockAction',
                    getCacheKey: () => 'mockCacheKey',
                    dataCacheType: () => 'application',
                    // @ts-ignore
                    saveCacheEntries: jest.fn()
                }
            ];
            const actionExecutor = new ActionExecutor(mockAction, mockinputs, StaticTelemetry);
            const mockContext = {
                chainAction: jest.fn(),
                update: jest.fn(),
                trace: jest.fn(),
                get: jest.fn(),
                getAll: jest.fn(),
                telemetry: {},
                requestContext: {},
                runAllActionsInQueue: jest.fn()
            };
            // @ts-ignore -- don't need to mock all values
            const mockCache = {
                get: jest.fn(() => {
                    return { item: 'super-secret-string' };
                }),
                put: jest.fn(),
                getValue: jest.fn()
            };
            const output = await actionExecutor.execute(mockContext, mockCache, mockCache);
            expect(output.length).toBe(0);
            expect(mockAction).not.toHaveBeenCalled();
            expect(mockCache.put).not.toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=action-executor.test.js.map
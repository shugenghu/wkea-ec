{"version":3,"file":"action-context.js","sourceRoot":"","sources":["../../src/action-context.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable: no-any\nimport { ICache, ICacheItem, ICacheKey, ICacheSource, RequestCache } from '@msdyn365-commerce/cache-internal';\nimport { IAction, IActionContext, IActionInput, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { GenericConsoleLogger, ITelemetry, LogLevel, StaticTelemetry, Telemetry } from '@msdyn365-commerce/telemetry-internal';\nimport uuidv1 from 'uuid/v1';\nimport ActionExecutor from './action-executor';\nimport { ActionRegistrar } from './action-registrar';\nimport { shouldWriteToAppCache } from './action-runtime-utils';\nimport { addLocaleInformation, readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\n/**\n * This interface is used in ActionContext only, for saving information needed to refresh data actions.\n *\n */\ninterface IRefreshConfigs {\n    refreshContext: IActionContext;\n    actionInputs: IActionInput[];\n    paramExecutor: ActionExecutor;\n}\n/**\n * This class contains the primary logic which controls the execution flow of the action runtime\n *\n */\n/*@internal*/\nexport class ActionContext implements IActionContext {\n    public static maxDepth: number = 200;\n\n    public readonly executionParams: ActionExecutor[] = [];\n    public readonly requestContext: any;\n\n    /**\n     * Telemetry object to log information\n     */\n    public telemetry: ITelemetry;\n\n    private readonly requestCache: ICache;\n    private readonly appCache: ICache | null = null;\n    private readonly cacheKeyMap: string[] = [];\n\n    /**\n     * Action context creates a new instance for every tier of execution,\n     * This number specifies the depth/current tier in the execution flow\n     */\n    private readonly currentExecutionTier: number;\n\n    /**\n     * Thread ID\n     */\n    private readonly threadId: string;\n\n    /**\n     * Event ID\n     * Unique ID for each action context, automatically generated\n     */\n    private readonly eventId: string;\n\n    /**\n     * Whether the current context as executed\n     */\n    private hasRun: boolean = false;\n\n    /**\n     * When this number is > 0, the current context will wait for all the actions to\n     * be queued before kicking off execution.\n     * This number is decremented for every action that is successful in current tier.\n     */\n    private expectedActionsInCurrentTier: number;\n\n    /**\n     * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count\n     */\n    private currentActionsInQueue: number = 0;\n\n    /**\n     * Object to track the next tier number.\n     */\n    private nextTierCounter: { next: number } = { next: 0 };\n\n    /**\n     * When true will span a new independent action context when an action is executed resetting depth limits\n     * Otherwise will invoke the action in the current context.\n     */\n    private spawnChildOnExecute: boolean = false;\n\n    /**\n     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7\n     * @param expectedActionCount: This value specifies the expected number of actions to be queued before\n     *                             we kick off execution in the current tier\n     */\n    constructor(args: {\n        id: string;\n        requestContext: any;\n        requestCache: ICache;\n        appCache: ICache | null;\n        currentExecutionTier?: number;\n        expectedActionCount?: number;\n        spawnChildOnExecute?: boolean;\n        telemetry?: ITelemetry;\n    }) {\n        const {\n            id,\n            requestContext,\n            requestCache,\n            appCache,\n            currentExecutionTier,\n            expectedActionCount,\n            spawnChildOnExecute,\n            telemetry\n        } = args;\n        this.threadId = id;\n        this.eventId = uuidv1();\n\n        this.currentExecutionTier = currentExecutionTier || 0;\n        if (this.currentExecutionTier === 0) {\n            this.nextTierCounter = { next: 0 };\n        }\n\n        this.expectedActionsInCurrentTier = expectedActionCount || 0;\n        this.requestCache = requestCache;\n        this.requestContext = requestContext || {};\n        this.spawnChildOnExecute = Boolean(spawnChildOnExecute);\n\n        // If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object\n        if (telemetry) {\n            this.telemetry = telemetry;\n        } else {\n            // register default console logger\n            const moduleTelemetry = new Telemetry();\n            const isDebug = requestContext.params && requestContext.params.isDebug;\n\n            // register tracelogger only in development environment or debug is true.\n            (process.env.NODE_ENV === 'development' || isDebug) &&\n                moduleTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: isDebug } });\n\n            this.telemetry = moduleTelemetry;\n        }\n\n        /**\n         * @deprecated\n         * Trace is an alias for telemetry.log(LogLevel.Trace, message)\n         * Use the telemetry object directly.\n         */\n        this.trace = (message: string) => {\n            this.telemetry.log(LogLevel.Debug, message);\n        };\n\n        // enable app cache only if the disable_app_cache feature switch is false\n        if (requestContext.features && !!!requestContext.features.disable_app_cache) {\n            this.appCache = appCache;\n        }\n    }\n\n    /**\n     * Chains an action method to the current context for execution\n     * @param action - action method\n     * @param inputs - action input\n     */\n    // tslint:disable-next-line:max-func-body-length\n    public chainAction<T>(_action: IAction<T>, inputs: IActionInput | IActionInput[], actionOption?:IDataActionOptions): Promise<T | (T | null)[] | null> {\n        const action = ActionRegistrar.unwrapAction(_action);\n        addLocaleInformation(inputs, this.requestContext.locale);\n        if (!action || !inputs) {\n            // Decrement the expected actions on this tier since this action was incorrectly configured\n            this.expectedActionsInCurrentTier--;\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                return Promise.resolve(null);\n            }\n\n            if (!this.hasRun) {\n                return this.runAllActionsInQueue().then(() => null);\n            }\n\n            return Promise.resolve(null);\n        }\n\n        if (this.isMaxDepthExceeded()) {\n            this.debug('Max depth exceeded - not running further.');\n            return Promise.resolve(null);\n        }\n\n        if (this.hasRun) {\n            // If the parent action decides to queue another action after the current tier completes execution\n            // then set the hasRun to false, so the action can fire right away\n            this.hasRun = false;\n            this.executionParams.length = 0;\n            this.currentActionsInQueue = 0;\n        }\n\n        this.currentActionsInQueue++;\n        const isBatched = action.prototype.isBatched;\n        const inputsArray = <IActionInput[]>(isBatched ? inputs : [inputs]);\n\n        let current = this.executionParams.find(a => a.action === action);\n        if (current && isBatched) {\n            current.addInputs(inputsArray);\n        } else {\n            const inputIdentifier = `${inputsArray[0].getCacheObjectType()}||${inputsArray[0].getCacheKey()}`;\n            if (!this.cacheKeyMap.find(key => key === inputIdentifier)) {\n                current = new ActionExecutor(action, inputsArray, this.telemetry, actionOption);\n                this.executionParams.push(current);\n                this.cacheKeyMap.push(inputIdentifier);\n            }\n        }\n\n        // @ts-ignore\n        // tslint:disable-next-line: max-func-body-length\n        const asyncResult = new AsyncResult<T | T[]>(async (resolve, reject) => {\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                // Hold the thread until the entire tier is populated\n                await new Promise((innerResolve: Function) => {\n                    const onEventIdCompletion = (tierNum: number) => {\n                        if (tierNum === this.currentExecutionTier) {\n                            innerResolve();\n                        }\n                    };\n                    EventHelper.on<[number]>(`${this.eventId}:completed`, onEventIdCompletion);\n                });\n                EventHelper.removeAllListeners(`${this.eventId}:completed`);\n            }\n\n            if (!this.hasRun) {\n                await this.runAllActionsInQueue();\n            }\n\n            const outputs = inputsArray.map(i => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        const entry = readCacheEntries(i, this.requestCache, this.appCache, false, StaticTelemetry);\n                        return entry.entry;\n                    } catch (e) {\n                        this.debug(\n                            `Error execution action type '[${i && i.getCacheObjectType()}' and cache key '[{${i &&\n                                i.getCacheKey()}}]', returning null`\n                        );\n                        return null;\n                    }\n                } else {\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    const cacheItem = this.requestCache.get<ICacheItem<T>>(cacheKey);\n                    const cacheValue = !!cacheItem ? this.requestCache.getValue<T>(cacheKey) : null;\n\n                    if (cacheItem && !!cacheItem.error) {\n                        throw cacheValue;\n                    } else {\n                        if (cacheItem && !msdyn365Commerce.isBrowser) {\n                            switch (cacheItem.s!) {\n                                case ICacheSource.AppCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'AppCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                case ICacheSource.RequestCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'RequestCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                default: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey, 'Undefined']\n                                        }\n                                    );\n                                }\n                            }\n                        }\n                        return cacheValue;\n                    }\n                }\n            });\n\n            this.cacheKeyMap.splice(0, this.cacheKeyMap.length);\n\n            // Batched observable actions need to be merged into a single AsyncResult\n            if (isBatched && action.prototype.isObservable) {\n                resolve(\n                    Promise.all(outputs).then(results => {\n                        // Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped\n                        return results.map(result => {\n                            return result && result._type === 'AsyncResult' ? result.result : result;\n                        });\n                    })\n                );\n            } else {\n                // We need to pass along the metadata explicitly to the outer AsyncResult\n                if (isAsyncResult(outputs[0]) && !isBatched) {\n                    outputs[0].then(() => {\n                        asyncResult.metadata = outputs[0].metadata;\n                    });\n                }\n\n                resolve(isBatched ? outputs : (outputs.length && outputs[0]) || null);\n            }\n        });\n\n        return asyncResult;\n    }\n\n    /**\n     * Helper method to update cache\n     * @param input The input\n     * @param data The data\n     */\n    public update<T>(inputs: IActionInput | IActionInput[], data: T): T {\n        if (inputs && data) {\n            // If an array of actionInputs has been passed, an equal amount of data items must be present\n            const dataArray = <unknown[]>(Array.isArray(inputs) ? data : [data]);\n            const inputArray = Array.isArray(inputs) ? inputs : [inputs];\n            if (inputArray.length !== dataArray.length) {\n                throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');\n            }\n            addLocaleInformation(inputArray, this.requestContext.locale);\n            inputArray.map((i, idx) => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        saveCacheEntries(i, dataArray[idx], this.requestCache, this.appCache, shouldWriteToAppCache(i, this.appCache));\n                    } catch (e) {\n                        this.debug(\n                            `Error in updating cache with input '[${i.getCacheObjectType()}]' - '[${i.getCacheKey()}]', returning null`\n                        );\n                        this.error(e);\n                    }\n                } else {\n                    // When updating OPs, only result can be updated, passed OPs will also be unwrapped.\n                    if (isAsyncResult(<object>dataArray[idx])) {\n                        dataArray[idx] = (<AsyncResult<unknown>>dataArray[idx]).result;\n                    }\n\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    this.requestCache.put(cacheKey, { item: dataArray[idx] });\n                    if (this.appCache && shouldWriteToAppCache(i, this.appCache)) {\n                        this.appCache.put(cacheKey, { item: dataArray[idx] });\n                    }\n                }\n            });\n\n            if (Array.isArray(inputs)) {\n                return <T>(<unknown>inputs.map(input => {\n                    return this.requestCache.getValue({ typeName: input.getCacheObjectType(), key: input.getCacheKey() });\n                }));\n            } else {\n                return <T>this.requestCache.getValue({ typeName: inputs.getCacheObjectType(), key: inputs.getCacheKey() });\n            }\n        }\n\n        // For scenarios where data/input was bad, we just return original data\n        return data;\n    }\n\n    /**\n     * Helper method to log trace using telemetry\n     * @param message message to log to console\n     */\n    public trace = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log error using telemetry\n     * @param message message to log to console\n     */\n    public error = (message: string): void => {\n        this.telemetry.log(LogLevel.Error, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log debug using telemetry\n     * @param message message to log to console\n     */\n    public debug = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param cacheObjectType entity type that was cached\n     * @param cacheKey cache key against which the object is cached\n     * @throws if cacheObjecttype is null or empty\n     */\n    public get<T>(cacheObjectType: string, cacheKey: string): T | T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        if (!cacheKey) {\n            throw new Error('Cannot have null or empty cacheKey');\n        }\n\n        const preparedCacheKey = { typeName: cacheObjectType, key: cacheKey };\n        let cachedItem = this.requestCache.get<any>(preparedCacheKey);\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && !cachedItem && this.appCache) {\n            cachedItem = this.appCache.get<any>(preparedCacheKey);\n        }\n\n        if (!cachedItem) {\n            return null;\n        }\n\n        if (typeof cachedItem.item !== 'object' || cachedItem.item.$ref !== true) {\n            return cachedItem.item;\n        }\n\n        return Array.isArray(cachedItem.item.key) ? <T[]>(<string[]>cachedItem.item.key)\n                  .map(key => this.getItemFromCache<T>({ typeName: cacheObjectType, key }))\n                  .filter(Boolean) : null;\n    }\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param input The input\n     * @param data The data\n     * @throws if cacheObjecttype is null or empty\n     */\n    public getAll<T>(cacheObjectType: string): T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        let cachedEntries = this.requestCache.getAllItems<any>(cacheObjectType);\n        if (!cachedEntries) {\n            if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n                cachedEntries = this.appCache && this.appCache.getAllItems<any>(cacheObjectType);\n            }\n\n            if (!cachedEntries) {\n                return null;\n            }\n        }\n\n        return <T[]>Object.keys(cachedEntries)\n            .filter(key => typeof cachedEntries![key].item !== 'object' || cachedEntries![key].item.$ref !== true)\n            .map(key => cachedEntries![key].item);\n    }\n\n    /**\n     * Executes all the actions in the current context in parallel\n     */\n    // tslint:disable max-func-body-length\n    public async runAllActionsInQueue(): Promise<void> {\n        const { threadId, requestContext, requestCache, appCache, nextTierCounter, executionParams } = this;\n        if (!executionParams.length) {\n            this.trace('No actions to execute - not running further.');\n            return;\n        }\n        // Increment the tier each pass through run all actions\n        if (this.isMaxDepthExceeded()) {\n            this.trace('Max depth exceeded - not running further.');\n            return;\n        }\n\n        // When kicking off the next tier,\n        // set the max number of chain actions the can be expected from child actions\n        // equal to the number of actions that are executing in current tier\n        const expectedNumberOfChildThreads = executionParams.length;\n\n        let nextTierStartingDepth;\n        if (this.spawnChildOnExecute) {\n            nextTierStartingDepth = nextTierCounter.next + 1;\n        } else {\n            nextTierStartingDepth = ++nextTierCounter.next;\n        }\n\n        const nextTier = new ActionContext({\n            id: threadId,\n            requestContext: requestContext,\n            requestCache: requestCache,\n            appCache: appCache,\n            currentExecutionTier: nextTierStartingDepth,\n            expectedActionCount: expectedNumberOfChildThreads,\n            telemetry: this.telemetry\n        });\n\n        const refreshContext = new ActionContext({\n            id: 'Refresh Context',\n            requestContext: requestContext,\n            requestCache: new RequestCache(),\n            telemetry: this.telemetry,\n            appCache: appCache,\n            spawnChildOnExecute: true\n        });\n        const refreshconfigslocal: Set<IRefreshConfigs> = new Set();\n\n        nextTier.nextTierCounter = { next: nextTierStartingDepth };\n        // DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions\n        const promises: Promise<any>[] = executionParams.map(param => {\n            // TODO: should we read from input about the cacheability?\n            return param\n                .execute(nextTier, requestCache, appCache, this.requestContext.query && !!this.requestContext.query.cachebypass, [])\n                .then(refreshActions => {\n                    // refresh the data actions which need to be refreshed.\n                    if (refreshActions.length) {\n                        refreshconfigslocal.add({\n                            paramExecutor: param,\n                            actionInputs: refreshActions,\n                            refreshContext: refreshContext\n                        });\n                    }\n\n                    // If the current chain action completes execution\n                    // decrement the max number of threads that we expect\n                    // from the next tier\n                    nextTier.expectedActionsInCurrentTier--;\n\n                    if (!nextTier.hasRun) {\n                        // First check if the next tier has any actions\n                        // then check if the number of thread match expected\n                        if (\n                            nextTier.currentActionsInQueue > 0 &&\n                            nextTier.currentActionsInQueue === nextTier.expectedActionsInCurrentTier\n                        ) {\n                            return nextTier.runAllActionsInQueue();\n                        }\n                    }\n                });\n        });\n\n        // Wait until all the actions in current tier are run to completion\n        return Promise.all(promises)\n            .then(() => {\n                if (refreshconfigslocal.size > 0 && requestContext.features && !!!requestContext.features.disable_appcache_refresh) {\n                    refreshconfigslocal.forEach(rf => {\n                        const refreshRequestCache = new RequestCache();\n                        rf.paramExecutor\n                            .execute(\n                                rf.refreshContext,\n                                refreshRequestCache,\n                                this.appCache,\n                                this.requestContext.query && !!this.requestContext.query.cachebypass,\n                                rf.actionInputs\n                            )\n                            .then(() =>\n                                StaticTelemetry.log(\n                                    LogLevel.Information,\n                                    `BackgroundRefresh - Executed refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                )\n                            )\n                            .catch(error => {\n                                StaticTelemetry.log(\n                                    LogLevel.Warning,\n                                    `BackgroundRefresh - Error execution refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                );\n                            });\n                    });\n                }\n                this._endCurrentTier();\n            })\n            .catch(error => {\n                this._endCurrentTier();\n                throw error;\n            });\n    }\n\n    /**\n     * Returns true if current tier has exceeded max depth\n     */\n    private isMaxDepthExceeded = (): boolean => {\n        const maxDepth = (this.requestContext && this.requestContext.app && this.requestContext.app.maxDepth) || ActionContext.maxDepth;\n        return this.nextTierCounter.next > maxDepth;\n    };\n\n    /**\n     * Retrieves item from request cache and fallsback to app cache if not found\n     */\n    private getItemFromCache = <T>(cacheKey: ICacheKey): T | undefined => {\n        let cachedItem = this.requestCache.get<T>(cacheKey);\n\n        if (cachedItem) {\n            return cachedItem.item;\n        }\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n            cachedItem = this.appCache.get<T>(cacheKey);\n        }\n\n        return cachedItem ? cachedItem.item : undefined;\n    };\n\n    /**\n     * Signals the end of current tier so actions can return the response\n     */\n    private _endCurrentTier = (): void => {\n        this.hasRun = true;\n        EventHelper.emit(`${this.eventId}:completed`, this.currentExecutionTier);\n    };\n}\n"]}
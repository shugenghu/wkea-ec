/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ICache } from '@msdyn365-commerce/cache-internal';
import { IAction, IActionContext, IActionInput, IDataActionOptions } from '@msdyn365-commerce/core-internal';
import { ITelemetry } from '@msdyn365-commerce/telemetry-internal';
import ActionExecutor from './action-executor';
/**
 * This class contains the primary logic which controls the execution flow of the action runtime
 *
 */
export declare class ActionContext implements IActionContext {
    static maxDepth: number;
    readonly executionParams: ActionExecutor[];
    readonly requestContext: any;
    /**
     * Telemetry object to log information
     */
    telemetry: ITelemetry;
    private readonly requestCache;
    private readonly appCache;
    private readonly cacheKeyMap;
    /**
     * Action context creates a new instance for every tier of execution,
     * This number specifies the depth/current tier in the execution flow
     */
    private readonly currentExecutionTier;
    /**
     * Thread ID
     */
    private readonly threadId;
    /**
     * Event ID
     * Unique ID for each action context, automatically generated
     */
    private readonly eventId;
    /**
     * Whether the current context as executed
     */
    private hasRun;
    /**
     * When this number is > 0, the current context will wait for all the actions to
     * be queued before kicking off execution.
     * This number is decremented for every action that is successful in current tier.
     */
    private expectedActionsInCurrentTier;
    /**
     * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count
     */
    private currentActionsInQueue;
    /**
     * Object to track the next tier number.
     */
    private nextTierCounter;
    /**
     * When true will span a new independent action context when an action is executed resetting depth limits
     * Otherwise will invoke the action in the current context.
     */
    private spawnChildOnExecute;
    /**
     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7
     * @param expectedActionCount: This value specifies the expected number of actions to be queued before
     *                             we kick off execution in the current tier
     */
    constructor(args: {
        id: string;
        requestContext: any;
        requestCache: ICache;
        appCache: ICache | null;
        currentExecutionTier?: number;
        expectedActionCount?: number;
        spawnChildOnExecute?: boolean;
        telemetry?: ITelemetry;
    });
    /**
     * Chains an action method to the current context for execution
     * @param action - action method
     * @param inputs - action input
     */
    chainAction<T>(_action: IAction<T>, inputs: IActionInput | IActionInput[], actionOption?: IDataActionOptions): Promise<T | (T | null)[] | null>;
    /**
     * Helper method to update cache
     * @param input The input
     * @param data The data
     */
    update<T>(inputs: IActionInput | IActionInput[], data: T): T;
    /**
     * Helper method to log trace using telemetry
     * @param message message to log to console
     */
    trace: (message: string) => void;
    /**
     * Helper method to log error using telemetry
     * @param message message to log to console
     */
    error: (message: string) => void;
    /**
     * Helper method to log debug using telemetry
     * @param message message to log to console
     */
    debug: (message: string) => void;
    /**
     * Helper method to data cache from cache
     * if cachekey is null or empty, it returns all entries of cacheObjectType
     * @param cacheObjectType entity type that was cached
     * @param cacheKey cache key against which the object is cached
     * @throws if cacheObjecttype is null or empty
     */
    get<T>(cacheObjectType: string, cacheKey: string): T | T[] | null;
    /**
     * Helper method to data cache from cache
     * if cachekey is null or empty, it returns all entries of cacheObjectType
     * @param input The input
     * @param data The data
     * @throws if cacheObjecttype is null or empty
     */
    getAll<T>(cacheObjectType: string): T[] | null;
    /**
     * Executes all the actions in the current context in parallel
     */
    runAllActionsInQueue(): Promise<void>;
    /**
     * Returns true if current tier has exceeded max depth
     */
    private isMaxDepthExceeded;
    /**
     * Retrieves item from request cache and fallsback to app cache if not found
     */
    private getItemFromCache;
    /**
     * Signals the end of current tier so actions can return the response
     */
    private _endCurrentTier;
}

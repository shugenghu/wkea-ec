#!/usr/bin/env node
/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const path = require('path');
const trace = require('@msdyn365-commerce/utilities-internal').trace;
const ModuleDefinitionGenerator = require('../src/module-definition-generator');
const { getDataDefinitionFiles } = require('../src/data-definition-generator');
const { getDefinitionFiles, runDefinitionGenerator } = require('../src/utils/helpers');
const yargs = require('yargs')
    .alias('d', 'dir')
    .alias('f', 'file')
    .alias('o', 'output')
    .alias('h', 'help')
    .alias('s', 'search')
    .alias('v', 'version')
    .describe('d', 'Path to a module base directory to process all definition files and update schema timestamp')
    .describe('f', 'Path to a single definition file to process')
    .describe('o', 'Path to an alternative output directory (Optional)')
    .describe('s', 'Only search and list definition files under a given directory')
    .conflicts('d', 'f')
    .conflicts('d', 'o')
    .usage(
        '\ngendef [-d] <path to module base directory>' +
            '\ngendef -f <path to definition file> [-o <alternative output path>]' +
            '\ngendef -s <path to module base directory>' +
            '\ngendef [-h | -v]'
    )
    .check(checkArguments).argv;

/**
 * Perform basic checks of provided arguments
 *
 * @param argv Arguments parsed from command line input
 *
 * @returns True if checks passed, otherwise throw exception with specific error
 */
function checkArguments(argv) {
    trace.debug(`Input arguments count [${Object.keys(argv).length}]`);
    trace.debug(`Input arguments [${Object.keys(argv)}]`);
    Object.keys(argv).forEach(key => trace.info(`key [${key}] value [${argv[key]}]`));

    if (!argv.d && !argv.f && !argv.s && !argv._.length) {
        trace.debug(`Arguments required not provided -d [${argv.d}], -f [${argv.f}], default [${argv._}]`);
        throw new Error(
            'Must provide one of the following arguments:\n' +
                '\t Path to module base directory (Optionally with -d switch) \n' +
                '\t Path to a module definition file (With -f switch)'
        );
    }

    if (argv.d && !fs.lstatSync(path.resolve(argv.d)).isDirectory()) {
        throw new Error(`Invalid option -d value [${argv.d}], not path to a module base directory`);
    }

    if (argv.f && !fs.lstatSync(path.resolve(argv.f)).isFile()) {
        throw new Error(`Invalid option -f value [${argv.f}], not path to a definition file`);
    }

    if (argv.s && !fs.lstatSync(path.resolve(argv.s)).isDirectory()) {
        throw new Error(`Invalid option -s value [${argv.s}], not path to a module base directory`);
    }

    if (argv._.length && (argv._.length > 1 || !fs.lstatSync(path.resolve(argv._[0])).isDirectory())) {
        if (argv._.length > 1) {
            throw new Error(`Invalid [${argv._.length}] module base path arguments provided`);
        } else {
            throw new Error(`Invalid argument [${argv._[0]}], not path to module base directory`);
        }
    }

    if (argv.o && !fs.lstatSync(path.resolve(argv.o)).isDirectory()) {
        throw new Error(`Invalid option -o value [${argv.o}], not a path to an alternative output directory`);
    }

    if (argv._.length && (argv.f || argv.d)) {
        throw new Error(`Invalid option combination, switches (-d | -f) cannot be combined when providing a module base path argument`);
    }

    if (argv._.length && argv.o) {
        throw new Error(`Invalid option combination, cannot specify alternative output path when providing a module base path argument`);
    }
    return true;
}

trace.info('[Start]=====================================================================');
const moduleBasePath = yargs.d
    ? path.resolve(yargs.d)
    : yargs.s
        ? path.resolve(yargs.s)
        : yargs._.length
            ? path.resolve(yargs._[0])
            : undefined;
const moduleDefinitionPath = yargs.f ? path.resolve(yargs.f) : undefined;
const altOutputPath = yargs.o ? path.resolve(yargs.o) : undefined;

if (moduleBasePath) {
    trace.info(`Using base module path [${moduleBasePath}]`);

    const generator = new ModuleDefinitionGenerator(process.cwd);
    const jsonDefinitionFiles = getDefinitionFiles(moduleBasePath);
    const dataDefinitionFiles = getDataDefinitionFiles(moduleBasePath, generator);

    if (!jsonDefinitionFiles.length) {
        trace.error(`No definition files found under [${moduleBasePath}]`);
    }

    if (yargs.s) {
        trace.success(`Search found [${jsonDefinitionFiles.length}] files`);
        trace.debug(jsonDefinitionFiles);
        process.exit(0);
    }

    runDefinitionGenerator(generator, jsonDefinitionFiles, dataDefinitionFiles, false /* isLocal */).then((result) => {
        if (result){
            trace.info(`End Module definition generation [beforeCompile]`);
            trace.debug(`=====================================================================`);
        } else {
            trace.info(`No files updated`);
        }

        process.exit(0);
    }).catch((error)=>{
        trace.error(`error for [${moduleBasePath}]`);
        trace.error(error);
        process.exit(1);
    });

    trace.info('---------runDefinitionGenerator----------');
}

if (moduleDefinitionPath) {
    trace.info(`Using module definition path [${moduleDefinitionPath}]`);
    const generator = new ModuleDefinitionGenerator(process.cwd);
    generator.fileName = moduleDefinitionPath;

    if (generator.isValidJsonFile() && generator.isSupportedDefinition()) {
        if (altOutputPath) {
            trace.debug(`Changing output path from [${generator.outputPath}] to [${altOutputPath}]`);
            generator.outputPath = altOutputPath;
        }
        if (!generator.generateDefinitionInterfaces()) {
            trace.error(`Error processing given file [${moduleDefinitionPath}]`);
            process.exit(1);
        }
    } else {
        trace.error(`Invalid or not supported definition file [${moduleDefinitionPath}]`);
        process.exit(1);
    }

    process.exit(0);
}
trace.info('[End]=====================================================================');
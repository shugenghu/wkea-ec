/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const glob = require('glob');
const path = require('path');
const { generateDataDefinitionJsonFiles } = require('../data-definition-generator');
const { trace, safeReadJsonSync, getSupportedNamespaces } = require('@msdyn365-commerce/utilities-internal');

const resolvedHoistedPath = path.resolve(process.cwd(), '../..').replace(/\\/gi, '/');

const DEFINITIONS = {
    fromInstalledModules: getSupportedNamespaces().map(moduleNamespace => `${process.cwd()}/node_modules/${moduleNamespace}`),
    fromHoistedModules: getSupportedNamespaces().map(moduleNamespace => `${resolvedHoistedPath}/node_modules/${moduleNamespace}`)
};

const DEFNITION_FILE_EXTENSION = '.definition.json';
const EXTENDED_DEFINITION_FILE_EXTENSION = '.definition.ext.json';
const parentDefDependentSchemaConfig = new Map();

/**
 * Runs the module definition generator
 *
 * @param {string} moduleBasePath Absolute path to module base directory
 * @param {string[]} jsonDefinitionFiles Array of absolute paths to found definition files
 *
 * @returns {boolean} True if any files are generated, false otherwise
 */
async function runDefinitionGenerator(generator, jsonDefinitionFiles, jsonDataDefinitionFiles, isLocal) {
    let isAnyFilesUpdated = false;
    let targetFile = '';

    let installedModuleDefinitions = [];
    DEFINITIONS.fromInstalledModules.map(pathDir => {
        installedModuleDefinitions = installedModuleDefinitions.concat(getDefinitionFiles(pathDir, true));
    });

    let hoistedModuleDefinitions = [];
    DEFINITIONS.fromHoistedModules.map(pathDir => {
        hoistedModuleDefinitions = hoistedModuleDefinitions.concat(getDefinitionFiles(pathDir, true));
    });

    let definitionFilePaths = jsonDefinitionFiles
        .concat(installedModuleDefinitions)
        .concat(hoistedModuleDefinitions);

    isAnyFilesUpdated = await generateDataDefinitionJsonFiles(jsonDataDefinitionFiles, generator, isLocal);
    let warnings = [];
    if (jsonDefinitionFiles && jsonDefinitionFiles.length) {
        for (let i = 0; i < jsonDefinitionFiles.length; ++i) {
            try {
                trace.debug(`Input JSON file: [${jsonDefinitionFiles[i]}]`);
                targetFile = jsonDefinitionFiles[i];
                var result = await generator.start(jsonDefinitionFiles[i], definitionFilePaths);
                var isUpdated = result.isUpdated;
                if (isUpdated) {
                    isAnyFilesUpdated = isAnyFilesUpdated || isUpdated;
                }
                warnings = warnings.concat(result.warnings);
            } catch (e) {
                trace.error(e, `Error processing definition file [${targetFile}]`);
            }
        }
        if (warnings.length > 0) {
            trace.warn(`-----WARNINGS-----`);
            trace.warn(`The following warnings were discovered when running the definition generator`);
            warnings.forEach(warning => {
                trace.warn(warning);
            });
        }
    }

    if (generator.processingErrors.length > 0) {
        trace.error(`[${generator.processingErrors.length}] Error${generator.processingErrors.length > 1 ? 's' : ''} detected`);
        generator.processingErrors.forEach(err => trace.error(err));

        // TODO: To enforce build failure when errors are encountered will uncomment following line. Now it just display error/warning messages.
        // process.exit(1);
    }

    return isAnyFilesUpdated;
}

/**
 * Gets all JSON files under basedir
 *
 * @param {string} baseDir Path to base directory to search under
 *
 * @returns {string[]} Array of absolute path to files found or an empty array
 */
function getDefinitionFiles(baseDir, searchNodeModules = false) {
    const matchList = [];

    try {
        baseDir = path.resolve(baseDir);
        if (searchNodeModules && !fs.existsSync(baseDir)) {
            return [];
        }
        if (baseDir && fs.lstatSync(baseDir).isDirectory()) {
            trace.debug(`Getting all definition JSON files under [${baseDir}]`);
            const pattern = searchNodeModules
                ? `${baseDir}/*/dist/lib/**/*definition.json`
                : `${baseDir}/**/src/**/*definition.{ext.json,json}`;
            const ignorePaths = searchNodeModules ? ['**/build/**'] : ['**/node_modules/**', '**/build/**'];
            glob.sync(pattern, { cwd: baseDir, ignore: ignorePaths }).filter(item => {
                if (fs.lstatSync(item).isFile()) {
                    matchList.push(item);
                } else {
                    trace.warn(`Found item [${item}] that is not a JSON file`);
                }
            });
            trace.debug(`Found [${matchList.length}] definition JSON files`);
            trace.debug(`Definition JSON files [${matchList}]`);
            // If the provided base dir is not a valid directory and we are not searching node_modules
            // indicate an error. The reason an error is not shown when searching node_modules is because
            // it is a valid scenario that there are no installed modules with definition files
        } else if (!searchNodeModules) {
            trace.error(`Parameter baseDir [${baseDir}] is not defined or not a directory`);
        }
    } catch (e) {
        trace.error(e, `Error getting all definition JSON files under [${baseDir}]`);
    }
    return matchList;
}

/**
 * Merges an extended definition json with its parent
 */
function mergeExtendedDefinitionFile(jsonExtendedDefinitionFile, definitionFilePaths) {
    const parentDefinitionFile = findParentDefinitionFile(jsonExtendedDefinitionFile, definitionFilePaths);
    if (!parentDefinitionFile) {
        // If unable to find the parent definition file, error out the build
        trace.error(`Unable to find parent definition file for file ${jsonExtendedDefinitionFile}`);
        throw new Error(`Unable to find parent definition file for file ${jsonExtendedDefinitionFile}`);
    }
    const parentDefJson = safeReadJsonSync(parentDefinitionFile);
    const extendedDefJson = safeReadJsonSync(jsonExtendedDefinitionFile);

    if (extendedDefJson['$type'] !== 'definitionExtension') {
        trace.error(`Extended definition file must declare '$type' as 'definitionExtension'`);
        throw new Error(`Extended definition file must declare '$type' as 'definitionExtension'`);
    }

    // Add the extension config properties
    extendProperty(extendedDefJson, parentDefJson, 'config');

    // Maps the config properties present in dependentSchemas property of extended definition to 
    // parent config property for definition generator to handle dependency schema
    if (extendedDefJson['dependentSchemas']) {
        const extendedModuleName = path.basename(jsonExtendedDefinitionFile);
        mapDependenciesProperties(extendedDefJson, parentDefJson, 'config', extendedModuleName);
    }

    // Remove the properties that are part of the disableParentConfigProperties array
    if (Array.isArray(extendedDefJson.disableConfigProperties)) {
        const configPropertiesToDelete = extendedDefJson.disableConfigProperties;
        for (let i = 0; i < configPropertiesToDelete.length; i++) {
            delete parentDefJson.config[configPropertiesToDelete[i]];
        }
    }

    // Add extension slots
    extendProperty(extendedDefJson, parentDefJson, 'slots');

    // Add extension resources
    extendProperty(extendedDefJson, parentDefJson, 'resources');
    return parentDefJson;
}

/**
 * Maps the config properties defined in dependentSchemas of extended definition to parent definition- config property 
 * @param {*} extendedDfn 
 * @param {*} parentDfn 
 * @param {*} propertyType 
 */
function mapDependenciesProperties(extendedDfn, parentDfn, propertyType, extendedModuleName) {
    if (!parentDfn[propertyType]) {
        return;
    }
    parentDfn[propertyType] = parentDfn[propertyType] || {};
    const dependenciesProperty = extendedDfn['dependentSchemas'];
    const entries = dependenciesProperty && Object.keys(dependenciesProperty);
    if (entries && entries.length > 0) {
        const parentDefinitionExtProperties = parentDfn[propertyType];
        if (parentDefinitionExtProperties) {
            shouldExtendDependentConfigProperty(entries, dependenciesProperty, parentDefinitionExtProperties, propertyType, false, extendedModuleName);
        }
    }
}


/**
 * Helper function to traverse through dependentSchemas config properties
 * @param {*} entries 
 * @param {*} dependenciesProperty 
 * @param {*} parentDefinitionExtProperties 
 * @param {*} propertyType  
 */
function shouldExtendDependentConfigProperty(entries, dependenciesProperty, parentDefinitionExtProperties, propertyType, isExtendConfigProperty, moduleName) {
    entries.forEach(key => {
        const selectorProperty = dependenciesProperty[key];
        if (selectorProperty) {
            if (selectorProperty['oneOf']) {
                const oneOf = selectorProperty['oneOf']
                for (let i = 0; i < oneOf.length; i++) {
                    const extendedproperties = oneOf[i]['properties'];
                    if (extendedproperties) {
                        // Break the build if, dependentSchema does not contain selector property of type enum in oneOf
                        if(!extendedproperties[key]) {
                            trace.error(`DependentSchema error: ${moduleName} dependentSchema does not contain ${propertyType} value '${key}' of type enum in OneOf property.`);
                            process.exit(1);
                        } else {
                            // Break the build if, in dependentSchema-OneOf, the selector property is not of type enum
                            const extendedpropertiesKeys = Object.keys(extendedproperties[key]);
                            if(!extendedproperties[key][`enum`]) {
                                trace.error(`DependentSchema error: ${moduleName} dependentSchema ${propertyType} value '${key}' in OneOf property does not contain 'enum' property.`);
                                process.exit(1);
                            }
                            // Break the build if, in dependentSchema-OneOf, the selector property contains any property other than enum type
                            else if(extendedpropertiesKeys.length > 1) {
                                trace.error(`DependentSchema error: ${moduleName} dependentSchema ${propertyType} value '${key}' in OneOf property should only contains 'enum' property.`);
                                process.exit(1);
                            }
                        }
                        replaceIfPropExistsInParentDef(extendedproperties, key, parentDefinitionExtProperties, propertyType, isExtendConfigProperty);
                    }
                }
            }
            if (selectorProperty[`properties`]) {
                const extendedproperties = selectorProperty[`properties`];
                replaceIfPropExistsInParentDef(extendedproperties, key, parentDefinitionExtProperties, propertyType, isExtendConfigProperty);
            }
        }
    })
}

/**
 * Function that checks and replaces the config properties that exist in parent definition and in dependencies
 * Scenarios and expected result for contextual property panel -dependentSchemas handles on SDK end:
 *  a) Dependency Schema only in definition extension, uses all properties inside the definition extension 
 *     (ex: content block)  - Apply dependency schema. 
 
 *  b) Dependency schema only in module definition. No conflicts between properties inside dependency schema 
       and definition extension. - Apply dependency schema.

    c) Dependency schema only in module definition. Conflicts between properties inside dependency schema and 
       definition extension. i.e. PROP A inside dependency schema of Module definition is declared as is in Definition extension 
       without dependency schema - Throw exception 

 * @param {*} extendedproperties
 * @param {*} key
 * @param {*} parentDefinitionExtProperties
 * @param {*} propertyType
 */
function replaceIfPropExistsInParentDef(extendedProperties, key, parentDefinitionExtProperties, propertyType, isExtendConfigProperty) {
    for (const propertyKey in extendedProperties) {
        if (!isExtendConfigProperty) {
            if (propertyKey !== 'moduleLayout' && propertyKey !== key) {
                replaceConfigProperty(parentDefinitionExtProperties, propertyKey, extendedProperties, propertyType);
            }
        } else if (isExtendConfigProperty && propertyKey !== key) {
            // Adding all the config properties from Dependent-Schemas parent Definition to a map.
            // To handle edge case where if prop A exsist in parent definition-dependentSchemas and in Config of extended definition, we break the build.
            parentDefDependentSchemaConfig.set(propertyKey, true);
        }
    }
}

/**
 * Function to use the config property of Extended definition if same property exisit in parent definition
 * @param {*} parentDefinitionExtProperties
 * @param {*} propertyKey
 * @param {*} extendedProperties
 * @param {*} propertyType
 */
function replaceConfigProperty(parentDefinitionExtProperties, propertyKey, extendedProperties, propertyType) {
    if (parentDefinitionExtProperties[propertyKey]) {
        trace.warn(
            `${propertyType} value '${propertyKey}' already exists in parent definition. The property defined in extended definition will be applied`
        );
    }
    parentDefinitionExtProperties[propertyKey] = extendedProperties[propertyKey];
}

/**
 * Extends a parent property with the extended definition properties
 * @param {*} extendedDfn
 * @param {*} parentDfn
 * @param {*} propertyType
 */
function extendProperty(extendedDfn, parentDfn, propertyType) {
    if (!parentDfn[propertyType] && !extendedDfn[propertyType]) {
        return;
    }

    parentDfn[propertyType] = parentDfn[propertyType] || {};
    const parentDefinitionExtProperties = parentDfn[propertyType];
    if (parentDfn[`dependentSchemas`] && propertyType === 'config') {
        const entries = parentDfn[`dependentSchemas`] && Object.keys(parentDfn[`dependentSchemas`]);
        if (entries && entries.length > 0) {
            shouldExtendDependentConfigProperty(entries, parentDfn[`dependentSchemas`], parentDefinitionExtProperties, propertyType, true);
        }
    }

    const extendedProperties = extendedDfn[propertyType];
    for (const propertyKey in extendedProperties) {
        if (propertyType === 'config') {
            // Break the build if property A exists in parent definition-dependentSchemas and in Config of extended definition.
            if (!parentDefDependentSchemaConfig.has(propertyKey)) {
                replaceConfigProperty(parentDefinitionExtProperties, propertyKey, extendedProperties, propertyType);
            } else {
                throw new Error(`${propertyType} value '${propertyKey}' already exisist in 'dependentSchemas' of ${parentDfn[`name`]} definition. Please remove the ${propertyType} value '${propertyKey} from extended definition or build to succeed.`)
            }
        }
        else {
            replaceConfigProperty(parentDefinitionExtProperties, propertyKey, extendedProperties, propertyType);
        }
    }
}

/**
 * Searches the list of installed and local definition files to find the extended definition's
 * parent file
 * @param {*} fileName The extended definition filename
 */
function findParentDefinitionFile(fileName, definitionFiles) {
    // Find the parent module name based on convention (e.g. for hero.definition.ext.json the parent file should be hero.definition.json)
    const parentModuleName = path.basename(fileName, EXTENDED_DEFINITION_FILE_EXTENSION);

    // Check for the existence for a file that ends with the required parent definition file
    return definitionFiles.find(filePath => path.basename(filePath, DEFNITION_FILE_EXTENSION) === parentModuleName);
}

/**
 * Initialize debugger listener
 */
function initDebugger() {
    if (process.env.autogendebugger) {
        process._debugProcess(process.pid);
    }
}

const helpers = {
    getDefinitionFiles,
    initDebugger,
    runDefinitionGenerator,
    mergeExtendedDefinitionFile,
    extendProperty,
    findParentDefinitionFile,
    shouldExtendDependentConfigProperty,
    DEFNITION_FILE_EXTENSION,
    EXTENDED_DEFINITION_FILE_EXTENSION
};

module.exports = helpers;

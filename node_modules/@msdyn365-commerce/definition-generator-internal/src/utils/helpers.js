/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const glob = require('glob');
const path = require('path');
const { generateDataDefinitionJsonFiles } = require('../data-definition-generator');
const { trace, safeReadJsonSync, getSupportedNamespaces } = require('@msdyn365-commerce/utilities-internal');

const resolvedHoistedPath = path.resolve(process.cwd(), '../..').replace(/\\/gi, '/');

const DEFINITIONS = {
    fromInstalledModules: getSupportedNamespaces().map(moduleNamespace => `${process.cwd()}/node_modules/${moduleNamespace}`),
    fromHoistedModules: getSupportedNamespaces().map(moduleNamespace => `${resolvedHoistedPath}/node_modules/${moduleNamespace}`)
};

const DEFNITION_FILE_EXTENSION = '.definition.json';
const EXTENDED_DEFINITION_FILE_EXTENSION = '.definition.ext.json';

/**
 * Runs the module definition generator
 *
 * @param {string} moduleBasePath Absolute path to module base directory
 * @param {string[]} jsonDefinitionFiles Array of absolute paths to found definition files
 *
 * @returns {boolean} True if any files are generated, false otherwise
 */
async function runDefinitionGenerator(generator, jsonDefinitionFiles, jsonDataDefinitionFiles, isLocal) {
    let isAnyFilesUpdated = false;
    let targetFile = '';

    let installedModuleDefinitions = [];
    DEFINITIONS.fromInstalledModules.map(pathDir => {
        installedModuleDefinitions = installedModuleDefinitions.concat(getDefinitionFiles(pathDir, true));
    });

    let hoistedModuleDefinitions = [];
    DEFINITIONS.fromHoistedModules.map(pathDir => {
        hoistedModuleDefinitions = hoistedModuleDefinitions.concat(getDefinitionFiles(pathDir, true));
    });

    let definitionFilePaths = jsonDefinitionFiles
        .concat(installedModuleDefinitions)
        .concat(hoistedModuleDefinitions);

    isAnyFilesUpdated = await generateDataDefinitionJsonFiles(jsonDataDefinitionFiles, generator, isLocal);
    let warnings = [];
    if (jsonDefinitionFiles && jsonDefinitionFiles.length) {
        for (let i = 0; i < jsonDefinitionFiles.length; ++i) {
            try {
                trace.debug(`Input JSON file: [${jsonDefinitionFiles[i]}]`);
                targetFile = jsonDefinitionFiles[i];
                var result = await generator.start(jsonDefinitionFiles[i], definitionFilePaths);
                var isUpdated = result.isUpdated;
                if (isUpdated) {
                    isAnyFilesUpdated = isAnyFilesUpdated || isUpdated;
                }
                warnings = warnings.concat(result.warnings);
            } catch (e) {
                trace.error(e, `Error processing definition file [${targetFile}]`);
            }
        }
        if (warnings.length > 0) {
            trace.warn(`-----WARNINGS-----`);
            trace.warn(`The following warnings were discovered when running the definition generator`);
            warnings.forEach(warning => {
                trace.warn(warning);
            });
        }
    }

    if (generator.processingErrors.length > 0) {
        trace.error(`[${generator.processingErrors.length}] Error${generator.processingErrors.length > 1 ? 's' : ''} detected`);
        generator.processingErrors.forEach(err => trace.error(err));

        // TODO: To enforce build failure when errors are encountered will uncomment following line. Now it just display error/warning messages.
        // process.exit(1);
    }

    return isAnyFilesUpdated;
}

/**
 * Gets all JSON files under basedir
 *
 * @param {string} baseDir Path to base directory to search under
 *
 * @returns {string[]} Array of absolute path to files found or an empty array
 */
function getDefinitionFiles(baseDir, searchNodeModules = false) {
    const matchList = [];

    try {
        baseDir = path.resolve(baseDir);
        if (searchNodeModules && !fs.existsSync(baseDir)) {
            return [];
        }
        if (baseDir && fs.lstatSync(baseDir).isDirectory()) {
            trace.debug(`Getting all definition JSON files under [${baseDir}]`);
            const pattern = searchNodeModules
                ? `${baseDir}/*/dist/lib/**/*definition.json`
                : `${baseDir}/**/src/**/*definition.{ext.json,json}`;
            const ignorePaths = searchNodeModules ? ['**/build/**'] : ['**/node_modules/**', '**/build/**'];
            glob.sync(pattern, { cwd: baseDir, ignore: ignorePaths }).filter(item => {
                if (fs.lstatSync(item).isFile()) {
                    matchList.push(item);
                } else {
                    trace.warn(`Found item [${item}] that is not a JSON file`);
                }
            });
            trace.debug(`Found [${matchList.length}] definition JSON files`);
            trace.debug(`Definition JSON files [${matchList}]`);
            // If the provided base dir is not a valid directory and we are not searching node_modules
            // indicate an error. The reason an error is not shown when searching node_modules is because
            // it is a valid scenario that there are no installed modules with definition files
        } else if (!searchNodeModules) {
            trace.error(`Parameter baseDir [${baseDir}] is not defined or not a directory`);
        }
    } catch (e) {
        trace.error(e, `Error getting all definition JSON files under [${baseDir}]`);
    }
    return matchList;
}

/**
 * Merges an extended definition json with its parent
 */
function mergeExtendedDefinitionFile(jsonExtendedDefinitionFile, definitionFilePaths) {
    const parentDefinitionFile = findParentDefinitionFile(jsonExtendedDefinitionFile, definitionFilePaths);
    if (!parentDefinitionFile) {
        // If unable to find the parent definition file, error out the build
        trace.error(`Unable to find parent definition file for file ${jsonExtendedDefinitionFile}`);
        throw new Error(`Unable to find parent definition file for file ${jsonExtendedDefinitionFile}`);
    }
    const parentDefJson = safeReadJsonSync(parentDefinitionFile);
    const extendedDefJson = safeReadJsonSync(jsonExtendedDefinitionFile);

    if (extendedDefJson['$type'] !== 'definitionExtension') {
        trace.error(`Extended definition file must declare '$type' as 'definitionExtension'`);
        throw new Error(`Extended definition file must declare '$type' as 'definitionExtension'`);
    }

    // Add the extension config properties
    extendProperty(extendedDefJson, parentDefJson, 'config');

    // Maps the config properties present in dependencies property of extended definition to 
    // parent config property for definition generator to handle dependency schema
    if (extendedDefJson['dependencies']) {
        mapDependenciesProperties(extendedDefJson, parentDefJson, 'config');
    }

    // Remove the properties that are part of the disableParentConfigProperties array
    if (Array.isArray(extendedDefJson.disableConfigProperties)) {
        const configPropertiesToDelete = extendedDefJson.disableConfigProperties;
        for (let i = 0; i < configPropertiesToDelete.length; i++) {
            delete parentDefJson.config[configPropertiesToDelete[i]];
        }
    }

    // Add extension slots
    extendProperty(extendedDefJson, parentDefJson, 'slots');

    // Add extension resources
    extendProperty(extendedDefJson, parentDefJson, 'resources');
    return parentDefJson;
}

/**
 * Maps the config properties defined in dependencies of extended definition to parent definition- config property 
 * @param {*} extendedDfn 
 * @param {*} parentDfn 
 * @param {*} propertyType 
 */
function mapDependenciesProperties(extendedDfn, parentDfn, propertyType) {
    if (!parentDfn[propertyType]) {
        return;
    }
    parentDfn[propertyType] = parentDfn[propertyType] || {};
    const dependenciesProperty = extendedDfn['dependencies']['moduleLayout']['oneOf'];
    const parentDefinitionExtProperties = parentDfn[propertyType];
    for (let i = 0; i < dependenciesProperty.length; i++) {
        const extendedproperties = dependenciesProperty[i]['properties'];
        for (const propertyKey in extendedproperties) {
            if (propertyKey !== 'moduleLayout') {
                if (parentDefinitionExtProperties[propertyKey]) {
                    trace.warn(
                        `${propertyType} value '${propertyKey}' already exists in parent definition. The property defined in extended definition- dependencies, will be applied`
                    );
                }
                parentDefinitionExtProperties[propertyKey] = extendedproperties[propertyKey];
            }
        }
    }
}

/**
 * Extends a parent property with the extended definition properties
 * @param {*} extendedDfn
 * @param {*} parentDfn
 * @param {*} propertyType
 */
function extendProperty(extendedDfn, parentDfn, propertyType) {
    if (!parentDfn[propertyType] && !extendedDfn[propertyType]) {
        return;
    }

    parentDfn[propertyType] = parentDfn[propertyType] || {};
    const extendedProperties = extendedDfn[propertyType];
    const parentDefinitionExtProperties = parentDfn[propertyType];
    for (const propertyKey in extendedProperties) {
        if (parentDefinitionExtProperties[propertyKey]) {
            trace.warn(
                `${propertyType} value '${propertyKey}' already exists in parent definition. The property defined in extended definition will be applied`
            );
        }

        parentDefinitionExtProperties[propertyKey] = extendedProperties[propertyKey];
    }
}

/**
 * Searches the list of installed and local definition files to find the extended definition's
 * parent file
 * @param {*} fileName The extended definition filename
 */
function findParentDefinitionFile(fileName, definitionFiles) {
    // Find the parent module name based on convention (e.g. for hero.definition.ext.json the parent file should be hero.definition.json)
    const parentModuleName = path.basename(fileName, EXTENDED_DEFINITION_FILE_EXTENSION);

    // Check for the existence for a file that ends with the required parent definition file
    return definitionFiles.find(filePath => path.basename(filePath, DEFNITION_FILE_EXTENSION) === parentModuleName);
}

/**
 * Initialize debugger listener
 */
function initDebugger() {
    if (process.env.autogendebugger) {
        process._debugProcess(process.pid);
    }
}

const helpers = {
    getDefinitionFiles,
    initDebugger,
    runDefinitionGenerator,
    mergeExtendedDefinitionFile,
    extendProperty,
    findParentDefinitionFile,
    DEFNITION_FILE_EXTENSION,
    EXTENDED_DEFINITION_FILE_EXTENSION
};

module.exports = helpers;

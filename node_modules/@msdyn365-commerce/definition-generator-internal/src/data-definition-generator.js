/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const { camelCase } = require('lodash');
const typeson = require('typescript-json-schema');
const buildUtils = require('@msdyn365-commerce/utilities-internal');
const path = require('path');
const trace = buildUtils.trace;

const REF_DEFINITIONS_SUFFIX = '#/definitions/';
const DATA_ACTIONS_REGEX = new RegExp('@dataAction[\\s]*[\'\\"]?(@[\\w\\-\\/\\.\\\\]+)', 'ig');

/**
 * Generates data definition files for the given list of data.ts files in modules
 * @param {string[]} jsonDataDefinitionFiles
 */
async function generateDataDefinitionJsonFiles(jsonDataTypeDefinitionFiles, defGenerator, isLocal) {
    if (jsonDataTypeDefinitionFiles && jsonDataTypeDefinitionFiles.length > 0) {
        return generateDefinitionFiles(
            jsonDataTypeDefinitionFiles,
            {
                allowedKeywords: ['friendlyName', 'description', 'max', 'typeName', 'required', 'dataAction', 'runAt'],
                titles: false,
                type: 'definitions',
                inputFileExtensionRegex: /\.ts/ig,
                logFriendlyName: 'data definition'
            },
            defGenerator,
            isLocal
        );
    }

    return Promise.resolve(false);
}

/**
 * Generates data definition files for the given list of data.ts files in modules
 * @param {string[]} definitionFiles
 */
async function generateDefinitionFiles(definitionFiles, options, defGenerator, isLocal) {
    if (!definitionFiles || definitionFiles.length === 0) {
        return false;
    }

    // typeson schema generator options
    const settings = {
        required: false,
        maxNodeModuleJsDepth: 1,
        aliasRef: true,
        refs:true,
        ignoreErrors: true,
        validationKeywords: options.allowedKeywords
    };

    // typeson compiler options
    const compilerOptions = {
        strictNullChecks: false,
        maxNodeModuleJsDepth: 1
    };

    const program = typeson.getProgramFromFiles(definitionFiles, compilerOptions, '*');
    const generator = typeson.buildGenerator(program, settings);

    let isUpdated = false;
    if (generator) {
        const allDataInterfaces = generator.getMainFileSymbols(program);
        const promises = [];
        definitionFiles.forEach(definitionFile => {
            promises.push(
                new Promise(async (resolve, reject) => {
                    const dataFileNameWithoutExtension = path.basename(definitionFile.replace(options.inputFileExtensionRegex, ''));
                    const entryDataInterface = getEntryDataInterfaceName(dataFileNameWithoutExtension);
                    if (allDataInterfaces.indexOf(entryDataInterface) !== -1) {
                        try {
                            const moduleName = path.basename(path.dirname(definitionFile));
                            let dataDefinitionOutput = generator.getSchemaForSymbol(entryDataInterface, true);                                
                            dataDefinitionOutput = await filterInvalidDataTypes(dataDefinitionOutput, path.resolve(process.cwd(), definitionFile));
                            dataDefinitionOutput.moduleName = moduleName;
                            const generatedFileLoc = path.resolve(
                                process.cwd(),
                                `${
                                    isLocal ? `build/${options.type}` : 'dist/lib/modules'
                                }/${moduleName}/${dataFileNameWithoutExtension}.json`
                            );

                            trace.info(`Generating ${options.logFriendlyName} file: ${generatedFileLoc}`);

                            await buildUtils.safeWriteJson(generatedFileLoc, dataDefinitionOutput);
                            isUpdated = true;
                            resolve();
                        } catch (error) {
                            defGenerator.processingErrors.push(`Could not generate ${options.logFriendlyName} ${entryDataInterface} for file: ${definitionFile} ${error}`);
                            reject(error);
                        }
                    } else {
                        trace.error(`Missing entry data interface ${entryDataInterface} in definition file ${definitionFile}`);
                        trace.error(definitionFiles);
                        resolve();
                    }
                })
            );
        });

        if (promises.length > 0) {
            trace.info(`Generating ${options.logFriendlyName} json files...`);
            await Promise.all(promises).catch(err => {
                defGenerator.processingErrors.push(`Error in data-definition generator: ${err}`);
            });
        }
    }

    return isUpdated;
}

async function getDataActions(definitionFileAbsolutePath) {
    // no path, no data actions
    if (!definitionFileAbsolutePath) {
        return [];
    }
    const definitionTS = await buildUtils.safeReadFile(definitionFileAbsolutePath);
    if (!definitionTS) {
        trace.error(`Failed processing file: ${definitionFileAbsolutePath}`)
        process.exit(1);
    }

    const dataActions = [];
    try {
        let hasMorePlaceHolders = true;
        while (hasMorePlaceHolders) {
            const dataActionTokens = DATA_ACTIONS_REGEX.exec(definitionTS.toString());
            if (dataActionTokens && dataActionTokens.length > 0) {
                dataActions.push(dataActionTokens[1]);
            } else {
                hasMorePlaceHolders = false;
            }

        }
    } catch(e) {
        trace.error(`Failed processing file: ${definitionFileAbsolutePath}`);
        trace.error(e);
        process.exit(1);
    }

    return dataActions;
}

/**
 * filterFromDAPIs properties which are not data-types. An interface is considered as a valid datatype only
 * if it is marked with typeName property in its js-doc. It is important to strip off data definition files
 * of such properties to prevent noise which could break tooling.
 * @param {string} entryDefinition
 * @param {object} allDataTypes
 */
async function filterInvalidDataTypes(entryDefinition, definitionFilePath) {
    const allDataTypeDefinitions = entryDefinition.definitions;

    // Iterate over all properties of entry data interface       
    if (entryDefinition.properties) {        
        const dataActionsQueue = await getDataActions(definitionFilePath);        

        let nextDataActionIndex = 0;
        Object.keys(entryDefinition.properties).forEach(eachDataTypePropertyKey => {                
            const eachDataTypeProperty = entryDefinition.properties[eachDataTypePropertyKey];

            if (eachDataTypeProperty.dataAction === '' && dataActionsQueue[nextDataActionIndex]) {
                eachDataTypeProperty.dataAction = dataActionsQueue[nextDataActionIndex];
                nextDataActionIndex++;
            }

            // If $ref property is found, that means its a referenced type
            if (eachDataTypeProperty.$ref) {
                // Extract the type name by removing the REF_DEFINITIONS_SUFFIX
                const dataTypeName = eachDataTypeProperty.$ref.replace(REF_DEFINITIONS_SUFFIX, '');

                // If a type contains typeName annotation/property defined in its js-doc then its a valid
                // data type. Therefore, let us search for the type in allTypeDefinitions with typeName defined
                if (allDataTypeDefinitions[dataTypeName] && allDataTypeDefinitions[dataTypeName].typeName) {
                    // replace the dataDefinitionTypeName with typeName specified in the datatype
                    entryDefinition.properties[eachDataTypePropertyKey].$ref = `${REF_DEFINITIONS_SUFFIX}${allDataTypeDefinitions[dataTypeName].typeName}`
                } else if (!eachDataTypeProperty.required) {
                    // Any data definition without typeName defined should be stripped off from dapi response.
                    // These properties cause noise and break tooling. Lets mark them to be filtered.
                    entryDefinition.properties[eachDataTypePropertyKey].filterFromDAPI = true;
                }

              // In case if the property type is array, $ref property will be present inside items
            } else if (eachDataTypeProperty.type === 'array' && eachDataTypeProperty.items.$ref) {
                // Extract the type name by removing the REF_DEFINITIONS_SUFFIX
                const dataTypeName = eachDataTypeProperty.items.$ref.replace(REF_DEFINITIONS_SUFFIX, '');

                // If a type contains typeName annotation/property defined in its js-doc then its a valid
                // data type. Therefore, let us search for the type in allTypeDefinitions with typeName defined
                if (allDataTypeDefinitions[dataTypeName] && allDataTypeDefinitions[dataTypeName].typeName) {
                    // replace the dataDefinitionTypeName with typeName specified in the datatype
                    entryDefinition.properties[eachDataTypePropertyKey].items.$ref = `${REF_DEFINITIONS_SUFFIX}${allDataTypeDefinitions[dataTypeName].typeName}`;
                } else if (!eachDataTypeProperty.required) {
                    // Any data definition without typeName defined should be stripped off from dapi response.
                    // These properties cause noise and break tooling. Lets mark them to be filtered.
                    entryDefinition.properties[eachDataTypePropertyKey].filterFromDAPI = true;
                }                 
            } else if (!eachDataTypeProperty.typeName && !eachDataTypeProperty.required) {
                entryDefinition.properties[eachDataTypePropertyKey].filterFromDAPI = true;
            }
        }
    )};

    delete entryDefinition.definitions;

    return entryDefinition;
}

/**
 * Gets all data definition files under basedir
 * eg: <rootDir>/src/modules/partner-hero/partner-hero.data.ts
 *
 * @param {string} baseDir Path to base directory to search under
 *
 * @returns {string[]} Array of absolute path to files found or an empty array
 */
function getDataDefinitionFiles(baseDir, defGenerator) {
    return getDefinitionFiles(baseDir, 'src/**/*.data.ts', ['**/node_modules/**', '**/build/**'], 'Data definition', defGenerator);
}

/**
 * Gets all data definition files under basedir
 *
 * @param {string} baseDir Path to base directory to search under
 *
 * @returns {string[]} Array of absolute path to files found or an empty array
 */
function getDefinitionFiles(baseDir, inputFilePath, ignoreFolders, logFriendlyName, defGenerator) {
    const matchList = [];

    try {
        baseDir = path.resolve(baseDir);

        if (baseDir && fs.lstatSync(baseDir).isDirectory()) {
            trace.debug(`Getting all ${logFriendlyName} files under [${baseDir}]`);

            buildUtils.safeGetAllFilesPathSync(inputFilePath, trace, { cwd: baseDir, ignore: ignoreFolders }).filter(item => {
                if (fs.lstatSync(item).isFile()) {
                    matchList.push(item);
                } else {
                    trace.warn(`Found item [${item}] that is not ${logFriendlyName} file`);
                }
            });

            trace.debug(`Found [${matchList.length}] ${logFriendlyName} files`);
            trace.debug(`${logFriendlyName} files [${matchList}]`);
        } else {
            defGenerator.processingErrors.push(`Parameter baseDir [${baseDir}] is not defined or not a directory`);
        }
    } catch (e) {
        defGenerator.processingErrors.push(e, `Error getting all ${logFriendlyName} files under [${baseDir}]`);
    }

    return matchList;
}

/**
 * Constructs entry data interface for a given module name.
 * Entry data interface name should be of the form I<module_name>Data
 * @param {string} moduleName
 */
function getEntryDataInterfaceName(moduleName) {
    moduleName = camelCase(moduleName);
    return 'I' + moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
}

const dataDefinitionGenerator = {
    generateDataDefinitionJsonFiles,
    getDataActions,
    filterInvalidDataTypes,
    getDataDefinitionFiles
};

module.exports = dataDefinitionGenerator;

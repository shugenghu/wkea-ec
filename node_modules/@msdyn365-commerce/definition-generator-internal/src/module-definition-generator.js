/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const path = require('path');
const prettier = require('prettier');
const utilities = require('@msdyn365-commerce/utilities-internal');
const trace = utilities.trace;
const { mergeExtendedDefinitionFile, EXTENDED_DEFINITION_FILE_EXTENSION } = require('./utils/helpers');

const prettierRules = {
    tabWidth: 4,
    useTabs: false,
    singleQuote: true,
    parser: 'typescript',
    printWidth: 110
};

const resourcesDefinition = 'resourcesDefinition';
const dataBinderDefinition = 'dataBinderDefinition';
const DEFAULT_CSS_CLASS_NAME_FIELD = '__cssClassName__';

// Script to generate module definition .ts files from JSON schema
class ModuleDefinitionGenerator {
    constructor(moduleBasePath) {
        // moduleBasePath: The absolute path to root folder of current node module where package.json exists.
        this.moduleBasePath = moduleBasePath;
        // latestTime: The latest time obtained from all definition files processed, used to update schema timestamp with.
        this.latestTime = undefined;
        // json: The parsed JSON from current definition file being processed.
        this.json = null;
        // definitionType: The current definition file type.
        this.definitionType = '';
        // processingErrors: Stores all errors ecountered through processing all definition files for reporting and failing build.
        this.processingErrors = [];
        // jsonFilePath: The absolute path to the current JSON definition file being processed.
        this.jsonFilePath = '';
        // fileName: The name of current definition file
        this.fileName = '';
        // moduleName: The name obtained from current module definition being processed
        this.moduleName = '';
        // moduleInterfaceName: The interface name generated based on current moduleName
        this.moduleInterfaceName = '';
        // outputPath: The absolute path to output directory. Defaults to ../.. from source definition file.
        this.outputPath = '';
        // propsFileName: The name of the generated props TS file based on current moduleName and definition type.
        this.propsFileName = '';
        // isResourcesGenerated: Flag to indicate if resources interface is generated
        this.isResourcesGenerated = false;
        // isConfigGenerated: Flag to indicate if configuration interface is generated
        this.isConfigGenerated = false;
        // isModulesGenerated: Flag to indicate if container modules iterface is generated
        this.isModulesGenerated = false;
        // isPropsGenerated: Flag to indicate if any props are generated.
        this.isPropsGenerated = false;
        // customObjectsToGenerate: Keeps track of the custom objects that will need to be generated
        this.customObjectsToGenerate = [];
        // definitionObjectsToInterfaceName: Maps an object field name from the definitions section to its interface name
        this.definitionObjectsToInterfaceName = {};
        // localRefsToInterfaceName: If a config property points to a local ref object, this maps the config property name to the object interface name
        this.localRefsToInterfaceName = {};
        // objectsFromLocalDefinitions: String that contains the actual generated TypeScript interfaces for the objects in local definitions section
        this.objectsFromLocalDefinitions = '';
        // isExtendedDefinition: Indicates whether the current file is an extended definition file
        this.isExtendedDefinition = false;
        // allDefinitionFiles: Contains a list of file paths to all definition files, local and installed
        this.allDefinitionFiles = [];
        // configInterfaceTitle: Used to store the config interface title
        this.configInterfaceTitle = '';
        // warnings: Stores a list of warnings the definition generator encounters
        this.warnings = [];
    }

    /**
     * Resets all instance variables used in processing each definition file
     *
     */
    resetValues() {
        this.json = null;
        this.definitionType = '';
        this.jsonFilePath = '';
        this.fileName = '';
        this.moduleName = '';
        this.moduleInterfaceName = '';
        this.outputPath = '';
        this.propsFileName = '';
        this.isResourcesGenerated = false;
        this.isConfigGenerated = false;
        this.isModulesGenerated = false;
        this.isPropsGenerated = false;
        this.customObjectsToGenerate = [];
        this.definitionObjectsToInterfaceName = {};
        this.localRefsToInterfaceName = {};
        this.objectsFromLocalDefinitions = '';
        this.isExtendedDefinition = false;
        this.configInterfaceTitle = '';
        this.warnings = [];
    }

    /**
     * The main entry point to processing a definition file.
     *
     * @param {string} srcJsonFilePath Src path of the definition file to be processed.
     * Returns an object containing warnings, errors from processing the definition file and whether the file was updated
     */
    async start(srcJsonFilePath, definitionFilesPaths) {
        this.resetValues();
        if (this.allDefinitionFiles.length === 0) {
            this.allDefinitionFiles = definitionFilesPaths;
        }
        let isUpdated = false;

        if ((await this.isValidJsonFile(srcJsonFilePath)) && this.isSupportedDefinition()) {
            trace.info(`Processing [${this.definitionType}] file: [${this.fileName}]`);
            isUpdated = this.generateDefinitionInterfaces();
        }
        return { isUpdated: isUpdated, warnings: this.warnings };
    }

    /**
     * Verify current file is a valid json definition file
     *
     * @param {string} srcJsonFilePath Src path of the definition file to be processed.
     * @returns {boolean} True if file is a valid json definition file, false otherwise.
     */
    async isValidJsonFile(srcJsonFilePath) {
        const jsonExtRegex = /\.json/i;
        try {
            if (srcJsonFilePath && srcJsonFilePath.trim()) {
                this.jsonFilePath = path.resolve(srcJsonFilePath.trim());
                this.fileName = path.basename(this.jsonFilePath);
            } else {
                trace.error(`Undefined or empty path to JSON file [${srcJsonFilePath}]`);
                return false;
            }

            if (!this.jsonFilePath || !jsonExtRegex.test(path.extname(this.jsonFilePath))) {
                trace.warn(`Not a JSON file [${this.jsonFilePath}]`);
                return false;
            }

            let defJSON;
            // If we are reading an extended definition, merge with the parent definition
            if (this.jsonFilePath.endsWith(EXTENDED_DEFINITION_FILE_EXTENSION)) {
                try {
                    defJSON = mergeExtendedDefinitionFile(this.jsonFilePath, this.allDefinitionFiles);
                } catch (err) {
                    trace.error(err);
                    trace.error(`Error processing extended definition file ${this.jsonFilePath}.`);
                    trace.error(
                        `Please check to make sure parent definition exists, the extended definition is the right type and does not override parent properties.`
                    );
                    process.exit(1);
                }
                this.isExtendedDefinition = true;
            } else {
                defJSON = JSON.parse(fs.readFileSync(`${this.jsonFilePath}`).toString());
            }

            // If this is an inherited definition without any view override, skip auto-props generation
            if (defJSON && defJSON.$ref && (!defJSON.module || !defJSON.module.view)) {
                trace.debug('Inhertied definition with no view specified, skipping auto-props generation');
                return false;
            }
            // If custom objects exist in definitions, process and generate the TS interfaces
            this.json = defJSON;
            // Map each definition object property to its intended TypeScript interface name
            this.mapDefinitionObjectsToInterfaceName();
            // for each custom object within definitions section generate the interface
            this.generateObjectsFromDefinitions();
            // Mark all the local ref paths and map each config property containing a ref to its object interface name
            this.markLocalRefObjects(this.json.config);

            this.json = await utilities.resolveRef(defJSON, srcJsonFilePath, trace);
            if (!this.json) {
                trace.debug(`Not a valid JSON definition file [${this.jsonFilePath}]`);
                return false;
            }

            if (!this.json.name || !this.json.name.trim()) {
                trace.error(`Invalid or missing (definition.name) in [${this.fileName}]`);
                this.processingErrors.push(`Invalid or missing (definition.name) in [${this.jsonFilePath}]`);
                return false;
            }
        } catch (e) {
            trace.error(e, `Error parsing JSON file [${this.jsonFilePath}]`);
            this.processingErrors.push(`Error parsing JSON file [${this.jsonFilePath}] [${e}]`);
            return false;
        }

        return true;
    }

    /**
     * Verify current definition file type is supported (module-definition OR dataBinder-definition OR resources-definition)
     * Saves the current file definition type for later use.
     *
     * @returns {boolean} True if definition type is supported, false otherwise.
     */
    isSupportedDefinition() {
        let isSupportedDef = false;
        const defType = this.json['$type'];
        this.definitionType = defType;

        if (this.isModuleDefinition() || defType === 'dataBinderDefinition' || defType === resourcesDefinition) {
            trace.info(`Got definition type [${defType}] from [${this.fileName}]`);
            if (this.json['$type'] === 'moduleDefinition') {
                const deprecationWarning = `Invalid type for ${this.fileName}. $type of 'moduleDefinition' is deprecated. Please choose from the types 'contentModule', 'containerModule', 'pageModule', 'scriptModule', htmlHeadTagsModule' or 'definitionExtension'.`;
                trace.warn(deprecationWarning);
                this.warnings.push(deprecationWarning);
            }
            isSupportedDef = this.initAttributes();
        } else {
            this.definitionType = '';
            trace.info(`Not supported definition type [${defType}] from [${this.fileName}]`);
        }

        return isSupportedDef;
    }

    /**
     * Initialize multiple instance variables used for later processing of the given definition file
     *
     * @returns {boolean} True if all variables are initialized, false otherwise.
     */
    initAttributes() {
        let isInit = false;
        this.moduleName = this.json.name.trim();
        if (this.isValidModuleName()) {
            this.moduleInterfaceName = this.nameToInterface(this.moduleName);
            this.configInterfaceTitle = this.shouldExtendIModuleConfig()
                ? `${this.moduleInterfaceName}Config extends Msdyn365.IModuleConfig`
                : `${this.moduleInterfaceName}Config`;
            trace.debug(`Module Name [${this.moduleName}], Module Interface Name [${this.moduleInterfaceName}]`);

            this.outputPath = path.resolve(path.dirname(this.jsonFilePath));
            trace.info(`Output Path [${this.outputPath}]`);
            if (this.isModuleDefinition()) {
                this.propsFileName = this.isExtendedDefinition
                    ? `${this.moduleName}.ext.props.autogenerated.ts`
                    : `${this.moduleName}.props.autogenerated.ts`;
            } else {
                trace.error(`Unsupported definition type [${this.definitionType}] src [${this.fileName}]`);
                return isInit;
            }

            isInit = true;
        }
        return isInit;
    }

    shouldExtendIModuleConfig() {
        const moduleType = this.json.$type;
        return moduleType === 'contentModule' || moduleType === 'containerModule' || moduleType === 'pageModule';
    }

    /**
     * Validate module name have only alpha-numeric chars or dashes or underscores
     *
     * @returns {boolean} True if name have allowed chars only, false otherwise.
     */
    isValidModuleName() {
        let isValid = !!this.moduleName && !!this.moduleName.trim();
        if (isValid) {
            let matches = this.moduleName.match(/[^a-zA-Z\d-_]/g);
            if (matches) {
                trace.error(
                    `Invalid (definition.name) [${this.moduleName}], not allowed chars [${matches}], source file [${this.fileName}]`
                );
                this.processingErrors.push(
                    `Invalid (definition.name) [${this.moduleName}], not allowed chars [${matches}], source file [${this.jsonFilePath}]`
                );
                isValid = false;
            }
        } else {
            trace.error(`Invalid or missing (definition.name) in [${this.fileName}]`);
            this.processingErrors.push(`Invalid or missing (definition.name) in [${this.jsonFilePath}]`);
        }
        return isValid;
    }

    /**
     * Checks if a module definition is for a container module
     *
     * @returns {boolean} True if container module definition, false otherwise.
     */
    isContainerModule() {
        let isContainer = false;
        if (this.json.slots && Object.keys(this.json.slots).length > 0) {
            trace.debug(`Container module definition file [${this.fileName}]`);
            isContainer = true;
        }
        return isContainer;
    }

    /**
     * Checks if current definition file is a module definition
     *
     * @returns {boolean} True if valid definition type, false otherwise.
     */
    isModuleDefinition() {
        return (
            this.definitionType === 'moduleDefinition' ||
            this.definitionType === 'contentModule' ||
            this.definitionType === 'containerModule' ||
            this.definitionType === 'pageModule' ||
            this.definitionType === 'scriptModule' ||
            this.definitionType === 'htmlHeadTagsModule' ||
            this.definitionType === 'appModule'
        );
    }

    /**
     * Checks if current definition file is a resourcesDefinition
     *
     * @returns {boolean} True if resourcesDefinition, false otherwise.
     */
    isResourcesDefinition() {
        return this.definitionType === resourcesDefinition;
    }

    /**
     * Checks if current definition file is a dataBinderDefinition
     *
     * @returns {boolean} True if dataBinderDefinition, false otherwise.
     */
    isModuleDataBinder() {
        return this.definitionType === dataBinderDefinition;
    }

    /**
     * Converts the declared type in the JSON to its typescript equivalent
     *
     * @returns {string} The type for a property
     */
    normalizeType(fieldObject, fieldName) {
        if (!fieldObject) {
            return undefined;
        }
        // Reserved field name for default css class name
        // if encountered, we don't want to generate prop for this field
        if (fieldName === DEFAULT_CSS_CLASS_NAME_FIELD) {
            // If this field name is provided it's editorial must be set to false and it must provide a default
            if (
                typeof fieldObject.editable === 'undefined' ||
                typeof fieldObject.default === 'undefined' ||
                fieldObject.editable === true
            ) {
                trace.error(`Field ${DEFAULT_CSS_CLASS_NAME_FIELD} must have its 'editable' set to false and provide a 'default value'.`);
                process.exit(1);
            }
            return undefined;
        }

        const type = fieldObject.type;
        switch (type) {
            case 'integer':
                return 'number';
            case 'resource':
                const resourceWarning = `Invalid config type in ${this.fileName}. Config type 'resource' is deprecated. Please use the top-level resource property to define resources.`;
                trace.warn(resourceWarning);
                this.warnings.push(resourceWarning);
                return 'string';
            case 'css':
                return 'string';
            case 'imageSettings':
                return 'Msdyn365.IImageSettings';
            case 'image':
                return 'Msdyn365.IImageData';
            case 'productList':
                return 'Msdyn365.IProductList';
            case 'richText':
                return 'Msdyn365.RichText';
            case 'link':
                return 'Msdyn365.ILinkData';
            case 'video':
                return 'Msdyn365.IVideoData';
            case 'object':
                // TEMP: Using this now to determine product list type
                if (fieldObject.format === 'productList') {
                    return 'Msdyn365.IProductList';
                }
                // If this object has already been generated from the definitions section
                // use the local ref to interface name mapping generated earlier to fetch the type name
                if (fieldName in this.localRefsToInterfaceName) {
                    return this.localRefsToInterfaceName[fieldName];
                }
                // If we reach this section it means the object is described inline
                // add this object to the processing queue and let it be processed with generateInlineObjects()
                fieldName = this.nameToInterface(fieldName) + 'Data';
                this.customObjectsToGenerate.push([fieldObject, fieldName]);
                return fieldName;
            case 'array':
                if (fieldObject.items.type === 'object') {
                    if (fieldName in this.localRefsToInterfaceName) {
                        return `${this.localRefsToInterfaceName[fieldName]}[]`;
                    }
                    fieldName = this.nameToInterface(fieldName) + 'Data';
                    this.customObjectsToGenerate.push([fieldObject.items, fieldName]);
                    return `${fieldName}[]`;
                } else {
                    const type = this.normalizeType(fieldObject.items);
                    return `${type}[]`;
                }
            default:
                return type;
        }
    }

    /**
     * Generates any custom objects that have been defined inline, versus being defined in the definitions secion
     * NOTE: Inline objects are not guranteed to be de-duped, i.e. two config properties that define the same inline object
     * will generate two separate objects (but with the same properties)
     * To define a shared object, define the object in the definitions section and use $ref
     */
    generateInlineObjects() {
        let customObjects = '';
        // Dequeue objects encoutnered inline and generate the interface for each one
        while (this.customObjectsToGenerate.length > 0) {
            const objectDetails = this.customObjectsToGenerate.shift();
            const objectDefinition = objectDetails[0];
            const objectTitle = objectDetails[1];
            customObjects += this.getConfigInterfaces(objectDefinition.properties, objectTitle);
        }
        return customObjects;
    }

    /**
     * Maps an object type defined in the definition section to its intended TypeScript interface name
     */
    mapDefinitionObjectsToInterfaceName() {
        const definitions = this.json.definitions;
        if (!definitions) {
            return;
        }
        for (const field in definitions) {
            const fieldObject = definitions[field];
            const objectTitle = this.nameToInterface(field) + 'Data';
            if (fieldObject.type === 'object') {
                this.definitionObjectsToInterfaceName[field] = objectTitle;
            } else if (fieldObject.type === 'array' && fieldObject.items) {
                // If the definition is defining an array which is using a custom object as its type, generate this object
                if (fieldObject.items.type === 'object') {
                    this.definitionObjectsToInterfaceName[field] = objectTitle;
                }
            }
        }
    }

    /**
     * Parses the definition section of a module definition file to generate any custom objects
     */
    generateObjectsFromDefinitions() {
        const definitions = this.json.definitions;
        let reffedDefinitionFieldName = '';
        if (!definitions) {
            return;
        }
        for (const field in definitions) {
            const fieldObject = definitions[field];
            const objectTitle = this.definitionObjectsToInterfaceName[field];

            if (fieldObject.type === 'object') {
                // Generate the typescript interface for this object
                this.objectsFromLocalDefinitions += this.getConfigInterfaces(fieldObject.properties, objectTitle);
            } else if (fieldObject.type === 'array' && fieldObject.items) {
                // If the definition property is defining an array which is using a custom object as its type, generate this object
                if (fieldObject.items.type === 'object') {
                    this.objectsFromLocalDefinitions += this.getConfigInterfaces(fieldObject.items.properties, objectTitle);
                    //  or if reffing another object, fetch the interface name for the reffed object and add it to the mapping
                } else if (fieldObject.items['$ref']) {
                    reffedDefinitionFieldName = this.getDefinitionObjectFieldName(fieldObject.items['$ref']);
                    this.definitionObjectsToInterfaceName[field] = this.definitionObjectsToInterfaceName[reffedDefinitionFieldName];
                }

                // If the property itself is reffing another definition property, fetch the interface name for the reffed property
                // and add it to the mapping
            } else if (fieldObject['$ref']) {
                reffedDefinitionFieldName = this.getDefinitionObjectFieldName(fieldObject['$ref']);
                this.definitionObjectsToInterfaceName[field] = this.definitionObjectsToInterfaceName[reffedDefinitionFieldName];
            }
        }
    }

    /**
     * Goes through the config properties recusrively and finds any refs pointing to the local definitions
     * and creates a mapping between config property field name and the interface name of the local object it is reffing
     *
     * @param {*} configProperties The config properties to seach through for local refs
     */
    markLocalRefObjects(configProperties) {
        if (configProperties) {
            for (const field in configProperties) {
                const fieldObject = configProperties[field];
                if (fieldObject['$ref'] && fieldObject['$ref'][0] === '#') {
                    this.addEntryToLocalRefToObjects(field, fieldObject['$ref']);
                } else if (fieldObject.type === 'array' && fieldObject.items['$ref'] && fieldObject.items['$ref'].indexOf('#') === 0) {
                    this.addEntryToLocalRefToObjects(field, fieldObject.items['$ref']);
                } else if (fieldObject.type === 'object') {
                    this.markLocalRefObjects(fieldObject.properties);
                }
            }
        }
    }

    /**
     * Adds an entry for a config property using a local ref to the interface name of the object
     * its using.
     * NOTE: Requires deinitionObjectToInterface name to be populated with the mappings from
     * definition field name to the interface name that it generates
     *
     * @param {*} field The config property field name
     * @param {*} refProperty The ref path. e.g. '#/definitions/sampleObject'
     */
    addEntryToLocalRefToObjects(field, refProperty) {
        const definitionFieldName = this.getDefinitionObjectFieldName(refProperty);
        this.localRefsToInterfaceName[field] = this.definitionObjectsToInterfaceName[definitionFieldName];
    }

    /**
     * Grabs the definition field name field name from a ref path
     * e.g. '#/definitions/sampleObject' -> returns 'sampleObject'
     * @param {*} refPath The ref path string
     */
    getDefinitionObjectFieldName(refPath) {
        const refParts = refPath.split('/');
        const definitionFieldName = refParts[2];
        if (refParts[1] !== 'definitions') {
            trace.error("$ref path to local definitions must be inside a definitions object, e.g. '#/definitions/<object here'");
            this.processingErrors.push('local $ref path does not point to a local definitions object');
        }
        return definitionFieldName;
    }

    /**
     * Generates the interfaces for supported definition types and writes to expected file
     *
     */
    generateDefinitionInterfaces() {
        let isFieldInfterfacesGenerated = false;

        trace.info(`Generating [${this.propsFileName}]`);

        try {
            let contentToWrite = this.getConfigInterfaces();
            contentToWrite += this.getResourcesInterface();
            // Add the generated interfaces for the inline objects
            contentToWrite += this.generateInlineObjects();
            contentToWrite += this.getPropsInterface();
            // Finally, append the objects generated from the definitions section
            contentToWrite += this.objectsFromLocalDefinitions;

            // Switch to writing props header after we get the config types so we know what core data types we need to import
            contentToWrite = this.getPropsHeader() + contentToWrite;

            if (this.isPropsGenerated && contentToWrite && contentToWrite.length) {
                if (!fs.existsSync(this.outputPath)) {
                    fs.mkdirSync(this.outputPath);
                }
                contentToWrite = prettier.format(contentToWrite, prettierRules);
                fs.writeFileSync(`${this.outputPath}${path.sep}${this.propsFileName}`, contentToWrite);
                isFieldInfterfacesGenerated = true;

                trace.info(`Generated [${this.outputPath}${path.sep}${this.propsFileName}]`);
            } else {
                trace.warn(`[${this.propsFileName}] not generated for [${this.fileName}]`);
            }
        } catch (e) {
            trace.error(e, `Error generating [${this.propsFileName}] from [${this.fileName}]`);
        }

        return isFieldInfterfacesGenerated;
    }

    /**
     * Constructs the file header based on current definition type
     *
     * @returns {string} Constructed file header text.
     */
    getPropsHeader() {
        let propsHeader =
            '' +
            '/**\r\n' +
            ' * Copyright (c) 2018 Microsoft Corporation\n' +
            ` * ${this.moduleInterfaceName} ${this.definitionType} Interface Properties \n` +
            ' * THIS FILE IS AUTO-GENERATED - MANUAL MODIFICATIONS WILL BE LOST \n' +
            ' */\n\n';
        if (this.isModuleDefinition()) {
            propsHeader += `import * as Msdyn365 from '@msdyn365-commerce/core';\n`;
            if (this.isContainerModule()) {
                propsHeader += "import * as React from 'react';\n";
            }
        }

        return propsHeader + '\n';
    }

    /**
     * Constructs the resources interfaces parsed from the current definition
     *
     * @returns {string} Constructed resoruces interfaces or empty string if none.
     */
    getResourcesInterface() {
        const resources = this.json.resources;
        let partialContent = '';

        if (!this.json.resources) {
            return partialContent;
        }

        trace.debug(`[${this.moduleName}] [${this.definitionType}] configs count [${Object.keys(resources).length}]`);

        const mappedResourcesInterface = Object.keys(resources)
            .map(field => `\t${field}: string;`)
            .join('\n');

        this.isResourcesGenerated = true;
        partialContent += this.createInterfaceTemplate(`${this.moduleInterfaceName}Resources`, mappedResourcesInterface);

        return partialContent;
    }

    /**
     * Constructs the config interfaces parsed from the current definition type
     *
     * @returns {string} Constructed config interfaces or empty string if none.
     */
    getConfigInterfaces(configs = this.json.config, interfaceTitle = this.configInterfaceTitle) {
        let partialContent = '';
        if (!this.json.config) {
            if (!this.isResourcesDefinition()) {
                trace.info(`[${this.moduleName}] [${this.definitionType}] (definition.config) is not defined or empty`);
            }
            return partialContent;
        }

        if (this.isResourcesDefinition()) {
            trace.error(`(definition.config) should not be in a [${resourcesDefinition}] definition file. Remove from [${this.fileName}]`);
            this.processingErrors.push(
                `(definition.config) should not be in a [${resourcesDefinition}] definition file. Remove from [${this.jsonFilePath}]`
            );
            return partialContent;
        }

        trace.debug(`[${this.moduleName}] [${this.definitionType}] configs count [${Object.keys(configs).length}]`);

        const enums = new Set();
        const interfaceConfig = [];
        let isRequired = false;
        let isArray = false;
        let fieldObject = {};
        let enumConfig = '';
        let type = '';

        // if module contains "page" attribute "true" or moduleGroup is "page" --> this is a page
        // explicit check for "true" instead of truthy value
        if (
            (this.json.$type && this.json.$type.toLowerCase() === 'pagemodule') ||
            (this.json.attributes && this.json.attributes.page === true) ||
            (this.json.moduleGroup || '').toLowerCase() === 'page'
        ) {
            const defaultPageJsonFilePath = path.join(__dirname, 'default', 'page.json');
            if (utilities.safeFileExistsSync(defaultPageJsonFilePath)) {
                const pageSpecificConfigs = JSON.parse(fs.readFileSync(defaultPageJsonFilePath));
                Array.prototype.push.apply(interfaceConfig, pageSpecificConfigs);
            }
        }

        for (const field in configs) {
            trace.debug(`Processing field [${field}]`);
            isRequired = false;
            isArray = false;
            enumConfig = '';
            type = '';
            fieldObject = configs[field];

            if (!fieldObject.type) {
                trace.error(
                    `[${this.moduleName}] [${this.definitionType}] definition.config.[${field}].type is not defined [${fieldObject.type}]`
                );
                continue;
            }
            if (fieldObject.required) {
                if (typeof fieldObject.required === 'boolean') {
                    isRequired = true;
                } else {
                    trace.warn(
                        `[${this.moduleName}] [${
                            this.definitionType
                        }] definition.config.[${field}] typeof required property is [${typeof fieldObject.required}] expected [boolean] or [array], setting isRequired to [${isRequired}]`
                    );
                }
            }

            let enumName = '';
            if (fieldObject.enum) {
                const enumKeys = Object.keys(fieldObject.enum);
                if (Object.keys(fieldObject.enum).length > 0) {
                    // If generating an enum for an object, scope the enum to the object
                    if (interfaceTitle !== this.configInterfaceTitle) {
                        enumName = this.interfaceNameToObjectTitle(interfaceTitle) + field.charAt(0).toUpperCase() + field.slice(1);
                    } else {
                        enumName = field;
                    }

                    enums.add(field);

                    enumConfig = enumKeys.map(enumKey => `\t${enumKey} = '${enumKey}'`).join(',\n');

                    trace.info(`[${field}] enum keys/values set to [${enumConfig}]`);
                    partialContent += this.createEnumTemplate(enumName, enumConfig);
                } else {
                    trace.error(`[${field}] configured enum with no keys/values [${this.fileName}]`);
                    this.processingErrors.push(`[${field}] configured enum with no keys/values [${this.srcJsonFilePath}]`);
                }
                // If a default value is specified for enum it must match one of the enum key specified
                if (fieldObject.default && enumKeys.indexOf(fieldObject.default) === -1) {
                    trace.error(
                        `[${field}] configured a default value that doesn't match any enum keys specified. Default value:[${fieldObject.default}] is not a defined enum key`
                    );
                    this.processingErrors.push(
                        `[${field}] configured a default value that doesn't match any enum keys specified [${this.srcJsonFilePath}]`
                    );
                }
            }

            if (enums.has(field)) {
                type = enumName;
            } else {
                type = this.normalizeType(fieldObject, field);
            }

            if (type) {
                interfaceConfig.push({
                    name: field,
                    type,
                    isRequired,
                    isArray
                });
            }
        }

        const mappedInterfaceConfig = interfaceConfig
            .map(field => {
                let { name, type, isRequired, isArray } = field;

                trace.debug(
                    `[${this.moduleInterfaceName}] [${this.definitionType}] mapped config name [${name}], type [${type}], isRequired [${isRequired}], isArray [${isArray}]`
                );
                if (isArray) {
                    type = type + '[]';
                }

                return isRequired ? `\t${name}: ${type};` : `\t${name}?: ${type};`;
            })
            .join('\n');

        if (!mappedInterfaceConfig || mappedInterfaceConfig.length === 0) {
            partialContent += `// tslint:disable-next-line:no-empty-interface\n`;
        }

        this.isConfigGenerated = true;
        partialContent += this.createInterfaceTemplate(interfaceTitle, mappedInterfaceConfig);

        return partialContent;
    }

    /**
     * Constructs the container interfaces parsed from the current definition type
     *
     * @returns {string} Constructed container interfaces or empty string if none.
     */
    getModulesInterfaces() {
        let modulesInterfaces = '';

        if (this.isModuleDefinition() && this.isContainerModule()) {
            const slots = this.json.slots;
            trace.debug(`[${this.moduleInterfaceName}] [${this.definitionType}] container modules count [${slots.length}]`);
            const modulesConfig = Object.keys(slots)
                .map(slotId => {
                    const slot = slots[slotId];
                    if (!slot || !slot.description) {
                        let label =
                            (!slot && ` module.slotId [${slotId}] `) + (!slot.description && ` module.description [${slot.description}]`);
                        trace.error(
                            `[${this.moduleInterfaceName}] container module [${Object.keys(slots).indexOf(slotId)}] missing ${label}`
                        );

                        return false;
                    }

                    trace.debug(`[${this.moduleInterfaceName}] mapped container module [${slotId}: React.ReactNode;]`);
                    return `${slotId}: React.ReactNode[];`;
                })
                .filter(Boolean)
                .join('\n');

            if (modulesConfig) {
                modulesInterfaces = `{\n${modulesConfig}\n}`;
                this.isModulesGenerated = true;
            }
        } else if (this.isContainerModule()) {
            trace.error(`Container modules can not be in a [${this.definitionType}] definition file. Remove from [${this.fileName}]`);
            this.processingErrors.push(
                `Container modules can not be in a [${this.definitionType}] definition file. Remove from [${this.jsonFilePath}]`
            );
        }

        return modulesInterfaces;
    }
    /**
     * Constructs the props interfaces based on previously constructed resources, config and slots interfaces
     *
     * @returns {string} Constructed props interfaces or empty string if none.
     */
    getPropsInterface() {
        let propsGenerated = '';
        let propsInterface = '';

        if (this.isResourcesGenerated) {
            let resourcesProp = `\tresources: ${this.moduleInterfaceName}Resources;`;
            trace.debug(`[${this.moduleInterfaceName}] [${this.definitionType}] adding resources prop [${resourcesProp}]`);
            propsGenerated += resourcesProp;
        }

        if (this.isConfigGenerated) {
            let configProp = `\tconfig: ${this.moduleInterfaceName}Config;`;
            trace.debug(`[${this.moduleInterfaceName}] [${this.definitionType}] adding config prop [${configProp}]`);
            propsGenerated += this.isResourcesGenerated ? '\n' + configProp : configProp;
        }

        var slots = this.getModulesInterfaces();
        if (this.isModulesGenerated) {
            let modulesProps = `\tslots: ${slots}`;
            trace.debug(`[${this.moduleInterfaceName}] [${this.definitionType}] adding modules prop [${modulesProps}]`);
            propsGenerated += modulesProps;
        }

        trace.info(`[${this.moduleInterfaceName}] [${this.definitionType}] props [${propsGenerated}]`);
        propsInterface = this.createPropsInterfaceTemplate(`${this.moduleInterfaceName}Props`, propsGenerated);

        // If no config, slots or resources were defined, create the props interface
        // and add the tslint ignore line for empty interfaces
        if (propsGenerated === '') {
            propsInterface = `// tslint:disable-next-line:no-empty-interface\n${propsInterface}`;
        }
        this.isPropsGenerated = true;
        return propsInterface;
    }

    /**
     * Constructs props interface template based on given parameters and definition type
     *
     * @returns {string} Props interface template.
     */
    createPropsInterfaceTemplate(interfaceName, Config) {
        let interfaceTemplate = `export interface ${interfaceName}`;
        if (this.isModuleDefinition()) {
            interfaceTemplate += '<T> extends Msdyn365.IModule<T>';
        }
        return `${interfaceTemplate} {\n${Config}\n}\n\n`;
    }

    /**
     * Constructs an interface template based on given parameters
     *
     * @returns {string} Interface template.
     */
    createInterfaceTemplate(interfaceName, Config) {
        return `export interface ${interfaceName} {\n${Config}\n}\n\n`;
    }

    /**
     * Constructs an enum template based on given parameters
     *
     * @returns {string} Enum template.
     */
    createEnumTemplate(enumName, enumValues) {
        return `export const enum ${enumName} {\n${enumValues}\n }\n\n`;
    }

    /**
     * Converts an interface name back to the object title
     * e.g IAddressData -> Address
     */
    interfaceNameToObjectTitle(interfaceName) {
        if (interfaceName) {
            return interfaceName.substring(1, interfaceName.length - 4);
        }
        return interfaceName;
    }
    /**

    /**
     * Converts given name to interface name
     *
     * @returns {string} Interface name.
     */
    nameToInterface(name) {
        if (name) {
            name = name.replace(/-(.)/g, x => x[1].toUpperCase()).replace(/-/g, '');
            return 'I' + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name;
    }
}

module.exports = ModuleDefinitionGenerator;

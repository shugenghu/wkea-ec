/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/
const fs = require('fs');
const path = require('path');
const trace = require('@msdyn365-commerce/utilities-internal').trace;
const { getDefinitionFiles, initDebugger, runDefinitionGenerator, DEFNITION_FILE_EXTENSION, EXTENDED_DEFINITION_FILE_EXTENSION } = require('./utils/helpers');
const chalk = require('chalk');
const { getDataDefinitionFiles } = require('./data-definition-generator');
const ModuleDefinitionGenerator = require('./module-definition-generator');

function ModuleDefinitionGeneratorPlugin(moduleName) {
    this.moduleName = moduleName;
    this.startTime = Date.now();
    this.prevTimestamps = new Map();
    initDebugger();
}

ModuleDefinitionGeneratorPlugin.prototype.apply = function(compiler) {
    const isDebug = process.env.NODE_ENV === 'development';
    const lifecycleHook = isDebug ? 'watchRun' : 'beforeCompile';
    compiler.hooks[lifecycleHook].tapPromise('ModuleDefinitionGenerator', async (compilation, callback) => {
        // web always runs first
        if (compiler.options.target === 'node') {
            return;
        }

        let context = isDebug ? compilation.context : compilation.normalModuleFactory.context;

        let changedFiles = [];
        if (isDebug) {
            const compilationFileStampKeys = Array.from(compilation.fileTimestamps.keys());
            changedFiles = compilationFileStampKeys.filter(watchedFileKey => {
                return (
                    (this.prevTimestamps.get(watchedFileKey) || this.startTime) <
                    (compilation.fileTimestamps.get(watchedFileKey) || Infinity)
                );
            });

            const definitionsUpdated = changedFiles.filter(
                fileName => fileName.endsWith(DEFNITION_FILE_EXTENSION) || fileName.endsWith(EXTENDED_DEFINITION_FILE_EXTENSION) || fileName.endsWith('.data.ts')
            );
            const shouldDefinitionGeneratorRun = compilationFileStampKeys.length === 0 || definitionsUpdated.length > 0;

            // updated local timestamp cache
            this.prevTimestamps = compilation.fileTimestamps;

            // bail early if we have nothing to update
            if (!shouldDefinitionGeneratorRun) {
                trace.info(chalk.bgGreen(`[INFO] Skipping module definition generator`));
                return Promise.resolve();
            }
        }

        trace.info(`[${compiler.options.target}]=====================================================================`);
        trace.info(`Start Module definition generation [${lifecycleHook}] context [${context}]`);

        // Get path to current module from compilation context
        const moduleBasePath = path.resolve(context);

        // Check path exists and is a directory and not a symbolic link
        try {
            if (!fs.statSync(moduleBasePath).isDirectory() || fs.lstatSync(moduleBasePath).isSymbolicLink()) {
                trace.debug(`Skipping [${moduleBasePath}] not a directory`);
                return;
            }
        } catch (e) {
            trace.error(e, `Error skipping [${moduleBasePath}]`);
            return;
        }

        const modifiedDefinitionFiles = changedFiles.filter(fileName => fileName.endsWith('.definition.json') || fileName.endsWith('.definition.ext.json'));
        const modifiedDataDefinitionFiles = changedFiles.filter(fileName => fileName.endsWith('.data.ts'));

        if (moduleBasePath && moduleBasePath.trim()) {
            const defGenerator = new ModuleDefinitionGenerator(moduleBasePath);

            let definitionFiles = [];
            let dataDefinitionFiles = [];

            // During initial pass, changed files will be empty, and we should process all definition and data definition files
            if (changedFiles.length === 0) {
                // Get json files in definitions directories under any sub-directories of base path        
                definitionFiles = getDefinitionFiles(moduleBasePath);
                dataDefinitionFiles = getDataDefinitionFiles(moduleBasePath, defGenerator);
            }

            const jsonDefinitionFiles = modifiedDefinitionFiles.length > 0 ? modifiedDefinitionFiles : definitionFiles;
            const jsonDataDefinitionFiles = modifiedDataDefinitionFiles.length > 0 ? modifiedDataDefinitionFiles : dataDefinitionFiles;
            trace.debug(`Definition files: ${modifiedDefinitionFiles}`);
            trace.debug(`Data definition files: ${modifiedDataDefinitionFiles}`);

            return runDefinitionGenerator(defGenerator, jsonDefinitionFiles, jsonDataDefinitionFiles, true)
                .then(result => {
                    if (result) {
                        trace.info(`End Module definition generation [beforeCompile]`);
                        trace.info(`[${compiler.options.target}]=====================================================================`);
                    } else {
                        trace.info(`Nothing updated under [${moduleBasePath}]`);
                    }
                })
                .catch(ex => {
                    trace.error(`error for [${moduleBasePath}]`, ex);
                });
        } else {
            trace.error(`invalid module base path: ${moduleBasePath}`);
            return Promise.resolve({});
        }
    });
};

module.exports = ModuleDefinitionGeneratorPlugin;

#! /usr/bin/env node
/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/


'use strict';

process.env.NODE_ENV = 'development';
const webpack = require('webpack');
const createConfig = require('./create-config');
const modified = require('../index');
const WPDS = require('webpack-dev-server');
const chalk = require('chalk');
const portfinder = require('portfinder');
const fse = require('fs-extra');
const paths = require('./paths');

// Capture any --inspect or --inspect-brk flags (with optional values) so that we
// can pass them when we invoke nodejs
process.env.INSPECT_BRK = (process.argv.find(arg => arg.match(/--inspect-brk(=|$)/)) && '--inspect-brk') || '';
process.env.INSPECT = (process.argv.find(arg => arg.match(/--inspect(=|$)/)) && '--inspect') || '';

function compile(config) {
    let compiler;
    try {
        compiler = webpack(config);
    } catch (e) {
        console.log(`Failed to compile`, e);
        process.exit(1);
    }
    return compiler;
}

async function findPort(port = process.env.PORT || 3000, label) {
    if (isNaN && isNaN(port)) {
        port = 3000;
    }
    const emptyPort = await portfinder.getPortPromise({ port: parseInt(port, 10) });
    console.log(chalk.bgGreenBright(chalk.black(`[INFO] Port '${emptyPort}' is available for ${label}.`)));
    return emptyPort;
}

async function main() {
    const emptyPort = await findPort(parseInt(process.env.PORT), 'http server');
    process.env.PORT = emptyPort;
    const emptyDevPort = await findPort(emptyPort + 1, 'dev server statics');
    if (process.env.INSPECT_BRK) {
        const inspectPort = await findPort(9229, 'node inspector');
        process.env.INSPECT_PORT = inspectPort;
    }
    const clientBase = createConfig('web', 'dev', { port: emptyPort, devPort: emptyDevPort });
    const serverBase = createConfig('node', 'dev', {});
    const clientUpdated = await modified(clientBase, { target: 'web', dev: true }, webpack);
    const serverUpdated = await modified(serverBase, { target: 'node', dev: true }, webpack);
    console.log(`[INFO] Copying public folder...`);
    fse.copySync(paths.appPublic, paths.appBuildPublic, { dereference: true });
    const clientCompiler = compile(clientUpdated);
    const serverCompiler = compile(serverUpdated);

    const compilerPromise = new Promise(resolve => {
        console.log(`[INFO] Starting client compilation...`);
        let isWatching = false;
        clientCompiler.plugin('done', () => {
            console.log();
            console.log(`Server started on port ${emptyPort}`);
            if (isWatching) {
                return;
            }
            isWatching = serverCompiler.watch({ quiet: false, stats: 'normal' }, (err, stats) => {
                isWatching = true;
                console.log(err || 'No Errors for server.');
                resolve();
            });
        });
        const clientDevServer = new WPDS(clientCompiler, clientUpdated.devServer);
        // Start Webpack-dev-server
        clientDevServer.listen(emptyDevPort, err => {
            if (err) {
                console.error(err);
            }
        });
        // TODO kopik: Keep below code for now as that's what allows us to switch between HMR & Webpack watch with minor tweaks
        // clientCompiler.watch({ quiet: false, stats: 'normal' }, () => {
        //     console.log(`Starting server compilation...`);
        //     if (isWatching) {
        //         return resolve();
        //     } else {
        //         serverCompiler.watch({ quiet: false, stats: 'normal' }, (err, stats) => {
        //             isWatching = true;
        //             console.log(err || 'No Errors for server.');
        //             resolve();
        //         });
        //     }
        // });
    });

    return compilerPromise;
}

main();

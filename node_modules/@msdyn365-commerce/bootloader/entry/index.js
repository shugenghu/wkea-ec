/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/


import http from 'http';
import https from 'https';
import net from 'net';
import * as path from 'path';
import * as appInsights from 'applicationinsights';
// This skips node's module resolution process and allows for HMR on keystone-core
// NOTE: This breaks source maps, so swap it back when you want to debug node code.
// import * as core from '../node_modules/@msdyn365-commerce/runtime-internal/dist/lib/server';
import * as core from '@msdyn365-commerce/runtime-internal/dist/lib/server';
import msdyn365Commerce from '@msdyn365-commerce/core-internal'; // eslint-disable-line no-unused-vars
import { trace, safeReadJsonSync } from '@msdyn365-commerce/utilities-internal';
import { SeverityLevel } from 'applicationinsights/out/Declarations/Contracts';
import createCertificate from '../scripts/create-certificate';

// TODO: file is too big, please refactor
// // Configure Node.js Application Insights
let environmentId = 'Development';
let commerceCoreEnvironmentId = 'Development';
let appInfra = 'Development';

if (process.env.NODE_ENV !== 'development') {
    environmentId =
        process.env.ENVIRONMENTID ||
        (process.env.Fabric_ApplicationName || '-').slice((process.env.Fabric_ApplicationName || '-').indexOf('-') + 1);
    commerceCoreEnvironmentId = process.env.CommerceCore_EnvironmentId;
    appInfra = process.env.DEPLOYMENT_ENV === 'WEBAPP' ? 'WebApp' : 'ServiceFabric';
}
// Read the ikey from env var, if not set it as empty space
let ikey = process.env.APPINSIGHTS_INSTRUMENTATIONKEY || ' ';
appInsights
    .setup(ikey)
    // disable all console logs from being collected
    .setAutoCollectConsole(false)
    // avoid the annoying ACL permissions errors from AI when in dev mode, always attempt use disk retry in prod
    .setUseDiskRetryCaching(process.env.NODE_ENV !== 'development');

appInsights.defaultClient.commonProperties = {
    'Environment id': environmentId,
    'App type': process.env.MSDyn365_APP_TYPE || 'modules',
    Region: process.env.AZUREREGION || process.env.ClusterRegion || 'unknown',
    'Cluster name': process.env.ClusterName || 'unknown',
    'SDK NodeId': process.env.Fabric_NodeId || 'unknown',
    'SDK NodeVersion': process.version || 'unknown',
    'Commerce core environment id': commerceCoreEnvironmentId,
    AppInfra: appInfra,
    'Deployment Environment Type': process.env.DEPLOYMENT_ENV || 'Service Fabric',
    'Retail Proxy Version': process.env.MSDyn365Commerce_RSVERSION || '-.-',
    'SDK Version': process.env.MSDyn365Commerce_SDK_VERSION || '-.-',
    'SSK Version': process.env.MSDyn365Commerce_SSK_VERSION || '-.-'
};
const clientContextKeyString = 'http.ClientRequest';
const serverContextKeyString = 'http.ServerRequest';
const healthCheckPathList = ['/keepalive', '/containerhealth', '/environmenthealth'];
const sdkPathList = ['/_sdk/features', '/_sdk/version'];

const sanitizeDependencyUrls = (envelope, context) => {
    // Filter out successful healthcheck calls
    const serverContext = context[serverContextKeyString];
    if (context && serverContext) {
        const { url, originalUrl, res } = serverContext;
        if (
            ((url && healthCheckPathList.includes(url.toLowerCase())) ||
                (originalUrl && sdkPathList.includes(originalUrl.toLowerCase()))) &&
            res &&
            res.statusCode < 300
        ) {
            return false;
        }
    }

    const { data } = envelope;
    if (data && data.baseType === 'RemoteDependencyData') {
        // auto-correlated http calls
        const baseData = data.baseData;
        const type = baseData.type;
        if (type === 'Http (tracked component)' || type === 'Http') {
            // if we have OUN & RequestId header, then drop the call as it'll be tracked via axios interceptors
            if (context && context[clientContextKeyString]) {
                const contextClientRequest = context[clientContextKeyString];
                if (contextClientRequest._headers) {
                    const headers = contextClientRequest._headers;
                    if (headers.oun && headers.requestid) {
                        return false;
                    }
                }
            }

            if (baseData) {
                // TODO if debug mode no changes to baseData
                baseData.data = 'CENSORED';
                baseData.name = 'CENSORED';
            }
        }
    }
    if (envelope.tags && data && data.baseData) {
        const tags = envelope.tags;
        tags['ai.operation.name'] = '';
    }
    return true;
};
appInsights.defaultClient.addTelemetryProcessor(sanitizeDependencyUrls);
appInsights.start();

trace.info('Running Partner');
const getClientStats = () => safeReadJsonSync(path.join(process.cwd(), 'build', 'public', 'stats-web.json'));

let bindings = {
    modules: {},
    dataActions: {},
    views: {}
};

// installed modules registration
try {
    const moduleRegistration = require('lib/module-registration');
    bindings = moduleRegistration.registerAllModules();

    bindings = {
        modules: {
            ...bindings.modules
        },
        dataActions: {
            ...bindings.dataActions
        }
    };
} catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
        trace.info(`module registration file not found.`);
        trace.error(e);
    } else {
        throw e;
    }
}

// local modules registration
try {
    const partnerModuleRegistration = require('lib/module-registration.local');
    const registeredPartnerModules = partnerModuleRegistration.registerAllModules();

    bindings = {
        modules: {
            ...bindings.modules,
            ...registeredPartnerModules.modules
        },
        dataActions: {
            ...bindings.dataActions,
            ...registeredPartnerModules.dataActions
        }
    };
} catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
        trace.info(`No local modules found`);
    }
}

// view extensions registration
try {
    const viewsRegistration = require('lib/view-registration');
    bindings.views = viewsRegistration ? viewsRegistration.viewDictionary : {};
} catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
        process.env.NODE_ENV === 'development' && console.log(`view registration files not found.`);
    }
}

// component extensions registration
try {
    const componentsRegistration = require('lib/component-registration');
    bindings.components = componentsRegistration ? componentsRegistration.componentDictionary : {};
} catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
        process.env.NODE_ENV === 'development' && console.log(`component registration files not found.`);
    }
}

// connectors registration
try {
    const connectorsRegistration = require('lib/connector-registration');
    // Validate registration
    connectorsRegistration.validateConnectorRegistration();
    bindings.connectors = connectorsRegistration ? connectorsRegistration.connectorDictionary : {};
} catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
        process.env.NODE_ENV === 'development' && console.log(`connector registration files not found.`);
    } else {
        // validateConnectorRegistration threw
        trace.error(
            `Error registering connectors. Please check implementation of connectors and please ensure that connectors have been configured properly in connector.settings.json.`
        );
        appInsights.defaultClient.trackTrace({
            message: `Error registering connectors. Please check implementation of connectors and please ensure that connectors have been configured properly in connector.settings.json.`,
            severity: SeverityLevel.Error
        });
    }
}

core.initializeServerApp(bindings).then(() => {
    console.log(`Initializing server`);
    trace.info('--------------------------server entry point-----------------------------------------');
    process.env.NODE_DEBUG && trace.info(msdyn365Commerce);
    process.env.NODE_DEBUG && trace.info(msdyn365Commerce.bindings);

    let port = Number(process.env.PORT || 3000);
    const originalPort = port;
    const servers = [];

    if (process.env.NODE_ENV === 'development') {
        const portOverrideDevMode = process.argv.filter(_ => _ && _.toLocaleLowerCase().startsWith('port:'));
        if (portOverrideDevMode && portOverrideDevMode.length) {
            port = parseInt(portOverrideDevMode[0].split('port:')[1], 10);
            trace.info(`[INFO] Override port to: ${port}`);
        }
    }

    let serverPorts;

    /**
     * Binds a server to a specific port.
     * Returns an error if unable to bind otherwise returns port number.
     * @param {net.Server} serverInstance
     * @param {number} targetPort
     * @param {Function} callback
     */
    const bindServerToPort = (serverInstance, targetPort, callback) => {
        serverInstance.listen(targetPort);
        serverInstance.once('listening', () => {
            servers.push(serverInstance);
            callback && callback(null, targetPort);
        });

        serverInstance.on('error', err => {
            if (err.message && err.message.indexOf(`EADDRINUSE`) !== -1) {
                // clear all the listeners for this server
                serverInstance.removeAllListeners('error');
                serverInstance.removeAllListeners('listening');
                serverInstance.close(() => {
                    callback && callback(err);
                });
            } else {
                trace.error(err);
                appInsights.defaultClient.trackTrace({
                    message: `Error binding server to port ${targetPort}, Error: ${err}`,
                    severity: SeverityLevel.Error
                });
            }
        });
    };

    /**
     * Attempts to bind the server to the target port. Will continue scanning ports +1 until the scan limit is reached.
     * Callback returns an error if no port is found and the actual port the server binds to
     * @param {net.Server} serverInstance
     * @param {number} targetPort
     * @param {number} scanLimit
     * @param {Function} callback
     */
    const startServer = (serverInstance, targetPort, scanLimit, callback) => {
        return bindServerToPort(serverInstance, targetPort, (err, boundPort) => {
            if (err) {
                const newPort = targetPort + 1;
                if (newPort <= scanLimit) {
                    return startServer(serverInstance, newPort, scanLimit, callback);
                }
            }
            return callback(err, boundPort);
        });
    };

    /**
     * Caculates offsets for http and https servers.
     * @param {number} targetPort Initial port server tried to start on
     * @param {number} boundPort Actual port server is listening on
     */
    const caculatePorts = (targetPort, boundPort) => {
        /**
         * Quick Maths
         * target: 4000, Bound: 4000, http: 3998, https: 3999
         * target: 4000, Bound: 4001, http: 3996, https: 3997
         * target: 4000, Bound: 4000, http: 3994, https: 3995
         */
        const diff = boundPort - targetPort + 1;

        let offset = 2 * diff;
        return {
            http: targetPort - offset,
            https: targetPort - (offset - 1)
        };
    };

    /**
     * Error event handler
     * @param {Error} connection
     */
    const noop = () => {};

    /**
     * routes tcp request to final port to the http / https servers based on connection type
     * @param {*} conn
     */
    const tcpConnection = conn => {
        conn.on('error', noop);
        conn.once('data', function(buf) {
            // A TLS handshake record starts with byte 22.
            var address = buf[0] === 22 ? serverPorts.https : serverPorts.http;
            // Establish a new tcp connection on the local box through assigned ports.
            var proxy = net.createConnection(address, function() {
                proxy.write(buf); // send connection data to app server
                conn.pipe(proxy).pipe(conn); // echo back response
            });
            proxy.on('error', conn.destroy);
        });
    };

    /**
     * Redirects http connections to https
     * @param {*} req - http request
     * @param {*} res - http response
     */
    function httpRedirect(req, res) {
        res.writeHead(307, {
            Location: `https://${req.headers['host']}${req.url}`
        });
        res.end();
    }

    try {
        const options = createCertificate();
        if (process.env.DEPLOYMENT_ENV === 'WEBAPP') {
            trace.info('🚀 Server starting in http');
            const httpRedirectServer = http.createServer(app);
            bindServerToPort(httpRedirectServer, originalPort);
        } else {
            trace.info('🚀 Server starting in https');
            const secureServer = https.createServer(options, app);
            const tunnelServer = net.createServer(tcpConnection);
            const httpRedirectServer = http.createServer(httpRedirect);
            // Limit the total number of servers running on the same box to 50
            startServer(tunnelServer, port, port + (process.env.MAX_NUM_CONCURRENT_SERVERS || 50), (error, actualPort) => {
                if (error) {
                    trace.error(`FAILED TO START NODE SERVER. ERROR: `);
                    trace.error(error);
                    appInsights.defaultClient.trackTrace({
                        message: `FAILED TO START NODE SERVER. ERROR: ${error}`,
                        severity: SeverityLevel.Error
                    });
                } else {
                    serverPorts = caculatePorts(originalPort, actualPort);
                    bindServerToPort(secureServer, serverPorts.https);
                    bindServerToPort(httpRedirectServer, serverPorts.http);
                    trace.info(`Server started on port ${actualPort}`);
                    appInsights.defaultClient.trackTrace({
                        message: `Server successfully started on ${actualPort}`,
                        severity: SeverityLevel.Verbose
                    });
                }
            });
        }
    } catch (e) {
        trace.error(`\n\n\nIssue starting node server. See next error message for details.`);
        trace.error(e);
        appInsights.defaultClient.trackTrace({ message: `Issue starting node server. Error: ${e}`, severity: SeverityLevel.Error });
    }

    if (module.hot) {
        trace.info('✅  Server-side HMR Enabled!');
        // ['@msdyn365-commerce/runtime-internal/dist/lib/server']
        module.hot.dispose(() => {
            // Kill the servers and have webpack restart them
            servers.forEach(server => {
                server.close();
            });
        });
        module.hot.accept(err => {
            if (err) {
                trace.error(`Error while attempting to hot load modules. See next error message for details.`);
                trace.error(err);
            } else {
                trace.info(`🔁 Hot load of modules succeeded without issues.`);
            }
        });
    } else {
        trace.error();
        trace.info(`--------> NO SS HMR <---------------`);
    }
});

const getThemeRegistration = () => safeReadJsonSync(path.join(process.cwd(), 'build', 'theme-registration.json'));

msdyn365Commerce.setThemeRegistration(getThemeRegistration());
let app = core.appFunc(
    {
        clientStats: getClientStats()
    },
    process.env,
    {},
    appInsights.defaultClient
);

/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/


import 'custom-event-polyfill';

import * as app from '@msdyn365-commerce/runtime-internal/dist/lib/client';
const { getUniqueRequestedAssets } = require('../common');

// Fetches the registration object from a given file and dictionary name
// If the module is not found or dictionary does not exist an empty object is returned
const fetchRegistrationObject = (registration, dictionaryName) => {
    return registration ? registration[dictionaryName] : {};
};

// Registers all the local and installed modules need to render the page client-side
const registerModules = (requestContext, requestedAssets) => {
    let registeredModules = { modules: {}, dataActions: {} };
    let registeredPartnerModules = { modules: {}, dataActions: {} };

    let modulesRegistration;
    let partnerModuleRegistration;

    // installed modules registration
    try {
        modulesRegistration = require('lib/module-registration');
    } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            console.error(`registration file not found.`, e);
        } else {
            throw e;
        }
    }

    // local modules registration
    try {
        partnerModuleRegistration = require('lib/module-registration.local');
    } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            process.env.NODE_ENV === 'development' && console.log(`no local modules found.`, e);
        }
    }

    // If in an editor scenario and feature 'enableAuthoringRemoveAndAddModule' has been enabled,
    // register all modules so that editor canvas can add modules client side without page refresh
    if (
        requestContext &&
        requestContext.params &&
        requestContext.params.isEditor &&
        requestContext.features &&
        requestContext.features.enableAuthoringRemoveAndAddModule
    ) {
        registeredModules = modulesRegistration ? modulesRegistration.registerAllModules() : registeredModules;
        registeredPartnerModules = partnerModuleRegistration ? partnerModuleRegistration.registerAllModules() : registeredPartnerModules;
    } else {
        registeredModules = modulesRegistration
            ? modulesRegistration.registerAllModules(requestedAssets && requestedAssets.modules)
            : registeredModules;
        registeredPartnerModules = partnerModuleRegistration
            ? partnerModuleRegistration.registerAllModules(requestedAssets && requestedAssets.modules)
            : registeredPartnerModules;
    }

    return {
        modules: {
            ...registeredModules.modules,
            ...registeredPartnerModules.modules
        },
        dataActions: {
            ...registeredModules.dataActions,
            ...registeredPartnerModules.dataActions
        }
    };
};

const initializeConnectors = (connectorInformation = {}, connectorsRegistration, requestContext) => {
    let experimentationConnector;
    if (connectorsRegistration && connectorInformation) {
        const expConnectorName = connectorInformation.expConnector;
        if (expConnectorName && connectorsRegistration[expConnectorName]) {
            // Grab the stored config from the window object
            const config = window.___initialData___.experimentationConfig;
            // Grab the experimentation user ID
            const expUserId = requestContext && requestContext.experiments && requestContext.experiments.userId;
            // Initialize the provider and listener for client
            const experimentationProvider = connectorsRegistration[expConnectorName].provider;
            const experimentationListener = connectorsRegistration[expConnectorName].listener;

            if (!experimentationProvider || !experimentationListener) {
                return { experimentation: undefined };
            }

            experimentationProvider.initializeClientSide(config);
            experimentationListener.initializeClientSide(config, expUserId);
            experimentationConnector = { name: expConnectorName, provider: experimentationProvider, listener: experimentationListener };
        }
    }
    return { experimentation: experimentationConnector };
};

const initializeClient = () => {
    const requestedAssets = window.___initialData___ && getUniqueRequestedAssets(window.___initialData___);
    let bindings = { modules: {}, dataActions: {} };
    const requestContext = window.___initialData___ && window.___initialData___.requestContext;

    bindings = registerModules(requestContext, requestedAssets);

    // view extensions registration
    try {
        bindings.views = fetchRegistrationObject(require('lib/view-registration'), 'viewDictionary');
    } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            process.env.NODE_ENV === 'development' && console.log(`view registration files not found.`);
        }
    }

    // component extensions registration
    try {
        bindings.components = fetchRegistrationObject(require('lib/component-registration'), 'componentDictionary');
    } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            process.env.NODE_ENV === 'development' && console.log(`component registration files not found.`);
        }
    }

    // connectors registration
    try {
        bindings.connectors = fetchRegistrationObject(require('lib/connector-registration'), 'connectorDictionary');
    } catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            process.env.NODE_ENV === 'development' && console.log(`connector registration files not found.`);
        }
    }

    const connectorInformation = requestContext.connectors;
    const connectors = initializeConnectors(connectorInformation, bindings.connectors, requestContext);

    app.initializeClientApp(bindings, connectors);
    app.clientRender();
};

initializeClient();

/*******************************************************************************
* Copyright (c) Microsoft Corporation.
* All rights reserved. See LICENSE in the project root for license information.
*******************************************************************************/


const { safeReadJson } = require('@msdyn365-commerce/utilities-internal');
const path = require('path');
const PLATFORM_SETTINGS = 'platform.settings';
const fs = require('fs');
const utilities = require('@msdyn365-commerce/utilities-internal');
const { resolvePathFromDefinition, getModuleFileRelativePath } = require('@msdyn365-commerce/build-scripts-internal/dist/lib');

const MODULE = {
    registrationFileName: 'module-registration',
    namespace: utilities.getSupportedNamespaces()
};
const localNamespace = '__local__';

const resolvedHoistedPath = path.resolve(process.cwd(), '../..').replace(/\\/gi, '/');
const appDirectory = fs.realpathSync(process.cwd());
const fixPath = function(pathToFile, replaceWith) {
    if (replaceWith === void 0) {
        replaceWith = '/';
    }
    return pathToFile && pathToFile.replace(/\/|\\/g, replaceWith);
};
const hoistedPath = fixPath(path.resolve('../../node_modules'));
const MODULE_DETAILS_REGEX = utilities
    .getSupportedNamespaces()
    // eslint-disable-next-line
    .map(packageNamespace => new RegExp(`/node_modules\/(?<namespace>${packageNamespace})\/(?<packageName>.*)\/dist\/lib\/.*`));

const getModuleDetails = filePath => {
    let moduleNamespace = localNamespace;
    let packageName = localNamespace;
    let isHoisted = false;

    for (let i = 0; i < MODULE_DETAILS_REGEX.length; ++i) {
        const matchResult = filePath.match(MODULE_DETAILS_REGEX[i]);
        if (matchResult !== null && matchResult.groups && matchResult.groups.namespace && matchResult.groups.packageName) {
            moduleNamespace = matchResult.groups.namespace;
            packageName = matchResult.groups.packageName;
            isHoisted = (filePath || '').indexOf(hoistedPath) === 0;

            return {
                moduleNamespace,
                packageName,
                isHoisted
            };
        }
    }

    return {
        moduleNamespace,
        packageName,
        isHoisted
    };
};
const resolveFromSrcFolder = relativePath => path.resolve(appDirectory, 'src', relativePath);
const getPlatformSettings = async () => {
    const platFormSettings = await safeReadJson(path.resolve(resolveFromSrcFolder('settings'), `${PLATFORM_SETTINGS}.json`));
    return platFormSettings || {};
};

const getResolutionPathPattern = (registrationFileType, nodeExt, modulename) => {
    const resolutionPathPattern = {
        fromInstalledModule: MODULE.namespace.map(
            moduleNamespace =>
                `${process.cwd()}/node_modules/${moduleNamespace}/*/dist/lib/**/${modulename}.${registrationFileType}.${nodeExt}`
        ),
        fromHoistedModule: MODULE.namespace.map(
            moduleNamespace =>
                `${resolvedHoistedPath}/node_modules/${moduleNamespace}/*/dist/lib/**/${modulename}.${registrationFileType}.${nodeExt}`
        ),
        fromLocalModule: `${process.cwd()}/src/**/${modulename}.${registrationFileType}.${nodeExt}`
    };

    return resolutionPathPattern;
};

const getModuleName = pathToDefinition => {
    return pathToDefinition ? path.basename(pathToDefinition, '.definition.json') : '';
};

const getExcludedModuleImportPath = async moduleNameList => {
    if (!moduleNameList || moduleNameList.length === 0) {
        return [];
    }
    const moduleImportPathList = moduleNameList.map(async moduleName => {
        const patterns = getResolutionPathPattern('definition', 'json', moduleName);
        const installed = await utilities.safeGetAllFilesPath(patterns.fromInstalledModule);
        const hoisted = await utilities.safeGetAllFilesPath(patterns.fromHoistedModule);
        const local = await utilities.safeGetAllFilesPath(patterns.fromLocalModule);
        // excluded module priority is install > hoisted > local, which means if same module name existed in both installed and local, we exclude installed.
        const definitionPath = (installed && installed[0]) || (hoisted && hoisted[0]) || (local && local[0]);
        if (!definitionPath || definitionPath.length === 0) {
            return;
        }
        const fixPathDefinition = fixPath(path.relative(process.cwd(), definitionPath));
        const { moduleNamespace } = getModuleDetails(definitionPath);
        const definition = await utilities.safeReadJson(definitionPath);
        let parentDefinitionPath = null;
        if (definition.$ref) {
            parentDefinitionPath = definition.$ref;
            // resolve parent definition path with respect to current module definition or node_modules
            parentDefinitionPath = utilities.resolveParentDefinitionPath(parentDefinitionPath, path.dirname(definitionPath));
        }
        const referencedOutput = await utilities.resolveRef(definition, definitionPath);
        let moduleViewRelativePath = referencedOutput.module ? referencedOutput.module.view : null;
        let forceRelativePathResolution = false;
        if (!moduleViewRelativePath) {
            const parentModuleName = parentDefinitionPath ? getModuleName(parentDefinitionPath) : null;
            // Resolve parentview first (for $ref scenario) and fallback to current module in case of independent module
            moduleViewRelativePath = parentModuleName || definition.name;
            forceRelativePathResolution = true;
        }
        const moduleViewAbsolutePath = await resolvePathFromDefinition(
            '',
            moduleViewRelativePath,
            path.dirname(definitionPath),
            forceRelativePathResolution
        );
        const absolutePath = getModuleFileRelativePath({ moduleFileAbsolutePath: moduleViewAbsolutePath, moduleNamespace });
        const isNodeModule = absolutePath.isNodeModule;
        const pathFile = absolutePath.fileRelativePath;
        const isHoisted = fixPathDefinition.startsWith('../../node_modules/@msdyn365-commerce-modules');
        const alias = !isNodeModule ? 'partner/' : isHoisted ? `hoisted/${moduleNamespace}/` : `${moduleNamespace}/`;
        const importPath = `${alias}${fixPath(pathFile)}`;
        return importPath;
    });
    return Promise.all(moduleImportPathList);
};

exports.getPlatformSettings = getPlatformSettings;
exports.getExcludedModuleImportPath = getExcludedModuleImportPath;

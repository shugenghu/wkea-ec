/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { EVENT_HTTP_SERVICE_START, EVENT_HTTP_SERVICE_STOP, InternalTelemetry, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import axios from 'axios';
import msdyn365Commerce from '../msdyn365-commerce';
// Default timeout is 10 seconds
const defaultTimeout = 10000;
/**
 * Sets retail server specific headers needed for auth
 * @param requestConfig The current configuration settings of the request
 * @param apiSettings The retail server API configuration settings
 */
const setRetailServerRequestHeaders = (requestConfig) => {
    if (!requestConfig.headers) {
        requestConfig.headers = {};
    }
    requestConfig.headers['from-keystone'] = 'true';
    requestConfig.headers.oun = requestConfig.headers.oun || msdyn365Commerce.apiSettings.oun || '';
    requestConfig.headers.Accept = requestConfig.headers.Accept || 'application/json;odata=nometadata';
    requestConfig.headers.ContentType = requestConfig.headers.ContentType || 'application/json;odata=verbose';
    return requestConfig;
};
/**
 * Parses an OData Response and returns just the return type of the call without the extra OData Metadata
 */
const parseODataResponse = (response) => {
    if (response && response.value && response['@odata.context']) {
        return response.value;
    }
    else {
        return response;
    }
};
/**
 * Creates a basic Axios Request Config that is shared across commerce and standard HTTP calls
 * @param requestUrl The url of the request
 * @param httpMethod The HTTP method of the request
 * @param body The body content of the request
 * @param options The options associated with the request
 */
const createDefaultRequest = (requestUrl, httpMethod, body, options) => {
    return {
        method: httpMethod || 'get',
        url: requestUrl,
        data: body,
        timeout: options ? options.timeout || defaultTimeout : defaultTimeout,
        headers: options ? options.headers || {} : {}
    };
};
/**
 * Send an retail server request
 * @param requestUrl The url of the request
 * @param httpMethod The HTTP method of the request
 * @param body The body content of the request
 * @param options The options associated with the request
 */
export const sendCommerceRequest = async (requestUrl, httpMethod, body, options) => {
    let request = createDefaultRequest(requestUrl, httpMethod, body, options);
    const requestId = InternalTelemetry.generateGuid();
    // Add pre-call telemetry here
    StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_START, { id: requestId });
    // Add the retail server request headers
    // Ideally these will be pulled via our zone implementation so they can be completely hidden from the end user
    request = setRetailServerRequestHeaders(request);
    // Send the request
    return axios
        .request(request)
        .then((response) => {
        // Add any post-call telemetry here
        StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_STOP, {
            statusCode: `${response.status}`,
            success: 'true',
            id: requestId
        });
        // Parse OData and return response
        return {
            ...response,
            data: parseODataResponse(response.data)
        };
    })
        .catch((error) => {
        // Add error handling telemetry and response here
        StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_STOP, {
            statusCode: `${error.code}`,
            success: 'false',
            id: requestId
        });
        // Return either passed error response or empty response to user
        return error.response || {};
    });
};
/**
 * Send an external HTTP request
 * @param requestUrl The url of the request
 * @param httpMethod The HTTP method of the request
 * @param body The body content of the request
 * @param options The options associated with the request
 */
export const sendRequest = async (requestUrl, httpMethod, body, options) => {
    const request = createDefaultRequest(requestUrl, httpMethod, body, options);
    const requestId = InternalTelemetry.generateGuid();
    // Add pre-call telemetry here
    StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_START, { id: requestId });
    // Send the request
    return axios
        .request(request)
        .then((response) => {
        // Add any post-call telemetry here
        StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_STOP, {
            statusCode: `${response.status}`,
            success: 'true',
            id: requestId
        });
        // Return response
        return response;
    })
        .catch((error) => {
        StaticTelemetry.trackEvent(EVENT_HTTP_SERVICE_STOP, {
            statusCode: `${error.code}`,
            success: 'false',
            id: requestId
        });
        // Return either passed error response or empty response to user
        return error.response || {};
    });
};
//# sourceMappingURL=http-service.js.map
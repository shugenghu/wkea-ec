/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
export const DATA_ATTRIBUTE = 'data-i';
export const FRAGMENT_ATTRIBUTE = 'fragment';
export const FRAGMENT_MODULE_ATTRIBUTE = 'fragmentmodule';
export const CONTAINER_TYPE = 'containerModule';
export const EMPTY_SLOT_TYPE_NAME = 'empty-slot';
export const ADD_CONTAINER_CLASS_NAME = 'add-container-inner';
export const ADD_CONTAINER_CLASS_NAME_ON_DRAG_OVER = 'ondrop';
export const ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_MODULE = 'drop-module';
export const ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_FRAGMENT = 'drop-fragment';
export const ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_NOT_ALLOWED = 'drop-error';
export const NO_POINTER_EVENTS_CLASS_NAME = 'ms-no-pointer-events';
/**
 * Get HTML element by a given Id.
 * @param elementId The HTML element Id.
 * @returns {HTMLElement | null} Returns the html element if element exists. Otherwise, return null.
 */
export function getElementById(elementId) {
    return elementId ? document.getElementById(elementId) : null;
}
/**
 * Get the module html element by data Id.
 * @param moduleDataId The module data Id.
 * @returns {HTMLElement | null} Returns the html module element if module exists. Otherwise, return null.
 */
export function getModuleById(moduleDataId) {
    if (!moduleDataId) {
        return null;
    }
    const modules = [...Array.from(document.body.querySelectorAll(`[${DATA_ATTRIBUTE}]`))];
    const foundModule = modules.find(c => getElementDataInfo(c).dataInfo.id === moduleDataId);
    return foundModule ? foundModule : null;
}
/**
 * Get a list of all add module boxes.
 * @returns {ElementDataInfo[]} list of modules.
 */
export function getAllAddModuleBoxes() {
    const modules = [...Array.from(document.body.querySelectorAll(`[${DATA_ATTRIBUTE}]`))];
    return modules.map(m => getElementDataInfo(m)).filter(m => m.dataInfo.typeName === EMPTY_SLOT_TYPE_NAME);
}
/**
 * Get a list of modules by parent data Id and slot data Id.
 * @param parentId The parent data Id.
 * @param slotId The slot Id.
 * @returns {Element[]} list of modules.
 */
export function getModulesByParentIdAndSlotId(parentId, slotId) {
    let modules = [];
    if (!parentId || !slotId) {
        return modules;
    }
    const parentModule = getElementDataInfoById(parentId);
    if (parentModule.element) {
        modules = [...Array.from(parentModule.element.querySelectorAll(`[${DATA_ATTRIBUTE}]`))];
        modules = modules.filter(m => {
            const dataInfo = getElementDataInfo(m).dataInfo;
            if (dataInfo.parentId === parentId && dataInfo.slotId === slotId && dataInfo.typeName !== EMPTY_SLOT_TYPE_NAME) {
                return true;
            }
            return false;
        });
    }
    return modules;
}
/**
 * Get the closest module to a specific html element target.
 * @param target The specific html element target.
 * @returns {HTMLElement | null} Returns the html module element if element exists. Otherwise, return null.
 */
export function getModuleByTarget(target) {
    let moduleElement = target;
    const dataAttribute = moduleElement.getAttribute(DATA_ATTRIBUTE);
    if (!dataAttribute) {
        // Returns the closest ancestor which has an attribute equals to DATA_ATTRIBUTE
        // Gets the closest module to the target
        moduleElement = moduleElement.closest(`[${DATA_ATTRIBUTE}]`);
    }
    return moduleElement;
}
/**
 * Get data info from the data-i element attribute.
 * @param element The html element.
 * @returns {ElementDataInfo} data info from the data-i element attribute.
 */
export function getElementDataInfo(element) {
    if (element) {
        const dataAttribute = element.getAttribute(DATA_ATTRIBUTE);
        if (dataAttribute) {
            const json = dataAttribute.replace(/([^:,{}]+):([^:,{}]+)/g, '"$1":"$2"');
            const obj = JSON.parse(json);
            return {
                dataInfo: {
                    id: obj?.id,
                    parentId: obj?.p,
                    slotId: obj?.s,
                    typeName: obj?.t,
                    friendlyName: obj?.fn,
                    moduleType: obj?.mt,
                    isFragment: isElementFragment(element),
                    isFragmentModule: isElementFragmentModule(element)
                },
                element: element
            };
        }
    }
    return {
        dataInfo: {
            id: '',
            parentId: '',
            slotId: '',
            typeName: '',
            friendlyName: '',
            moduleType: '',
            isFragment: false,
            isFragmentModule: false
        },
        element: element
    };
}
/**
 * Get the element data info by target.
 * @param target The target html element.
 * @returns {ElementDataInfo} data info from the data-i element attribute.
 */
export function getElementDataInfoByTarget(target) {
    return getElementDataInfo(getModuleByTarget(target));
}
/**
 * Get the element data info by module Id.
 * @param moduleId The module Id.
 * @returns {ElementDataInfo} data info from the data-i element attribute.
 */
export function getElementDataInfoById(moduleId) {
    return getElementDataInfo(getModuleById(moduleId));
}
/**
 * clear the element data info object.
 */
export function cleanDataInfo() {
    return {
        dataInfo: {
            id: '',
            parentId: '',
            slotId: '',
            typeName: '',
            friendlyName: '',
            moduleType: '',
            isFragment: false,
            isFragmentModule: false
        },
        element: null
    };
}
/**
 * Get rendering helper.
 */
export function getRenderingHelper() {
    if (
    // @ts-ignore
    window._msdyn365.authoringHelper &&
        // @ts-ignore
        window._msdyn365.authoringHelper.renderingHelper) {
        // @ts-ignore
        return window._msdyn365.authoringHelper.renderingHelper;
    }
}
/**
 * Update the add module inner container class
 * @param addInnerContainer The add module inner container element.
 * @param state The state to where the element classes should be updated to.
 */
export function updateAddModuleInnerContainerClass(addInnerContainer, state = 'Initial') {
    let className = ADD_CONTAINER_CLASS_NAME;
    switch (state) {
        case 'InsertModule':
            className += ` ${ADD_CONTAINER_CLASS_NAME_ON_DRAG_OVER} ${ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_MODULE}`;
            appendNoPointerEventsToChildren(addInnerContainer);
            break;
        case 'InsertFragment':
            className += ` ${ADD_CONTAINER_CLASS_NAME_ON_DRAG_OVER} ${ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_FRAGMENT}`;
            appendNoPointerEventsToChildren(addInnerContainer);
            break;
        case 'MoveNotAllowed':
            className += ` ${ADD_CONTAINER_CLASS_NAME_ON_DRAG_OVER} ${ADD_CONTAINER_CLASS_NAME_ON_DRAGGING_NOT_ALLOWED}`;
            appendNoPointerEventsToChildren(addInnerContainer);
            break;
        default:
            removeNoPointerEventsFromChildren(addInnerContainer);
    }
    addInnerContainer.className = className;
}
/**
 * Set children to have no pointer events.
 * This prevents drag enter event from being triggered for each children in the add module slot
 * @param element the element which children classes should be updated.
 */
function appendNoPointerEventsToChildren(element) {
    const elementChildren = Array.from(element.children);
    elementChildren.map(c => {
        if (c.className) {
            if (!c.className.includes(NO_POINTER_EVENTS_CLASS_NAME)) {
                c.className += ` ${NO_POINTER_EVENTS_CLASS_NAME}`;
            }
        }
        else {
            c.className = `${NO_POINTER_EVENTS_CLASS_NAME}`;
        }
    });
}
/**
 * Remove no pointer events class.
 * This will set the children back to their original classes.
 * @param element the element which children classes should be updated.
 */
function removeNoPointerEventsFromChildren(element) {
    const elementChildren = Array.from(element.children);
    elementChildren.map(c => {
        if (c.className && c.className.includes(NO_POINTER_EVENTS_CLASS_NAME)) {
            c.className = c.className.replace(NO_POINTER_EVENTS_CLASS_NAME, '').trim();
        }
    });
}
/**
 * Returns whether or not the element is a fragment container.
 * @param element The html element.
 * @returns {boolean} Whether or not the element is a fragment container.
 */
function isElementFragment(element) {
    return !!element.getAttribute(FRAGMENT_ATTRIBUTE);
}
/**
 * Returns whether or not the element is a fragment module.
 * @param element The html element.
 * @returns {boolean} Whether or not the element is a fragment module.
 */
function isElementFragmentModule(element) {
    return !!element.getAttribute(FRAGMENT_MODULE_ATTRIBUTE);
}
//# sourceMappingURL=drag-and-drop-utils.js.map
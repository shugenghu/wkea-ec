/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { get as _get, has as _has, set as _set } from 'lodash';
import dragAndDropImage from './drag-and-drop-image';
import dragAndDropPlaceholder from './drag-and-drop-placehoder';
import { cleanDataInfo, EMPTY_SLOT_TYPE_NAME, getElementById, getElementDataInfoById, getElementDataInfoByTarget, getModuleById, getRenderingHelper, updateAddModuleInnerContainerClass } from './drag-and-drop-utils';
/**
 * Provides the drag and drop events implementation
 */
export class DragAndDropEvents {
    constructor() {
        /**
         * Set draggable events for a specific module.
         * @param sourceModuleId The module to be set as draggable.
         * @param rootModuleId The root module to be set as droppable.
         */
        this.setModuleAsDraggable = (sourceModuleId, rootModuleId) => {
            this.renderingHelper = getRenderingHelper();
            if (this.renderingHelper) {
                dragAndDropPlaceholder.setRenderingHelper(this.renderingHelper);
            }
            this._setRootModuleId(rootModuleId);
            this._setRootModuleAsDroppable();
            const module = getModuleById(sourceModuleId);
            if (module) {
                module.addEventListener('dragstart', this._onDragStart);
                module.addEventListener('drag', this._onDrag);
                module.addEventListener('dragend', this._onDragEnd);
                module.setAttribute('draggable', 'true');
            }
        };
        /**
         * Set the root module Id.
         * @param moduleId The root module Id.
         */
        this._setRootModuleId = (moduleId) => {
            this.rootModuleId = moduleId;
        };
        /**
         * Clear cache object.
         */
        this._clearCache = () => {
            this.cache = {};
        };
        /**
         * Check if cache has the information whether or not a module can be dropped in parent container.
         * @param moduleId The module id.
         * @param parentId The parent container id.
         * @param slotId The slot id.
         * @returns {boolean} Returns true cache has the information whether or not a module can be dropped in parent container. Otherwise returns false.
         */
        this._cacheHasIsDroppableInfo = (moduleId, parentId, slotId) => {
            return _has(this.cache, this._getCacheKey(moduleId, parentId, slotId));
        };
        /**
         * Return whether or not a module can be dropped in parent container.
         * @param moduleId The module id.
         * @param parentId The parent container id.
         * @param slotId The slot id.
         * @returns {boolean | unknown} Returns whether or not a module can be dropped in parent container.
         */
        this._isModuleDroppable = (moduleId, parentId, slotId) => {
            if (!parentId || !moduleId || !slotId) {
                return false;
            }
            this._checkIsDroppableAndAddToCache(moduleId, parentId, slotId);
            return _get(this.cache, this._getCacheKey(moduleId, parentId, slotId), false);
        };
        /**
         * Set whether or not a module can be dropped in parent container.
         * @param moduleId The module id.
         * @param parentId The parent container id.
         * @param slotId The slot id.
         */
        this._setModuleIsDroppable = (moduleId, parentId, slotId, canBeDrop) => {
            _set(this.cache, this._getCacheKey(moduleId, parentId, slotId), canBeDrop);
        };
        /**
         * Create a key to cache information whether or not a module is droppable in parent container.
         * @param moduleId The module id.
         * @param parentId The parent container id.
         * @param slotId The slot id.
         * @returns {string} Returns the cache key.
         */
        this._getCacheKey = (moduleId, parentId, slotId) => {
            return `${moduleId}_${parentId}_${slotId}`;
        };
        /**
         * Check if module can be dropped in parent container and cache the information.
         * @param moduleId The module id.
         * @param parentId The parent container id.
         * @param slotId The slot id.
         */
        this._checkIsDroppableAndAddToCache = (moduleId, parentId, slotId) => {
            if (!this._cacheHasIsDroppableInfo(moduleId, parentId, slotId)) {
                const elementDataInfo = getElementDataInfoById(parentId);
                if (elementDataInfo.dataInfo.isFragment || elementDataInfo.dataInfo.isFragmentModule) {
                    this._setModuleIsDroppable(moduleId, parentId, slotId, false);
                }
                else {
                    const isDroppable = this.renderingHelper?.isDroppable(moduleId, parentId, slotId) || false;
                    this._setModuleIsDroppable(moduleId, parentId, slotId, isDroppable);
                }
            }
        };
        /**
         * Handles the on drag over event for containers.
         * @param e The react drag event.
         */
        this._onDragOver = (e) => {
            if (!this.isDragging) {
                return;
            }
            e.preventDefault();
            this.isCursorOnDroppableArea = true;
            const dragEvent = e;
            const elementDataInfo = getElementDataInfoByTarget(e.target);
            if (elementDataInfo.dataInfo.typeName === EMPTY_SLOT_TYPE_NAME) {
                dragAndDropImage.updatePosition(dragEvent.pageX, dragEvent.pageY);
                return;
            }
            this.dropElement = elementDataInfo;
            if (this._isModuleDroppable(this.dragElement.dataInfo.id, this.dropElement.dataInfo.parentId, this.dropElement.dataInfo.slotId)) {
                dragAndDropPlaceholder.setPlaceHolderOnPosition(this.dragElement, this.dropElement, dragEvent.clientY);
                if (dragAndDropImage.isStatusNotDroppable()) {
                    dragAndDropImage.setDropAllowedImage(this.dragElement, dragEvent.pageX, dragEvent.pageY);
                }
            }
            else if (dragAndDropImage.isStatusDroppable()) {
                dragAndDropPlaceholder.clearAll();
                dragAndDropImage.setDropNotAllowedImage(dragEvent.pageX, dragEvent.pageY);
            }
            dragAndDropImage.updatePosition(dragEvent.pageX, dragEvent.pageY);
            this.isCursorOnDroppableArea = false;
        };
        /**
         * Handles the on drag enter event for containers.
         * @param e The react drag event.
         */
        this._onDragEnter = (e) => {
            if (this.isDragging) {
                e.preventDefault();
                this.isCursorOnDroppableArea = true;
                const elementDataInfo = getElementDataInfoByTarget(e.target);
                if (elementDataInfo.dataInfo.typeName === EMPTY_SLOT_TYPE_NAME &&
                    elementDataInfo.element &&
                    elementDataInfo.element.firstElementChild) {
                    const dragEvent = e;
                    // Remove placeholder from canvas and from site builder.
                    dragAndDropPlaceholder.clearAll();
                    if (this._isModuleDroppable(this.dragElement.dataInfo.id, elementDataInfo.dataInfo.id, elementDataInfo.dataInfo.slotId)) {
                        this.dropElement = elementDataInfo;
                        // Get the container inner element and update its class.
                        updateAddModuleInnerContainerClass(elementDataInfo.element.firstElementChild, this.dragElement.dataInfo.isFragment ? 'InsertFragment' : 'InsertModule');
                        // Add placeholder to position 0 on site builder.
                        this.renderingHelper?.onDrag(elementDataInfo.dataInfo.id, 0, elementDataInfo.dataInfo.slotId);
                        dragAndDropImage.setDropAllowedImage(this.dragElement, dragEvent.pageX, dragEvent.pageY);
                    }
                    else {
                        // Get the container inner element and update its class.
                        updateAddModuleInnerContainerClass(elementDataInfo.element.firstElementChild, 'MoveNotAllowed');
                        if (dragAndDropImage.isStatusDroppable()) {
                            dragAndDropImage.setDropNotAllowedImage(dragEvent.pageX, dragEvent.pageY);
                        }
                    }
                }
            }
        };
        /**
         * Handles the on drag leave event for containers.
         * @param e The react drag event.
         */
        this._onDragLeave = (e) => {
            if (this.isDragging) {
                e.preventDefault();
                const elementDataInfo = getElementDataInfoByTarget(e.target);
                if (elementDataInfo.dataInfo.typeName === EMPTY_SLOT_TYPE_NAME &&
                    elementDataInfo.element &&
                    elementDataInfo.element.firstElementChild) {
                    updateAddModuleInnerContainerClass(elementDataInfo.element.firstElementChild);
                }
                this.isCursorOnDroppableArea = false;
            }
        };
        /**
         * Handles the on drop event for containers.
         * @param e The react drag event.
         */
        this._onDrop = (e) => {
            if (this.isDragging) {
                e.preventDefault();
                if (this.dropElement.dataInfo.typeName === EMPTY_SLOT_TYPE_NAME) {
                    if (this._isModuleDroppable(this.dragElement.dataInfo.id, this.dropElement.dataInfo.id, this.dropElement.dataInfo.slotId)) {
                        this.renderingHelper?.onDrop(this.dragElement.dataInfo.id, this.dropElement.dataInfo.id, 0, this.dropElement.dataInfo.slotId);
                    }
                    if (this.dropElement.element && this.dropElement.element.firstElementChild) {
                        updateAddModuleInnerContainerClass(this.dropElement.element.firstElementChild);
                    }
                }
                else {
                    const placeholderInfo = dragAndDropPlaceholder.getPlaceholder();
                    if (placeholderInfo) {
                        const { moduleId, parentId, index, slotId } = placeholderInfo;
                        if (index >= 0 && this._isModuleDroppable(moduleId, parentId, slotId)) {
                            this.renderingHelper?.onDrop(moduleId, parentId, index, slotId);
                        }
                    }
                }
            }
        };
        /**
         * Remove draggable attributes and events.
         * @param moduleId The module to have attributes removed.
         */
        this._removeDraggableEvents = (moduleId) => {
            if (moduleId) {
                const draggableModule = getModuleById(moduleId);
                if (draggableModule) {
                    draggableModule.removeEventListener('dragstart', this._onDragStart);
                    draggableModule.removeEventListener('drag', this._onDrag);
                    draggableModule.removeEventListener('dragend', this._onDragEnd);
                    draggableModule.removeAttribute('draggable');
                }
            }
        };
        /**
         * Handles the drag event.
         * @param e The drag event.
         */
        this._onDrag = (e) => {
            if (!this.isDragging || !this.isCursorOnDroppableArea) {
                dragAndDropImage.hide();
            }
        };
        /**
         * Handles the drag start event.
         * @param e The drag event.
         */
        // tslint:disable-next-line:no-any
        this._onDragStart = (e) => {
            const dragEvent = e;
            this.isDragging = true;
            this.isCursorOnDroppableArea = true;
            this.dragElement = getElementDataInfoByTarget(e.target);
            dragAndDropImage.setDropAllowedImage(this.dragElement, dragEvent.pageX, dragEvent.pageY);
            // Set drag image to a empty div.
            // This prevents the ghost image from being displayed.
            dragEvent.dataTransfer?.setDragImage(dragAndDropImage.setTransparentImage(), 0, 0);
        };
        /**
         * Handles the drag end event.
         * @param e The drag event.
         */
        this._onDragEnd = (e) => {
            this.isDragging = false;
            this.isCursorOnDroppableArea = false;
            // remove draggable events
            this._removeDraggableEvents(this.dragElement.dataInfo.id);
            this._removeDroppableEvents();
            this._clearAllCache();
        };
        /**
         * Clear all cache information.
         */
        this._clearAllCache = () => {
            this.dragElement = cleanDataInfo();
            this.dropElement = cleanDataInfo();
            this.isDragging = false;
            this.isCursorOnDroppableArea = false;
            this._clearCache();
            dragAndDropPlaceholder.clearAll();
            dragAndDropImage.clear();
        };
        /**
         * Set droppable events for the root module.
         */
        this._setRootModuleAsDroppable = () => {
            const droppableModule = getElementById(this.rootModuleId || '');
            if (droppableModule) {
                droppableModule.addEventListener('dragenter', this._onDragEnter);
                droppableModule.addEventListener('dragleave', this._onDragLeave);
                droppableModule.addEventListener('dragover', this._onDragOver);
                droppableModule.addEventListener('drop', this._onDrop);
            }
        };
        /**
         * Remove droppable events.
         */
        this._removeDroppableEvents = () => {
            const droppableModule = getElementById(this.rootModuleId || '');
            if (droppableModule) {
                droppableModule.removeEventListener('dragenter', this._onDragEnter);
                droppableModule.removeEventListener('dragleave', this._onDragLeave);
                droppableModule.removeEventListener('dragover', this._onDragOver);
                droppableModule.removeEventListener('drop', this._onDrop);
            }
        };
        this.cache = {};
        this.dragElement = cleanDataInfo();
        this.dropElement = cleanDataInfo();
        this.isCursorOnDroppableArea = false;
        this.isDragging = false;
    }
}
const dragAndDropEvents = new DragAndDropEvents();
export default dragAndDropEvents;
//# sourceMappingURL=drag-and-drop-events.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { isEqual as _isEqual } from 'lodash';
import { getAllAddModuleBoxes, getElementDataInfo, getElementDataInfoById, getModuleById, getModulesByParentIdAndSlotId, updateAddModuleInnerContainerClass } from './drag-and-drop-utils';
const PLACEHOLDER_TOP_CLASS_NAME = 'ms-drag-placeholder-top';
const PLACEHOLDER_BOTTOM_CLASS_NAME = 'ms-drag-placeholder-bottom';
/**
 * Provides the drag and drop events implementation
 */
export class DragAndDropPlaceholder {
    constructor() {
        /**
         * Return the placeholder information.
         */
        this.getPlaceholder = () => {
            return this.placement;
        };
        /**
         * Clear placeholder.
         */
        this.clear = () => {
            this._removePlaceholderFromElement();
            this._setAllAddModuleBoxesToInitialState();
            this.placement = null;
            this.moduleElement = null;
            this.addModuleBoxes = null;
        };
        /**
         * Clear placeholder on site builder and SDK.
         */
        this.clearAll = () => {
            this.clear();
            this.renderingHelper?.removePlaceholder();
        };
        /**
         * Set rendering helper to be used when calling site builder APIs.
         * @param renderingHelper The rendring helper interface.
         */
        this.setRenderingHelper = (renderingHelper) => {
            this.renderingHelper = renderingHelper;
        };
        /**
         * Move placeholder to a specific position inside a specific container.
         * @param parentId The module id where the module/container should to be dropped
         * @param index The index position for the module drop.
         * @param slotId The slot id where the module/container should to be dropped.
         * @param moduleId The module id of the element being dropped.
         */
        this.movePlaceholder = (parentId, index, slotId, moduleId) => {
            if (!parentId || !slotId || index < 0) {
                return;
            }
            const parentModule = getModuleById(parentId);
            if (parentModule) {
                // get all modules inside the container.
                const modules = getModulesByParentIdAndSlotId(parentId, slotId);
                this._setAllAddModuleBoxesToInitialState();
                if (modules.length === 0) {
                    this._removePlaceholderFromElement();
                    this._setAddModuleBoxToInsertState(parentId, slotId, moduleId ? getElementDataInfoById(moduleId).dataInfo.isFragment : false);
                }
                else {
                    if (index >= 0 && index < modules.length) {
                        // if position index is within the range of possible indexes, insert place holder in the position of the current module.
                        const currentModule = modules[index];
                        this._movePlaceholder(currentModule);
                    }
                    else {
                        // if position is not in the range of available indexes, append placeholder to last module.
                        const currentModule = modules[modules.length - 1];
                        this._movePlaceholder(currentModule, true);
                    }
                }
            }
        };
        /**
         * Set placeholder on position.
         * @param dragModule The draggable module attributes and html element.
         * @param dropModule The droppable module attributes and html element.
         * @param y The position of the mouse cursor on the y-axis.
         */
        this.setPlaceHolderOnPosition = (dragModule, dropModule, y) => {
            const placeholderInfo = this._getPlaceholderPlacementInfo(dragModule, dropModule, y);
            if (placeholderInfo) {
                if (dropModule.element && this._hasPlaceholderPositionChanged(placeholderInfo)) {
                    // If placeholder should be displayed in a new location, update placeholder on canvas and site builder.
                    this._movePlaceholder(dropModule.element, placeholderInfo.placeBottom);
                    this.renderingHelper?.onDrag(dropModule.dataInfo.parentId, placeholderInfo.relativeIndex, dropModule.dataInfo.slotId);
                }
            }
            else if (this._hasPlaceholderPositionChanged(placeholderInfo)) {
                // If placeholder should be removed and has not been yet, clear placeholder from canvas and site builder.
                this.clearAll();
            }
            this.placement = placeholderInfo;
        };
        /**
         * Get a specific add module box html element.
         * @param parentId The parent data Id.
         * @param slotId The slot data Id.
         * @returns {HTMLElement | null} Returns the html module element if module exists. Otherwise, return null.
         */
        this._getAddModuleBox = (parentId, slotId) => {
            if (!this.addModuleBoxes) {
                this.addModuleBoxes = getAllAddModuleBoxes();
            }
            const foundBox = this.addModuleBoxes.find(a => a.dataInfo.id === parentId && a.dataInfo.slotId === slotId);
            return foundBox ? foundBox.element : null;
        };
        /**
         * Update the targeted add module box to insert state.
         * @param parentId The parent data Id.
         * @param slotId The slot data Id.
         * @param isFragment True, if the module to be added is a fragment. Otherwise, false.
         */
        this._setAddModuleBoxToInsertState = (parentId, slotId, isFragment) => {
            const addModuleBoxElement = this._getAddModuleBox(parentId, slotId);
            if (addModuleBoxElement && addModuleBoxElement.firstElementChild) {
                updateAddModuleInnerContainerClass(addModuleBoxElement.firstElementChild, isFragment ? 'InsertFragment' : 'InsertModule');
            }
        };
        /**
         * Update all add module boxes to its initial state.
         */
        this._setAllAddModuleBoxesToInitialState = () => {
            if (!this.addModuleBoxes) {
                this.addModuleBoxes = getAllAddModuleBoxes();
            }
            this.addModuleBoxes.map(m => {
                if (m.element?.firstElementChild) {
                    updateAddModuleInnerContainerClass(m.element.firstElementChild);
                }
            });
        };
        /**
         * Returns whether or not the placeholder position has changed.
         */
        this._hasPlaceholderPositionChanged = (placement) => {
            return !_isEqual(this.placement, placement);
        };
        /**
         * Add placeholder to the top or to the bottom of a module.
         * @param moduleElement The module element.
         * @param placeBottom If the placeholder should be placed at the bottom of the module.
         */
        this._movePlaceholder = (moduleElement, placeBottom = false) => {
            this._removePlaceholderFromElement();
            if (placeBottom) {
                moduleElement.className += ` ${PLACEHOLDER_BOTTOM_CLASS_NAME}`;
            }
            else {
                moduleElement.className += ` ${PLACEHOLDER_TOP_CLASS_NAME}`;
            }
            this.moduleElement = moduleElement;
        };
        /**
         * Remove placeholder.
         */
        this._removePlaceholderFromElement = () => {
            if (this.moduleElement && this.moduleElement.className) {
                if (this.moduleElement.className.includes(PLACEHOLDER_BOTTOM_CLASS_NAME)) {
                    this.moduleElement.className = this.moduleElement.className.replace(PLACEHOLDER_BOTTOM_CLASS_NAME, '').trim();
                }
                else if (this.moduleElement.className.includes(PLACEHOLDER_TOP_CLASS_NAME)) {
                    this.moduleElement.className = this.moduleElement.className.replace(PLACEHOLDER_TOP_CLASS_NAME, '').trim();
                }
            }
            this.moduleElement = null;
        };
        this.placement = null;
        this.moduleElement = null;
        this.addModuleBoxes = null;
    }
    /**
     * Get the information for the placeholder placement on modules.
     * @param dragModule The draggable module attributes and html element.
     * @param dropModule The droppable module attributes and html element.
     * @param y The position of the mouse cursor on the y-axis.
     */
    _getPlaceholderPlacementInfo(dragModule, dropModule, y) {
        // Get all modules inside the container.
        const modules = getModulesByParentIdAndSlotId(dropModule.dataInfo.parentId, dropModule.dataInfo.slotId);
        if (modules.length === 0) {
            return null;
        }
        const dragModuleIndex = modules.findIndex(m => getElementDataInfo(m).dataInfo.id === dragModule.dataInfo.id);
        let dropModuleIndex = modules.findIndex(m => getElementDataInfo(m).dataInfo.id === dropModule.dataInfo.id);
        let dropModuleRelativeIndex = dropModuleIndex;
        // if drop module is not found or if it is the drag module, ignore it.
        if (dropModuleIndex < 0 || dropModuleIndex === dragModuleIndex) {
            return null;
        }
        // If the dragged module is in the current container and comes before the droppend module, update the drop index to ignore the drag module position.
        if (dragModuleIndex >= 0 && dragModuleIndex < dropModuleIndex) {
            dropModuleIndex -= 1;
        }
        let placeBottom = false;
        if (dropModule.element) {
            const box = dropModule.element.getBoundingClientRect();
            const distanceToBottom = box.bottom - y;
            const distanceToTop = y - box.top;
            if (distanceToBottom < distanceToTop) {
                dropModuleIndex += 1;
                dropModuleRelativeIndex += 1;
                placeBottom = true;
            }
        }
        return {
            moduleId: dragModule.dataInfo.id,
            parentId: dropModule.dataInfo.parentId,
            slotId: dropModule.dataInfo.slotId,
            index: dropModuleIndex,
            relativeIndex: dropModuleRelativeIndex,
            placeBottom
        };
    }
}
const dragAndDropPlaceholder = new DragAndDropPlaceholder();
export default dragAndDropPlaceholder;
//# sourceMappingURL=drag-and-drop-placehoder.js.map
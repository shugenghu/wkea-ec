{"version":3,"file":"dynamic-import-extensions.js","sourceRoot":"","sources":["../../../src/utilities/dynamic-import-extensions.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,EAAE,YAAY,EAAE,kBAAkB,EAAa,MAAM,8CAA8C,CAAC;AAK3G;;;;;GAKG;AACH,MAAM,iBAAiB,GAAG,CAAC,kBAA0B,EAAE,EAAE;IACrD,IAAI,MAAsB,CAAC;IAC3B,IAAI;QACA,MAAM,GAAG,mBAAmB,CAAC,kBAAkB,CAAC,CAAC;QACjD;;;;;;;;WAQG;KACN;IAAC,OAAO,CAAC,EAAE;QACR,sEAAsE;KACzE;IAED,OAAO,MAAM,CAAC;AAClB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,IAAwB,EAAsB,EAAE;IAC1E,IAAI,CAAC,IAAI,EAAE;QACP,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;KACvD;IAED,IAAI,MAA0B,CAAC;IAC/B,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;IAC9C,MAAM,kBAAkB,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;IACpD,IAAI,SAAuC,CAAC;IAC5C,mCAAmC;IACnC,SAAS,GAAG,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;IAClD,MAAM,UAAU,GAAG,CAAC,CAAC,SAAS,CAAC;IAE/B,IAAI,CAAC,UAAU,EAAE;QACb,SAAS,GAAG,cAAc,CAAC,IAAI,EAAE,CAAC;KACrC;IAED,2HAA2H;IAC3H,MAAM,SAAS,GAAG,OAAO,CAAC,OAAO,CAAwB,SAAS,CAAC,KAAK,SAAS,CAAC;IAClF,MAAM,GAAG;QACL,SAAS;QACT,SAAS,EAAE,SAAS,KAAK,SAAS;QAClC,MAAM,EAAE,SAAS;QACjB,+EAA+E;QAC/E,aAAa,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,kBAAkB,CAAwB,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI;QACvF,SAAS,EAAE,YAAY,CAAC,cAAc,CAAC;QACvC,iBAAiB,EAAE,IAAI;KAC1B,CAAC;IAEF,OAAO,MAAM,CAAC;AAClB,CAAC,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable no-single-line-block-comment no-reserved-keywords\nimport { IDynamicImportArgs, IDynamicLoadResult } from '../interfaces';\nimport { fixChunkName, getDefaultOrResult, IESModule } from './internal/dynamic-import-extensions-helpers';\n\n// global webpack defined require function\ndeclare var __webpack_require__: (webpackRequireName: string) => {};\n\n/**\n * Method tries to load the module synchronously if it is available or will return undefined\n * if module cannot be loaded synchronously.\n *\n * @param webpackResolvePath The path where webpack will try to load the module from\n */\nconst requireModuleSync = (webpackResolvePath: string) => {\n    let result: {} | undefined;\n    try {\n        result = __webpack_require__(webpackResolvePath);\n        /**\n         * The above is analagous to the following but more succinct.\n         *\n         * let requiredModule = __webpack_require__(loadedModWebpackyName);\n         * if (requiredModule) {\n         *    result = requiredModule;\n         * }\n         *\n         */\n    } catch (e) {\n        // intentionally blank, module was not able to be loaded synchronously\n    }\n\n    return result;\n};\n\nexport const dynamicImport = (args: IDynamicImportArgs): IDynamicLoadResult => {\n    if (!args) {\n        throw new Error(`args cannot be null or undefined`);\n    }\n\n    let result: IDynamicLoadResult;\n    const univeralImport = args.universalImport();\n    const actualResolvedPath = univeralImport.resolve();\n    let loadedMod: {} | Promise<{}> | undefined;\n    // try to load module synchronously\n    loadedMod = requireModuleSync(actualResolvedPath);\n    const loadedSync = !!loadedMod;\n\n    if (!loadedSync) {\n        loadedMod = univeralImport.load();\n    }\n\n    // This is how to check if object is a promise per spec http://www.ecma-international.org/ecma-262/6.0/#sec-promise.resolve\n    const isPromise = Promise.resolve(<IESModule | undefined>loadedMod) === loadedMod;\n    result = {\n        isPromise,\n        isSuccess: loadedMod !== undefined,\n        result: loadedMod,\n        // TODO: handle promise case in promise resolve for custom module async loading\n        defaultExport: !isPromise ? getDefaultOrResult(<IESModule | undefined>loadedMod) : null,\n        chunkName: fixChunkName(univeralImport),\n        __isDynamicResult: true\n    };\n\n    return result;\n};\n"]}
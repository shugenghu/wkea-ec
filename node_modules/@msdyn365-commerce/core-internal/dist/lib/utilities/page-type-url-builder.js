/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { parameterize } from './parameterize';
// Query params that must be appened to any URL generated when in preview mode
const PASSTHROUGH_QUERY_PARAMS = ['locale', 'market', 'sitepath', 'hostoverride', 'preview', 'domain'];
const categorySegment = (context, ctx) => {
    if (!context) {
        return '';
    }
    if (context.categories) {
        const parameterizeFeatureFlags = getParameterizeFeatureFlagsWithRequestContext(ctx && ctx.requestContext);
        return context.categories
            .map(record => `/${parameterize(record.Name, undefined, parameterizeFeatureFlags, record.NeutralizedName)}`)
            .join('');
    }
    else if (context.category) {
        return context.category.Slug;
    }
    return '';
};
const categoryMoniker = (context) => {
    if (context) {
        if (context.categories) {
            return `/${context.categories[context.categories.length - 1].RecordId}.c`;
        }
        if (context.category) {
            return `/${context.category.RecordId}.c`;
        }
    }
    return '';
};
const productMoniker = (context, ctx) => {
    if (context) {
        if (context.product && context.product.Name !== '') {
            const parameterizeFeatureFlags = getParameterizeFeatureFlagsWithRequestContext(ctx && ctx.requestContext);
            return `/${parameterize(context.product.Name, undefined, parameterizeFeatureFlags, context.product.NeutralizedName)}/${context.product.RecordId}.p`;
        }
        else if (context.product) {
            return `/${context.product.RecordId}.p`;
        }
    }
    return '';
};
const listMoniker = (context, ctx) => {
    const parameterizeFeatureFlags = getParameterizeFeatureFlagsWithRequestContext(ctx && ctx.requestContext);
    return context && context.list
        ? `/${parameterize(context.list.Name, undefined, parameterizeFeatureFlags, context.list.NeutralizedName)}.l`
        : '';
};
const platformRoutes = {
    category: (context, ctx) => `${categorySegment(context, ctx)}${categoryMoniker(context)}`,
    product: (context, ctx) => `${categorySegment(context, ctx)}${productMoniker(context, ctx)}`,
    list: listMoniker
};
/**
 * Forces strings to have a leading slash and no trailing slash
 */
const ensureSlashConsistency = (name) => {
    if (name[0] !== '/') {
        name = `/${name}`;
    }
    if (name[name.length - 1] === '/') {
        name = name.slice(0, -1);
    }
    return name;
};
/**
 * Correctly appends site path if required in the context
 * @param route Current route
 * @param ctx Action Context
 */
const populateSitePath = (route, ctx) => {
    const sitePath = ctx && ctx.requestContext && ctx.requestContext.sitePath;
    sitePath && route.unshift(sitePath);
    return route;
};
/**
 * Appends any query params that should be appended if preview mode is set to true
 * and returns the final result
 *
 * @param route The partially constructed destination url
 * @param queryParams The list of query params in the initial request
 */
export const appendQueryParams = (route, queryParams) => {
    if (route && queryParams && (queryParams.preview || queryParams.domain)) {
        const query = Object.keys(queryParams)
            .map(key => (PASSTHROUGH_QUERY_PARAMS.indexOf(key) !== -1 ? `${key}=${queryParams[key]}` : ''))
            .filter(Boolean)
            .join('&');
        return query.length ? `${route}${route.indexOf('?') === -1 ? '?' : '&'}${query}` : route;
    }
    return route || '';
};
const appendQueryString = (route, context) => {
    return appendQueryParams(route, context && context.requestContext && context.requestContext.query);
};
function getRoutePath(route, ctx, routeContext) {
    let returnUrl = '';
    if (route) {
        if (typeof route === 'function') {
            route = route(routeContext, ctx);
        }
        returnUrl = populateSitePath([route], ctx)
            .map(ensureSlashConsistency)
            .join('');
    }
    return appendQueryString(returnUrl, ctx);
}
/**
 * Gets the corresponding route for the given page type
 * @param pageType the type of page that needs to be routed to.
 * @param ctx current action context.
 */
export const getUrlSync = (pageType, ctx, routeContext = {}) => {
    let route;
    if (platformRoutes[pageType]) {
        return getRoutePath(platformRoutes[pageType], ctx, routeContext);
    }
    const requestContext = ctx && ctx.requestContext;
    if (requestContext) {
        route = requestContext.query && requestContext.query[pageType];
        if (route) {
            return getRoutePath(route, ctx, routeContext);
        }
        const appRoutes = requestContext.app && requestContext.app.routes;
        if (appRoutes) {
            const pageRouteFromAppSettings = appRoutes[pageType];
            if (pageRouteFromAppSettings && typeof pageRouteFromAppSettings === 'object') {
                return appendQueryString(pageRouteFromAppSettings.destinationUrl, ctx);
            }
            else if (pageRouteFromAppSettings && typeof pageRouteFromAppSettings === 'string') {
                return getRoutePath(pageRouteFromAppSettings, ctx, routeContext);
            }
        }
    }
    return getRoutePath(pageType, ctx, routeContext);
};
export const getCategoriesUrlSync = (categoriesPath, ctx) => {
    const categoriesPathUrls = [];
    const tempSegments = [];
    if (categoriesPath && categoriesPath.Segments) {
        categoriesPath.Segments.map(seg => {
            tempSegments.push({
                Name: seg.CategoryName || '',
                RecordId: seg.CategoryId || ''
            });
            const context = {
                categories: tempSegments
            };
            categoriesPathUrls.push({
                Name: seg.CategoryName,
                Url: getUrlSync("category" /* Category */, ctx, context) || ''
            });
        });
    }
    return categoriesPathUrls;
};
/**
 * Gets localized friendlyName from category NameTranslations object based on the locale
 * @param locale Locale from current requestContext
 * @param nameTranslations LocalizedNames for a given category.
 */
export const getFriendlyName = (locale, nameTranslations) => {
    let nameTranslation;
    if (locale && nameTranslations && nameTranslations.length > 0) {
        nameTranslation = nameTranslations.find(item => item.Language.toLowerCase() === locale.toLowerCase());
    }
    return nameTranslation && nameTranslation.Text;
};
/**
 * Return ParameterizedFeatureFlags based on requestContext
 * @param ctx Action Context
 */
export const getParameterizeFeatureFlags = (ctx) => {
    return {
        enableUrlEncoding: (ctx && ctx.requestContext.features && ctx.requestContext.features.enableUrlEncoding) || false,
        enableUrlLocalization: (ctx && ctx.requestContext.features && ctx.requestContext.features.enableUrlLocalization) || false
    };
};
/**
 * Return ParameterizedFeatureFlags based on requestContext
 * @param ctx Request Context
 */
export const getParameterizeFeatureFlagsWithRequestContext = (ctx) => {
    return {
        enableUrlEncoding: (ctx && ctx.features && ctx.features.enableUrlEncoding) || false,
        enableUrlLocalization: (ctx && ctx.features && ctx.features.enableUrlLocalization) || false
    };
};
//# sourceMappingURL=page-type-url-builder.js.map
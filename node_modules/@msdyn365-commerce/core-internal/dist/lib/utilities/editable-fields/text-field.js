/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import createDOMPurify from 'dompurify';
import React, { Component } from 'react';
import ContentEditable from 'react-contenteditable';
import { FieldType } from './editable-field';
import { getEditableFieldClassName } from './utils';
/**
 * Component class for text field
 */
export class TextField extends Component {
    constructor(props) {
        super(props);
        this.state = {
            displayHtml: props.fieldProps.text
        };
        this._onChange = this._onChange.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this.isEmpty = false;
    }
    componentWillReceiveProps(nextProps) {
        if (this.props.fieldProps.text !== nextProps.fieldProps.text) {
            this.isEmpty = this._isTextEmpty(nextProps.fieldProps.text);
            // hook to handle props changes - when a field is changed between edit enabled/disabled states
            this.state = {
                displayHtml: this._getDisplayText(nextProps.fieldProps.text)
            };
        }
    }
    render() {
        if (!!this.props.disabled) {
            return this.props.fieldProps.text ? (React.createElement(ContentEditable, { html: this.state.displayHtml, tagName: this.props.fieldProps.tag, disabled: true, onChange: this._onChange, className: getEditableFieldClassName(true, this.props.fieldProps.className, this.props.requestContext) })) : null;
        }
        return (React.createElement(ContentEditable, Object.assign({ html: this.state.displayHtml, tagName: this.props.fieldProps.tag, disabled: false, onChange: this._onChange || this._onChange, onFocus: this.props.onFocus, onBlur: this.props.onBlur || this._onBlur, onMouseOver: this.props.onMouseOver, onMouseOut: this.props.onMouseOut, className: getEditableFieldClassName(false, this.props.fieldProps.className, this.props.requestContext) }, (this.props.fieldProps.additionalProperties || {}))));
    }
    _onChange(event) {
        if (this.props.onChange) {
            const displayValue = this.props.type === FieldType.Text || this.props.type === FieldType.Link
                ? event.currentTarget.innerText
                : event.target.value;
            this.isEmpty = this._isTextEmpty(displayValue);
            this.setState({
                displayHtml: !this.isEmpty ? displayValue : ''
            });
            event.target.value = displayValue;
            this.props.onChange(event);
        }
    }
    _onBlur(event) {
        if (this.isEmpty && !!this.props.fieldProps.required) {
            this.setState({
                displayHtml: this._getDisplayText(this.props.fieldProps.text)
            });
        }
    }
    _getDisplayText(text) {
        return !!this.props.fieldProps.required && this.isEmpty ? this.props.placeholderText || 'Click to Edit' : text;
    }
    _isTextEmpty(text) {
        const DOMPurify = createDOMPurify(window);
        const sanitizedText = DOMPurify.sanitize(text, {
            ALLOWED_TAGS: []
        }).replace(/\n/, '');
        return sanitizedText === '';
    }
}
//# sourceMappingURL=text-field.js.map
import axios from 'axios';
import 'jest';
import sinon from 'sinon';
import { sendCommerceRequest, sendRequest } from '../http-service';
// Promise that imitates a successful HTTP Request
const successfulRequestPromise = new Promise((resolve) => {
    setTimeout(() => {
        resolve({
            status: 200,
            data: { foo: 'bar' },
            config: {},
            statusText: ''
        });
    }, 100);
});
// Promise that imitates a unsuccessful HTTP request
const unsuccessfulRequestPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject({
            code: '404',
            response: {
                status: 404,
                config: {},
                statusText: ''
            }
        });
    }, 100);
});
describe('sendCommerceRequest', () => {
    let sandbox;
    beforeEach(() => {
        sandbox = sinon.createSandbox();
    });
    afterEach(() => {
        sandbox.restore();
    });
    it('should allow you to set a custom oun value', async () => {
        sandbox.stub(axios, 'request').returns(successfulRequestPromise);
        await sendCommerceRequest('/foo', 'post', {}, { headers: { oun: 'test123' } });
        // @ts-ignore
        sinon.assert.calledWith(axios.request, {
            data: {},
            headers: {
                Accept: 'application/json;odata=nometadata',
                ContentType: 'application/json;odata=verbose',
                'from-keystone': 'true',
                oun: 'test123'
            },
            method: 'post',
            timeout: 10000,
            url: '/foo'
        });
    });
});
describe('sendRequest', () => {
    let sandbox;
    beforeEach(() => {
        sandbox = sinon.createSandbox();
    });
    afterEach(() => {
        sandbox.restore();
    });
    it('should properly return reponse object on successful request', () => {
        sandbox.stub(axios, 'request').returns(successfulRequestPromise);
        sendRequest('/foo')
            .then((response) => {
            expect(response.status).toEqual(200);
            expect(response.data).toEqual({ foo: 'bar' });
        })
            .catch((error) => {
            console.error('Error during test!');
        });
    });
    it('should properly return reponse object on unsuccessful request', () => {
        sandbox.stub(axios, 'request').returns(unsuccessfulRequestPromise);
        sendRequest('/foo')
            .then((response) => {
            expect(response.status).toEqual(404);
            expect(response.data).toBeUndefined();
        })
            .catch((error) => {
            console.error('Error during test!');
        });
    });
});
//# sourceMappingURL=http-service.test.js.map
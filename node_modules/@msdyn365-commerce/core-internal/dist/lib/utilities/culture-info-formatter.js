/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:no-any
import { EXCEPTION_INVALID_ARGUMENT, NAME_CULTURE_INFO_FORMATTER_EXCEPTION } from '@msdyn365-commerce/telemetry-internal';
import memoizeFormatConstructor from 'intl-format-cache';
import areIntlLocalesSupported from 'intl-locales-supported';
const numericIdentifier = 'numeric';
/**
 * CultureInfoFormatter provides functions that support the localized formatting
 * of currencies, numbers, dates and times.
 */
export class CultureInfoFormatter {
    /**
     * Constructs a new instance of this formatter using the given locale.
     * Default value for locale is 'en-US'
     *
     * @param locale A string containing a BCP-47 locale tag e.g. 'en', 'en-us', 'fr-fr'. Default value of 'en-US'
     * For more information see https://tools.ietf.org/html/bcp47
     */
    constructor(locale, currencyCode) {
        /**
         * Returns a localized currency formatted version of a price.
         *
         * @param price Either a string or number representing the price that will be localized and formatted
         * @param currencyCode Optional argument. The three letter currency code that will be used for formatting the currency.
         * If the currency code is not provided the locale will be used to determine the best fit currency code.
         */
        this.formatCurrency = (price, currencyCode) => {
            CultureInfoFormatter._validateInput(price === undefined, 'formatCurrency', 'price');
            price = price || 0;
            if (!this.currencyFormatter) {
                this.currencyFormatter = this.numFormatterConstructor(this.locale, {
                    style: 'currency',
                    currency: currencyCode || this.currencyCode
                });
            }
            return !currencyCode
                ? this.currencyFormatter.format(+price)
                : this.formatNumber(+price, { style: 'currency', currency: currencyCode });
        };
        /**
         * Returns a localized formatted version of a number
         *
         * @param value The number that will be localized and formatted
         * @param options An optional argument that controls the formatting.
         */
        this.formatNumber = (value, options) => {
            CultureInfoFormatter._validateInput(value === undefined, 'formatNumber', 'value');
            value = value || 0;
            if (!this.numberFormatter) {
                this.numberFormatter = this.numFormatterConstructor(this.locale);
            }
            // If no options are given to us, we can use the basic cached formatter
            return options !== undefined
                ? this.numFormatterConstructor(this.locale, options).format(value)
                : this.numberFormatter.format(value);
        };
        /**
         * Returns a localized formatted version of a date
         *
         * @param date Date object representing the date that will be localized and formatted
         * @param options An optional argument that controls the formatting.
         */
        this.formatDate = (date, options) => {
            CultureInfoFormatter._validateInput(!date, 'formatDate', 'date');
            if (!this.dateFormatter) {
                this.dateFormatter = this.dateFormatterConstructor(this.locale);
            }
            // If no options are given to us, we can use the basic cached formatter
            return options !== undefined ? this.dateFormatterConstructor(this.locale, options).format(date) : this.dateFormatter.format(date);
        };
        /**
         * Returns a localized formatted version of a time
         *
         * @param time Date object representing the time that will be localized and formatted
         * @param options An optional argument that controls the formatting
         */
        this.formatTime = (time, options) => {
            CultureInfoFormatter._validateInput(!time, 'formatTime', 'time');
            if (!this.timeFormatter) {
                this.timeFormatter = (this.dateFormatterConstructor(this.locale, { hour: numericIdentifier, minute: numericIdentifier }));
            }
            // If no options are given to us, we can use the basic cached formatter
            if (options !== undefined) {
                options.hour = 'numeric';
                options.minute = 'numeric';
                return this.dateFormatterConstructor(this.locale, options).format(time);
            }
            return this.timeFormatter.format(time);
        };
        CultureInfoFormatter._validateInput(!locale, 'CultureInfoFormatter', 'locale');
        CultureInfoFormatter._validateInput(!currencyCode, 'CultureInfoFormatter', 'currencyCode');
        this.locale = locale;
        this.currencyCode = currencyCode;
        // If we are running server side or the browser does not support the locale, use the polyfill for Intl
        if (process.env.CURRENT_ENVIRONMENT === 'node' || !areIntlLocalesSupported(this.locale)) {
            // Intl doesn't have the data we need, so load the
            // polyfill and replace the constructors with need with the polyfill's.
            // tslint:disable-next-line:no-require-imports
            const IntlPolyfill = require('intl');
            Intl.NumberFormat = IntlPolyfill.NumberFormat;
            Intl.DateTimeFormat = IntlPolyfill.DateTimeFormat;
        }
        // Create cached number, date and time formatter for basic formatting
        this.numFormatterConstructor = memoizeFormatConstructor(Intl.NumberFormat);
        this.dateFormatterConstructor = memoizeFormatConstructor(Intl.DateTimeFormat);
    }
    static _validateInput(validation, methodName, argName) {
        if (validation) {
            throw new Error(`${NAME_CULTURE_INFO_FORMATTER_EXCEPTION}: ${EXCEPTION_INVALID_ARGUMENT(methodName, argName)}`);
        }
    }
}
//# sourceMappingURL=culture-info-formatter.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { EVENT_COMMERCE_REQUEST_START, EVENT_COMMERCE_REQUEST_STOP, InternalTelemetry, StaticTelemetry, TelemetryBase } from '@msdyn365-commerce/telemetry-internal';
import axios from 'axios';
// Default timeout is 10 seconds
const defaultTimeout = 10000;
/**
 * Helper class to call the commerce retail server
 */
export class CommerceRequest {
    constructor(context) {
        this.post = async (args) => {
            const { httpOptions } = this.parseOptions(args);
            return this.sendCommerceRequest(args.requestUrl, 'post', args.body, httpOptions);
        };
        this.get = async (args) => {
            const { httpOptions } = this.parseOptions(args);
            return this.sendCommerceRequest(args.requestUrl, 'get', null, httpOptions);
        };
        this.parseOptions = (args) => {
            const apiSettings = this.apiSettings;
            const { options } = args;
            const requestId = (options && options.headers && (options.headers.requestId || options.headers.operationId)) ||
                this.requestContext.operationId ||
                TelemetryBase.generateGuid();
            const httpOptions = {
                ...{ headers: { oun: apiSettings.oun, requestId } },
                ...args.options
            };
            return { httpOptions };
        };
        /**
         * Creates a basic Axios Request Config that is shared across commerce and standard HTTP calls
         * @param requestUrl The url of the request
         * @param httpMethod The HTTP method of the request
         * @param body The body content of the request
         * @param options The options associated with the request
         */
        this.createDefaultRequest = (requestUrl, httpMethod, body, options) => {
            return {
                method: httpMethod || 'get',
                url: requestUrl,
                data: body,
                timeout: options ? options.timeout || defaultTimeout : defaultTimeout,
                headers: options ? options.headers || {} : {}
            };
        };
        /**
         * Sets retail server specific headers needed for auth
         * @param requestConfig The current configuration settings of the request
         * @param apiSettings The retail server API configuration settings
         */
        this.setRetailServerRequestHeaders = (requestConfig) => {
            if (!requestConfig.headers) {
                requestConfig.headers = {};
            }
            requestConfig.headers['from-keystone'] = 'true';
            requestConfig.headers.oun = requestConfig.headers.oun || '';
            requestConfig.headers.Accept = requestConfig.headers.Accept || 'application/json;odata=nometadata';
            requestConfig.headers.ContentType = requestConfig.headers.ContentType || 'application/json;odata=verbose';
            return requestConfig;
        };
        /**
         * Parses an OData Response and returns just the return type of the call without the extra OData Metadata
         */
        this.parseODataResponse = (response) => {
            if (response && response.value && response['@odata.context']) {
                return response.value;
            }
            else {
                return response;
            }
        };
        /**
         * Send an retail server request
         * @param requestUrl The url of the request
         * @param httpMethod The HTTP method of the request
         * @param body The body content of the request
         * @param options The options associated with the request
         */
        this.sendCommerceRequest = async (requestUrl, httpMethod, body, options) => {
            const apiVersion = requestUrl.indexOf('?') === -1 ? '?api-version=7.3' : '&api-version=7.3';
            requestUrl = `${this.apiSettings.baseUrl}${requestUrl}${apiVersion}`;
            let request = this.createDefaultRequest(requestUrl, httpMethod, body, options);
            // generate telemetryid to track event
            const requestId = InternalTelemetry.generateGuid();
            // Add pre-call telemetry here
            StaticTelemetry.trackEvent(EVENT_COMMERCE_REQUEST_START, { id: requestId });
            // Add the retail server request headers
            // Ideally these will be pulled via our zone implementation so they can be completely hidden from the end user
            request = this.setRetailServerRequestHeaders(request);
            // Send the request
            return axios
                .request(request)
                .then((response) => {
                // Add any post-call telemetry here
                StaticTelemetry.trackEvent(EVENT_COMMERCE_REQUEST_STOP, {
                    statusCode: `${response.status}`,
                    success: 'true',
                    id: requestId
                });
                // Parse OData and return response
                return {
                    ...response,
                    data: this.parseODataResponse(response.data)
                };
            })
                .catch((error) => {
                StaticTelemetry.trackEvent(EVENT_COMMERCE_REQUEST_STOP, {
                    statusCode: `${error.code}`,
                    success: 'false',
                    id: requestId
                });
                // Return either passed error response or empty response to user
                return error.response || {};
            });
        };
        if (!context) {
            throw Error('Context passed in as null, cannot call API');
        }
        const requestContext = context.requestContext;
        if (!requestContext || !requestContext.apiSettings || !requestContext.apiSettings.baseUrl) {
            throw Error('Context passed is not of type ActionContext, cannot call API');
        }
        this.apiSettings = requestContext.apiSettings;
        this.requestContext = requestContext;
    }
}
//# sourceMappingURL=commerce-request.js.map
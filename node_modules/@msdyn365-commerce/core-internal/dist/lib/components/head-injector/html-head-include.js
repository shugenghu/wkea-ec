/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { isEqual } from 'lodash';
import React, { Component } from 'react';
import withSideEffect from 'react-side-effect';
import { updateHead } from './html-head-utils';
import { ALLOWED_DUPLICATES, BODY_END_LOAD_POINT, BODY_START_LOAD_POINT, COMPONENT_TYPES, DATA_LOAD_POINT, FAVICON_REL, HEAD_ELEMENT_IDENTIFIER_ATTR, HEAD_END_LOAD_POINT, HEAD_START_LOAD_POINT, META_CONTENT_APPEND_ATTR, METATYPES, NON_SCRIPT_TAGS, TAG_NAMES } from './IHtmlHeadModel';
import msdyn365Commerce from '../../msdyn365-commerce';
/**
 * reduces props of various HtmlHeadInclude instances and deduces a final state value
 *
 * @function reduceComponents
 * @access public
 * @param {IHtmlHeadProps[]} props - props list of all the HtmlHeadInclude instances
 * @return {HtmlHead} - final list of merged tags
 */
function reduceComponents(props) {
    const reducedComponents = props
        .map((component) => {
        return component.children;
    })
        .reduce((a, b) => {
        if (b instanceof React.createElement || Array.isArray(b)) {
            return a.concat(React.Children.toArray(b));
        }
        return a.concat(b);
    }, [])
        .reverse()
        .filter(Boolean)
        .filter(unique())
        .reverse();
    const mergedComponents = [];
    reducedComponents.forEach((child, index) => {
        const childElement = child;
        // Append content for conflicting meta tags with same 'name' property
        if (childElement.type === TAG_NAMES.META) {
            for (let i = 0; i < mergedComponents.length; ++i) {
                if (mergedComponents[i].props.name === childElement.props.name &&
                    (mergedComponents[i].props[META_CONTENT_APPEND_ATTR] || childElement.props[META_CONTENT_APPEND_ATTR])) {
                    mergedComponents[i] = React.cloneElement(mergedComponents[i], {
                        content: `${mergedComponents[i].props.content}, ${childElement.props.content}`
                    });
                    return;
                }
            }
        }
        const className = (childElement.props && childElement.props.className ? `${childElement.props.className} ` : '') + HEAD_ELEMENT_IDENTIFIER_ATTR;
        const key = childElement.key || index;
        mergedComponents.push(React.cloneElement(childElement, { key, className }));
    });
    // Initialize dictionary to map all merged components into their respective slots
    const componentMap = {};
    // tslint:disable-next-line: prefer-for-of
    for (let i = 0; i < COMPONENT_TYPES.length; i++) {
        componentMap[COMPONENT_TYPES[i]] = [];
    }
    let hasFavIcon = false;
    // Loop through the merged components and map the component to its appropriate slot
    mergedComponents.forEach((comp) => {
        if (comp.type === 'script') {
            switch (comp.props[DATA_LOAD_POINT]) {
                case HEAD_START_LOAD_POINT:
                    componentMap[HEAD_START_LOAD_POINT].push(comp);
                    break;
                case HEAD_END_LOAD_POINT:
                    componentMap[HEAD_END_LOAD_POINT].push(comp);
                    break;
                case BODY_START_LOAD_POINT:
                    componentMap[BODY_START_LOAD_POINT].push(comp);
                    break;
                default:
                    componentMap[BODY_END_LOAD_POINT].push(comp);
            }
        }
        else if (comp.type !== 'script') {
            if (FAVICON_REL.indexOf(comp.props.rel) !== -1) {
                hasFavIcon = true;
            }
            componentMap[NON_SCRIPT_TAGS].push(comp);
        }
    });
    return {
        tags: mergedComponents,
        nonScriptTags: componentMap[NON_SCRIPT_TAGS],
        scriptTags: {
            headStart: componentMap[HEAD_START_LOAD_POINT],
            headEnd: componentMap[HEAD_END_LOAD_POINT],
            bodyStart: componentMap[BODY_START_LOAD_POINT],
            bodyEnd: componentMap[BODY_END_LOAD_POINT]
        },
        hasFavIcon: hasFavIcon
    };
}
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>,
 except we explicit allow it in ALLOWED_DUPLICATES array
*/
export function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (tagComponent) => {
        const tagElement = tagComponent;
        if (tagElement instanceof React.createElement && tagElement.key) {
            if (keys.has(tagElement.key)) {
                return false;
            }
            keys.add(tagElement.key);
        }
        switch (tagElement.type) {
            case TAG_NAMES.TITLE:
            case TAG_NAMES.BASE:
                if (tags.has(tagElement.type)) {
                    return false;
                }
                tags.add(tagElement.type);
                break;
            case TAG_NAMES.META:
                // tslint:disable-next-line: prefer-for-of
                for (let i = 0; i < METATYPES.length; i++) {
                    const metaType = METATYPES[i];
                    if (tagElement.props[metaType]) {
                        if (metaType === 'charSet') {
                            if (metaTypes.has(metaType)) {
                                return false;
                            }
                            metaTypes.add(metaType);
                        }
                        else {
                            const category = tagElement.props[metaType];
                            const categories = metaCategories[metaType] || new Set();
                            if (categories.has(category) && !ALLOWED_DUPLICATES.has(category)) {
                                return false;
                            }
                            categories.add(category);
                            metaCategories[metaType] = categories;
                        }
                    }
                }
                break;
            case TAG_NAMES.LINK:
                tags.add(tagElement.type);
                break;
            default:
        }
        return true;
    };
}
/**
 * maps state on server
 * @function mapOnServer
 * @param {HtmlHead} head - final list of merged tags
 * @return {HtmlHead} - final list of merged tags
 */
function mapOnServer(head) {
    return head;
}
/**
 * state change handler
 * @function onStateChange
 * @param {HtmlHead} head - final list of merged tags
 */
function onStateChange(head) {
    updateHead(head);
}
/**
 * <HtmlHeadInclude>
 *     <title></title>
 *     <meta name='description' content='Home page'>
 *     <meta property='og:type, content='article>
 *     <script src='http://include.com/pathtojs.js  type='text/javascript' />
 * </HtmlHeadInclude>
 *
 * HigherOrder Component to wrap HtmlHeadInclude instance and pass it to another higher order component withSideEffect
 * that tracks changes on various instances of HtmlHeadInclude and arrives at a final merged list of props that can be
 * used to update head tags
 */
// tslint:disable-next-line:no-any
const withHtmlHeadInclude = (WrappedComponent) => { var _a; return _a = class WrapperComponent extends Component {
        static set canUseDOM(canUseDOM) {
            WrappedComponent.canUseDOM = canUseDOM;
        }
        shouldComponentUpdate(nextProps) {
            return !isEqual(this.props, nextProps);
        }
        render() {
            if (msdyn365Commerce.isBrowser) {
                return React.createElement(React.Fragment, null);
            }
            return React.createElement(WrappedComponent, Object.assign({}, this.props));
        }
    },
    _a.peek = () => {
        return WrappedComponent.peek();
    },
    _a.rewind = () => {
        let mappedState = WrappedComponent.rewind();
        if (!mappedState) {
            // provide fallback if mappedState is undefined
            mappedState = mapOnServer({
                tags: [],
                nonScriptTags: [],
                scriptTags: {
                    headStart: [],
                    headEnd: [],
                    bodyStart: [],
                    bodyEnd: []
                },
                hasFavIcon: false
            });
        }
        return mappedState;
    },
    _a; };
const htmlHeadIncludeWithSideEffect = withSideEffect(reduceComponents, onStateChange, mapOnServer);
export const HtmlHeadInclude = withHtmlHeadInclude(htmlHeadIncludeWithSideEffect(() => null));
//# sourceMappingURL=html-head-include.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { BODY_START_LOAD_POINT, DATA_LOAD_POINT, HEAD_ELEMENT_IDENTIFIER_ATTR, HEAD_START_LOAD_POINT } from './IHtmlHeadModel';
const DOMAttributeNames = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * update title of the page
 * @function updateTitle
 * @param {HtmlHeadElement} title - final derived title component
 */
const updateTitle = (titleComponent) => {
    let title = '';
    if (titleComponent) {
        const { children } = titleComponent.props;
        title = typeof children === 'string' ? children : '';
    }
    switch (titleComponent && titleComponent.props['data-ms-action']) {
        case 'format':
            // @ts-ignore
            if (window && window.___initialData___ && window.___initialData___.pageRoot) {
                // @ts-ignore
                const titleTemplate = window.___initialData___.pageRoot.titleTemplate;
                title = titleTemplate.replace(/\{0\}/, title);
            }
            break;
        case 'append':
            title = document.title !== title ? `${document.title} ${title}` : title;
            break;
        case 'override':
        default:
    }
    if (document.title !== title) {
        document.title = title;
    }
};
/**
 * update head tag on change, on client side
 * @function reactElementToDOM
 * @param {HtmlHeadElement} element - final react element that needs to be added to DOM
 * @return {HTMLElement} - html dom element
 */
const reactElementToDOM = (element) => {
    const tagType = typeof element.type === 'string' ? element.type : '';
    const el = document.createElement(tagType);
    Object.keys(element.props).forEach((property) => {
        if (property !== 'children' && property !== 'dangerouslySetInnerHTML') {
            const attr = DOMAttributeNames[property] || property.toLowerCase();
            el.setAttribute(attr, element.props[property]);
        }
    });
    // @ts-ignore
    const { children, dangerouslySetInnerHTML } = element.props;
    if (el && dangerouslySetInnerHTML) {
        // tslint:disable-next-line:no-inner-html
        el.innerHTML = dangerouslySetInnerHTML.__html || '';
    }
    else if (el && children) {
        el.textContent = typeof children === 'string' ? children : children.join('');
    }
    return el;
};
/**
 * Filters a script based on the filterFromBody parameter
 * If filterFromBody is true, only those scripts that have head load points will
 * return true. Otherwise, only scripts with body load points will return true.
 *
 * @param filterBody Set to true to filter out scripts in body. False to filter out scripts in the head
 * @param t The script node
 */
const filterScripts = (filterBody, t) => {
    const el = t;
    if (el.tagName === 'SCRIPT') {
        const attrVal = el.getAttribute(DATA_LOAD_POINT);
        if (attrVal === 'bodyStart' || attrVal === 'bodyEnd' || attrVal === null) {
            return filterBody ? false : true;
        }
    }
    return filterBody ? true : false;
};
/**
 * Adds an HTML node to a particular slot
 *
 * @param slot The parent Element to which the HTML node should be added
 * @param loadPointToLookFor The load point type to look for to determine if the node should be prepended to append to the parent node
 * @param t The HTML node to add
 */
const addElementToHtmlSlot = (slot, loadPointToLookFor, t) => {
    const loadPoint = t.getAttribute(DATA_LOAD_POINT);
    if (loadPoint && loadPoint === loadPointToLookFor) {
        slot.prepend(t);
    }
    else {
        slot.appendChild(t);
    }
};
/**
 * update head tag on change, on client side
 * @function doUpdateHead
 * @param {HtmlHead} head - final list of merged tags
 * @return {HtmlHead} - final list of merged tags
 */
const updateElements = (tagType, components) => {
    const headEl = document.getElementsByTagName('head')[0];
    const bodyEl = document.getElementsByTagName('body')[0];
    let oldTags = Array.prototype.slice.call(headEl.querySelectorAll(`${tagType}.${HEAD_ELEMENT_IDENTIFIER_ATTR}`));
    // sepcial condition for scripts: read script tags from body tag as well
    if (tagType === 'script') {
        const bodyScriptTags = Array.prototype.slice.call(bodyEl.querySelectorAll(`script.${HEAD_ELEMENT_IDENTIFIER_ATTR}`));
        oldTags = oldTags.concat(bodyScriptTags);
    }
    const newTags = components.map(reactElementToDOM).filter((newTag) => {
        const len = oldTags.length;
        for (let i = 0; i < len; i++) {
            const oldTag = oldTags[i];
            oldTag.removeAttribute('data-reactroot');
            if (oldTag.isEqualNode(newTag)) {
                oldTags.splice(i, 1);
                return false;
            }
            else if (oldTag.nodeName === 'SCRIPT' &&
                (oldTag.innerHTML === newTag.innerHTML || oldTag.getAttribute('src') === newTag.getAttribute('src'))) {
                oldTags.splice(i, 1);
                return false;
            }
        }
        return true;
    });
    // Remove all the old tags and add new tags in the correct places
    oldTags.forEach((t) => t.parentNode && t.parentNode.removeChild(t));
    // First, filter out all the script tags that are in the body and then reinsert
    // the new tags in the head in their appropriate locations based on the load-point (if applicable)
    newTags
        .filter((t) => {
        return filterScripts(true, t);
    })
        .forEach((t) => {
        addElementToHtmlSlot(headEl, HEAD_START_LOAD_POINT, t);
    });
    // If any script tags were defined in the body, add these script tags back into the body
    // based on their load-points
    newTags
        .filter((t) => {
        return filterScripts(false, t);
    })
        .forEach((t) => {
        addElementToHtmlSlot(bodyEl, BODY_START_LOAD_POINT, t);
    });
};
/**
 * update head tag on change, on client side
 * @function doUpdateHead
 * @param {HtmlHead} head - final list of merged tags
 */
const doUpdateHead = (head) => {
    const tags = {};
    head.tags.forEach((h) => {
        const headType = h.type.toString();
        const components = tags[headType] || [];
        components.push(h);
        tags[headType] = components;
    });
    const titleTag = tags.title;
    updateTitle(titleTag && titleTag.length > 0 ? titleTag[0] : null);
    const types = ['meta', 'link', 'style', 'script'];
    types.forEach((tagType) => {
        updateElements(tagType, tags[tagType] || []);
    });
};
/**
 * update head on change, on client side
 * @function updateHead
 * @param {HtmlHead} head - final list of merged tags
 */
export const updateHead = (head) => {
    doUpdateHead(head);
};
//# sourceMappingURL=html-head-utils.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import classnames from 'classnames';
import * as React from 'react';
import ReactDOM from 'react-dom';
import { EditableField, FieldType } from '../../utilities/editable-fields/editable-field';
import { isDefaultPlaceholderFeatureOn, isEditorialMode } from '../../utilities/editable-fields/utils';
import { DEFAULT_PLACEHOLDER } from '../../utilities/svg-loader';
import { getImageResizeUrl, getLargestGridSettingViewportName, getSourceData } from './source-builder';
export const placeholderImageUrl = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAEALAAAAAABAAEAAAIBTAA7';
/**
 *  Image
 */
export class Image extends React.PureComponent {
    constructor(props) {
        super(props);
        // tslint:disable-next-line
        this.getSVGConfig = (attributes, largestViewport) => {
            // when add module from tools, the viewPort contains height/width instead of h/w.
            const SVGHeight = (largestViewport && largestViewport.h) || attributes.height;
            const SVGWidth = (largestViewport && largestViewport.w) || attributes.width;
            return {
                ...(SVGHeight && { height: SVGHeight }),
                ...(SVGWidth && { width: SVGWidth }),
                ...(this.getPlaceholderAspectRatio(this.state.src) && {
                    preserveAspectRatio: this.getPlaceholderAspectRatio(this.state.src)
                })
            };
        };
        // tslint:disable-next-line
        this.defaultImage = (largestGridSettingViewportName, imageAttributes, lazyLoad, inputImageSettings, loaded) => {
            const { src, className, image, imageSettings, binaryHash, altText, quality, focalRegion, cropRegions, description, fileName, fileSize, imageStyle, isLocalizable, isDecorativeImage, orientation, _links, ...attributes } = imageAttributes;
            const cssClassName = this.props.className || '';
            const filteredClassName = lazyLoad ? (cssClassName ? `${cssClassName} lazyload` : 'lazyload') : cssClassName;
            const viewports = inputImageSettings && inputImageSettings.viewports;
            if (viewports && Object.keys(viewports).length) {
                delete attributes.width;
                delete attributes.height;
            }
            const largestViewport = viewports && viewports[largestGridSettingViewportName];
            let placeholderConfig;
            if (this.isUsingSVGPlaceholder(this.state.src, this.props)) {
                placeholderConfig = {
                    name: this.getPlaceholderName(this.state.src)
                };
                const SVGConfig = this.getSVGConfig(attributes, largestViewport);
                placeholderConfig.svgConfig = SVGConfig;
            }
            const urlSrc = getImageResizeUrl(this.state.src, largestViewport, inputImageSettings);
            const hiddenStyle = loaded || this.state.loadFailed || !this.props.fallBackSrc ? {} : { visibility: 'hidden' };
            return (React.createElement(EditableField, { type: FieldType.Image, editPropKey: this.props.editProps && this.props.editProps.key, requestContext: this.props.editProps && this.props.editProps.requestContext, fieldProps: {
                    ...(hiddenStyle && { style: hiddenStyle }),
                    alt: this.props.altText,
                    ...(lazyLoad ? { src: placeholderImageUrl, 'data-src': urlSrc } : { src: urlSrc }),
                    ...attributes,
                    key: 'default-image',
                    className: filteredClassName,
                    onError: this.imageFailed,
                    onLoad: this.imageLoaded,
                    additionalProperties: this.props.additionalProperties,
                    ...(placeholderConfig && { placeholderConfig: placeholderConfig })
                } }));
        };
        this.imageFailed = (...args) => {
            if ((this.props.fallBackSrc && this.props.fallBackSrc === this.state.src) || !this.props.fallBackSrc) {
                this.setState({ loadFailed: true });
            }
            else {
                this.setState({ src: this.props.fallBackSrc ? this.props.fallBackSrc : this.props.src });
            }
            if (typeof this.props.onError === 'function') {
                this.props.onError(...args);
            }
        };
        this.imageLoaded = (...args) => {
            if (this.props.fallBackSrc) {
                const node = ReactDOM.findDOMNode(this);
                if (node && node.querySelector) {
                    const child = node.querySelector('img');
                    if (child && child.complete && child.naturalWidth > 1) {
                        this.setState({ loaded: true });
                    }
                }
            }
        };
        this.getSourceTag = (viewport, imageSettings, largestGridSettingViewportName, lazyLoad) => {
            const srcData = getSourceData(this.state.src, this.props.gridSettings, this.props, imageSettings, viewport, largestGridSettingViewportName);
            if (!srcData) {
                return;
            }
            return (React.createElement("source", Object.assign({ key: viewport }, (lazyLoad ? { 'data-srcset': srcData.srcSet } : { srcSet: srcData.srcSet }), (srcData.media ? { media: srcData.media } : {}))));
        };
        this.isUsingSVGPlaceholder = (src, props) => {
            if (!src) {
                return false;
            }
            return src.startsWith('svg.') && this.shouldUseDefaultSVGPlaceholder(props);
        };
        this.getPlaceholderName = (src) => {
            const configs = src.split('.');
            if (configs.length >= 2) {
                return configs[1];
            }
            return '';
        };
        this.getPlaceholderAspectRatio = (src) => {
            const configs = src.split('.');
            if (configs.length >= 3) {
                return configs[2];
            }
            return '';
        };
        this.shouldUseDefaultSVGPlaceholder = (props) => {
            const requestContext = props.editProps && props.editProps.requestContext;
            // if default image placeholder feature is diabled, we dont use SVG placeholder.
            return isEditorialMode(requestContext) && isDefaultPlaceholderFeatureOn(requestContext);
        };
        // if no src indicated and we are rendering in site builder context.
        const stateSrc = !props.src && this.shouldUseDefaultSVGPlaceholder(props) ? `svg.${DEFAULT_PLACEHOLDER}` : props.src;
        this.state = {
            loaded: false,
            loadFailed: false,
            src: stateSrc
        };
    }
    componentDidUpdate(prevProps) {
        if (this.props.src !== prevProps.src || this.props.fallBackSrc !== prevProps.fallBackSrc) {
            this.setState({ loadFailed: false, src: this.props.src });
        }
    }
    componentDidMount() {
        // onError will sometimes fire before the react events get hooked up. So we
        // cannot rely on it for determining when image load fails. Instead we also have
        // to find the img that the Image component uses> If its complete, but naturalWidth
        // is zero that means load failed
        const node = ReactDOM.findDOMNode(this);
        if (node && node.querySelector) {
            const child = node.querySelector('img');
            if (child && child.complete && child.naturalWidth === 0) {
                if ((this.props.fallBackSrc && this.props.fallBackSrc === this.state.src) || !this.props.fallBackSrc) {
                    this.setState({ loadFailed: true });
                }
                else {
                    this.setState({ src: this.props.fallBackSrc ? this.props.fallBackSrc : this.props.src });
                }
                return;
            }
            if (child && child.complete && child.naturalWidth > 1) {
                this.setState({ loaded: true });
            }
        }
    }
    render() {
        const { loadFailureBehavior, pictureAttributes = {}, gridSettings, fallBackSrc, ...imageAttributes } = this.props;
        if (this.state.loadFailed || !this.state.src) {
            if (loadFailureBehavior === 'hide') {
                return null;
            }
            else if (loadFailureBehavior === 'empty') {
                return React.createElement("div", { className: classnames('msc-empty_image', imageAttributes.className) });
            }
        }
        const loaded = this.state.loaded;
        const imageSettings = this.props.imageSettings || imageAttributes.imageSettings;
        const largestGridSettingViewportName = getLargestGridSettingViewportName(gridSettings);
        // Lazyload by default if nothing is specified
        const lazyLoad = !imageSettings || !imageSettings.disableLazyLoad;
        // render placeholder if its using SVG placholder image
        if (this.isUsingSVGPlaceholder(this.state.src, this.props)) {
            return this.defaultImage(largestGridSettingViewportName, imageAttributes, lazyLoad, imageSettings);
        }
        const sourceTags = imageSettings && imageSettings.viewports
            ? Object.keys(imageSettings.viewports)
                .map(vp => this.getSourceTag(vp, imageSettings, largestGridSettingViewportName, lazyLoad))
                .filter(Boolean) || []
            : [];
        sourceTags.push(this.defaultImage(largestGridSettingViewportName, imageAttributes, lazyLoad, imageSettings, loaded));
        return React.createElement("picture", Object.assign({}, pictureAttributes), sourceTags);
    }
}
//# sourceMappingURL=image.js.map
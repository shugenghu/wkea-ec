/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import classnames from 'classnames';
import * as React from 'react';
import ReactDOM from 'react-dom';
import { EditableField, FieldType } from '../../utilities/editable-fields/editable-field';
import { getImageResizeUrl, getLargestGridSettingViewportName, getSourceData } from './source-builder';
export const placeholderImageUrl = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAEALAAAAAABAAEAAAIBTAA7';
/**
 *  Image
 */
export class Image extends React.PureComponent {
    constructor(props) {
        super(props);
        this.defaultImage = (largestGridSettingViewportName, imageAttributes, lazyLoad, inputImageSettings) => {
            const { src, className, image, imageSettings, binaryHash, altText, quality, focalRegion, cropRegions, description, fileName, fileSize, imageStyle, isLocalizable, isDecorativeImage, orientation, _links, ...attributes } = imageAttributes;
            const cssClassName = this.props.className || '';
            const filteredClassName = lazyLoad ? (cssClassName ? `${cssClassName} lazyload` : 'lazyload') : cssClassName;
            const viewports = inputImageSettings && inputImageSettings.viewports;
            if (viewports && Object.keys(viewports).length) {
                delete attributes.width;
                delete attributes.height;
            }
            const largestViewport = viewports && viewports[largestGridSettingViewportName];
            const urlSrc = getImageResizeUrl(this.state.src, largestViewport, inputImageSettings);
            return (React.createElement(EditableField, { type: FieldType.Image, editPropKey: this.props.editProps && this.props.editProps.key, requestContext: this.props.editProps && this.props.editProps.requestContext, fieldProps: {
                    alt: this.props.altText,
                    ...(lazyLoad ? { src: placeholderImageUrl, 'data-src': urlSrc } : { src: urlSrc }),
                    ...attributes,
                    key: 'default-image',
                    className: filteredClassName,
                    onError: this.imageFailed,
                    additionalProperties: this.props.additionalProperties
                } }));
        };
        this.imageFailed = (...args) => {
            if ((this.props.fallBackSrc && this.props.fallBackSrc === this.state.src) || !this.props.fallBackSrc) {
                this.setState({ loadFailed: true });
            }
            else {
                this.setState({ src: this.props.fallBackSrc ? this.props.fallBackSrc : this.props.src });
            }
            if (typeof this.props.onError === 'function') {
                this.props.onError(...args);
            }
        };
        this.getSourceTag = (viewport, imageSettings, largestGridSettingViewportName, lazyLoad) => {
            const srcData = getSourceData(this.state.src, this.props.gridSettings, this.props, imageSettings, viewport, largestGridSettingViewportName);
            if (!srcData) {
                return;
            }
            return (React.createElement("source", Object.assign({ key: viewport }, (lazyLoad ? { 'data-srcset': srcData.srcSet } : { srcSet: srcData.srcSet }), (srcData.media ? { media: srcData.media } : {}))));
        };
        this.state = {
            loadFailed: false,
            src: props.src
        };
    }
    componentDidUpdate(prevProps) {
        if (this.props.src !== prevProps.src || this.props.fallBackSrc !== prevProps.fallBackSrc) {
            this.setState({ loadFailed: false, src: this.props.src });
        }
    }
    componentDidMount() {
        // onError will sometimes fire before the react events get hooked up. So we
        // cannot rely on it for determining when image load fails. Instead we also have
        // to find the img that the Image component uses> If its complete, but naturalWidth
        // is zero that means load failed
        const node = ReactDOM.findDOMNode(this);
        if (node && node.querySelector) {
            const child = node.querySelector('img');
            if (child && child.complete && child.naturalWidth === 0) {
                if ((this.props.fallBackSrc && this.props.fallBackSrc === this.state.src) || !this.props.fallBackSrc) {
                    this.setState({ loadFailed: true });
                }
                else {
                    this.setState({ src: this.props.fallBackSrc ? this.props.fallBackSrc : this.props.src });
                }
                return;
            }
        }
    }
    render() {
        const { loadFailureBehavior, pictureAttributes = {}, gridSettings, fallBackSrc, ...imageAttributes } = this.props;
        if (this.state.loadFailed || !this.props.src) {
            if (loadFailureBehavior === 'hide') {
                return null;
            }
            else if (loadFailureBehavior === 'empty') {
                return React.createElement("div", { className: classnames('msc-empty_image', imageAttributes.className) });
            }
        }
        const imageSettings = this.props.imageSettings || imageAttributes.imageSettings;
        const largestGridSettingViewportName = getLargestGridSettingViewportName(gridSettings);
        // Lazyload by default if nothing is specified
        const lazyLoad = !imageSettings || !imageSettings.disableLazyLoad;
        const sourceTags = imageSettings && imageSettings.viewports
            ? Object.keys(imageSettings.viewports)
                .map(vp => this.getSourceTag(vp, imageSettings, largestGridSettingViewportName, lazyLoad))
                .filter(Boolean) || []
            : [];
        sourceTags.push(this.defaultImage(largestGridSettingViewportName, imageAttributes, lazyLoad, imageSettings));
        return React.createElement("picture", Object.assign({}, pictureAttributes), sourceTags);
    }
}
//# sourceMappingURL=image.js.map
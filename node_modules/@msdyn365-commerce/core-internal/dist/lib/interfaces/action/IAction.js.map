{"version":3,"file":"IAction.js","sourceRoot":"","sources":["../../../../src/interfaces/action/IAction.ts"],"names":[],"mappings":"","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\nimport { AsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { ITelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { IRequestContext } from '../context';\nimport { IActionInput } from './IActionInput';\nimport { CacheType } from './ICache';\n\nexport type IActionPrototype = {\n    id: string;\n    inputFunc: Function;\n    isBatched: boolean;\n    isAction: true;\n    [property: string]: unknown;\n};\n\n/**\n * Data Action interface\n */\nexport type IAction<TOut> = (input: IActionInput | IActionInput[], context: IActionContext) => Promise<TOut>;\n\n/**\n * Interface for new observable AsyncResult based action\n */\nexport type IObservableAction<TOut> = (input: IActionInput | IActionInput[], context: IActionContext) => AsyncResult<TOut>;\n\nexport interface IDataActionOptions {\n    cacheType?: CacheType;\n}\n\nexport interface IActionContext {\n    requestContext: IRequestContext;\n    telemetry: ITelemetry;\n    /**\n     * DEPRECATED\n     *\n     * Actions can now chain automatically, so chainAction calls are unncessary\n     *\n     * @param action The action to be chained\n     * @param input The input for the action that will be called\n     * @deprecated\n     */\n    chainAction<T>(\n        action: IAction<T>,\n        input: IActionInput | IActionInput[],\n        actionOption?: IDataActionOptions\n    ): Promise<T | (T | null)[] | null>;\n    update<T>(input: IActionInput | IActionInput[], data: T): T;\n    get<T>(cacheObjectType: string, cacheKey: string): T | T[] | null;\n    getAll<T>(cacheObjectType: string): T[] | null;\n    /**\n     * DEPRECATED.\n     *\n     * This is deprecated in favor of using `telemetry` property directly on action context\n     *\n     * @param message The message to log with trace\n     * @deprecated\n     */\n    trace(message: string): void;\n    runAllActionsInQueue(): Promise<void>;\n}\n\n/**\n * Internal type that matches both IAction and IObservableAction\n * @internal\n */\ntype _IMergedAction<TOut> = (input: IActionInput | IActionInput[], context: IActionContext) => AsyncResult<TOut> | Promise<TOut>;\n\n/**\n * Interface that matches IAction or IObservableAction with fully typed prototype\n * @internal\n */\nexport interface IAnyAction<TOut> extends _IMergedAction<TOut> {\n    prototype: IActionPrototype;\n}\n"]}
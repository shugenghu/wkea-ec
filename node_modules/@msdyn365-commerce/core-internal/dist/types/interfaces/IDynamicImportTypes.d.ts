/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { IAny } from './types';
/**
 * Options to create a dynamic import
 */
export interface IDynamicImportArgs {
    /**
     * The result of a dynamic import from within your code.  It needs to be within your code
     * as the path is dynamically generated based on the `import` statement
     */
    universalImport(): IUniversalImport;
}
export interface IUniversalImport {
    id: string;
    then(callback: IAny): void;
    chunkName(): string;
    load(): Promise<any>;
    path(): string;
    resolve(): string;
}
/**
 * Result object of a dynamic import
 */
export interface IDynamicLoadResult {
    /**
     * Is the result a promise?
     */
    isPromise: boolean;
    /**
     * Was the call for the dynamic import a success?
     */
    isSuccess: boolean;
    /**
     * Actual result of the dynamic import. Will be either a `Promise<Module>` or the module itself,
     * which is the same as the result of a normal `require(Module)`.
     */
    result: unknown;
    /**
     * The chunk name corresponding to this dynamic import.  This is autogenerated.
     */
    chunkName: string;
    /**
     * Discriminator property to determine of object is of type IDynamicResult
     */
    __isDynamicResult: boolean;
    /**
     * Convenience function to point to default import. If no default is provided, will return module
     * import result, which will contain all exports. Currently will only be populated if
     * the module was able to be loaded synchronously. For modules loaded asynch, you'll need
     * to await the promise resolve in the `result` property.
     */
    defaultExport?: null | Function | {};
}

/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { IDictionary, IExpLogger, TelemetryEvent, TelemetryEventContent } from '@msdyn365-commerce/telemetry-internal';
import { ISecretManager } from '../interfaces';
/**
 * State of an experiment
 */
export declare const EXPERIMENTATION_CACHE_TYPE = "EXPERIMENTATION";
export declare const EXPERIMENTATION_DATAFILE_CACHE_TYPE = "EXPERIMENTATIONDATAFILE";
export declare enum State {
    Draft = "Draft",
    Active = "Active",
    Running = "Running",
    Paused = "Paused",
    Archived = "Archived"
}
export declare enum RefreshType {
    DataFile = "DataFile",
    Experiments = "Experiments"
}
/**
 * refresh options.
 * @param refreshFunction the call back function that refresh will trigger.
 * @param parameters the parameters for the refresh function. If no parameters need, pass an empty array.
 */
export interface IExperimentRefreshOptions {
    refreshType: RefreshType;
    parameters: any[];
}
export interface IActiveExperiments {
    userId: string;
    activeExperiments: IVariants[];
    moduleIdToExperimentIdMap?: IDictionary<string>;
}
/**
 * Variations on each experiment
 */
export interface IVariations {
    friendlyName: string;
    id: string;
    status: State;
    weight?: string;
}
/**
 * Experiments
 */
export interface IExperiments {
    friendlyName: string;
    id: string;
    status: State;
    variations: IVariations[];
    createdDate?: string;
    lastModifiedDate?: string;
    lastModifiedBy?: string;
    description?: string;
    type?: string;
    link?: string;
    resultLink?: string;
}
/**
 * Experiment results to display connector name and experiments[] related to the connector
 */
export interface IExperimentsResult {
    name?: string;
    experiments?: IExperiments[];
}
/**
 * Experiments
 */
export interface IVariants {
    variantId: string;
    experimentId: string;
    moduleId?: string;
}
export interface IExperimentationProvider {
    /**
     * Allows the experimentation connector to do any startup related tasks
     * using the config provided by the partner.
     *
     * This method is only called once during server startup.
     * @param config The config provided by the partner in connector settings.
     * @param secretManager Class used to retrieve secrets stored in retail server key vault
     */
    initialize(config: any, secretManager?: ISecretManager): Promise<boolean>;
    /**
     * Returns the configuration that should be passed to the experimentation connector
     * when it is initialized client-side
     */
    getConfigForClientSideInit(): Promise<any>;
    /**
     * Initailizes the experimentation provider on the browser (client-side) so that
     * it may activate experiments for a user.
     *
     * @param config The config that is required to initialize the experimentation connector
     * client-side. The result of getConfigForClientSideInit() is passed into this method
     */
    initializeClientSide(config: any): boolean;
    /**
     * Returns a list of all the experiments currently configured whether active or not.
     * This list will be cached and periodically refreshed.
     * @param retailServerBaseUrl The retail server base URL.
     * @param connectorName The optimizely conector name.
     * @param page Optional argument that specifies the page to return.
     * @param items Optional argument that specifies the maximum number of objects to return per request.
     */
    getExperiments(retailServerBaseUrl: string, connectorName: string, page?: string, items?: string): Promise<IExperimentsResult>;
    /**
     * Returns a list of experiments and variants a user will be a part of based
     * off the userId. Optional attributes can provide the connector with additional criteria
     * to determine which experiments a user should be a part of.
     *
     * @param userId userId unique to a user if signed in or unique to a session if user is anonymous.
     * userId will be generated from hash if user is signed-in to deterministically generate sanatized userIds.
     * @param attributes Optional user related attributes
     */
    getVariantsForUser(userId: string, attributes?: {
        [index: string]: string;
    }): IVariants[];
    /**
     * Activates experiment(s) a user is currently being served. This call will be made
     * client-side after the connector has been initialized client-side
     *
     * @param userId userId unique to a user if signed in or unique to a session if user is anonymous.
     * userId will be generated from hash if user is signed-in to deterministically generate sanatized userIds.
     * @param experiments The experiments the user is participating in.
     * @param attributes Optional user related attributes
     */
    activateExperiment(userId: string, experiments: IVariants[], attributes?: {
        [index: string]: string;
    }): boolean;
}
export interface IExperimentationListener {
    /**
     * Initailizes the experimentation listener on the browser (client-side) so that
     * it may keep track of any conversion events related to the current experiements.
     *
     * @param config The config that is required to initialize the experimentation connector
     * client-side. The result of getConfigForClientSideInit() is passed into this method
     * @param userId The current user being served the experiment and tracked.
     */
    initializeClientSide(config: any, userId: string): boolean;
    /**
     * Tracks a successful user conversion event.
     *
     * @param eventType The event type that occured
     * @param payload Any additional tags or data related to the conversion event
     */
    trackEvent(eventType: TelemetryEvent, payload: TelemetryEventContent): void;
}
export interface IExperimentationConnector {
    name: string;
    provider: IExperimentationProvider;
    listener?: IExpLogger;
}

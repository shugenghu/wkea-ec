/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import uuid from 'uuid/v4';
import { commerceInsightsAttributeRenderer } from '../attribute-renderers';
import { CommerceInsightsLogger } from '../event-loggers';
import { generateEventNameHash, p } from '../helpers';
import { NumericLogLevel, TelemetryEvent } from '../interfaces';
// tslint:disable:no-floating-promises
/**
 * Base class for Telemetry & Internal telemetry
 * @abstract
 * @class TelemetryBase
 */
export class TelemetryBase {
    constructor() {
        /**
         * Start a named timer
         *
         * @param {string} id of timer
         * @memberof InternalTelemetry
         */
        this.startTimer = (timerId) => {
            this._timers.set(timerId, Date.now());
        };
        /**
         * Stops a named timer
         *
         * @param {string} timerId id of timer
         * @param {boolean} [removeTimer=true] should time be removed from dictionary? default rue
         * @returns {number} elapsed time in ms
         */
        this.stopTimer = (timerId, removeTimer = true) => {
            const now = Date.now();
            const result = this._timers.has(timerId) ? now - this._timers.get(timerId) : -1;
            if (removeTimer) {
                this._timers.delete(timerId);
            }
            return result;
        };
        /**
         * Saves the feature swtich marking whether data analytics is enabled for this request
         */
        this.enableDataAnalytics = (enableDataAnalytics) => {
            this._enableDataAnalytics = enableDataAnalytics;
            if (this._enableDataAnalytics) {
                this._eventLoggers = [new CommerceInsightsLogger()];
                this._attributeRenderers = [commerceInsightsAttributeRenderer];
            }
        };
        /**
         * Renders a data attribute string
         */
        this.setTelemetryAttribute = (telemetryId, additionalTelemetryData) => {
            let telemetryAttribute = {};
            for (let i = 0; i < this._attributeRenderers.length; ++i) {
                telemetryAttribute = { ...telemetryAttribute, ...this._attributeRenderers[i](telemetryId, additionalTelemetryData) };
            }
            return telemetryAttribute;
        };
        /**
         * Logs a telemetry event.
         */
        this.logEvent = (eventType, payload) => {
            for (let i = 0; i < this._eventLoggers.length; ++i) {
                p(() => this._eventLoggers[i].logEvent(eventType, payload));
            }
            // If exp logger is registered, mutate and send event
            if (this._expLogger) {
                let eventName = '';
                switch (eventType) {
                    case TelemetryEvent.PageView:
                        const pageViewEventName = payload.title ? `${payload.title}.PageView` : '';
                        eventName = pageViewEventName;
                        break;
                    case TelemetryEvent.Custom:
                        eventName = this._generateEventName(payload);
                        if (eventName) {
                            break;
                        }
                    default:
                        eventName = eventType;
                }
                const eventNameHash = generateEventNameHash(eventName);
                this._expLogger.logEvent(eventNameHash, payload);
            }
        };
        /**
         * Tracks a metric
         */
        this.trackMetric = (name, value) => {
            this.notifyTraceLoggers(logger => logger.trackMetric(name, value, this._telemetryContext));
        };
        /**
         * Tracks an event
         */
        this.trackEvent = (name, properties, measurements, context) => {
            this.notifyTraceLoggers(logger => logger.trackEvent(name, properties, measurements, context));
        };
        this.trackPageView = (page, url) => {
            this.notifyTraceLoggers(logger => logger.trackPageView(page, url));
        };
        this.trackDependency = (options) => {
            this.notifyTraceLoggers(logger => logger.trackDependency(options));
        };
        /**
         * Adds the given trace logger to the list of trace loggers.
         * @param traceLogger - The ILogger object to be added to the list of trace loggers
         */
        this.registerTraceLogger = (options) => {
            if (options.traceLogger) {
                if (options.traceLogger.initialize && options.options) {
                    options.traceLogger.initialize(options.options);
                }
                this._traceLoggers.push(options.traceLogger);
                options.name && (this._namedLoggers[options.name] = options.traceLogger);
            }
        };
        /**
         * Adds the given event logger to the list of event loggers
         * @param eventLogger - The IEventLogger object to be added to the list of event loggers
         */
        this.registerEventLogger = (eventLogger) => {
            this._eventLoggers.push(eventLogger);
        };
        /**
         * Adds the given experimentation logger to the telemetry object
         * @param expLogger - The IExpLogger object to be added
         */
        this.registerExpLogger = (expLogger) => {
            this._expLogger = expLogger;
        };
        /**
         * Adds the given attribute renderer to the list of attribute renderers
         * @param attributeRenderer - The IDataAttributeRenderer object to be added to the list of attribute renderers
         */
        this.registerAttributeRenderer = (attributeRenderer) => {
            this._attributeRenderers.push(attributeRenderer);
        };
        /**
         * Registers the Web Analytics plugin for use in the BI logging framework
         */
        this.registerWebAnalyticsPlugin = (webAnalyticsPlugin) => {
            this._webAnalyticsPlugin = webAnalyticsPlugin;
            // Pass Web Analytics plugin to the Commerce Insights logger
            if (this._enableDataAnalytics) {
                this._eventLoggers[0].registerWebAnalyticsPlugin(webAnalyticsPlugin);
            }
        };
        /**
         * Merges the properties specific to the current request that should be added to every log
         * @param requestContext Contains the context items specific to the current request
         */
        this.setTelemetryRequestContext = (requestContext) => {
            this._telemetryContext.requestContext = { ...(this._telemetryContext.requestContext || {}), ...requestContext };
        };
        /**
         * Gets named logger if it exists
         *
         * @param {string} name name of logger to get
         */
        this.getNamedLoggerInstance = (name) => {
            return this._namedLoggers[name];
        };
        /**
         * String formatter
         * @param templateString Template string
         * @param args ordered argument list
         */
        this.stringFormat = (templateString, args) => {
            for (let index = 0; index < args.length; ++index) {
                templateString = templateString.replace(`$${index}`, args[index]);
            }
            return templateString;
        };
        /**
         * Helper to notify trace loggers
         *
         * @private
         * @memberof Telemetry
         */
        this.notifyTraceLoggers = (fx) => {
            // tslint:disable-next-line:no-console
            for (let i = 0; i < this._traceLoggers.length; ++i) {
                // TODO: revisit this unhandled promise
                fx(this._traceLoggers[i]);
            }
        };
        this._log = (logLevel, messageTemplate, logOptions) => {
            const requestedLogLevel = NumericLogLevel[logLevel];
            const minLogLevel = process.env.SDK_MIN_LOG_LEVEL;
            // Do not log if below minimum log level
            if (requestedLogLevel < minLogLevel) {
                return;
            }
            // Create map of placeholders in string and arguments provided
            const regex = /{([a-zA-Z_0123456789]+)}/g;
            const placeholders = new Map();
            const values = logOptions && logOptions.values ? logOptions.values : [];
            let i = 0;
            let match = regex.exec(messageTemplate);
            while (match !== null) {
                // If this placeholder is a repeat of a previous one
                if (placeholders.get(match[1]) !== undefined) {
                    match = regex.exec(messageTemplate);
                    // Else if a new placeholder but no more arguments were given
                }
                else if (values[i] === undefined) {
                    values[i] = `Undefined - No value given for this placeholder`;
                    // Still increment in case a placeholder value in the middle was undefined
                    placeholders.set(match[1], values[i++]);
                    // Get next match
                    match = regex.exec(messageTemplate);
                    // Else save match and next argument provided
                }
                else {
                    placeholders.set(match[1], values[i++]);
                    // Get next match
                    match = regex.exec(messageTemplate);
                }
            }
            this.notifyTraceLoggers((logger) => {
                logger.sendLog(logLevel, this._telemetryContext, messageTemplate, placeholders, logOptions && logOptions.customTags, logOptions && logOptions.exception);
            });
        };
        this._enableDataAnalytics = false;
        this._traceLoggers = [];
        this._eventLoggers = [];
        this._attributeRenderers = [];
        this._telemetryContext = {
            requestContext: {},
            moduleContext: {}
        };
        this._namedLoggers = {};
        this._timers = new Map();
    }
    /**
     * Generates the event name for a custom click event
     * @param payload Payload of custom event
     */
    _generateEventName(payload) {
        if (payload.contentCategory === 'click') {
            // tslint:disable-next-line:no-any
            const attributes = payload.contentAction;
            // Generate event name for custom clicks with page name, module name, and either element text or recordId
            if (attributes && attributes.pgname && attributes.mname && (attributes.etext || attributes.recid)) {
                return `${attributes.pgname}.${attributes.mname}.${attributes.etext || attributes.recid}${attributes.etype ? `.${attributes.etype}` : ''}`;
            }
        }
    }
}
TelemetryBase.generateGuid = () => {
    return uuid();
};
//# sourceMappingURL=telemetry-base.js.map
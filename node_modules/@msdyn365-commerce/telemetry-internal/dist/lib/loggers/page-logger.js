/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { LogLevel } from '../interfaces';
/**
 * Page Logger
 * Captures server side logs and surfaces them to the client
 */
class PageLogger {
    constructor() {
        this.logs = [];
        this.options = {};
    }
    initialize(options) {
        this.options = options;
    }
    /**
     * @internal
     * Logs a message to the console, prefixed with custom tags, and with arguments following
     * @param logLevel LogLevel of the message
     * @param context Telemetry context to add to log
     * @param messageTemplate Structured log formatted string
     * @param placeholders List of placeholders in messageTemplate along with position in string
     * @param values Arguments to replace placeholders
     * @param customTags Array of strings to attach to log
     */
    sendLog(logLevel, context, messageTemplate, 
    // tslint:disable-next-line:no-any
    placeholders, customTags, exception) {
        // Output tags and message template
        let tagsString = '';
        if (customTags !== undefined) {
            customTags.forEach(tag => {
                tagsString += `[${tag}]`;
            });
        }
        tagsString && this._print(logLevel, tagsString);
        let message = messageTemplate;
        // Output arguments
        for (const [key, value] of placeholders.entries()) {
            let messageValue;
            // If Dynamics privacy object only print data value, else print object
            if (value.__isDynamicsPrivacy) {
                messageValue = value.data;
            }
            else {
                messageValue = value;
            }
            if (messageValue.toString() === '[object Object]') {
                messageValue = JSON.stringify(messageValue, null, 2);
            }
            message = message.replace(new RegExp(`{${key}}`, 'g'), messageValue);
        }
        this._print(logLevel, message);
        // Print exception if present
        if (exception !== undefined && exception.stack) {
            this._print(LogLevel.Error, exception.stack);
        }
    }
    /**
     * @internal
     * Logs a message to the console based on LogLevel
     */
    log(logLevel, message, args, context) {
        switch (logLevel) {
            case LogLevel.Information:
                // @ts-ignore
                this.options.isInfo && this._print(LogLevel.Information, message, args);
                break;
            case LogLevel.Debug:
                this.options.isDebug && this._print(LogLevel.Debug, message, args);
                break;
            case LogLevel.Trace:
            case LogLevel.Warning:
                this._print(logLevel, message, args);
                break;
            case LogLevel.Critical:
            case LogLevel.Error:
                this._print(LogLevel.Error, message, args);
                break;
            default:
        }
    }
    /**
     * @internal
     * Logs an exception object to the console
     */
    exception(error, context) {
        if (error && error.stack) {
            this._print(LogLevel.Error, error.stack);
        }
    }
    /**
     * @internal
     * Tracks a metric
     * @param name Metric name
     * @param value Metric value
     */
    trackMetric(name, value, context) {
        this._print(LogLevel.Debug, `${name}: ${value}`);
    }
    trackEvent(name, properties, measurements, context) {
        const event = {
            name: name,
            time: new Date(),
            properties,
            measurements
        };
        this.log(LogLevel.Information, name, [event], context);
    }
    /**
     * Track a page view
     *
     * @param {string} name
     * @param {string} [url]
     */
    trackPageView(name, url) {
        // intentionally blank
    }
    /**
     * Track request
     * @param options the request options
     */
    trackDependency(options) {
        // intentionally blank
    }
    _print(printLevel, message, args) {
        this.logs.push(`[${printLevel.toUpperCase()}] ${message}`);
        args &&
            args.forEach(arg => {
                this.logs.push(JSON.stringify(arg));
            });
    }
}
export { PageLogger };
//# sourceMappingURL=page-logger.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:no-floating-promises
import { LogLevel } from '../interfaces';
/**
 * Default console logger
 * This is a default logger that just logs messages directly to the console
 */
class GenericConsoleLogger {
    constructor() {
        this.options = {};
    }
    initialize(options) {
        this.options = options;
    }
    /**
     * @internal
     * Logs a message to the console, prefixed with custom tags, and with arguments following
     * @param logLevel LogLevel of the message
     * @param context Telemetry context to add to log
     * @param messageTemplate Structured log formatted string
     * @param placeholders List of placeholders in messageTemplate along with position in string
     * @param values Arguments to replace placeholders
     * @param customTags Array of strings to attach to log
     */
    sendLog(logLevel, context, messageTemplate, 
    // tslint:disable-next-line:no-any
    placeholders, customTags, exception) {
        // Determine console output method based on log level
        let printFunction;
        switch (logLevel) {
            case LogLevel.Critical:
            case LogLevel.Error:
                printFunction = console.error;
                break;
            case LogLevel.Warning:
                printFunction = console.warn;
                break;
            case LogLevel.Information:
            case LogLevel.Debug:
            case LogLevel.Trace:
                // Don't print debug and info messages to console unless in debug mode
                if (!this.options.isDebug) {
                    return;
                }
            default:
                printFunction = console.log;
        }
        // Output tags and message template
        let tagsString = '';
        if (customTags !== undefined) {
            customTags.forEach(tag => {
                tagsString += `[${tag}]`;
            });
        }
        tagsString && printFunction(tagsString);
        let message = messageTemplate;
        // Output arguments
        for (const [key, value] of placeholders.entries()) {
            let messageValue;
            // If Dynamics privacy object only print data value, else print object
            if (value.__isDynamicsPrivacy) {
                messageValue = value.data;
            }
            else {
                messageValue = value;
            }
            if (messageValue.toString() === '[object Object]') {
                messageValue = JSON.stringify(messageValue, null, 2);
            }
            message = message.replace(new RegExp(`{${key}}`, 'g'), messageValue);
        }
        printFunction(`[${logLevel}] ${message}`);
        // Print exception if present
        if (exception !== undefined) {
            printFunction(exception.stack);
        }
    }
    /**
     * @internal
     * Logs a message to the console based on LogLevel
     */
    log(logLevel, message, args, context) {
        switch (logLevel) {
            case LogLevel.Information:
                // @ts-ignore
                this.options.isInfo && this._printMessages(console.log, message, args);
                break;
            case LogLevel.Debug:
                this.options.isDebug && this._printMessages(console.log, message, args);
                break;
            case LogLevel.Trace:
                this._printMessages(console.log, message, args);
                break;
            case LogLevel.Warning:
                this._printMessages(console.warn, message, args);
                break;
            case LogLevel.Critical:
            case LogLevel.Error:
                this._printMessages(console.error, message, args);
                break;
            default:
        }
    }
    /**
     * @internal
     * Logs an exception object to the console
     */
    exception(error, context) {
        if (error) {
            console.error(error.stack);
        }
    }
    /**
     * @internal
     * Tracks a metric
     * @param name Metric name
     * @param value Metric value
     */
    trackMetric(name, value, context) {
        console.log(`${name}: ${value}`);
    }
    trackEvent(name, properties, measurements, context) {
        const event = {
            name: name,
            time: new Date(),
            properties,
            measurements
        };
        this.log(LogLevel.Information, name, [event], context);
    }
    /**
     * Track a page view
     *
     * @param {string} name
     * @param {string} [url]
     */
    trackPageView(name, url) {
        this.trackEvent('trackPageView', { url });
    }
    /**
     * Track request
     * @param options the request options
     */
    trackDependency(options) {
        this.trackEvent('trackRequest', options);
    }
    /**
     * Prints the given message and arguments to the console via the given function
     * @param printFunction Function to use to print
     * @param message String to print
     * @param args Additional args to print
     */
    _printMessages(printFunction, message, args) {
        printFunction(message);
        args.forEach(arg => {
            printFunction(arg);
        });
    }
}
const singletonLoggerInstance = new GenericConsoleLogger();
export { singletonLoggerInstance as GenericConsoleLogger };
//# sourceMappingURL=generic-console-logger.js.map
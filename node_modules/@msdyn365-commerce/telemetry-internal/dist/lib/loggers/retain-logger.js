/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:no-floating-promises
import { p } from '../helpers';
import { LogLevel } from '../interfaces';
import { getFilteredData } from '../privacy/dynamics-privacy-helper';
import { safeStringify } from './logging-helper';
/**
 * This is a logger that stores logs so they can be sent back with the response
 */
export class RetainLogger {
    constructor() {
        this.logList = [];
    }
    /**
     * @internal
     * Retains a trace message
     * @param logLevel LogLevel of the message
     * @param context Telemetry context to add to log
     * @param messageTemplate Structured log formatted string
     * @param placeholders List of placeholders in messageTemplate along with position in string
     * @param values Arguments to replace placeholders
     * @param customTags Array of strings to attach to log
     */
    sendLog(logLevel, context, messageTemplate, 
    // tslint:disable-next-line:no-any
    placeholders, customTags, exception) {
        // Add message template
        this.logList.push({ logLevel, message: messageTemplate });
        // Add arguments
        for (const value of placeholders.values()) {
            // Get filtered data out of placeholder if it is a privacy object
            const data = getFilteredData(value);
            this.logList.push({ logLevel, message: safeStringify(data) });
        }
    }
    /**
     * @internal
     * Retains a trace message
     * @param logLevel Severity level of the log
     * @param message String to log
     * @param args Any additional objects to log
     * @param context Additional properties to add to the log
     */
    log(logLevel, message, args, context) {
        this.logList.push({ logLevel, message });
        // Append extra arguments to the message as strings (stringifying json objects as necessary)
        args.forEach((arg) => {
            p(() => {
                let data = String(arg);
                if (typeof arg === 'object') {
                    try {
                        data = JSON.stringify(arg);
                    }
                    catch (err) {
                        // If the data is unable to be stringified
                        // eat the error and log data as is
                    }
                }
                this.logList.push({ logLevel, message: data });
            });
        });
    }
    /**
     * @internal
     * Retains an error object
     * @param error Error object to log
     * @param context Additional properties to add to the log
     */
    exception(exception, context) {
        this.logList.push({ logLevel: LogLevel.Error, message: `${exception.name}: ${exception.message}` });
    }
    /**
     * @internal
     * Retains a metric
     * @param name Name of the metric to log
     * @param value Value of the metric to log
     * @param context Additional properties to add to the log
     */
    trackMetric(name, value, context) {
        const logLevel = LogLevel.Information;
        const message = `${name}: ${value}`;
        this.logList.push({ logLevel, message });
    }
    trackEvent(name, properties, measurements) {
        const message = JSON.stringify({
            eventName: name,
            properties,
            measurements
        });
        this.logList.push({ message, logLevel: LogLevel.Information });
    }
    /**
     * Track a page view
     *
     * @param {string} name
     * @param {string} [url]
     */
    trackPageView(name, url) {
        this.trackEvent('trackPageView', { url });
    }
    /**
     * Track request
     * @param options the request options
     */
    trackDependency(options) {
        this.trackEvent('trackRequest', options);
    }
    getLogs() {
        return this.logList;
    }
}
//# sourceMappingURL=retain-logger.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
/// <reference types="node" />
import { ICacheItem, ICacheKey } from '@msdyn365-commerce/cache-internal';
import { IDictionary, IParsedQSP, IRenderingHelper, IRequestContext } from '@msdyn365-commerce/core-internal';
import { IInternalTelemetry, InternalTelemetry, ITelemetry } from '@msdyn365-commerce/telemetry-internal';
import { NextFunction, Request, Response } from 'express';
import { ReactElement } from 'react';
import { Stream } from 'stream';
export declare const MODULE_ERROR_TYPE_NAME_FOR_CACHE: string;
export declare const EMPTY_MODULE_RESULT_VALUE = "empty-module-result";
export declare const UNREGISTERED_MODULE_VALUE = "unregistered-module";
export declare const SSK2_VERSION = "2.0.0";
/**
 * Creates and returns an ICacheKey object for storing
 * results of module render errors inside the RequestCache
 *
 * @param id The id of the module that encountered an error
 */
export declare const createCacheKeyForModuleError: (id: string) => ICacheKey;
/**
 * Creates and returns an ICacheItem object that inidcates
 * a module render result was null or empty
 */
export declare const createCacheValueForEmptyModule: () => ICacheItem<string>;
/**
 * Creates and returns an ICacheItem object that inidcates
 * a module was unregistered and thus not rendered
 */
export declare const createCacheValueForUnregisteredModule: () => ICacheItem<string>;
/**
 * Utility function to async check if file exists
 * @param filePath file path to check
 */
export declare const fileExists: (filePath: string, telemetry: IInternalTelemetry) => Promise<string>;
/**
 * Utility function to access the site builder rendering helper
 */
export declare const getRenderingHelper: () => IRenderingHelper | undefined;
/**
 * Converts a readable stream (that has yet to emit 'data') to a string
 *
 * @param stream Stream-like object
 */
export declare const streamToString: (stream: Stream) => Promise<string>;
/**
 * Checks is value is truthy
 * @param value value to check
 */
export declare const isTruthy: (value: string | number | boolean | null | undefined) => boolean;
/**
 * Checks optional QSP value and returns as a structured type
 *
 * @param qspValue QSP value to check
 */
export declare const parseToQSPObject: <TValue>(qspValue: TValue) => IParsedQSP<TValue>;
/**
 * Server has whitelisting of QSPs, so QSPs going through Server have be put beind a whitelisted QSP such as item.
 *
 * Example:
 *  In localhost, we'll have `?debug=true` but when running through Server, this is equivalent to ?item=debug:true
 *
 * This method also supports parsing out a comma separated item list, makes assumption that everything is properly URIEncoded
 *  e.g. ?item=debug:true,foo:bar,bar:123
 *
 * @param itemQueryString the `item` query string value
 */
export declare const parseItemQSP: (itemQueryString: string | null | undefined) => IDictionary<string>;
export declare const LinkTag: (baseUrl: string, preloadAttribute: string) => (src: string) => string;
export declare const CommentTag: (comment: string | object) => string;
/**
 * Wraps express routes and makes sure to catch & rethrow any errors.
 * Actual handling will be done by the handlerServerError method that logs error and sends response
 * @param fn Function for wrapped route
 */
export declare const safeRoute: (fn: any) => (...args: any[]) => any;
/**
 * Sample helper
 * @param res Response
 */
export declare const throwHelper: (req: Request<import("express-serve-static-core").ParamsDictionary>, res: Response<any>, next: NextFunction, message: string) => never;
export declare const getAbsoluteUri: (req: any) => string;
/**
 * Wrapped render to string method that replaces the SDK Fragment element with nothing
 * used as a drop-in for renderToString on elements where we blindly set innerHTML.
 *
 * @param element the element to render
 */
export declare const patchedRenderToString: (element: ReactElement<any, string | ((props: any) => ReactElement<any, string | any | (new (props: any) => import("react").Component<any, any, any>)> | null) | (new (props: any) => import("react").Component<any, any, any>)>, disableServerSideErrorChecking: boolean) => string;
export declare const CurrencyCodeIdentifier = "cc";
export declare const getCurrencyCodeFromContext: (requestContext: IRequestContext) => string;
/**
 * Extracts the name of the module from the path to its definition file
 * @param definitionPath path to the definition file
 */
export declare const getModuleName: (definitionPath: string) => string;
/**
 * Returns the binder object for the given module
 * @param typeName name of the module
 */
export declare const getModuleBinder: (typeName: string) => import("../app-initialization/models").IModuleBinder;
/**
 * Returns name of the parent module for given module name
 * @param moduleName name of the module
 */
export declare const getParentModuleName: (moduleName: string) => string;
export declare const isSSK2App: () => boolean;
export declare const verboseLogger: (context: IRequestContext, telemetry: InternalTelemetry | ITelemetry, message: string) => void;

import { EXCEPTION_ERROR_CLIENT_BOUNDARY, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { get as _get } from 'lodash';
import React, { useMemo } from 'react';
import { MODULE_CONFIG_ERRORS_KEY } from '../consts';
import { renderView } from './render-view';
const getStandardErrorModuleMarkup = (props) => {
    return (React.createElement("div", Object.assign({ className: 'error-module card mb-3', id: props.id }, props.renderModuleAttributes(props)),
        React.createElement("div", { className: 'card-header text-white bg-danger' },
            props.id,
            "' threw exception"),
        React.createElement("div", { className: 'card-body' },
            React.createElement("p", { className: 'card-text' }, props.error && props.error.toString()),
            React.createElement("p", { className: 'card-text' }, props.message))));
};
/**
 * The error module
 */
export const ErrorModule = (props) => {
    const params = _get(props, 'context.request.params', {});
    const { isDebug } = params;
    return isDebug ? useMemo(() => getStandardErrorModuleMarkup(props), [props]) : null;
};
// tslint:disable: no-any
export const renderErrorOrPlaceHolderModules = (err, internalTelemetry, mappedProps, state, props, isEditor, renderModuleAttributes) => {
    if (!isEditor) {
        internalTelemetry.log(LogLevel.Error, EXCEPTION_ERROR_CLIENT_BOUNDARY, { exception: err });
        return (React.createElement(ErrorModule, Object.assign({}, mappedProps, { errorType: state.error ? 'error' : 'empty', error: err, message: state.info && state.info.componentStack, renderModuleAttributes: renderModuleAttributes, renderView: renderView })));
    }
    /* The following logic helps us retry rendering the component if it previously failed in editor scenario
           There are two cases where we should render the placeholder instead of trying to render the component when authoring

            1. If error state is set because the module threw an error from rendering.
            In this case the module will have an entry in the cache for errors that was set in componentShouldUpdate.
            When a module is ready to retry rendering, clearing it's MODULE_CONFIG_ERRORS_KEY entry will force a retry.
            Should the component fail to render again, the state and cache entry will be re-updated with error(s)

            2. If the module has known config errors, then we should show the placeholder div

        */
    let moduleError = props.store.requestCache.get({ typeName: MODULE_CONFIG_ERRORS_KEY, key: props.id });
    if (state.error && moduleError.item && moduleError.item.length > 0) {
        moduleError = [{ property: props.id, message: err.message }];
    }
    else if (mappedProps.configErrors && mappedProps.configErrors.length > 0) {
        moduleError = mappedProps.configErrors;
    }
    // In an editor scenario, if add/remove module without server refresh feature is enabled
    // SDK will have to place the placeholder module instead of OneRF
    if (isEditor &&
        moduleError &&
        moduleError.length > 0 &&
        _get(props, ['context', 'request', 'features', 'enableAuthoringRemoveAndAddModule'], false)) {
        // error module doesnt render 'click here to configure' placeholder module anymore
        // an empty div with module markers data-i attributes is rendered instead
        const dataInfo = [`id:${mappedProps.id}`];
        mappedProps.slotId && dataInfo.push(`s:${mappedProps.slotId}`);
        mappedProps.parentId && dataInfo.push(`p:${mappedProps.parentId}`);
        mappedProps.typeName && dataInfo.push(`t:${mappedProps.typeName}`);
        return React.createElement("div", { id: `placeholder_${props.id}`, "data-i": `{${dataInfo.join(',')}}` });
    }
    return undefined;
};
//# sourceMappingURL=error-module.js.map
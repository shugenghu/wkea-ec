import { __decorate, __metadata } from "tslib";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:no-use-before-declare
import { CoreContext, isAuthoringEditEnabled, msdyn365Commerce, SDK_FRAGMENT_NAME, WithContext } from '@msdyn365-commerce/core-internal';
import { asSystemMetadata, EXCEPTION_MISSINGMODULECONFIG, EXCEPTION_MODULERENDERFAIL, EXCEPTION_NOMODULEBINDER, EXCEPTION_UNREGISTEREDMODULEID, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { get as _get } from 'lodash';
import { observer } from 'mobx-react';
import * as React from 'react';
import ReactDOM from 'react-dom';
import { ReportChunks } from 'react-universal-component';
import { LAYOUT_MOUNT_POINT, MODULE_CONFIG_ERRORS_KEY, MODULE_LAYOUT_FIELD } from '../consts';
import { AddControlMode, AddModuleControl } from './add-module-control';
import { AddModuleWrapper } from './add-module-wrapper';
import { ErrorModule, renderErrorOrPlaceHolderModules } from './error-module';
import { renderView } from './render-view';
/**
 * Component to render module
 */
let SafeRenderModule = class SafeRenderModule extends React.Component {
    constructor(props) {
        super(props);
        this.shouldDisplayErrors = false;
        this.isRenderAttrributeCalled = false;
        this.disableSSRErrorChecks = false;
        this.renderModuleAttributes = (props) => {
            this.isRenderAttrributeCalled = true;
            if (!props || !props.id) {
                return {};
            }
            // Construct telemetry attributes for module
            const telemetryId = props.friendlyName || props.id;
            const telemetryAttributes = this.props.internalTelemetry && this.props.internalTelemetry.setTelemetryAttribute
                ? this.props.internalTelemetry.setTelemetryAttribute(telemetryId)
                : {};
            const moduleAttributes = { 'data-m-t': props.typeName, ...telemetryAttributes };
            if (this.shouldDisplayErrors || this._isEditorial()) {
                moduleAttributes['data-i'] = this._setDataInfoAttribute(props);
            }
            if (props.platform && typeof props.platform === 'object') {
                Object.keys(props.platform).forEach(key => {
                    moduleAttributes[`data-m-${key}`] = props.platform[key];
                });
            }
            // If a module is associated with an experiment, add this attribtue to track when to activate the experiment
            if (props.context.request && props.context.request.experiments?.moduleIdToExperimentIdMap) {
                if (props.context.request.experiments.moduleIdToExperimentIdMap[props.id]) {
                    moduleAttributes[`data-exp`] = `id:${props.context.request.experiments.moduleIdToExperimentIdMap[props.id]}`;
                }
            }
            // In editor scenario, Authoring will update the module layout by sending us updates on
            // the MODULE_LAYOUT_FIELD in the config object
            if (this._isEditorial() && props.config && props.config[MODULE_LAYOUT_FIELD]) {
                moduleAttributes[`data-m-layout`] = props.config[MODULE_LAYOUT_FIELD];
            }
            return moduleAttributes;
        };
        this.state = {
            error: undefined,
            info: undefined,
            isConfigured: true,
            isRegistered: true,
            mounted: false
        };
        this.componentRef = React.createRef();
        this.shouldDisplayErrors = props && props.context ? props.context.request.params.isDebug : true;
        // If App Setting to disable server-side rendering error checks is true then instead of rendering each module
        // separately and potentially containing each one in an error-boundary in case of an error,
        // safe-render-module will instead render all modules together in one pass for improved performance.
        this.disableSSRErrorChecks = props.context && props.app && props.app.platform && props.app.platform.disableServerSideErrorChecking;
        // In the event that this is being rendered in editor or debug mode we will override this setting to render each individual module separately
        // to catch module errors at the cost of performance
        this.disableSSRErrorChecks =
            this.disableSSRErrorChecks && !props.context.request.params.isDebug && !props.context.request.params.isEditor;
        this.props.internalTelemetry.log(LogLevel.Debug, `Safe Render module constructor type-'{typeName}' with id-'{id} and is ${this.disableSSRErrorChecks ? 'not ' : ''}running in error check mode.'`, {
            values: [asSystemMetadata(this.props.typeName), asSystemMetadata(this.props.id)]
        });
    }
    static getDerivedStateFromError(error) {
        return { error: error };
    }
    componentDidMount() {
        if (!this.state.mounted) {
            this.setState({ mounted: true });
        }
        if (this.isRenderAttrributeCalled) {
            return;
        }
        this._setErrorStates();
        this._setDataAttributes();
    }
    shouldComponentUpdate(nextProps, nextState) {
        if (this._isEditorial()) {
            if (nextState.error) {
                this.props.store.requestCache.put({ typeName: MODULE_CONFIG_ERRORS_KEY, key: this.props.id }, { item: [{ property: this.props.id, message: nextState.error.message }] });
            }
        }
        return true;
    }
    componentDidUpdate() {
        if (this.isRenderAttrributeCalled) {
            return;
        }
        this._setErrorStates();
        this._setDataAttributes();
    }
    componentDidCatch(error, info) {
        this.setState({ error, info });
    }
    // tslint:disable-next-line:cyclomatic-complexity
    render() {
        const config = this.props.config;
        const { internalTelemetry } = this.props;
        internalTelemetry.log(LogLevel.Debug, `Safe Render module render type-'{typeName}' with id-'{id}'`, {
            values: [asSystemMetadata(this.props.typeName), asSystemMetadata(this.props.id)]
        });
        const isMounted = this.state.mounted;
        const mappedProps = mapStateToProps(this.props.store, this.props, isMounted);
        const { id, typeName } = mappedProps && mappedProps.id ? mappedProps : this.props;
        const configErrors = mappedProps.configErrors;
        const Component = mappedProps.component;
        if (!Component) {
            const message = internalTelemetry.stringFormat(EXCEPTION_UNREGISTEREDMODULEID, [id, typeName]);
            internalTelemetry.log(LogLevel.Error, message);
            return (React.createElement(ErrorModule, Object.assign({ errorType: 'unregistered' }, { ...this.props, ...mappedProps }, { error: new Error(message), renderModuleAttributes: this.renderModuleAttributes, renderView: renderView })));
        }
        const err = this.state.error || (configErrors && configErrors.length && new Error(configErrors.map(x => x.message).join(', ')));
        if (err) {
            const element = renderErrorOrPlaceHolderModules(err, internalTelemetry, mappedProps, this.state, this.props, this._isEditorial(), this.renderModuleAttributes);
            if (element) {
                return element;
            }
        }
        if (process.env.CURRENT_ENVIRONMENT === 'node') {
            if (config && config.hasOwnProperty('clientRender') && config.clientRender && !this._isEditorial()) {
                return React.createElement(React.Fragment, null);
            }
            else {
                return this._doServerSideRender(mappedProps, Component, internalTelemetry);
            }
        }
        else if (!this.state.mounted && this.props.store.deferred(this.props.id)) {
            // module needs two passes
            return null;
        }
        else if (config && config.hasOwnProperty('clientRender') && config.clientRender && !this._isEditorial()) {
            if (this.state.mounted) {
                return (React.createElement(Component, Object.assign({}, mappedProps, { ref: this.componentRef }, { renderModuleAttributes: this.renderModuleAttributes, renderView: renderView })));
            }
            else {
                return React.createElement(React.Fragment, null);
            }
        }
        return (React.createElement(Component, Object.assign({}, mappedProps, { ref: this.componentRef }, { renderModuleAttributes: this.renderModuleAttributes, renderView: renderView })));
    }
    /**
     * Set the data info attribute to be added to the modules
     * @param props The module props.
     */
    _setDataInfoAttribute(props) {
        const dataInfo = [`id:${props.id}`];
        props.slotId && dataInfo.push(`s:${props.slotId}`);
        props.parentId && dataInfo.push(`p:${props.parentId}`);
        props.typeName && dataInfo.push(`t:${props.typeName}`);
        props.friendlyName && dataInfo.push(`fn:${props.friendlyName}`);
        // @ts-ignore
        const moduleBinder = msdyn365Commerce.moduleBinder(props.typeName);
        if (moduleBinder) {
            moduleBinder.$type && dataInfo.push(`mt:${moduleBinder.$type}`);
        }
        props.errorType && dataInfo.push(`e:${props.errorType}`);
        return `{${dataInfo.join(',')}}`;
    }
    /**
     * isEditor
     * Determines if request is coming from the editor
     */
    _isEditorial() {
        return _get(this.props, ['context', 'request', 'params', 'isEditor'], false);
    }
    /**
     * Creates data info string to be used by cms e.g '{id:prop-id,s:content,p:parent-id}'
     */
    _generateDataInfo() {
        const dataInfo = [`id:${this.props.id}`];
        this.props.slotId && dataInfo.push(`s:${this.props.slotId}`);
        this.props.parentId && dataInfo.push(`p:${this.props.parentId}`);
        this.props.typeName && dataInfo.push(`t:${this.props.typeName}`);
        this.props.friendlyName && dataInfo.push(`fn:${this.props.friendlyName}`);
        // @ts-ignore
        const moduleBinder = msdyn365Commerce.moduleBinder(this.props.typeName);
        if (moduleBinder) {
            moduleBinder.$type && dataInfo.push(`mt:${moduleBinder.$type}`);
        }
        // Error scenarios
        // 1. Empty module
        // 2. Unregistered module
        // 3. Generic error
        !this.state.isConfigured && dataInfo.push('e:empty');
        !this.state.isRegistered && dataInfo.push('e:unregistered');
        this.state.error && dataInfo.push('e:error');
        return `{${dataInfo.join(',')}}`;
    }
    /**
     * Conducts the server side render and returns the result.
     * If disable SSR Error Checking flag is turned on, the React Element is returned immediately,
     * otherwise the render result is calculated using renderToString to catch errors
     * and defer modules (used for editor and debug scenarios)
     */
    // tslint:disable-next-line: no-any
    _doServerSideRender(
    // tslint:disable-next-line: no-any
    mappedProps, 
    // tslint:disable-next-line: no-any
    Component, internalTelemetry) {
        let renderHtmlString;
        const renderHtml = (React.createElement(CoreContext.Provider, { value: this.props.context },
            React.createElement(ReportChunks, { report: this.props.addChunk },
                React.createElement(Component, Object.assign({}, mappedProps, { renderModuleAttributes: this.renderModuleAttributes, renderView: renderView })))));
        if (this.disableSSRErrorChecks) {
            // In non editorial or non debug mode and if app setting to disable server side error checking is turned on
            // return the JSX directly without computing the render result to save time and compute cost
            return renderHtml;
        }
        else {
            try {
                // tslint:disable-next-line:no-require-imports
                renderHtmlString = require('react-dom/server').renderToString(renderHtml);
                if (!renderHtmlString.length) {
                    // module returned null
                    this.props.store.markModuleAsDeferred(this.props.id);
                }
            }
            catch (e) {
                internalTelemetry.log(LogLevel.Error, `Safe Render module Failed to render type-'{typeName}' with id-'{id}'`, {
                    exception: e,
                    values: [asSystemMetadata(this.props.typeName), asSystemMetadata(this.props.id)]
                });
                return (React.createElement(ErrorModule, Object.assign({}, mappedProps, { errorType: 'error', error: e, message: e && e.stack, renderModuleAttributes: this.renderModuleAttributes, renderView: renderView })));
            }
            // tslint:disable:react-no-dangerous-html -- intentionally set inner html
            return React.createElement(SDK_FRAGMENT_NAME, { key: this.props.id, dangerouslySetInnerHTML: { __html: renderHtmlString } });
        }
    }
    /**
     * Assignes data-i and data-t attributes to child component if isEditor is enabled
     */
    _setDataAttributes() {
        let refNode;
        if (this._isEditorial()) {
            // If type name only exists on the props then this module is not registered.
            if (this.state.error || !this.state.isRegistered || !this.state.isConfigured) {
                refNode = document.getElementById(this.props.id);
            }
            else if (this.componentRef.current) {
                refNode = this.props.root
                    ? document.getElementById(LAYOUT_MOUNT_POINT)
                    : ReactDOM.findDOMNode(this.componentRef.current);
            }
        }
        if (refNode && typeof refNode.setAttribute === 'function') {
            refNode.setAttribute('data-i', this._generateDataInfo());
        }
    }
    _setErrorStates() {
        const isMounted = this.state.mounted;
        const mappedProps = mapStateToProps(this.props.store, this.props, isMounted);
        // Registration check
        const isRegistered = !!mappedProps.component;
        if (isRegistered !== this.state.isRegistered) {
            this.setState({ ...this.state, isRegistered: isRegistered });
            return;
        }
        // Configuration check
        const isConfigured = !(mappedProps.configErrors && mappedProps.configErrors.length > 0);
        if (isConfigured !== this.state.isConfigured) {
            this.setState({ ...this.state, isConfigured: isConfigured });
            return;
        }
    }
};
SafeRenderModule = __decorate([
    observer,
    __metadata("design:paramtypes", [Object])
], SafeRenderModule);
export { SafeRenderModule };
export const getRenderSlotComponent = (parentProps, moduleConfigs, slotId, addSiblingIndices, isMounted) => {
    if (!moduleConfigs) {
        return [];
    }
    const canAddAtIndex = (index) => {
        return addSiblingIndices ? addSiblingIndices.indexOf(index + 1) >= 0 : false;
    };
    // if addSiblingIndices is not undefined, we add the AddModuleControl components between each module; but in hidden state if index value isnt provider
    // this prevents re-rendering of the module when the AddModuleControl components are enabled/disabled
    // in preview mode, addSiblingIndices will be undefined and we will only render the modules
    return moduleConfigs.map((moduleConfig, index) => {
        return addSiblingIndices && isMounted ? (React.createElement(AddModuleWrapper, { safeRenderProps: {
                key: moduleConfig.id,
                ...moduleConfig,
                parentId: parentProps.id,
                slotId: slotId,
                store: parentProps.store,
                addChunk: parentProps.addChunk
            }, addModuleProps: {
                moduleId: parentProps.id,
                index: index + 1,
                enabled: canAddAtIndex(index),
                slotId: slotId,
                mode: AddControlMode.Sibling
            } })) : (React.createElement(SafeRenderModuleWithContext, Object.assign({ key: moduleConfig.id }, moduleConfig, { parentId: parentProps.id, slotId: slotId, store: parentProps.store, addChunk: parentProps.addChunk })));
    });
};
/**
 * Maps the application state to the modules props
 * @param state The application state
 * @param ownProps The props for the specific module
 */
const mapStateToProps = (store, props, isMounted) => {
    try {
        const { internalTelemetry } = props;
        const moduleConfig = getModuleConfig(store, props.id);
        if (!moduleConfig) {
            internalTelemetry.log(LogLevel.Error, internalTelemetry.stringFormat(EXCEPTION_MISSINGMODULECONFIG, [props.id, props.typeName]));
            return {};
        }
        // TODO - following statements introducing side effect in render method (props should not change in render). Please take a look after public preview
        // Pull value out of stuff that came from cache (doing this gives us reactivity via MobX)
        Object.keys(moduleConfig.data).forEach(key => {
            if (moduleConfig.data[key] && moduleConfig.data[key].Item) {
                moduleConfig.data[key] = moduleConfig.data[key].Item;
            }
        });
        // @ts-ignore
        const moduleBinder = msdyn365Commerce.moduleBinder(moduleConfig.typeName);
        if (!moduleBinder) {
            internalTelemetry.log(LogLevel.Error, EXCEPTION_NOMODULEBINDER, { values: [asSystemMetadata(moduleConfig.typeName)] });
            return {};
        }
        const enableAddModuleControls = isAuthoringEditEnabled(store.requestContext);
        return {
            ...props,
            ...moduleConfig,
            component: moduleBinder.component,
            slots: enableAddModuleControls ? getSlotDictionary(props, moduleConfig.slotsForAddModule, isMounted) : getSlotDictionary(props)
        };
    }
    catch (e) {
        props.internalTelemetry.log(LogLevel.Error, props.internalTelemetry.stringFormat(EXCEPTION_MODULERENDERFAIL, [props.id]), {
            exception: e
        });
        return {};
    }
};
const getModuleConfig = (store, moduleId) => {
    return store.modules(moduleId);
};
const getSlotDictionary = (props, slotsForAddModule, isMounted) => {
    const slotDictionary = {};
    const { modules } = props;
    const slotsWithAddModuleControls = (slotsForAddModule || []).filter(a => !a.index && a.slotName);
    const addSiblingIndexDictionary = {};
    (slotsForAddModule || [])
        .filter(a => a.index && !a.slotName)
        .forEach(a => {
        addSiblingIndexDictionary[a.slotId] = a.index || [];
    });
    // removes placeholder 'click here to configure' modules
    // tslint:disable-next-line:no-any
    const getNonPlaceholderModules = (mods) => {
        return mods.filter(a => a.typeName !== 'place-holder-for-container-preview');
    };
    if (modules) {
        Object.keys(modules).forEach((key) => {
            slotDictionary[key] = getRenderSlotComponent(props, getNonPlaceholderModules(modules[key]), key, slotsForAddModule ? addSiblingIndexDictionary[key] || [] : undefined, isMounted);
        });
    }
    slotsWithAddModuleControls.forEach((slot) => {
        if (isMounted && (!modules || !modules[slot.slotId] || getNonPlaceholderModules(modules[slot.slotId]).length === 0)) {
            slotDictionary[slot.slotId] = [
                // tslint:disable-next-line:jsx-wrap-multiline
                React.createElement(AddModuleControl, { key: `${props.id}.${slot}`, moduleId: props.id, enabled: true, slotId: slot.slotId, parentId: props.parentId, slotName: slot.slotName, mode: AddControlMode.EmptySlot })
            ];
        }
    });
    return slotDictionary;
};
const SafeRenderModuleWithContext = WithContext(SafeRenderModule);
export default SafeRenderModuleWithContext;
//# sourceMappingURL=safe-render-module.js.map
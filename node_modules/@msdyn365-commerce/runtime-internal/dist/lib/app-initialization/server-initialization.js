/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { AppCache } from '@msdyn365-commerce/cache-internal';
import { MSDyn365Commerce, msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { safeFileExists, safeFileExistsSync, safeReadJson } from '@msdyn365-commerce/utilities-internal';
import axios from 'axios';
import { merge } from 'lodash';
import { useStaticRendering } from 'mobx-react';
import { dirname, join, resolve } from 'path';
import { isDAPIOptimizationDisabled } from '../_server/Definition/moduleDefinition';
import { HttpsRequestInterceptor } from '../_server/inteceptors/https-agent-inteceptor';
import keystonePaths from '../paths';
import { ResourceManager } from '../resources/resource-manager';
import sdkAppSettings from '../settings/app.settings.json';
import { getModuleName } from '../utils/helpers';
import { getAppSecretsCacheSetings, getCacheSettings, getExperimentsCacheSettings, getPlatformSettingsSync } from '../utils/platform-utils';
import { SecretManager } from '../utils/secret-manager';
import { initializeApp } from './initialization';
import { createComponent } from './render-component';
const APP_SETTINGS = 'app.settings';
const IMAGE_SETTINGS = 'image.settings';
const THEME_SETTINGS = 'theme.settings';
const ROOT_SITE = '__root_site__';
const CONNECTOR_SETTINGS = 'connector.settings';
const PLATFORM_SETTINGS = 'platform.settings';
/**
 * @function {getAppSettings}   - Method to return merged object of both sdk and partner app settings
 */
const getAppSettings = async (bindings) => {
    const appSettings = {
        app: { config: {}, routes: {} },
        msdyn365: { config: sdkAppSettings.config, contentSecurityPolicy: sdkAppSettings.contentSecurityPolicy }
    };
    const partnerAppSettings = await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${APP_SETTINGS}.json`));
    if (partnerAppSettings) {
        appSettings.app = partnerAppSettings;
    }
    if (sdkAppSettings.routes) {
        appSettings.app.routes = merge({}, sdkAppSettings.routes, appSettings.app.routes || {});
    }
    if (msdyn365Commerce.themes && msdyn365Commerce.themes.themes) {
        appSettings.app.themes = merge({}, msdyn365Commerce.themes.themes, appSettings.app.themes || {});
    }
    // Add friendly name to theme where applicable
    const themeModules = isDAPIOptimizationDisabled() ? msdyn365Commerce.themeModules : bindings.dapi.themes;
    themeModules.forEach((themeModule) => {
        if (appSettings.app.themes && appSettings.app.themes[themeModule.name] && !appSettings.app.themes[themeModule.name].friendlyName) {
            appSettings.app.themes[themeModule.name].friendlyName = themeModule.friendlyName;
        }
    });
    return appSettings;
};
/**
 * @function {getImageSettings}   - Method to return merged object of both sdk and partner image settings
 */
const getImageSettings = async () => {
    return await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${IMAGE_SETTINGS}.json`)) || {};
};
/**
 * @function {getThemeSettings}   - Method to return partner theme settings
 */
const getThemeSettings = async (platformSettings) => {
    const themeSettings = {};
    // theme settings defined prior to serviceability
    const partnerThemeSettings = await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${THEME_SETTINGS}.json`)) || {};
    if (!isDAPIOptimizationDisabled(platformSettings)) {
        const generatedThemeSettings = await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DAPI_FILEPATH));
        return {
            default: partnerThemeSettings,
            ...generatedThemeSettings
        };
    }
    const allModulesBinder = (await msdyn365Commerce.getAllModuleBinder()) || [];
    const themeModules = allModulesBinder.filter(def => def.$type === 'themeModule');
    await Promise.all(themeModules.map(async (themeModule) => {
        let settings = {};
        if (themeModule.themeSettings) {
            settings = (await safeReadJson(resolve(themeModule.moduleDirectory, themeModule.themeSettings))) || {};
        }
        if (themeModule.parentDefinitionPath) {
            const parentModuleName = getModuleName(themeModule.parentDefinitionPath);
            const parentSettingsPath = join(dirname(themeModule.parentDefinitionPath), `${parentModuleName}${".theme.settings.json" /* SETTINGS_FILE */}`);
            if (await safeFileExists(parentSettingsPath)) {
                settings = merge(settings, (await safeReadJson(parentSettingsPath)) || {});
            }
        }
        let overrideSettings = {};
        const overrideSettingsFile = resolve(keystonePaths.KEYSTONE_THEMES_DIR, themeModule.name, `${themeModule.name}${".theme.settings.json" /* SETTINGS_FILE */}`);
        if (await safeFileExists(overrideSettingsFile)) {
            overrideSettings = (await safeReadJson(overrideSettingsFile)) || {};
        }
        themeSettings[themeModule.name] = merge(settings, overrideSettings);
    }));
    return {
        default: partnerThemeSettings,
        ...themeSettings
    };
};
const getPlatformSettings = async () => {
    const platFormSettings = await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${PLATFORM_SETTINGS}.json`));
    return platFormSettings ? platFormSettings : {};
};
const getExperimentationCache = async () => {
    const connectorCacheSettings = getExperimentsCacheSettings();
    let cacheSetting = getCacheSettings();
    cacheSetting = merge(cacheSetting, connectorCacheSettings);
    return new AppCache(cacheSetting);
};
/**
 * Creates and returns a refernce to the app cache used to store
 * RS access token and any C1 secrets
 */
const createAppSecretsCache = async () => {
    const cacheSettings = getAppSecretsCacheSetings();
    return new AppCache(cacheSettings);
};
/**
 * During local development, we capture the secrets file stored locally
 * to read necessary secret values
 */
const getLocalSecretsFile = async () => {
    let localSecrets;
    if (safeFileExistsSync(resolve(keystonePaths.KEYSTONE_SECRETS_DIR, `secrets.json`))) {
        localSecrets = await safeReadJson(resolve(keystonePaths.KEYSTONE_SECRETS_DIR, `secrets.json`));
    }
    return localSecrets;
};
/**
 * During local development, read and store the credentials json file to mock user signed in behavior
 */
const getLocalCredentialsFile = async () => {
    let localCreds;
    if (safeFileExistsSync(resolve(keystonePaths.KEYSTONE_SECRETS_DIR, `credentials.json`))) {
        localCreds = await safeReadJson(resolve(keystonePaths.KEYSTONE_SECRETS_DIR, `credentials.json`));
    }
    return localCreds;
};
const getExperimentaionConnector = async (secretManager) => {
    const connectorSettings = await safeReadJson(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${CONNECTOR_SETTINGS}.json`));
    if (connectorSettings && connectorSettings.experimentation) {
        const connectorSettingsForExperimentation = connectorSettings.experimentation;
        const experimentationProvider = (
        // @ts-ignore - Compiler indicates that types of IMSDyn365CommerceExtension and MSDyn365Commerce do not overlap
        // but typeof IMSDyn365CommerceWithPrototype = typeof MSDyn365Commerce & IPrototype
        // See initialization.ts for an explanation of why we use prototype in conjunction with IMSDyn365CommerceWithPrototype
        msdyn365Commerce.getConnector(connectorSettingsForExperimentation.name)?.provider);
        if (experimentationProvider) {
            try {
                const experimentReady = await experimentationProvider.initialize(connectorSettingsForExperimentation.config, secretManager);
                if (!experimentReady) {
                    console.error(`experimentation connector registered with name ${connectorSettingsForExperimentation.name} not initialized successfully`);
                    return undefined;
                }
            }
            catch (err) {
                console.error(`experimentation connector registered error ${err} with name ${connectorSettingsForExperimentation.name}`);
                return undefined;
            }
            return { name: connectorSettingsForExperimentation.name, provider: experimentationProvider };
        }
        console.error(`No experimentation connector registered with name ${connectorSettingsForExperimentation.name}`);
        return undefined;
    }
    return undefined;
};
const getDAPIBindings = async () => {
    return {
        modules: (await safeReadJson(keystonePaths.KEYSTONE_APP_DAPI_FILEPATH)) || {},
        themes: (await safeReadJson(keystonePaths.KEYSTONE_APP_THEMES_DAPI_FILEPATH)) || []
    };
};
/**
 * @function {getAppCacheForRootSite} - Method to return app cache instance for root site
 */
const getAppCacheForRootSite = () => {
    const appCacheDictionary = {};
    appCacheDictionary[ROOT_SITE] = new AppCache(getCacheSettings());
    return appCacheDictionary;
};
const removeExcludedModues = (bindings) => {
    // remove excluded modules from binding
    const platformSettings = getPlatformSettingsSync();
    const excludedModules = platformSettings.excludedModules;
    if (excludedModules && excludedModules.length > 0) {
        for (const moduleName of excludedModules) {
            delete bindings.modules[`${moduleName}`];
        }
    }
};
// tslint:disable:no-invalid-this
export const initializeServerApp = async (bindings) => {
    bindings.dapi = await getDAPIBindings();
    removeExcludedModues(bindings);
    initializeApp(bindings);
    useStaticRendering(true);
    axios.interceptors.request.use(HttpsRequestInterceptor);
    const packageVersion = await safeReadJson(keystonePaths.KEYSTONE_APP_PACKAGE_VERSION);
    const appSecretsCache = await createAppSecretsCache();
    const platformSettings = await getPlatformSettings();
    // In local dev mode read local secrets file and credentials file
    let localAppSecrets;
    let localCredentials;
    if (process.env.NODE_ENV === 'development') {
        localAppSecrets = await getLocalSecretsFile();
        localCredentials = await getLocalCredentialsFile();
    }
    const secretManager = new SecretManager(appSecretsCache, localAppSecrets);
    const appSettingsPromise = getAppSettings(bindings);
    const imageSettingsPromise = getImageSettings();
    const themeSettingsPromise = getThemeSettings(platformSettings);
    const experimentationConnectorPromise = getExperimentaionConnector(secretManager);
    const experimentationCachePromise = getExperimentationCache();
    const [appSettings, imageSettings, themeSettings, experimentationConnector, experimentationCache] = await Promise.all([
        appSettingsPromise,
        imageSettingsPromise,
        themeSettingsPromise,
        experimentationConnectorPromise,
        experimentationCachePromise
    ]);
    const resourceManager = new ResourceManager();
    await resourceManager.init(platformSettings);
    MSDyn365Commerce.prototype.updatePrivateVariable = function () {
        // @ts-ignore
        this._buildVersion = packageVersion && packageVersion.buildVersion;
        // @ts-ignore
        this._resourceManager = resourceManager;
        // @ts-ignore
        this._appSettings = appSettings;
        // @ts-ignore
        this._imageSettings = imageSettings;
        // @ts-ignore
        this._themeSettings = themeSettings;
        // @ts-ignore
        this.createComponent = createComponent;
        // @ts-ignore
        this._experimentationCache = experimentationCache;
        // @ts-ignore
        this._secretManager = secretManager;
        // @ts-ignore
        this._experimentationConnector = experimentationConnector;
        // @ts-ignore
        this._platformSettings = platformSettings;
        // @ts-ignore
        this._localCredentials = localCredentials;
    };
    MSDyn365Commerce.prototype.appCache = getAppCacheForRootSite();
    MSDyn365Commerce.prototype.getAppCache = function (requestContext) {
        if (!requestContext || !requestContext.apiSettings) {
            return this.appCache[ROOT_SITE];
        }
        const appCacheKey = `${requestContext.apiSettings.baseUrl}-${requestContext.apiSettings.channelId}`;
        if (!this.appCache[appCacheKey]) {
            this.appCache[appCacheKey] = new AppCache(getCacheSettings());
        }
        const appCache = this.appCache[appCacheKey];
        appCache.setRequestContext(requestContext);
        return appCache;
    };
    msdyn365Commerce.updatePrivateVariable();
};
//# sourceMappingURL=server-initialization.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { isEmptyOrNullObject } from '@msdyn365-commerce/core-internal';
import { EXCEPTION_INVALID_URL, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { getRCSUversion } from '@msdyn365-commerce/utilities-internal';
import axios from 'axios';
import * as bodyParser from 'body-parser';
import compression from 'compression';
import cookieSession from 'cookie-session';
import express from 'express';
import { httpsOverHttp } from 'tunnel';
import url from 'url';
import { getMockDataBasedOnRequestQueryString, getV3mockPageJson } from '../mock/mock-helper';
import keystonePaths from '../paths';
import { safeRoute } from '../utils/helpers';
import { detectProxy, getCheckoutRoute, getRequestUrl, KEYSTONE_ENVIRONMENT, loadFeatureFlags, registerAttributeRenderers, renderPage, resolveRouteInformation, sanitizeUrlForLogging, setCorsHeaders, setResponseHeaders, setTelemetryObject, validateRouteAndChannelConfig } from '../utils/platform-utils';
import { HttpException } from './error';
import { RSRequestInterceptor, RSRequestInterceptorErrorHandler, RSResponseInterceptor, RSResponseInterceptorErrorHandler } from './inteceptors/rs-logging-interceptor';
import { requestTimeout } from './middleware/route-timeout';
import { requestRouteTimer } from './middleware/route-timers';
import { getBodyConfig, mapRequestContextWithRenderingContext, mergeSwtichFromPlatformSettingsWithFeatureSwitch } from './parse-request';
import { preProcessRequest, serverExceptionParser } from './request-routers';
import apiRouter from './request-routers/api-router';
import experimentationRouter from './request-routers/experimentation-router';
import healthRouter from './request-routers/health-router';
import sdkRouter from './request-routers/sdk-router';
import staticsRouter, { parseHashedStaticsRequest } from './request-routers/statics-router';
import { HASHED_STATICS_PREFIX } from './statics-pipeline/statics-helpers';
import PageContractApiService from './temp-page-contract-api-service';
// store previous request context of previous request
// to be used in the api-router during local development
export let previousRequestContext = {};
const computerName = process.env.COMPUTERNAME;
let rcsuVersion = process.env.MSDyn365Commerce_RCSUVERSION;
console.log(computerName);
const environment = KEYSTONE_ENVIRONMENT;
console.log(JSON.stringify(environment));
console.log(JSON.stringify(keystonePaths));
// In debug mode, add the proxy debug interceptor for all HTTP Requests
if (process.env.NODE_ENV === 'development') {
    axios.interceptors.request.use(config => {
        // Only use the interceptor when debug flag is enabled
        if (process.env.NODE_USE_DEBUG_PROXY === '1') {
            config.httpsAgent = httpsOverHttp({
                proxy: {
                    host: '127.0.0.1',
                    port: 8888,
                    headers: {}
                }
            });
        }
        return config;
    });
}
// TODO: move these to server-initialization
axios.interceptors.request.use(RSRequestInterceptor, RSRequestInterceptorErrorHandler);
axios.interceptors.response.use(RSResponseInterceptor, RSResponseInterceptorErrorHandler);
// tslint:disable-next-line:max-func-body-length
export function appFunc({ clientStats }, env, options, appInsightsTelemetryClient) {
    const PUBLIC_DIR = process.env.PUBLIC_DIR || 'build/public';
    const server = express();
    const sdkRouterInstance = sdkRouter(server);
    const staticsRouterInstance = staticsRouter(PUBLIC_DIR, clientStats);
    const healthRouterInstance = healthRouter();
    const experimentationRouterInstance = experimentationRouter();
    const apiRouterInstance = apiRouter();
    server
        .use(requestRouteTimer)
        .use(cookieSession({
        name: 'msdyn365c_aad',
        signed: false,
        maxAge: 3600000 // 1 hour in ms, the lifespan of an aad token
    }))
        .disable('x-powered-by')
        .disable('etag')
        .use(bodyParser.urlencoded({ limit: '50mb', extended: false }))
        .use(bodyParser.json({ limit: '50mb' }))
        .use(express.urlencoded({ extended: true }))
        .use(detectProxy)
        .use(compression())
        .use(loadFeatureFlags)
        .use(setResponseHeaders)
        .use(requestTimeout)
        .use(express.static(PUBLIC_DIR, {
        // disable etag
        etag: false,
        // disable special handling of ../ and ./
        dotfiles: 'deny',
        // don't provide generated directory listings
        index: false,
        // max cache timeout of a week
        maxAge: process.env.NODE_ENV === 'development' ? 1 : 604800000
    }))
        .use(setTelemetryObject(appInsightsTelemetryClient))
        .use('/_sdk', sdkRouterInstance)
        .use(experimentationRouterInstance)
        .use(apiRouterInstance)
        .use('/version', (req, res) => {
        res.sendFile(keystonePaths.KEYSTONE_APP_PACKAGE_VERSION);
    })
        .use('/sockjs-node', (req, res) => {
        if (process.env.NODE_ENV === 'development' && req.query.t) {
            // This is a workaround for dealing with sockjs requests to the wrong port
            // In local dev scenario, sock js requests should only be made to the dev server port
            // e.g. localhost:4001/sockjs-node/info?t=1587868046907 in most cases. However for some reason a sockjs request is made the http server as well
            // causing us to look up the server page (e.g. int2.fabrikam.com/sock-js) which is unnecessary and leads to console spam
            //
            // This change here will not impact HMR as changes are observed on the dev port not the http port. All this does is add a
            // workaround that will send a 404 back immediately so it doesn't go through our request flow and print out a bunch of errors in the console
            // TODO: Find out why something is sending request to http server
            // See https://github.com/webpack/webpack-dev-server/issues/1802#issuecomment-484372015 for a discussion of the issue. Apparently issue still
            // exists in webpack dev server v3.8.1
            res.status(404).send();
        }
    })
        /**
         * Health check endpoints
         */
        .use(healthRouterInstance)
        .use([
        // statics route from 1rf with submission id
        `/_scnr/${process.env.SUBMISSIONID || 'statics'}`,
        // statics route from 1rf for hashed js statics
        `/_scnr/${process.env.SUBMISSIONID || 'statics'}/j`,
        // (legacy) route from 1rf without submission id
        `/_scnr`,
        // local with submission id
        `/${process.env.SUBMISSIONID || 'statics'}`,
        // local hashed js statics
        `/j`
    ], staticsRouterInstance)
        /**
         * localhost serving of assets
         */
        .get([
        // non-local route with submission ID
        `/${HASHED_STATICS_PREFIX}${process.env.SUBMISSIONID}/:hashedUrl`,
        // local routes without submission id
        `/${HASHED_STATICS_PREFIX}:hashedUrl`
    ], safeRoute(async (req, res, next) => {
        return parseHashedStaticsRequest(req, res, next, { clientStats, PUBLIC_DIR }, res.locals.telemetry);
    }))
        /**
         * Local development auth redirect route.
         *  If the request is from AAD capture the auth information in the session and redirect to the requested
         *  url as a get.
         */
        .post('*', (req, res, next) => {
        if (req.body && req.body.id_token) {
            // @ts-ignore
            req.session && (req.session.id_token = req.body.id_token);
            return res.redirect(url.format({
                protocol: req.protocol,
                host: req.get('host'),
                pathname: req.originalUrl
            }));
        }
        next();
    })
        /**
         * Page Rendering Routes
         */
        .use((req, res, next) => {
        res.locals.requestContext = preProcessRequest(req, res, process.env.COMPUTERNAME, res.locals.telemetry);
        if (process.env.NODE_ENV === 'development') {
            previousRequestContext = res.locals.requestContext;
        }
        next();
    })
        /**
         * Create mock PageResponse for Modules routes
         */
        .get('/modules', safeRoute(async (req, res, next) => {
        const content = await getMockDataBasedOnRequestQueryString(req.query, res.locals.telemetry);
        res.locals.isMockRequest = true;
        res.locals.pageResponse = content;
        const context = res.locals.requestContext;
        context.locale = req.query.locale || context.locale;
        if (!context.locale) {
            context.locale = 'en-us';
        }
        next();
    }))
        .get('/page/:themeName/:pageType/:layout', safeRoute(async (req, res, next) => {
        const context = res.locals.requestContext;
        context.locale = req.query.locale || context.locale;
        if (req.params) {
            res.locals.pageResponse = await PageContractApiService.getThemeLayout(req.params.themeName, req.params.pageType, req.params.layout, res.locals.telemetry);
        }
        return renderPage(req, res, next, { clientStats });
    }))
        .get('/segment/:themeName/:segmentName', safeRoute(async (req, res, next) => {
        const context = res.locals.requestContext;
        context.locale = req.query.locale || context.locale;
        if (req.params) {
            const segmentJson = await PageContractApiService.getThemeSegment(req.params.themeName, req.params.segmentName, res.locals.telemetry);
            // Get the default mock page json
            const pageJsonV3 = getV3mockPageJson();
            // @ts-ignore
            pageJsonV3.pageRoot.modules.body[0].modules.primary[0].modules.content.push(segmentJson);
            res.locals.pageResponse = pageJsonV3;
        }
        next();
    }))
        /**
         * Get Page Response for rendering
         */
        .use(
    // tslint:disable-next-line:cyclomatic-complexity
    safeRoute(async (req, res, next) => {
        const serverHost = (req.query && req.query.server && req.query.server) ||
            process.env.MSDyn365_HOST ||
            process.env.SERVER_HOST ||
            undefined;
        // For POST /render routes, res.locals.pageResponse will already be set
        if (isEmptyOrNullObject(res.locals.pageResponse) && serverHost) {
            await PageContractApiService.handleGetPageResponse(req, res, serverHost);
        }
        const requestUrl = getRequestUrl(res);
        const routeInfo = resolveRouteInformation(res, requestUrl);
        const checkoutRoute = getCheckoutRoute(res);
        // If the RCSU version environment variable is not defined,
        // set it with API settings from the first request and save it for future requests
        if (!rcsuVersion || rcsuVersion === '--') {
            if (res.locals.pageResponse &&
                res.locals.pageResponse.renderingContext &&
                res.locals.pageResponse.renderingContext.apiSettings?.baseUrl) {
                rcsuVersion = await getRCSUversion(res.locals.pageResponse.renderingContext.apiSettings.baseUrl);
            }
        }
        if (routeInfo) {
            res.locals.telemetry.log(LogLevel.Information, 'Processing request for {URL} {route} by process {processId} with {SDKVersion}, {SSKVersion}, {RetailProxy} {RCSUVersion} {CheckoutRoute}', {
                values: [
                    sanitizeUrlForLogging(requestUrl),
                    routeInfo || '',
                    process.pid,
                    process.env.MSDyn365Commerce_SDK_VERSION,
                    process.env.MSDyn365Commerce_SSK_VERSION,
                    process.env.MSDyn365Commerce_RSVERSION,
                    rcsuVersion,
                    checkoutRoute
                ]
            });
        }
        // Re-initialize request context against rendering context
        res.locals.requestContext = mapRequestContextWithRenderingContext(req, res.locals.requestContext, res.locals.pageResponse.renderingContext, res.locals.pageResponse.appContext, getBodyConfig(res.locals.pageResponse));
        logExpVariantsInfo(res.locals);
        // Set Feature switches if they could not be set above
        if (!res.locals.features || (isEmptyOrNullObject(res.locals.features) && res.locals.pageResponse.renderingContext)) {
            res.locals.requestContext.features = res.locals.pageResponse.renderingContext.features || {};
        }
        res.locals.requestContext = mergeSwtichFromPlatformSettingsWithFeatureSwitch(res.locals.requestContext);
        registerAttributeRenderers(res.locals.telemetry, res.locals.moduleTelemetry, res.locals.requestContext);
        next();
    }))
        .use(setCorsHeaders)
        /**
         * Validate Route Middleware
         */
        .use(validateRouteAndChannelConfig)
        .get('/modules', safeRoute(async (req, res, next) => {
        return renderPage(req, res, next, { clientStats });
    }))
        .get('*', safeRoute(async (req, res, next) => {
        // For invalid page, pageResponse is not set
        if (isEmptyOrNullObject(res.locals.pageResponse)) {
            throw new HttpException(404, EXCEPTION_INVALID_URL);
        }
        return renderPage(req, res, next, { clientStats });
    }))
        .post('/render', safeRoute(async (req, res, next) => {
        return renderPage(req, res, next, { clientStats });
    }))
        .use(serverExceptionParser);
    return server;
}
// tslint:disable-next-line:no-any
const logExpVariantsInfo = (locals) => {
    if (locals.requestContext.experiments && locals.requestContext.experiments.activeExperiments) {
        const activeExperiments = locals.requestContext.experiments.activeExperiments;
        if (activeExperiments.length > 0) {
            const variantsInfo = JSON.stringify(activeExperiments);
            locals.telemetry.log(LogLevel.Information, `Exp variants: ${variantsInfo}`);
        }
        else {
            locals.telemetry.log(LogLevel.Information, `No exp variants found.`);
        }
    }
};
//# sourceMappingURL=index.js.map
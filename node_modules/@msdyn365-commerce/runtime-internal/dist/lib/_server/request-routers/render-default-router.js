/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { RequestCache } from '@msdyn365-commerce/cache-internal';
import { EXCEPTION_PARSE_ISSUE, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { sha256 } from 'js-sha256';
import { getContentSecurityPolicy } from '../../utils/base-page-utils';
import { getPageConfig } from '../parse-request';
import serverRenderVnext from '../server-render.vnext';
import { handleServerException } from './request-router-helper';
export const renderDefaultRouter = (req, res, next, content, context, { clientStats }) => {
    Promise.resolve()
        .then(async () => {
        const { telemetry } = res.locals;
        try {
            if (!content) {
                throw new Error(EXCEPTION_PARSE_ISSUE);
            }
            const isEditor = context.params.isEditor;
            const enableAuthoringRemoveAndAddModule = context.features?.enableAuthoringRemoveAndAddModule;
            const pageConfig = getPageConfig(content, telemetry);
            // If OneRF sends back config errors for a particular module, OneRF will automatically set the module type to placeholder. However,
            // in editor mode, and iff authoring helper client side refresh feature is enabled (enableAuthoringRemoveAndAddModule)
            // we want to control this logic client side to enable client refresh once the module receives valid information
            // Therefore, we change the typename back to its original type and let safe-render-module decide whether to render a placeholder or not
            if (isEditor && enableAuthoringRemoveAndAddModule && content && content.slots) {
                changePlaceholdersBackToOriginalModuleType(content.slots);
            }
            telemetry.setTelemetryRequestContext({
                siteId: '[[Placeholder]]',
                channelId: context.channel?.RecordId ? context.channel.RecordId.toString() : 'Unavailable',
                pageType: context.urlTokens.pageType,
                pageId: content.pageRoot.id
            });
            if (!res.locals.isMockRequest) {
                // set channel from res.locals as it's initially set in middleware or has errored out
                context.channel = res.locals.getOrgUnitConfigurationAsyncResult;
            }
            const routeRefreshActions = res.locals.routeRefreshActions;
            // generate nonce token based on request id, and save it to requestContext
            generateNonceToken(context);
            let rootComponentResponse = '';
            if (content.slots && content.slots.length) {
                rootComponentResponse = await serverRenderVnext({
                    content,
                    options: { clientStats },
                    context,
                    telemetry,
                    moduleTelemetry: res.locals.moduleTelemetry,
                    pageConfig,
                    // set request cache or re-use one created from route validation
                    requestCache: res.locals.requestCache || new RequestCache(),
                    routeRefreshActions
                });
            }
            // Add Content-Security-Policy Header
            // If report-only mode set Content-Security-Policy-Report-Only header
            let contentSecurityPolicyHeader = 'Content-Security-Policy';
            if (context.app && context.app.contentSecurityPolicy && context.app.contentSecurityPolicy.enableReportOnlyMode) {
                contentSecurityPolicyHeader = 'Content-Security-Policy-Report-Only';
            }
            const contentSecurityPolicy = getContentSecurityPolicy(context);
            // Set header if policies exist and if CSP is enabled
            if (contentSecurityPolicy) {
                res.setHeader(contentSecurityPolicyHeader, contentSecurityPolicy);
            }
            // Apppend server side cookies to response header if present
            // @ts-ignore not part of public contract
            const serverCookies = context.cookies ? context.cookies.serverCookies : [];
            if (serverCookies.length > 0) {
                // In local dev scenario, because we directly return this response,
                // send the response with the Set-Cookie headers to set the cookies from server side
                if (process.env.NODE_ENV === 'development') {
                    for (let i = 0; i < serverCookies.length; i++) {
                        res.setHeader('Set-Cookie', serverCookies[i]);
                    }
                }
                res.setHeader('X-Server-Cookies', serverCookies);
            }
            telemetry.log(LogLevel.Debug, 'End of Page Render... Sending response');
            res.send(rootComponentResponse);
        }
        catch (e) {
            handleServerException(res, 'Server Exception', e, telemetry);
        }
    })
        .catch((e) => {
        const { telemetry } = res.locals;
        telemetry.log(LogLevel.Error, 'Failed to render page', { exception: e });
        next();
    });
};
const changePlaceholdersBackToOriginalModuleType = (slots) => {
    for (let i = 0; i < slots.length; i++) {
        const curModule = slots[i];
        if (curModule.configErrors && curModule.configErrors.length > 0) {
            // OneRF will send the original module type in the config but in case it cannot be derived fall back to using
            // placeholder
            // @ts-ignore
            const originalModuleType = curModule.config?.moduleType;
            if (originalModuleType) {
                curModule.typeName = originalModuleType;
            }
        }
    }
};
const generateNonceToken = (requestContext) => {
    if (!requestContext ||
        !requestContext.app ||
        !requestContext.app.contentSecurityPolicy ||
        requestContext.app.contentSecurityPolicy.disableContentSecurityPolicy ||
        !requestContext.app.contentSecurityPolicy.enableNonce) {
        return;
    }
    const requestId = requestContext.operationId;
    const nonceToken = sha256(requestId);
    requestContext.app.contentSecurityPolicy ? (requestContext.app.contentSecurityPolicy.nonceToken = nonceToken) : null;
};
//# sourceMappingURL=render-default-router.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { readCachedExperimentsEntries, saveCachedExperimentsEntries } from '@msdyn365-commerce/cache-internal';
import { EXPERIMENTATION_CACHE_TYPE, msdyn365Commerce, RefreshType } from '@msdyn365-commerce/core-internal';
import { asSystemMetadata, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import express from 'express';
import { moduleListPage } from '../../components/module-list-page';
import { DEFAULT_REQUEST_TIMEOUT, PROVIDER_GET_EXPERIMENTS_FAIL, RETAIL_SERVER_BASE_URL_HEADER_KEY } from '../../consts';
import keystonePaths from '../../paths';
import featureFlags from '../../settings/featureflags.settings.json';
import { safeRoute, throwHelper } from '../../utils/helpers';
import { getModuleDefinitions, getModulesList, getThemeModules, getThemeModulesList } from '../Definition/moduleDefinition';
import { getPreviews } from '../Definition/previewDefinition';
import { getStyles } from '../Definition/stylesDefinition';
/**
 * Adds module details (name and default mock url) to a module type array
 *
 * @param moduleType The module type that the current module should be added to
 * @param moduleName The name of the module
 * @param modulesList The module list object containing the moduleType keys
 */
const addToModuleType = (moduleType, moduleName, modulesList) => {
    if (!modulesList[moduleType]) {
        modulesList[moduleType] = [];
    }
    modulesList[moduleType].push({ name: moduleName, mockUrl: `/modules?type=${moduleName}` });
};
/**
 * Returns a function used for resolving the behavior of the _sdk/allmodules route
 * which gets a list of registered modules from DAPI and categorizes
 * the modules by module type before sending that list module-list-page.tsx
 * to render a list of installed modules and their associated previews (if applicabile)
 */
const getAllModulesRouteParser = () => {
    return safeRoute(async (req, res, next) => {
        // Pass in empty string as the first argument so we get a list of all the modules
        const registeredModules = await getModuleDefinitions('', res.locals.telemetry);
        const modulesList = {};
        if (Array.isArray(registeredModules)) {
            const registeredModuleList = registeredModules;
            registeredModuleList.forEach(moduleDefinition => {
                const moduleType = moduleDefinition.type ? moduleDefinition.type : moduleDefinition.$type;
                if (moduleType && moduleType !== 'moduleDefinition') {
                    addToModuleType(moduleType, moduleDefinition.name, modulesList);
                }
                else {
                    addToModuleType('uncategorizedModules', moduleDefinition.name, modulesList);
                }
            });
        }
        res.send(moduleListPage(modulesList));
    });
};
/**
 * Returns a function for resolving the behvaior of the _sdk/featureflags route
 * Returns a json object containing information on the current feature
 */
const getFeatureFlagsJson = () => {
    return safeRoute(async (req, res, next) => {
        const features = featureFlags;
        if (process.env.MSDyn365Commerce_RSVERSION) {
            features.retailServerVersion = process.env.MSDyn365Commerce_RSVERSION;
            features.SDKVersion = process.env.MSDyn365Commerce_SDK_VERSION;
            features.SSKVersion = process.env.MSDyn365Commerce_SSK_VERSION;
        }
        res.send(features);
    });
};
const getExperimentsWithCache = async (res, retailServerBaseUrl, page, items) => {
    const experimentConnector = msdyn365Commerce.experimentationConnector && msdyn365Commerce.experimentationConnector;
    if (!experimentConnector) {
        res.status(204);
        return {};
    }
    let experimentList;
    let experiments;
    if (!page && !items) {
        const refreshOption = {
            refreshType: RefreshType.Experiments,
            parameters: []
        };
        const cacheKey = {
            typeName: EXPERIMENTATION_CACHE_TYPE,
            key: experimentConnector.name
        };
        experimentList = await readCachedExperimentsEntries(cacheKey, refreshOption, experimentConnector.provider, experimentConnector.name, retailServerBaseUrl);
        if (!experimentList) {
            try {
                experiments = await experimentConnector.provider.getExperiments(retailServerBaseUrl, experimentConnector.name);
                experimentList = experiments && experiments.experiments;
                if (experimentList && experimentList.length > 0) {
                    await saveCachedExperimentsEntries(cacheKey, experimentList);
                }
            }
            catch (e) {
                res.locals.telemetry.log(LogLevel.Error, PROVIDER_GET_EXPERIMENTS_FAIL, {
                    values: [asSystemMetadata(retailServerBaseUrl || '')],
                    exception: e
                });
            }
        }
        else {
            experiments = {
                name: experimentConnector.name,
                experiments: experimentList
            };
        }
    }
    else {
        try {
            experiments = await experimentConnector.provider.getExperiments(retailServerBaseUrl, experimentConnector.name, page, items);
        }
        catch (e) {
            res.locals.telemetry.log(LogLevel.Error, PROVIDER_GET_EXPERIMENTS_FAIL, {
                values: [asSystemMetadata(retailServerBaseUrl || '')],
                exception: e
            });
        }
    }
    return experiments || {};
};
/**
 * Method to process dapi request
 * @param req request object
 * @param res response object
 * @param next next function in the route chain
 */
const processDapiRequest = async (req, res, next) => {
    if (!req.stale) {
        return res.sendStatus(304);
    }
    let resultDefinition;
    switch (req.params.resource) {
        case "modules" /* Modules */:
            resultDefinition = await getModuleDefinitions(req.query.type, res.locals.telemetry);
            if (Array.isArray(resultDefinition) && resultDefinition.length > 0) {
                resultDefinition = resultDefinition.filter(moduleDef => moduleDef.type !== "themeModule" /* TYPE */);
            }
            break;
        case "modulelist" /* ModuleList */:
            resultDefinition = await getModulesList();
            break;
        case "styles" /* Styles */:
            resultDefinition = getStyles();
            break;
        case "experiments" /* Experiments */:
            const retailServerBaseUrl = req.headers[RETAIL_SERVER_BASE_URL_HEADER_KEY];
            resultDefinition = await getExperimentsWithCache(res, retailServerBaseUrl, req.query.page, req.query.items);
            break;
        case "appsettings" /* AppSettings */:
            resultDefinition = msdyn365Commerce.appSettings;
            break;
        case "imagesettings" /* ImageSettings */:
            resultDefinition = msdyn365Commerce.imageSettings;
            break;
        case "themesettings" /* ThemeSettings */:
            resultDefinition = msdyn365Commerce.themeSettings;
            break;
        case "themes" /* Themes */:
            resultDefinition = await getThemeModules(req.query.type, res.locals.telemetry);
            break;
        case "themeslist" /* ThemesList */:
            resultDefinition = await getThemeModulesList(res.locals.telemetry);
            break;
        case "resources" /* Resources */:
            resultDefinition = msdyn365Commerce.resourceManager
                ? msdyn365Commerce.resourceManager.getAuthoringResources()
                : { error: `Resource manager is not defined` };
            break;
        case "previews" /* Previews */:
            resultDefinition = await getPreviews(req.query, res.locals.telemetry);
            break;
        default:
            resultDefinition = { error: `type not defined [${req.params.resource}]` };
            res.status(404);
    }
    return res.send(resultDefinition);
};
// tslint:disable-next-line:typedef max-func-body-length
export default function (server) {
    const sdkRouter = express.Router();
    sdkRouter.use((req, res, next) => {
        res.append('build-version', msdyn365Commerce.buildVersion);
        res.setHeader('ETag', `"${msdyn365Commerce.buildVersion}"`);
        res.setHeader('Cache-Control', 'max-age=3600, public');
        next();
    });
    sdkRouter
        // @TODO kopik: move test routes behind an env flag
        // route to test that exceptions will be caught
        .get('/test-throw', safeRoute(async (req, res, next) => {
        return throwHelper(req, res, next, 'test-throw');
    }))
        // nested promise example
        .get('/test-throw-nested', safeRoute(async (req, res, next) => {
        return (async (req2, res2, next2) => {
            return throwHelper(req, res, next, 'test-throw-2');
        })(req, res, next);
    }))
        .get('/test-timeout', async (req, res, next) => {
        setTimeout(() => {
            try {
                res.send('timeout exceeded');
            }
            catch (e) {
                // eat the error silently in case we've already closed the connection
            }
            // tslint:disable-next-line:align
        }, DEFAULT_REQUEST_TIMEOUT + 1000);
    });
    /**
     * This route is for showing all registered routes and middleware in express. it's a raw dump,
     * useful in debugging express
     */
    sdkRouter.get('/debug', async (req, res, next) => {
        res.send({
            ...server._router
        });
    });
    // definition api routes
    sdkRouter.get('/dapi/:resource', safeRoute(processDapiRequest));
    sdkRouter.get('/allmodules', getAllModulesRouteParser());
    // version route
    sdkRouter.get('/version', (req, res) => {
        res.sendFile(keystonePaths.KEYSTONE_APP_PACKAGE_VERSION);
    });
    // enabled features route
    sdkRouter.get('/features', getFeatureFlagsJson());
    sdkRouter.get('/yarn-lock', (req, res) => {
        res.sendFile(keystonePaths.KEYSTONE_APP_YARN_LOCK);
    });
    sdkRouter.get('/registration/:resource', (req, res) => {
        const bindings = msdyn365Commerce.bindings;
        switch (req.params.resource) {
            case 'views':
                res.send(Object.keys(bindings.views || []));
                break;
            case 'components':
                res.send(Object.keys(bindings.components || []));
                break;
            case 'modules':
                // filter modules
                res.send(Object.keys(bindings.modules || [])
                    .map(key => bindings.modules[key])
                    .filter(value => value.$type !== "themeModule" /* TYPE */)
                    .map(val => {
                    return {
                        name: val.name,
                        type: val.$type,
                        packageName: val.packageName,
                        moduleNamespace: val.moduleNamespace,
                        isNodeModule: val.isNodeModule,
                        dataActions: val.dataActions,
                        parentDefinitionPath: val.parentDefinitionPath
                    };
                }));
                break;
            case 'themes':
                // filter theme modules
                res.send(Object.keys(bindings.modules || [])
                    .map(key => bindings.modules[key])
                    .filter(value => value.$type === "themeModule" /* TYPE */)
                    .map(val => {
                    return {
                        name: val.name,
                        packageName: val.packageName,
                        moduleNamespace: val.moduleNamespace,
                        isNodeModule: val.isNodeModule,
                        definitionExtensions: val.definitionExtensions,
                        views: Object.keys(bindings.views || []).filter(view => view.indexOf(`|${val.name}|views|`) > 0),
                        components: Object.keys(bindings.components || []).filter(component => component.indexOf(`|${val.name}|views|components|`) > 0),
                        themeSettings: val.themeSettings
                    };
                }));
                break;
            case 'data-actions':
                res.send(Object.keys(bindings.dataActions || []));
                break;
            default:
                const resultDefinition = { error: `type not defined [${req.params.resource}]` };
                res.status(404);
                return res.send(resultDefinition);
        }
    });
    return sdkRouter;
}
//# sourceMappingURL=sdk-router.js.map
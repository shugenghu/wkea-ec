{"version":3,"file":"chunking.js","sourceRoot":"","sources":["../../../src/_server/chunking.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IGeneric, IRequestContext } from '@msdyn365-commerce/core-internal';\nimport {\n    asSystemMetadata,\n    EVENT_JSCHUNKING_START,\n    EVENT_JSCHUNKING_STOP,\n    IInternalTelemetry,\n    LogLevel\n} from '@msdyn365-commerce/telemetry-internal';\nimport { difference, uniq } from 'lodash';\n// tslint:disable-next-line -- required to make typechecker happy\nimport * as React from 'react';\n\n/**\n * Convenience shorthand for number | type which can be used as a valid key index into an object\n */\nexport type IndexableType = number | string;\n\n/**\n * @description Interface representing returned data for chunks used in rendering pass, <script> and <link> tags,\n *             paths to files, and flag to determine of chunking is currently even enabled\n */\nexport interface IUsedChunks {\n    // is chunking enabled?\n    isChunkingEnabled: boolean;\n    // list of all assets used for current chunks requested\n    assets?: IAssetsByChunkName;\n    // renderable client-side string of entry chunk script(s)\n    entryChunkScripts?: string[];\n    // renderable client-side string of bootstrap (webpack init) chunk script(s)\n    bootstrapChunkScripts?: string[];\n    // renderable client-side string of async js (webpack init) chunk script(s)\n    jsScriptChunks?: string[];\n    // renderable client-side string of css (webpack init) chunk script(s)\n    cssScriptChunks?: string[];\n    // unique ids of chunks used in this render pass (numbered in prod)\n    chunkIds?: IndexableType[];\n}\n\n/**\n * @description Represents assets for chunk names along with <script> & <link> tags\n */\nexport interface IAssetsByChunkName {\n    // chunk names\n    chunks: IndexableType[];\n    // path to js files, relative\n    jsFiles: string[];\n    // path to css files, relative\n    cssFiles: string[];\n    // path to js scripts\n    jsScripts: string[];\n    // path to css scripts\n    cssScripts: string[];\n}\n\n/**\n * @description takes relative path of strings and maps them to script tags that can be rendered with\n *              fully qualified baseUrl path\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param pathOrPathsToFiles single or multiple paths to files\n */\nconst mapBaseUrlToString = (baseUrl: string, pathOrPathsToFiles: string | string[], context: IRequestContext): string[] => {\n    return (Array.isArray(pathOrPathsToFiles) ? pathOrPathsToFiles : [pathOrPathsToFiles]).map((script: string) => {\n        // fallback with `statics` in case submissionid is not set\n        return `${baseUrl}${process.env.SUBMISSIONID || 'statics'}/${script}`;\n    });\n};\n\nconst hasNamedChunk = (clientStats: IGeneric<{}>, chunkName: IndexableType) =>\n    clientStats.assetsByChunkName && clientStats.assetsByChunkName[chunkName];\nconst getNamedChunk = (clientStats: IGeneric<{}>, chunkName: IndexableType) => clientStats.assetsByChunkName[chunkName];\nconst hasNamedChunkGroup = (clientStats: IGeneric<{}>, chunkName: IndexableType) =>\n    clientStats.namedChunkGroups && clientStats.namedChunkGroups[chunkName];\nconst getNamedChunkGroup = (clientStats: IGeneric<{}>, chunkName: IndexableType) => clientStats.namedChunkGroups[chunkName];\nconst CONST_CLIENT = 'client';\nconst CONST_BOOTSTRAP = 'bootstrap';\n\n/**\n * @description checks the named chunks and chunks section of the clientStats generated by webpack\n *              and returns the corresponding file paths after mapping the baseUrl to their paths\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkNames list of chunk names\n * @param clientStats webpack generated client stats\n */\n// @ts-ignore -- re-exported type signature from react to make tsc happy\nconst getAssetsByChunkName = async (\n    baseUrl: string,\n    chunkNames: IndexableType[],\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    context: IRequestContext\n): Promise<IAssetsByChunkName | undefined> => {\n    let result: IAssetsByChunkName | undefined;\n    try {\n        let assets: string[] = [];\n        // group vs actual chunk names.\n        let actualChunkNames: IndexableType[] = [];\n        chunkNames.map((chunkName: IndexableType) => {\n            // strip off any file extensions eg: .js from the key\n            if (typeof chunkName === 'string' && chunkName.endsWith('.js')) {\n                // It is possible that the chunkName key here could be *.view.js\n                // usually view.js is expected to be grouped along with its module. However, we need to\n                // ensure we don't miss out on adding the chunk should webpack groups it into separate chunk\n                // see build/public/stats-web.json for more info.\n                chunkName = chunkName.split('.js')[0];\n            }\n\n            // check if we have a named chunk group with this name\n            if (hasNamedChunkGroup(clientStats, chunkName)) {\n                const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);\n                assets = assets.concat(namedChunkGroup.assets);\n                actualChunkNames = actualChunkNames.concat(namedChunkGroup.chunks);\n            } else if (hasNamedChunk(clientStats, chunkName)) {\n                // possible for this not to be a group but an individual named chunk, which could contain multiple files\n                const namedChunk = getNamedChunk(clientStats, chunkName);\n                assets = assets.concat(Array.isArray(namedChunk) ? namedChunk : [namedChunk]);\n                actualChunkNames.push(chunkName);\n            }\n        });\n\n        result = {\n            chunks: [...actualChunkNames],\n            jsFiles: uniq(assets.filter((assetFile: string) => assetFile.endsWith('.js'))),\n            cssFiles: uniq(assets.filter((assetFile: string) => assetFile.endsWith('.css'))),\n            cssScripts: [],\n            jsScripts: []\n        };\n        result = {\n            ...result,\n            jsScripts: mapBaseUrlToString(baseUrl, result.jsFiles, context),\n            cssScripts: mapBaseUrlToString(baseUrl, result.cssFiles, context)\n        };\n    } catch (e) {\n        telemetry.log(LogLevel.Error, '', { exception: e });\n    }\n\n    return result;\n};\n\n/**\n * @description Looks up single chunk information and details\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkName chunk name to look up\n * @param clientStats generated webpack client stats\n * @param fileTypes extension of files to include from chunk or chunk group\n */\nconst getScriptsForChunkName = async (\n    baseUrl: string,\n    chunkName: IndexableType,\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    fileTypes: string = '.js',\n    context: IRequestContext\n): Promise<string[]> => {\n    let results;\n    try {\n        if (hasNamedChunkGroup(clientStats, chunkName)) {\n            const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);\n            results = mapBaseUrlToString(\n                baseUrl,\n                namedChunkGroup.assets.filter((asset: string) => asset.endsWith(fileTypes)),\n                context\n            );\n        } else if (hasNamedChunk(clientStats, chunkName)) {\n            const namedChunk = getNamedChunk(clientStats, chunkName);\n            // we're not sure if it's an array, could be a single string, so coerce to array with concat, so we can filter it\n            results = mapBaseUrlToString(\n                baseUrl,\n                [].concat(namedChunk).filter((asset: string) => asset.endsWith(fileTypes)),\n                context\n            );\n        } else {\n            throw new Error(`Did not find chunk named ${chunkName}`);\n        }\n    } catch (e) {\n        telemetry.log(LogLevel.Error, 'Failed to get chunk named {chunkName}.', { values: [asSystemMetadata(chunkName)], exception: e });\n    }\n\n    return results;\n};\n\n/**\n * Gets the IDs of each named chunk\n *\n * @param chunkNames The chunk names for which to get IDs for\n * @param clientStats generated webpack client stats\n */\nconst getChunkIds = (chunkNames: IndexableType[], clientStats: IGeneric<{}>) => {\n    let ids: (string | number)[] = [];\n    chunkNames.forEach((id: IndexableType) => {\n        if (hasNamedChunkGroup(clientStats, id)) {\n            const chunkIds = getNamedChunkGroup(clientStats, id).chunks;\n            ids = ids.concat(chunkIds);\n        }\n    });\n\n    return uniq(ids);\n};\n\n/**\n * @description Returns object containing all necessary information to render chunks including\n *              paths to files, chunk information (entry, bootstrap, other), and breaks assets up into\n *              different groups (css, js)\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkNames list of chunk names to look up\n * @param clientStats generated webpack client stats\n * @returns {Promise<IUsedChunks>} returns value\n */\n// @ts-ignore -- re-exported type signature from react to make tsc happy\nexport const processClientStatsForChunking = (\n    baseUrl: string,\n    // tslint:disable-next-line\n    chunkNames: any,\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    context: IRequestContext\n): Promise<IUsedChunks> => {\n    const isChunkingEnabled = hasNamedChunkGroup(clientStats, CONST_CLIENT) && hasNamedChunk(clientStats, CONST_BOOTSTRAP);\n    if (!isChunkingEnabled) {\n        return Promise.resolve({\n            isChunkingEnabled: false\n        });\n    }\n    return Promise.all([\n        getScriptsForChunkName(baseUrl, CONST_CLIENT, clientStats, telemetry, undefined, context),\n        getScriptsForChunkName(baseUrl, CONST_BOOTSTRAP, clientStats, telemetry, undefined, context)\n    ]).then(([entryChunkScripts, bootstrapChunkScripts]) => {\n        return getAssetsByChunkName(baseUrl, chunkNames, clientStats, telemetry, context).then(assets => {\n            const chunkIds = uniq(getChunkIds(chunkNames, clientStats).concat(getChunkIds([CONST_CLIENT], clientStats)));\n            return {\n                assets: { ...(<IAssetsByChunkName>assets) },\n                isChunkingEnabled: true,\n                entryChunkScripts,\n                // @TODO @kopik: bootstrap is included in entry chunk as a peer, should we actually look it up?\n                // bootstrap chunk is used to make jsonp requests so we definitely need it but for initial page load we can defer probably\n                bootstrapChunkScripts,\n                jsScriptChunks: difference(assets!.jsScripts, entryChunkScripts),\n                cssScriptChunks: assets!.cssScripts,\n                chunkIds\n            };\n        });\n    });\n};\n"]}
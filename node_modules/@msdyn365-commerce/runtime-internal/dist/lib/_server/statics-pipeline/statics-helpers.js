/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import CombinedStream from 'combined-stream';
import * as fs from 'fs';
import { uniq } from 'lodash';
import * as path from 'path';
import { fileExists } from '../../utils/helpers';
/**
 * Separator for concat partial IDs
 */
export const URL_SEPARATOR = '!';
/**
 * Prefix for including JS files
 */
export const HASHED_STATICS_PREFIX = '_j/';
/**
 * Max number of URLs to generator
 */
export const MAX_JS_ASSETS = Number(process.env.MAX_JS_ASSETS || 1);
/**
 * Map hashed URL to actual asset files
 *
 * @param requestedAssets hashed asset string
 * @param clientStats webpack client stats
 */
export const mapAssetUrlToFiles = (requestedAssets, clientStats) => {
    const result = [];
    if (!requestedAssets) {
        return result;
    }
    const requestedIds = uniq(requestedAssets.split(URL_SEPARATOR) || []);
    const requestedChunks = [];
    requestedIds.forEach((chunkId) => {
        const targetIndex = clientStats.chunks.findIndex((item) => String(item.id) === String(decodeURIComponent(chunkId)));
        if (targetIndex !== -1) {
            Array.prototype.push.apply(requestedChunks, clientStats.chunks[targetIndex].files);
        }
    });
    // dedupe again as there may be commmon chunks between top level dependencies
    return uniq(requestedChunks.filter((pathToFile) => pathToFile.endsWith('.js')));
};
/**
 * Private helper functions below, exported for ease in testing
 */
/**
 * Takes in a single array of N items and splits it into an array with numPart arrays
 *
 * @param array The array of to split
 * @param numParts The max number of arrays to return
 * @private
 */
export const splitToMaxNArrays = (array, numParts) => {
    const res = [];
    const m = array.length / numParts + (array.length % numParts);
    while (array.length) {
        res.push(array.splice(0, m));
    }
    return res;
};
/**
 * Generates a set of magic asset urls
 * @param usedAssetChunks The required assets for the current render pass
 */
export const generateAssetUrls = (baseUrl, usedAssetChunks, numMax = MAX_JS_ASSETS) => {
    if (!usedAssetChunks || (usedAssetChunks.chunkIds && !usedAssetChunks.chunkIds.length)) {
        return [];
    }
    return splitToMaxNArrays(usedAssetChunks.chunkIds || [], numMax).map((array) => `${baseUrl}${HASHED_STATICS_PREFIX}${encodeURIComponent(array.join(URL_SEPARATOR))}`);
};
/**
 * Helper function to map the public folder to the currently requested file
 *
 * @param publicDir Public directory from app root, env.PUBLIC_DIR
 * @param filePath Current statics file path
 * @private
 */
export const mapPublicDirToPath = (publicDir) => (filePath) => path.resolve(path.join(publicDir, filePath));
/**
 *
 * @param filePaths File paths of files we need to stream
 * @param res
 * @returns {CombinedStream} combined stream response
 * @private
 */
/**
 *  TODO: remove use of any once the following PR gets merged in
 *  https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30295 to properly update type definitions
 */
// tslint:disable-next-line:no-any
export const createFileStreamResponse = async (filePaths, publicDir, telemetry) => {
    if (!filePaths || !filePaths.length) {
        return;
    }
    const realFilePathsPromises = filePaths.map(mapPublicDirToPath(publicDir)).map((item) => fileExists(item, telemetry));
    const realFilePaths = await Promise.all(realFilePathsPromises).then((possibleFilePaths) => (possibleFilePaths && possibleFilePaths.filter(Boolean)) || []);
    if (!realFilePaths.length) {
        return;
    }
    const jsStream = CombinedStream.create();
    realFilePaths.forEach((filePath) => {
        jsStream.append(fs.createReadStream(filePath));
        jsStream.append('\n;');
    });
    return jsStream;
};
//# sourceMappingURL=statics-helpers.js.map
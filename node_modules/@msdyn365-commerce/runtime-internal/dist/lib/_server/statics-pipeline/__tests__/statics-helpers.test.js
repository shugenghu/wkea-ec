/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import * as fs from 'fs';
import 'jest';
import MemoryStream from 'memorystream';
import mockfs from 'mock-fs';
import * as path from 'path';
import { streamToString } from '../../../utils/helpers';
import { processClientStatsForChunking } from '../../chunking';
import { createFileStreamResponse, generateAssetUrls, mapAssetUrlToFiles, mapPublicDirToPath, splitToMaxNArrays } from '../statics-helpers';
const telemetry = StaticTelemetry;
describe('helper functions', () => {
    it('maps publicDir to filepath correctly', () => {
        // arrange
        const publicDir = 'public';
        const filePaths = ['static/js/file1.js', 'static/js/file2.js'];
        const expectedResult = [path.resolve('public/static/js/file1.js'), path.resolve('public/static/js/file2.js')];
        // act
        const actualResult = filePaths.map(mapPublicDirToPath(publicDir));
        // assert
        expect(actualResult).toEqual(expectedResult);
    });
    it('can split array of even items correctly', () => {
        // arrange
        const input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        const n = 2;
        const expected = [
            [1, 2, 3, 4, 5],
            [6, 7, 8, 9, 10]
        ];
        const result = splitToMaxNArrays(input, n);
        expect(result.length).toBe(2);
        expect(result[0].length).toBe(5);
        expect(result[1].length).toBe(5);
        expect(result[0]).toEqual(expected[0]);
        expect(result[1]).toEqual(expected[1]);
    });
    it('can split array of odd items correctly', () => {
        // arrange
        const input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        const n = 2;
        const expected = [
            [1, 2, 3, 4, 5, 6],
            [7, 8, 9, 10, 11]
        ];
        const result = splitToMaxNArrays(input, n);
        expect(result.length).toBe(2);
        expect(result[0].length).toBe(6);
        expect(result[1].length).toBe(5);
        expect(result[0]).toEqual(expected[0]);
        expect(result[1]).toEqual(expected[1]);
    });
    it('can split into more than 2 groups correctly', () => {
        // arrange
        const input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        const n = 3;
        const expected = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10]
        ];
        const result = splitToMaxNArrays(input, n);
        expect(result.length).toBe(3);
        expect(result[0].length).toBe(4);
        expect(result[1].length).toBe(4);
        expect(result[2].length).toBe(2);
        expect(result[0]).toEqual(expected[0]);
        expect(result[1]).toEqual(expected[1]);
        expect(result[2]).toEqual(expected[2]);
    });
});
describe('url', () => {
    let usedAssetChunks;
    let clientStats;
    beforeEach(async (done) => {
        clientStats = JSON.parse(fs.readFileSync(path.join(__dirname, '__mocks__', 'stats-web-a.json')).toString());
        usedAssetChunks = await processClientStatsForChunking('', [
            'partner/modules-search-data-binders-search-data-binder',
            'partner/modules-product-placement-data-binders-search-filter-product-placement-data-binder',
            'partner/modules-search-reducers-reddit-search-reducer',
            'partner/modules-search-search',
            'partner/modules-product-placement-product-placement'
        ], clientStats, telemetry, 
        // tslint:disable-next-line
        {});
        done();
    });
    describe('generation', () => {
        it('handles generating url with blank used assets', () => {
            const generatedUrls = generateAssetUrls('', { isChunkingEnabled: true, chunkIds: [] }, 1);
            expect(generatedUrls).toEqual([]);
        });
        it('can properly generate a valid single asset url (localhost)', async (done) => {
            // arrange
            // IDs map to IDs in json file -- keep commented block to understand how snapshot is generated
            // const expectedUrl = `${HASHED_STATICS_PREFIX}75!70!77!79!72!89!0!90`;
            // act
            const generatedUrls = generateAssetUrls('', usedAssetChunks, 1);
            // assert
            expect(generatedUrls.length).toBe(1);
            expect(generatedUrls[0]).toMatchSnapshot('ExpectedUrl');
            done();
        });
        it('can properly generate a valid single asset url (cdn)', async (done) => {
            // arrange
            const CdnUrl = '//testsite-int.onerf.microsoft.com/testsite/_scnr/';
            // IDs map to IDs in json file -- keep commented block to understand how snapshot is genereated
            // const expectedUrl = `${CdnUrl}${HASHED_STATICS_PREFIX}75!70!77!79!72!89!0!90`;
            // act
            const generatedUrls = generateAssetUrls(CdnUrl, usedAssetChunks, 1);
            // assert
            expect(generatedUrls.length).toBe(1);
            expect(generatedUrls[0]).toMatchSnapshot('ExpectedUrl');
            done();
        });
    });
    describe('parsing', () => {
        it('can parse a valid url back to assets properly', () => {
            // arrange
            const urlPart = '75!70';
            const expectedResult = [
                'static/js/partner/modules-search-data-binders-search-data-binder.chunk.js',
                'static/js/partner/modules-product-placement-data-binders-search-filter-product-placement-data-binder.chunk.js'
            ];
            // act
            const result = mapAssetUrlToFiles(urlPart, clientStats);
            // assert
            expect(result).toEqual(expectedResult);
        });
        it('can successfully dedupe requested assets', () => {
            // arrange
            const urlPart = '75!70!75!75';
            const expectedResult = [
                'static/js/partner/modules-search-data-binders-search-data-binder.chunk.js',
                'static/js/partner/modules-product-placement-data-binders-search-filter-product-placement-data-binder.chunk.js'
            ];
            // act
            const result = mapAssetUrlToFiles(urlPart, clientStats);
            // assert
            expect(result).toEqual(expectedResult);
        });
        it('handles empty requests gracefully', () => {
            // arrange
            const urlPart = '';
            const expectedResult = [];
            // act
            const result = mapAssetUrlToFiles(urlPart, clientStats);
            // assert
            expect(result).toEqual(expectedResult);
        });
        it('handles mix of valid & invalid resource requests correctly', () => {
            // arrange
            const urlPart = '999999!75!70!1234567890';
            const expectedResult = [
                'static/js/partner/modules-search-data-binders-search-data-binder.chunk.js',
                'static/js/partner/modules-product-placement-data-binders-search-filter-product-placement-data-binder.chunk.js'
            ];
            // act
            const result = mapAssetUrlToFiles(urlPart, clientStats);
            // assert
            expect(result).toEqual(expectedResult);
        });
    });
});
describe('file streaming', () => {
    beforeAll(() => {
        const dirName = mapPublicDirToPath('public')('static/js');
        mockfs({
            [dirName]: {
                'file1.js': 'file 1 contents',
                'file2.js': 'file 2 contents'
            }
        });
    });
    afterAll(() => {
        mockfs.restore();
    });
    it('successfully exits on empty set of files', async (done) => {
        // arrange
        const publicDir = 'public';
        const files = [];
        // act
        // @ts-ignore
        const response = await createFileStreamResponse(files, publicDir, telemetry);
        // assert
        expect(response).toBe(undefined);
        done();
    });
    it('successfully exits on non-existing set of files', async (done) => {
        // arrange
        const publicDir = 'public';
        const files = ['static/js/file3.js'];
        // act
        // @ts-ignore
        const response = await createFileStreamResponse(files, publicDir, telemetry);
        // assert
        expect(response).toBe(undefined);
        done();
    });
    it('successfully parses existing & non-existing files', async (done) => {
        jest.setTimeout(10000);
        // arrange
        const publicDir = 'public';
        const files = ['static/js/file2.js', 'static/js/file3.js'];
        // act
        // @ts-ignore
        const response = await createFileStreamResponse(files, publicDir, telemetry);
        // assert
        expect(response).not.toEqual(undefined);
        const memstr = new MemoryStream();
        // act
        const streamPromise = streamToString(memstr);
        response.pipe(memstr);
        return streamPromise.then((fileStreamStrings) => {
            // assert
            expect(fileStreamStrings).toEqual('file 2 contents\n;');
            done();
        });
    });
    it('successfully concatenates files correctly', async (done) => {
        jest.setTimeout(10000);
        // arrange
        const publicDir = 'public';
        const files = ['static/js/file1.js', 'static/js/file2.js'];
        // act
        // @ts-ignore
        const response = await createFileStreamResponse(files, publicDir, telemetry);
        // assert
        expect(response).not.toEqual(undefined);
        // @ts-ignore
        const memstr = new MemoryStream();
        // act
        const streamPromise = streamToString(memstr);
        response.pipe(memstr);
        return streamPromise.then((fileStreamStrings) => {
            // assert
            expect(fileStreamStrings).toEqual('file 1 contents\n;file 2 contents\n;');
            done();
        });
    });
});
//# sourceMappingURL=statics-helpers.test.js.map
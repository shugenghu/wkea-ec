/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { asSystemMetadata, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { difference, uniq } from 'lodash';
/**
 * @description takes relative path of strings and maps them to script tags that can be rendered with
 *              fully qualified baseUrl path
 *
 * @param baseUrl baseUrl to map in front of file paths, relative from root
 * @param pathOrPathsToFiles single or multiple paths to files
 */
const mapBaseUrlToString = (baseUrl, pathOrPathsToFiles, context) => {
    return (Array.isArray(pathOrPathsToFiles) ? pathOrPathsToFiles : [pathOrPathsToFiles]).map((script) => {
        // fallback with `statics` in case submissionid is not set
        return `${baseUrl}${process.env.SUBMISSIONID || 'statics'}/${script}`;
    });
};
const hasNamedChunk = (clientStats, chunkName) => clientStats.assetsByChunkName && clientStats.assetsByChunkName[chunkName];
const getNamedChunk = (clientStats, chunkName) => clientStats.assetsByChunkName[chunkName];
const hasNamedChunkGroup = (clientStats, chunkName) => clientStats.namedChunkGroups && clientStats.namedChunkGroups[chunkName];
const getNamedChunkGroup = (clientStats, chunkName) => clientStats.namedChunkGroups[chunkName];
const CONST_CLIENT = 'client';
const CONST_BOOTSTRAP = 'bootstrap';
/**
 * @description checks the named chunks and chunks section of the clientStats generated by webpack
 *              and returns the corresponding file paths after mapping the baseUrl to their paths
 *
 * @param baseUrl baseUrl to map in front of file paths, relative from root
 * @param chunkNames list of chunk names
 * @param clientStats webpack generated client stats
 */
// @ts-ignore -- re-exported type signature from react to make tsc happy
const getAssetsByChunkName = async (baseUrl, chunkNames, clientStats, telemetry, context) => {
    let result;
    try {
        let assets = [];
        // group vs actual chunk names.
        let actualChunkNames = [];
        chunkNames.map((chunkName) => {
            // strip off any file extensions eg: .js from the key
            if (typeof chunkName === 'string' && chunkName.endsWith('.js')) {
                // It is possible that the chunkName key here could be *.view.js
                // usually view.js is expected to be grouped along with its module. However, we need to
                // ensure we don't miss out on adding the chunk should webpack groups it into separate chunk
                // see build/public/stats-web.json for more info.
                chunkName = chunkName.split('.js')[0];
            }
            // check if we have a named chunk group with this name
            if (hasNamedChunkGroup(clientStats, chunkName)) {
                const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);
                assets = assets.concat(namedChunkGroup.assets);
                actualChunkNames = actualChunkNames.concat(namedChunkGroup.chunks);
            }
            else if (hasNamedChunk(clientStats, chunkName)) {
                // possible for this not to be a group but an individual named chunk, which could contain multiple files
                const namedChunk = getNamedChunk(clientStats, chunkName);
                assets = assets.concat(Array.isArray(namedChunk) ? namedChunk : [namedChunk]);
                actualChunkNames.push(chunkName);
            }
        });
        result = {
            chunks: [...actualChunkNames],
            jsFiles: uniq(assets.filter((assetFile) => assetFile.endsWith('.js'))),
            cssFiles: uniq(assets.filter((assetFile) => assetFile.endsWith('.css'))),
            cssScripts: [],
            jsScripts: []
        };
        result = {
            ...result,
            jsScripts: mapBaseUrlToString(baseUrl, result.jsFiles, context),
            cssScripts: mapBaseUrlToString(baseUrl, result.cssFiles, context)
        };
    }
    catch (e) {
        telemetry.log(LogLevel.Error, '', { exception: e });
    }
    return result;
};
/**
 * @description Looks up single chunk information and details
 *
 * @param baseUrl baseUrl to map in front of file paths, relative from root
 * @param chunkName chunk name to look up
 * @param clientStats generated webpack client stats
 * @param fileTypes extension of files to include from chunk or chunk group
 */
const getScriptsForChunkName = async (baseUrl, chunkName, clientStats, telemetry, fileTypes = '.js', context) => {
    let results;
    try {
        if (hasNamedChunkGroup(clientStats, chunkName)) {
            const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);
            results = mapBaseUrlToString(baseUrl, namedChunkGroup.assets.filter((asset) => asset.endsWith(fileTypes)), context);
        }
        else if (hasNamedChunk(clientStats, chunkName)) {
            const namedChunk = getNamedChunk(clientStats, chunkName);
            // we're not sure if it's an array, could be a single string, so coerce to array with concat, so we can filter it
            results = mapBaseUrlToString(baseUrl, [].concat(namedChunk).filter((asset) => asset.endsWith(fileTypes)), context);
        }
        else {
            throw new Error(`Did not find chunk named ${chunkName}`);
        }
    }
    catch (e) {
        telemetry.log(LogLevel.Error, 'Failed to get chunk named {chunkName}.', { values: [asSystemMetadata(chunkName)], exception: e });
    }
    return results;
};
/**
 * Gets the IDs of each named chunk
 *
 * @param chunkNames The chunk names for which to get IDs for
 * @param clientStats generated webpack client stats
 */
const getChunkIds = (chunkNames, clientStats) => {
    let ids = [];
    chunkNames.forEach((id) => {
        if (hasNamedChunkGroup(clientStats, id)) {
            const chunkIds = getNamedChunkGroup(clientStats, id).chunks;
            ids = ids.concat(chunkIds);
        }
    });
    return uniq(ids);
};
/**
 * @description Returns object containing all necessary information to render chunks including
 *              paths to files, chunk information (entry, bootstrap, other), and breaks assets up into
 *              different groups (css, js)
 *
 * @param baseUrl baseUrl to map in front of file paths, relative from root
 * @param chunkNames list of chunk names to look up
 * @param clientStats generated webpack client stats
 * @returns {Promise<IUsedChunks>} returns value
 */
// @ts-ignore -- re-exported type signature from react to make tsc happy
export const processClientStatsForChunking = (baseUrl, 
// tslint:disable-next-line
chunkNames, clientStats, telemetry, context) => {
    const isChunkingEnabled = hasNamedChunkGroup(clientStats, CONST_CLIENT) && hasNamedChunk(clientStats, CONST_BOOTSTRAP);
    if (!isChunkingEnabled) {
        return Promise.resolve({
            isChunkingEnabled: false
        });
    }
    return Promise.all([
        getScriptsForChunkName(baseUrl, CONST_CLIENT, clientStats, telemetry, undefined, context),
        getScriptsForChunkName(baseUrl, CONST_BOOTSTRAP, clientStats, telemetry, undefined, context)
    ]).then(([entryChunkScripts, bootstrapChunkScripts]) => {
        return getAssetsByChunkName(baseUrl, chunkNames, clientStats, telemetry, context).then(assets => {
            const chunkIds = uniq(getChunkIds(chunkNames, clientStats).concat(getChunkIds([CONST_CLIENT], clientStats)));
            return {
                assets: { ...assets },
                isChunkingEnabled: true,
                entryChunkScripts,
                // @TODO @kopik: bootstrap is included in entry chunk as a peer, should we actually look it up?
                // bootstrap chunk is used to make jsonp requests so we definitely need it but for initial page load we can defer probably
                bootstrapChunkScripts,
                jsScriptChunks: difference(assets.jsScripts, entryChunkScripts),
                cssScriptChunks: assets.cssScripts,
                chunkIds
            };
        });
    });
};
//# sourceMappingURL=chunking.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:typedef
// tslint:disable:no-string-literal
import { isEmptyOrNullObject, isObject, resolveRef, safeFileExists, safeGetAllFilesPath, safeGetAllFilesPathSync, safeReadJson, safeWriteJson } from '@msdyn365-commerce/utilities-internal';
import * as path from 'path';
import { msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { EVENT_DAPI_GETALLMODULES_START, EVENT_DAPI_GETALLMODULES_STOP, LogLevel, METRIC_DAPI_NO_RESULT } from '@msdyn365-commerce/telemetry-internal';
import { merge as _merge } from 'lodash';
import keystonePaths from '../../paths';
import { getModuleBinder, getModuleName, isSSK2App } from '../../utils/helpers';
import { getAvailableThemes } from './stylesDefinition';
const defaults = {
    page: undefined
};
const classNameDefnProperty = {
    friendlyName: 'Default CSS Class Name(s)',
    description: 'Provides a way to set configurable default css class(es) to apply to your module.',
    type: 'css'
};
const globallyFailedModules = [];
const getOriginalModuleDefs = (moduleName) => {
    const bindings = msdyn365Commerce.bindings;
    if (bindings.dapi && bindings.dapi.modules) {
        return bindings.dapi.modules[moduleName];
    }
    return {};
};
export function getFailedModulesList() {
    return globallyFailedModules;
}
/**
 * route [/dapi/modulelist] to return list of all register modules.
 */
// tslint:disable:no-any
export async function getModulesList() {
    const bindings = msdyn365Commerce.getAllModuleBinder();
    if (!bindings || bindings.length === 0) {
        return ['No module registration found'];
    }
    return bindings.map((moduleBinder) => {
        return moduleBinder.name;
    });
}
const getPageDefaults = () => {
    if (!defaults.page) {
        // TODO: move this to json file?
        const temp = {
            className: {
                friendlyName: 'ClassName',
                description: 'class properties',
                type: 'string',
                default: '',
                group: 'Page Layout'
            },
            pageTheme: {
                friendlyName: 'Page theme',
                description: 'Page theme',
                type: 'string',
                enum: {},
                group: 'Theme'
            }
        };
        temp.pageTheme.enum = {
            ...getAvailableThemes()
        };
        defaults.page = temp;
    }
    return defaults.page;
};
const renameKeyInObject = (value, oldkey, newkey, depth) => {
    if (isObject(value) && isEmptyOrNullObject(value)) {
        return value;
    }
    if (oldkey !== newkey && value.hasOwnProperty(oldkey)) {
        // @ts-ignore
        Object.defineProperty(value, newkey, Object.getOwnPropertyDescriptor(value, oldkey));
        delete value[oldkey];
    }
    // if depth === undefined, then rename till all depth
    if (depth !== undefined && depth === 0) {
        return;
    }
    Object.keys(value).forEach((key) => {
        const childObject = value[key];
        if (isObject(childObject)) {
            renameKeyInObject(childObject, oldkey, newkey, depth && depth - 1);
        }
    });
};
const parseModuleDefinition = async (defN, definitionPath, telemetry) => {
    const definitionWithResolvedRef = await resolveRef(defN, definitionPath, telemetry);
    definitionWithResolvedRef['module'] && delete definitionWithResolvedRef['module'];
    renameKeyInObject(definitionWithResolvedRef, '$type', 'type', 0);
    return definitionWithResolvedRef;
};
export const getModuleDefinition = async (moduleBinder, telemetry) => {
    // read from cache or fs
    const pageDefault = getPageDefaults();
    const definition = await getModuleDefinitionObj(moduleBinder, telemetry);
    if (definition && definition.categories && definition.categories.indexOf && definition.categories.indexOf('page') !== -1) {
        definition.config = {
            ...definition.config,
            ...pageDefault
        };
    }
    if (definition && moduleBinder.$type === "themeModule" /* TYPE */) {
        definition.pages = moduleBinder.pages || {};
        definition.segments = moduleBinder.segments || [];
    }
    return definition;
};
export const isDAPIOptimizationDisabled = (platformSettings) => {
    platformSettings = platformSettings || msdyn365Commerce.platformSettings;
    return platformSettings && !!platformSettings.disableDAPIOptimizations;
};
const getModuleDefinitionObj = async (moduleBinder, telemetry) => {
    if (isDAPIOptimizationDisabled()) {
        const definitionFile = await safeReadJson(moduleBinder.definitionPath, {
            error: (input) => {
                telemetry.log(LogLevel.Error, `Couldn't read definition file [${moduleBinder.definitionPath}]`, { exception: input });
            }
        });
        if (!definitionFile || isEmptyOrNullObject(definitionFile)) {
            const definitionError = {
                error: `problem found with definition file [${moduleBinder.definitionPath}] for module [${moduleBinder.name}]`
            };
            globallyFailedModules.push(definitionError);
            return definitionError;
        }
        return parseModuleDefinition(definitionFile, moduleBinder.definitionPath, telemetry);
    }
    return getOriginalModuleDefs(moduleBinder.name);
};
const getAllModuleDefinitions = async (modules, telemetry) => {
    telemetry.trackEvent(EVENT_DAPI_GETALLMODULES_START);
    let definitions = await Promise.all(modules.map(async (moduleBinder) => {
        if (isDAPIOptimizationDisabled()) {
            const definition = await getModuleDefinition(moduleBinder, telemetry);
            const dataJson = await getDataJsonAndParse(moduleBinder, telemetry);
            !isEmptyOrNullObject(dataJson) && (definition['data'] = dataJson);
            return definition;
        }
        return getModuleDefinition(moduleBinder, telemetry);
    }));
    // filter out any deprecated modules, if its an SSK 2.0 app
    if (isSSK2App() && definitions) {
        definitions = definitions.filter(item => item && !(item['attributes'] && item['attributes']['deprecate']));
    }
    telemetry.trackEvent(EVENT_DAPI_GETALLMODULES_STOP);
    return definitions;
};
/**
 * Adds any default properties the module config should have
 * to the dapi response
 *
 * @param result List of modules
 */
const addDefaultModuleConfigProperties = (defJson) => {
    const type = defJson.type || defJson.$type;
    if (defJson && (type === 'contentModule' || type === 'containerModule' || type === 'pageModule' || type === 'definitionExtension')) {
        // Every module should have a class name property added if missing from the definition json
        if (!defJson.config) {
            defJson.config = {};
        }
        if (!defJson.config.className) {
            defJson.config.className = classNameDefnProperty;
        }
        else {
            // if className is defined ensure type is set to 'css'
            defJson.config.className.type = 'css';
        }
    }
};
/**
 * Get theme definition extensions
 * @param themeModuleName name of the theme module
 * @param themeModuleBinder theme module binder object
 */
const getThemeDefinitionExtensions = async (themeModuleName, themeModuleBinder) => {
    let themeDefinitionExtensions = {};
    // In case of extended theme module, read parent theme definiton extensions first
    if (themeModuleBinder.parentDefinitionPath) {
        const parentThemeName = getModuleName(themeModuleBinder.parentDefinitionPath);
        const parentThemeBinder = getModuleBinder(parentThemeName);
        parentThemeBinder.definitionExtensions = parentThemeBinder.definitionExtensions || [];
        for (const moduleName of parentThemeBinder.definitionExtensions) {
            const pathToDefinition = path.join(parentThemeBinder.moduleDirectory, "definition-extensions" /* DEF_EXTENSIONS */, `${moduleName}${".definition.ext.json" /* DEF_EXT_FILE */}`);
            const defExtensionJson = (await safeReadJson(pathToDefinition)) || {};
            addDefaultModuleConfigProperties(defExtensionJson);
            themeDefinitionExtensions[moduleName] = await resolveRef(defExtensionJson, pathToDefinition);
        }
    }
    // Read theme module definition extensions
    themeModuleBinder.definitionExtensions = themeModuleBinder.definitionExtensions || [];
    for (const moduleName of themeModuleBinder.definitionExtensions) {
        const pathToDefinition = path.join(themeModuleBinder.moduleDirectory, "definition-extensions" /* DEF_EXTENSIONS */, `${moduleName}${".definition.ext.json" /* DEF_EXT_FILE */}`);
        const defExtensionJson = (await safeReadJson(pathToDefinition)) || {};
        addDefaultModuleConfigProperties(defExtensionJson);
        themeDefinitionExtensions[moduleName] = await resolveRef(defExtensionJson, pathToDefinition);
    }
    // Read partner level definition extensions
    const partnerDefinitionExtensions = (await safeGetAllFilesPath(path.join(keystonePaths.KEYSTONE_THEMES_DIR, themeModuleName, "definition-extensions" /* DEF_EXTENSIONS */, `*${".definition.ext.json" /* DEF_EXT_FILE */}`))) || [];
    for (const pathToDefExt of partnerDefinitionExtensions) {
        // Check if partner has definition extension override for this theme and merge
        if (await safeFileExists(pathToDefExt)) {
            const partnerDefExtensionJson = (await safeReadJson(pathToDefExt)) || {};
            const moduleName = path.basename(pathToDefExt, ".definition.ext.json" /* DEF_EXT_FILE */);
            themeDefinitionExtensions[moduleName] = _merge(themeDefinitionExtensions[moduleName], partnerDefExtensionJson);
        }
    }
    // Check and remove config properties present from config of theme definition extension, if duplicate property exists in dependncies of definition extension
    themeDefinitionExtensions = filterConfigProperties(themeDefinitionExtensions);
    return themeDefinitionExtensions;
};
/**
 * Filters config properties present from config of Definition extension, if same property exists in dependncies of definition extension
 * @param themeDefinitionExtensions Final response of theme definition extension
 */
const filterConfigProperties = themeDefinitionExtensions => {
    const properties = Object.keys(themeDefinitionExtensions);
    if (properties.length > 0) {
        for (let i = 0; i < properties.length; i++) {
            const DefinitionExtension = themeDefinitionExtensions[properties[i]];
            const config = DefinitionExtension['config'];
            if (config && DefinitionExtension['dependencies']) {
                const dependencies = DefinitionExtension.dependencies.moduleLayout.oneOf;
                for (let j = 0; j < dependencies.length; j++) {
                    const extendedproperties = dependencies[j].properties;
                    for (const propertyKey of Object.keys(extendedproperties)) {
                        if (config[propertyKey]) {
                            delete config[propertyKey];
                        }
                    }
                }
            }
        }
    }
    return themeDefinitionExtensions;
};
/**
 * Get default theme style presets definition extensions
 * @param themeModuleName name of the theme module
 * @param themeModuleBinder theme module binder object
 */
const getDefaultThemeStylePreset = async (themeModuleName, themeModuleBinder) => {
    const pathToThemeStylesDefinition = path.join(themeModuleBinder.moduleDirectory, "styles" /* STYLES */, `${themeModuleName}${".definition.scss.json" /* STYLE_PRESET_DEFINITION_FILE */}`);
    const themeStylePresets = await resolveRef((await safeReadJson(pathToThemeStylesDefinition)) || {}, pathToThemeStylesDefinition);
    const pathToPartnerThemeStylePresets = path.join(keystonePaths.KEYSTONE_THEMES_DIR, themeModuleName, "styles" /* STYLES */, `${themeModuleName}${".definition.scss.json" /* STYLE_PRESET_DEFINITION_FILE */}`);
    const partnerThemeStylesDefinition = await resolveRef((await safeReadJson(pathToPartnerThemeStylePresets)) || {}, pathToPartnerThemeStylePresets);
    return _merge(themeStylePresets, partnerThemeStylesDefinition);
};
/**
 * Get additional theme style presets extensions
 * @param themeModuleName name of the theme module
 * @param themeModuleBinder theme module binder object
 */
const getThemeStylePresetInstances = async (themeModuleName, themeModuleBinder) => {
    const mergedFiles = {};
    const keystoneThemeFilePath = path.join(keystonePaths.KEYSTONE_THEMES_DIR, themeModuleName, "styles" /* STYLES */);
    const getThemeFilePaths = (await safeGetAllFilesPath(path.join(themeModuleBinder.moduleDirectory, "styles" /* STYLES */, `/*${".scss.json" /* STYLE_PRESET_INSTANCE_FILE */}`))).filter(p => !p.endsWith(".definition.scss.json" /* STYLE_PRESET_DEFINITION_FILE */));
    const getKeystoneFilePaths = safeGetAllFilesPathSync(path.join(keystoneThemeFilePath, `/*${".scss.json" /* STYLE_PRESET_INSTANCE_FILE */}`)).filter(p => !p.endsWith(".definition.scss.json" /* STYLE_PRESET_DEFINITION_FILE */));
    Array.prototype.push.apply(getThemeFilePaths, getKeystoneFilePaths);
    if (getThemeFilePaths.length > 0) {
        for (let i = 0; i < getThemeFilePaths.length; i++) {
            const stylePresetName = path.basename(getThemeFilePaths[i], '.scss.json');
            const additionalThemeStylePresets = (await safeReadJson(getThemeFilePaths[i])) || {};
            mergedFiles[stylePresetName] = _merge(mergedFiles[stylePresetName], additionalThemeStylePresets);
        }
    }
    return mergedFiles;
};
const getDataJsonPath = (definitionPath, isNodeModule) => {
    const filePath = (isNodeModule ? definitionPath : definitionPath.replace('src/modules', 'build/definitions')).replace('.definition.json', '.data.json');
    return path.resolve(filePath);
};
export const getDataJsonAndParse = async (moduleBinder, telemetry) => {
    let dataJsonPathFromDefinitionPath = getDataJsonPath(moduleBinder.definitionPath, moduleBinder.isNodeModule);
    let dataJsonFileExists = await safeFileExists(dataJsonPathFromDefinitionPath);
    // Look for parent data definition file - in case of $ref module
    if (!dataJsonFileExists && moduleBinder.parentDefinitionPath) {
        dataJsonPathFromDefinitionPath = getDataJsonPath(moduleBinder.parentDefinitionPath, moduleBinder.isNodeModule);
        dataJsonFileExists = await safeFileExists(dataJsonPathFromDefinitionPath);
    }
    if (!dataJsonFileExists) {
        return {};
    }
    const dataJsonFile = await safeReadJson(dataJsonPathFromDefinitionPath, {
        error: (input) => {
            telemetry.log(LogLevel.Error, `Couldn't read data json file [${dataJsonPathFromDefinitionPath}]`, { exception: input });
        }
    });
    const dataJson = dataJsonFile && dataJsonFile['properties'];
    if (!dataJson) {
        return {};
    }
    Object.keys(dataJson).forEach(eachDataTypePropertyKey => {
        const eachDataTypeProperty = dataJson[eachDataTypePropertyKey];
        if (eachDataTypeProperty.filterFromDAPI) {
            delete dataJson[eachDataTypePropertyKey];
        }
    });
    renameKeyInObject(dataJson, '$ref', 'type', 3);
    return dataJson;
};
export const getModuleDefinitionApiFile = async (modules, telemetry) => {
    if (process.env.NODE_ENV === 'production') {
        const moduleDefinitionApiFileExists = await safeFileExists(keystonePaths.KEYSTONE_APP_DEFINITION_FILEPATH, {
            debug: input => {
                telemetry.log(LogLevel.Debug, input);
            },
            error: input => {
                telemetry.log(LogLevel.Error, input);
            }
        });
        if (moduleDefinitionApiFileExists) {
            return safeReadJson(keystonePaths.KEYSTONE_APP_DEFINITION_FILEPATH, {
                error: (input) => {
                    telemetry.log(LogLevel.Error, `Couldn't read definition api file [${keystonePaths.KEYSTONE_APP_DEFINITION_FILEPATH}]`, {
                        exception: input
                    });
                }
            });
        }
        const definitions = await getAllModuleDefinitions(modules, telemetry);
        if (definitions && definitions.length > 0) {
            await safeWriteJson(keystonePaths.KEYSTONE_APP_DEFINITION_FILEPATH, definitions);
        }
        return definitions;
    }
    return getAllModuleDefinitions(modules, telemetry);
};
/**
 * route to return definition JSON
 * [/dapi/modules] - return all modules defintion
 * [/dapi/modules?type=<moduleType>] - return specific module type defintion
 * @param moduleType
 * @param telemetry
 */
export async function getModuleDefinitions(moduleType, telemetry) {
    if (moduleType && !msdyn365Commerce.moduleBinder(moduleType)) {
        return JSON.stringify({ error: `type [${moduleType}] not defined` });
    }
    const result = isDAPIOptimizationDisabled()
        ? await getModuleDefinitionApiFile(msdyn365Commerce.getAllModuleBinder(), telemetry)
        : await getAllModuleDefinitions(msdyn365Commerce.getAllModuleBinder(), telemetry);
    if (!result) {
        const message = `DefinitionAPI: There is no information in the result.`;
        telemetry.trackMetric(METRIC_DAPI_NO_RESULT, 1);
        return message;
    }
    // Add default module config properties to DAPI response
    for (let i = 0; i < result.length; i++) {
        addDefaultModuleConfigProperties(result[i]);
    }
    if (moduleType && result.length > 0) {
        const defN = result
            .map((definition) => definition && definition.name && definition.name === moduleType && definition)
            .filter(Boolean);
        if (defN && defN.length > 0) {
            return defN;
        }
        else {
            return `{ error: 'type not found [${moduleType}]'}`;
        }
    }
    return result;
}
/**
 * route to return definition JSON
 * [/dapi/themes] - return all modules defintion
 * [/dapi/themes?type=<moduleType>] - return specific module type defintion
 * @param moduleType
 * @param telemetry
 */
const getAllThemeModules = async (telemetry) => {
    const themeModules = msdyn365Commerce.themeModules || [];
    if (themeModules.length) {
        return themeModules;
    }
    const allModulesBinder = await msdyn365Commerce.getAllModuleBinder();
    if (Array.isArray(allModulesBinder)) {
        const allThemeModulesBinder = allModulesBinder.filter(def => def.$type === "themeModule" /* TYPE */);
        await Promise.all(allThemeModulesBinder.map(async (themeModuleBinder) => {
            const themeModule = await getModuleDefinition(themeModuleBinder, telemetry);
            themeModule.pages = await getThemePages(themeModuleBinder);
            themeModule.segments = await getThemeSegments(themeModuleBinder);
            themeModule.definitionExtensions = await getThemeDefinitionExtensions(themeModule.name, themeModuleBinder);
            const themeStylePresets = await getDefaultThemeStylePreset(themeModule.name, themeModuleBinder);
            themeModule.styles = {
                definition: themeStylePresets,
                presets: Object.entries(themeStylePresets).length !== 0
                    ? await getThemeStylePresetInstances(themeModule.name, themeModuleBinder)
                    : {}
            };
            themeModules.push(themeModule);
        }));
    }
    msdyn365Commerce.setThemeModules(themeModules);
    return themeModules;
};
/**
 * Gets the pages in the given theme module
 * @param themeModuleBinder binder for the theme module object
 */
const getThemePages = async (themeModuleBinder) => {
    const pageNames = Object.keys(themeModuleBinder.pages || {});
    const themePages = {};
    for (const pageName of pageNames) {
        const layouts = themeModuleBinder.pages[pageName] || [];
        for (const layout of layouts) {
            const pathToPageLayout = path.join(themeModuleBinder.moduleDirectory, "layouts" /* LAYOUTS */, "pages" /* PAGES */, pageName, `${layout}${".page.json" /* PAGE_FILE */}`);
            const pageLayoutJson = (await safeReadJson(pathToPageLayout)) || {};
            themePages[pageName] = themePages[pageName] || {};
            themePages[pageName][layout] = await resolveRef(pageLayoutJson, pathToPageLayout);
        }
    }
    return themePages;
};
/**
 * Gets the segments in the given theme module
 * @param themeModuleBinder binder for the theme module object
 */
const getThemeSegments = async (themeModuleBinder) => {
    const segments = {};
    themeModuleBinder.segments = themeModuleBinder.segments || [];
    for (const segment of themeModuleBinder.segments) {
        const pathToSegment = path.join(themeModuleBinder.moduleDirectory, "layouts" /* LAYOUTS */, "segments" /* SEGMENTS */, `${segment}${".segment.json" /* SEGMENT_FILE */}`);
        const segmentJson = (await safeReadJson(pathToSegment)) || {};
        segments[segment] = await resolveRef(segmentJson, pathToSegment);
    }
    return segments;
};
/**
 * Method to return the full theme module object with layouts and segments
 * @param moduleName theme module name to be filtered
 * @param telemetry
 */
export const getThemeModules = async (moduleName, telemetry) => {
    if (moduleName && !msdyn365Commerce.moduleBinder(moduleName)) {
        return JSON.stringify({ error: `theme module [${moduleName}] not found` });
    }
    const bindings = msdyn365Commerce.bindings;
    const themeModules = isDAPIOptimizationDisabled() ? await getAllThemeModules(telemetry) : bindings.dapi.themes || [];
    if (moduleName && themeModules.length > 0) {
        const defN = themeModules
            .map((definition) => definition && definition.name && definition.name === moduleName && definition)
            .filter(Boolean);
        if (defN && defN.length > 0) {
            return defN;
        }
        else {
            return `{ error: 'type not found [${moduleName}]'}`;
        }
    }
    return Promise.resolve(themeModules);
};
/**
 * Method to return list of theme modules names
 * @param telemetry
 */
export const getThemeModulesList = async (telemetry) => {
    const themeModulesList = await getThemeModules(null, telemetry);
    return Array.isArray(themeModulesList) ? themeModulesList.map(themeModule => themeModule.name) : [];
};
//# sourceMappingURL=moduleDefinition.js.map
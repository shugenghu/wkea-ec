/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { isEmpty as _isEmpty } from 'lodash';
import url from 'url';
import { RequestVectorizerInstance } from './request-vectorizer';
import { TTLCache } from './ttl-cache';
/**
 * Regular expression to match content inside round braces
 */
const regexGetRoundBraces = /\(.+?\)/gm;
/**
 * Default client error
 */
const DEFAULT_ERROR_STATUS_CODE = 408;
/**
 * Formats commerce URL parts used in retail server calls with odata formatting
 *
 * @param inputString The input string to replace
 * @param replaceString The replacement value, default of `(~)`.
 */
export const replaceIdentifiers = (inputString, replaceString) => {
    return (inputString || '').replace(regexGetRoundBraces, replaceString || `(~)`);
};
/**
 * Helper mapping lowercase keys to real keys in an object. Note this returns the keys only, mapping
 * lower case key to the actual cased key name in the dictionary
 *
 * e.g.
 *
 * HelloWorld will be returned as 'helloworld' allowing you to look up 'helloworld' to get HelloWorld to index into the real dictionary
 * @param objectDictionary the object dictionary
 */
export const toLowerCaseDict = (objectDictionary) => {
    return Object.keys(objectDictionary || {}).reduce((prevValue, current) => ({ ...prevValue, [current.toLocaleLowerCase()]: current }), {});
};
const ttlRequestCache = new TTLCache();
/**
 * Error retail se interceptor for axios
 *
 * @param config The request cofiguration
 * @param status The response status code
 * @param requestCache The optional request cache to use (mostly for testing)
 */
export const RSErrorResponseHandler = (config, status, requestCache) => {
    if (!requestCache) {
        requestCache = ttlRequestCache;
    }
    const headers = config && config.headers;
    let requestId;
    if (headers) {
        const lowercaseHeaders = toLowerCaseDict(headers);
        requestId = lowercaseHeaders.requestid && headers[lowercaseHeaders.requestid];
    }
    const statusCode = status ? status : DEFAULT_ERROR_STATUS_CODE;
    const properties = requestCache.get(requestId);
    if (properties) {
        const elapsedTime = StaticTelemetry.stopTimer(requestId);
        const parsedUrl = url.parse((config && (config.url || config.baseURL)) || '');
        StaticTelemetry.trackDependency({
            duration: elapsedTime,
            method: (properties.m || 'unknown').toUpperCase(),
            name: properties.e,
            resultCode: statusCode,
            success: status < 400,
            url: parsedUrl,
            target: parsedUrl.hostname,
            properties: {
                requestId,
                empty: false
            },
            dependencyName: 'RetailServer'
        });
    }
};
/**
 * Response interceptor for axios
 *
 * @param response The resposne
 * @param requestCache The optional request cache to use (mostly for testing)
 */
export const RSResponseInterceptor = (response, requestCache) => {
    if (!requestCache) {
        requestCache = ttlRequestCache;
    }
    // try get properties from request based on requestid header
    let requestId;
    if (process.env.CURRENT_ENVIRONMENT !== 'node') {
        // on web we need to check config
        const headers = response && response.config && response.config.headers;
        if (headers) {
            const lowercaseHeaders = toLowerCaseDict(headers);
            requestId = lowercaseHeaders.requestid && headers[lowercaseHeaders.requestid];
        }
    }
    else {
        requestId = response && response.headers && response.headers.requestid;
    }
    const properties = requestCache.get(requestId);
    if (properties) {
        const elapsedTime = StaticTelemetry.stopTimer(requestId);
        const { config, status, request } = response;
        const parsedUrl = url.parse((config && (config.url || config.baseURL)) || '');
        StaticTelemetry.trackDependency({
            duration: elapsedTime,
            method: (properties.m || (request && request.method) || 'unknown').toUpperCase(),
            name: properties.e,
            resultCode: status,
            success: status < 400,
            url: parsedUrl,
            target: parsedUrl.hostname,
            properties: {
                requestId,
                empty: _isEmpty(response.data)
            },
            dependencyName: 'RetailServer'
        });
    }
    return response;
};
/**
 * Captures outgoing calls to retail server
 */
export const RSRequestInterceptor = (request) => {
    if (!request || !request.headers) {
        return request;
    }
    const requestHeaders = request.headers;
    const caseInsensitiveHeaderMap = toLowerCaseDict(requestHeaders);
    // check if it's an outgoing request to retail server
    if (caseInsensitiveHeaderMap.oun && request.url) {
        // get the API endpoint
        const parsedUrl = url.parse(request.url, false);
        const apiEndPoint = replaceIdentifiers(parsedUrl.pathname);
        // associate with the request-id vector
        const requestIdVector = requestHeaders[caseInsensitiveHeaderMap['request-id']];
        // associate with the requestid (non-vectored)
        const caseInsensitiveRequestIdHeaderName = caseInsensitiveHeaderMap.requestid || 'requestid';
        const currentRequestId = requestHeaders[caseInsensitiveRequestIdHeaderName];
        const requestId = RequestVectorizerInstance.next(currentRequestId);
        StaticTelemetry.startTimer(requestId);
        const properties = {
            // method
            m: request.method,
            // endpoint
            e: apiEndPoint,
            // request vector
            rv: requestIdVector,
            // request id
            r: requestId
        };
        // add to cache
        ttlRequestCache.set(requestId, properties, () => {
            StaticTelemetry.stopTimer(requestId);
        });
        request.headers[caseInsensitiveRequestIdHeaderName] = requestId;
    }
    return request;
};
export const RSRequestInterceptorErrorHandler = (error) => {
    if (error.request) {
        RSRequestInterceptor(error.request);
    }
    throw error;
};
export const RSResponseInterceptorErrorHandler = (error) => {
    if (error.response) {
        RSResponseInterceptor(error.response);
    }
    else if (error.config) {
        RSErrorResponseHandler(error.config, DEFAULT_ERROR_STATUS_CODE);
    }
    throw error;
};
//# sourceMappingURL=rs-logging-interceptor.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
/**
 * Cache with TTL and polling to remove items from it, default implementaiton is to only poll on server
 */
export class TTLCache {
    constructor(options) {
        this.removalThresholdInMs = (options && options.removalThresholdInMs) || 300000;
        this.intervalForRemovalInMs = (options && options.intervalForRemovalInMs) || 120000;
        this._cache = new Map();
        if (process.env.CURRENT_ENVIRONMENT === 'node') {
            // interval trigger to clear the map -- only on server
            setInterval(() => this._cleanCache(), this.intervalForRemovalInMs);
        }
    }
    /**
     * Gets a value from cache
     *
     * @param {string} key the key
     * @returns {(TValue | undefined)} the value, if it exists
     */
    get(key) {
        const value = this._cache.get(key);
        if (value) {
            return value[0];
        }
    }
    /**
     * Set a value
     *
     * @param {string} key the key
     * @param {TValue} value the value
     */
    set(key, value, onRemoveCallback) {
        const now = Date.now();
        this._cache.set(key, [value, now, onRemoveCallback]);
    }
    clear() {
        this._cache.clear();
    }
    // cleans up the map implementation
    _cleanCache() {
        const now = Date.now();
        const keys = this._cache.keys();
        for (const key of keys) {
            const value = this._cache.get(key);
            if (value && value.length > 1 && now - value[1] > this.removalThresholdInMs) {
                this._cache.delete(key);
                if (typeof value[2] === 'function') {
                    value[2](key);
                }
            }
        }
    }
}
//# sourceMappingURL=ttl-cache.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { TTLCache } from '../ttl-cache';
describe('TTL cache', () => {
    it('can fetch get things from cache', () => {
        const instance = new TTLCache();
        const keys = ['abc', 'def', 'egh'];
        const values = [1, 2, 3];
        // @ts-ignore -- private spy access
        const _cleanCacheSpy = jest.spyOn(instance, '_cleanCache');
        expect(instance['_cache'].size).toBe(0);
        instance.set(keys[0], values[0]);
        instance.set(keys[1], values[1]);
        instance.set(keys[2], values[2]);
        expect(instance['_cache'].size).toBe(3);
        expect(_cleanCacheSpy).not.toHaveBeenCalled();
        // read from cache
        const results = [instance.get(keys[0]), instance.get(keys[1]), instance.get(keys[2])];
        expect(results).toEqual(values);
        // clean
        instance.clear();
        expect(instance['_cache'].size).toBe(0);
        expect(instance.get(keys[0])).toBeUndefined();
    });
    describe('short lived cached', () => {
        let instance;
        let originalEnv;
        const newPollInternal = 200;
        const newThreshold = 2000;
        beforeAll(() => {
            originalEnv = process.env;
            process.env.CURRENT_ENVIRONMENT = 'node';
            instance = new TTLCache({
                intervalForRemovalInMs: newPollInternal,
                removalThresholdInMs: newThreshold
            });
        });
        afterAll(() => {
            process.env = originalEnv;
        });
        it('can remove after timeout', done => {
            // arrange
            const key = 'abcd';
            const callback = jest.fn().mockImplementationOnce((removedKey) => {
                expect(removedKey).toBe(key);
            });
            expect(instance['_cache'].size).toBe(0);
            // @ts-ignore -- private spy access
            const _cleanCacheSpy = jest.spyOn(instance, '_cleanCache');
            // act
            instance.set(key, 12345, callback);
            expect(instance['_cache'].size).toBe(1);
            expect(callback).toHaveBeenCalledTimes(0);
            // assert
            setTimeout(() => {
                expect(_cleanCacheSpy).toBeCalled();
                expect(instance['_cache'].size).toBe(0);
                expect(instance['_cache'].get(key)).toBeUndefined();
                expect(callback).toHaveBeenCalledTimes(1);
                done();
            }, newThreshold * 2);
        });
    });
});
//# sourceMappingURL=ttl-cache.test.js.map
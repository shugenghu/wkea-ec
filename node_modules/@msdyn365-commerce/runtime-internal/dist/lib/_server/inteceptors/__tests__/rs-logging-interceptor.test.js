/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:align
import { StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { replaceIdentifiers, RSRequestInterceptor, RSRequestInterceptorErrorHandler, RSResponseInterceptor } from '../rs-logging-interceptor';
import { TTLCache } from '../ttl-cache';
// tslint:disable:no-unnecessary-callback-wrapper
describe('helper functions', () => {
    it('can replace identifiers correctly', () => {
        // arrange
        const baseUrl = 'https://www.foo.com';
        const urlPaths = [
            '/Commerce/BasicEndpoint',
            '/Commerce/BasicEndpoint(withArgument)',
            '/Commerce/BasicEndpoint(%20withEscapedArgument%20)',
            '/Commerce/Controller/Method',
            '/Commerce/Controller/Method(withArgument)',
            '/Commerce/Controller/Method(%20withEscapedArgument%20)',
            '/Commerce/Controller(%20withArguments%20)/Method(%20withEscapedArgument%20)'
        ];
        // act
        const result = urlPaths.map(u => `${baseUrl}${u}`).map(u => replaceIdentifiers(u));
        // assert
        expect(result).toMatchSnapshot();
    });
});
describe('retail server logging interceptor', () => {
    const inputs = ['Commerce/Cart(asdflasfadsfasdf)/Foo', 'Commerce(asdfas1231_)/Foo(asfas12312)/Bar(12321312)', undefined];
    const urlAsString = 'https://foo.bar/commerce/request/endpoint?baz=123&etc=abc#anchor5';
    it('properly replaces url parts', () => {
        // arrange
        // act
        const outputs = inputs.map(input => replaceIdentifiers(input));
        // assert
        expect(outputs).toMatchSnapshot();
    });
    it('properly replaces url parts with custom replacer', () => {
        // arrange
        // act
        const outputs = inputs.map(input => replaceIdentifiers(input, '(REPLACED)'));
        // assert
        expect(outputs).toMatchSnapshot();
    });
    describe('interceptor', () => {
        describe('response', () => {
            let response = {};
            describe('as web', () => {
                let originalEnv;
                beforeAll(() => {
                    originalEnv = process.env;
                    process.env.CURRENT_ENVIRONMENT = 'web';
                    response = {
                        request: {
                            method: 'GET'
                        },
                        headers: {
                            requestid: 12345
                        },
                        status: 200,
                        config: {
                            headers: {
                                requestid: 12345
                            },
                            url: urlAsString
                        }
                    };
                });
                afterAll(() => {
                    process.env = originalEnv;
                });
                it('can parse if the request is a web request', () => {
                    expect(RSResponseInterceptor(response)).toMatchSnapshot();
                });
            });
            [urlAsString, '', undefined].forEach(theUrl => {
                ['get', 'POST', 'PatCH', undefined].forEach(theMethod => {
                    const testArguments = `${theUrl}:${theMethod}`;
                    const testName = `can process a response: ${testArguments}`;
                    it(testName, () => {
                        // arrange
                        response = {
                            request: {
                                method: theMethod
                            },
                            status: 200,
                            config: {
                                headers: {
                                    requestid: 12345
                                },
                                url: theUrl
                            }
                        };
                        const staticTelemetryTrackDependencySpy = jest
                            .spyOn(StaticTelemetry, 'trackDependency')
                            .mockImplementationOnce(trackDependencyOptions => {
                            expect(trackDependencyOptions).toMatchSnapshot(`${testName}-trackDependency`);
                        });
                        jest.spyOn(StaticTelemetry, 'stopTimer').mockImplementation(timerId => {
                            // fake timer response
                            return 456;
                        });
                        const requestCache = new TTLCache({
                            intervalForRemovalInMs: 250,
                            removalThresholdInMs: 1500
                        });
                        requestCache.set(response.config.headers.requestid, {
                            e: theUrl || '',
                            m: theMethod || '',
                            r: response.config.headers.requestid,
                            rv: undefined
                        });
                        // act
                        const result = RSResponseInterceptor(response, requestCache);
                        // assert
                        return new Promise(resolve => {
                            setTimeout(() => {
                                expect(result).toMatchSnapshot(`${testName}-results`);
                                expect(staticTelemetryTrackDependencySpy).toHaveBeenCalledTimes(1);
                                staticTelemetryTrackDependencySpy.mockClear();
                                resolve();
                            }, 2000);
                        });
                    });
                });
            });
        });
        describe('request', () => {
            let request;
            beforeEach(() => {
                request = {
                    method: 'POST',
                    url: urlAsString,
                    headers: {
                        RequestId: 'abcdefghijklmnopq',
                        'Request-Id': 'vectora.123',
                        OUN: 'oun'
                    }
                };
            });
            it('handles invalid requests', () => {
                delete request.headers;
                expect(RSRequestInterceptor).not.toThrow();
                request = undefined;
                expect(RSRequestInterceptor).not.toThrow();
            });
            it('can ignores non-retail server requests', () => {
                // arrange
                delete request.headers.OUN;
                // act
                const result = RSRequestInterceptor(request);
                // assert
                expect(result).toMatchSnapshot();
            });
            it('processes valid requests requests', () => {
                // act
                const result = RSRequestInterceptor(request);
                // assert
                expect(result).toMatchSnapshot();
            });
            it('can handle error callback for request interceptor', () => {
                const errorMessage = 'foo';
                expect(() => RSRequestInterceptorErrorHandler(new Error(errorMessage))).toThrow(errorMessage);
            });
        });
    });
});
//# sourceMappingURL=rs-logging-interceptor.test.js.map
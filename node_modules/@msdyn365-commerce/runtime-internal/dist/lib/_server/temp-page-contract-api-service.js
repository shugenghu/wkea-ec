/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable-next-line:match-default-export-name 'axios' doesn't match 'Axios'
import msdyn365Commerce from '@msdyn365-commerce/core-internal';
import { asSystemMetadata, EXCEPTION_NO1RFRESPONSE, LogLevel, MESSAGE_GETTING_PAGE_RESPONSE, MESSAGE_NO_SERVER_ENDPOINT_SET, MESSAGE_SERVER_ENDPOINT } from '@msdyn365-commerce/telemetry-internal';
import { safeReadJson } from '@msdyn365-commerce/utilities-internal';
import axios from 'axios';
import jwt_decode from 'jwt-decode';
import path from 'path';
import Url from 'url';
import { getMockModule } from '../mock/mock-helper';
import keystonePaths from '../paths';
import { getFlattenedListOfModules } from '../utils/get-modules-flat-list';
import { getUserInformationROPC } from '../utils/ropc-auth-utils';
import { getThemeModules } from './Definition/moduleDefinition';
import { HttpException, HttpRedirectException } from './error';
/**
 * PageContract API
 *
 */
export var PageContractApiService;
(function (PageContractApiService) {
    const AUTHORIZATION_PATH = '/ForceAzureADSignIn';
    /**
     * Throws an HTTPRedirectException to prompt the user to log in
     * @param requestContext Current request context
     * @param platformUrl Platform url as string
     */
    const getAuthorization = async (requestContext, platformUrl) => {
        const authUrl = new URL(platformUrl);
        authUrl.pathname = AUTHORIZATION_PATH;
        authUrl.searchParams.append('ru', Url.format(requestContext.url.requestUrl));
        throw new HttpRedirectException(Url.format(authUrl));
    };
    /**
     * Populates page module section
     * @param page
     */
    PageContractApiService._inlineMockModules = async (page) => {
        // make sure we null out the modules so legacy workflow does not kick in
        const newPageResponse = { ...page, ...{ modules: null } };
        const slots = getFlattenedListOfModules(newPageResponse);
        let index = 0;
        for (const m of slots) {
            // @ts-ignore - mockId is not a first-class property
            const mockName = m.mockId || m.typeName;
            // @ts-ignore - array access is prohibited
            const existing = page.modules && page.modules[m.id];
            if (existing) {
                Object.assign(slots[index], existing);
            }
            else if (mockName) {
                const mock = await getMockModule(m.typeName, mockName);
                if (mock) {
                    Object.assign(m, { ...mock, ...m });
                }
            }
            index++;
        }
        newPageResponse.slots = slots;
        return newPageResponse;
    };
    /**
     * Retireves page response data from mock JSON files
     */
    PageContractApiService.getMockPayload = async (mockName) => {
        const mockFilePath = path.resolve(keystonePaths.KEYSTONE_PAGE_MOCKS_DIR, `${mockName}.json`);
        const page = await safeReadJson(mockFilePath);
        if (!page) {
            throw new HttpException(404, `Mock page: ${mockName} is either invalid json or not found`);
        }
        return PageContractApiService._inlineMockModules(page);
    };
    /**
     * Retrieves page response data from theme layout
     */
    PageContractApiService.getThemeLayout = async (themeName, pageType, layout, telemetry) => {
        const themeModules = await getThemeModules(null, telemetry);
        const theme = (themeModules || []).filter(themeModule => themeModule.name === themeName)[0];
        if (!theme) {
            throw new HttpException(404, `Theme: ${themeName} is either invalid json or not found`);
        }
        if (!theme.pages[pageType]) {
            throw new HttpException(404, `Page: ${pageType} is either invalid json or not found for theme ${themeName}`);
        }
        if (!theme.pages[pageType][layout]) {
            throw new HttpException(404, `Layout: ${layout} is either invalid json or not found for theme ${themeName}`);
        }
        return theme.pages[pageType][layout];
    };
    /**
     * Retrieves theme segment
     */
    PageContractApiService.getThemeSegment = async (themeName, segmentName, telemetry) => {
        const themeModules = await getThemeModules(null, telemetry);
        const theme = (themeModules || []).filter(themeModule => themeModule.name === themeName)[0];
        if (!theme) {
            throw new HttpException(404, `Theme: ${themeName} is either invalid json or not found`);
        }
        if (!theme.segments[segmentName]) {
            throw new HttpException(404, `Segment: ${segmentName} is either invalid json or not found for theme ${themeName}`);
        }
        return theme.segments[segmentName];
    };
    /**
     * Call server to retrieve page response
     */
    PageContractApiService.getServerPageResponse = async (url, telemetry, requestContext, idToken, userAgent, mockUser = false, retry = true) => {
        const platformUrl = new URL(url);
        const platformReqConfig = {};
        if (process.env.HEADER_REQ) {
            platformReqConfig.method = 'post';
            platformReqConfig.headers = {
                'Content-Type': 'application/json',
                nodeServiceProxy: true,
                'accept-language': 'en-US,en'
            };
        }
        else {
            if (!idToken) {
                await getAuthorization(requestContext, url);
            }
            platformUrl.searchParams.append('item', 'nodeserviceproxy:true');
            platformReqConfig.method = 'get';
            platformReqConfig.maxRedirects = 0;
            platformReqConfig.headers = {
                Authorization: `Bearer ${idToken}`,
                'accept-language': 'en-US,en'
            };
        }
        if (userAgent) {
            platformReqConfig.headers['User-Agent'] = userAgent;
        }
        // If mock user has been set, set X-Disable-C2ForceAuth to bypass forced C2 Auth
        if (mockUser) {
            platformReqConfig.headers['X-Disable-C2ForceAuth'] = true;
        }
        return axios(Url.format(platformUrl), platformReqConfig)
            .then(response => {
            return response.data;
        })
            .catch((error) => {
            if (error.response && error.response.status === 302) {
                return getAuthorization(requestContext, url);
            }
            if (retry && error.response && error.response.status === 403) {
                return PageContractApiService.getServerPageResponse(url, telemetry, requestContext, '', userAgent, mockUser, false);
            }
            telemetry.log(LogLevel.Error, EXCEPTION_NO1RFRESPONSE, { exception: error });
            if (error.response && error.response.status) {
                throw new HttpException(error.response.status, EXCEPTION_NO1RFRESPONSE);
            }
            else {
                throw new Error(EXCEPTION_NO1RFRESPONSE);
            }
        });
    };
    PageContractApiService.parsePayload = (content) => {
        const pageResponse = (typeof content === 'string' ? JSON.parse(content) : content);
        pageResponse.slots = getFlattenedListOfModules(pageResponse);
        return pageResponse;
    };
    /**
     * Sets the pageResponse object by either using mock if mock query param is supplied
     * or by requesting the page response object from OneRF
     *
     * @param req Request
     * @param res Response
     * @param serverHost OneRF server host
     */
    PageContractApiService.handleGetPageResponse = async (req, res, serverHost) => {
        let userToken;
        let modifiedSignInUrl;
        let modifiedSignOutUrl;
        // If in local dev mode and credentials are defined get user mock token and modify sign in and sign out url
        // to user mockUser query param
        if (process.env.NODE_ENV === 'development' && msdyn365Commerce.localCredentials) {
            userToken = await getMockUserToken(msdyn365Commerce.localCredentials, req.query);
            modifiedSignInUrl = Url.format({
                protocol: 'https',
                hostname: 'localhost',
                port: process.env.PORT,
                pathname: req.path,
                query: { ...req.query, ...{ mockUser: 'true' } }
            });
            modifiedSignOutUrl = Url.format({
                protocol: 'https',
                hostname: 'localhost',
                port: process.env.PORT,
                pathname: req.path,
                query: { ...req.query, ...{ mockUser: 'false' } }
            });
        }
        // @ts-ignore
        const idToken = req.session && req.session.id_token;
        const userAgent = req.header('User-Agent');
        const serverUrl = {
            serverHost,
            pathname: req.path,
            query: req.query
        };
        const content = await PageContractApiService.getPageResponse(res.locals.telemetry, res.locals.requestContext, idToken, userAgent, serverUrl, userToken !== undefined);
        if (process.env.NODE_ENV === 'development') {
            // If no page response was set as result of non-C2 signed in user, send message back indicating mockUser query param should be used
            // @ts-ignore - statusCode is not a typed property but is part of the returned pageResponse from OneRF
            if (!content.pageRoot && content?.statusCode === 302) {
                res.status(200).send(`Unable to retrieve server page resonse for path ${req.path} because it requires a signed in user to access. Use 'mockUser' query param to mock a signed in C2 user.`);
            }
            // If a user token has been generated through credentials.json and ROPC, inject it
            if (content.renderingContext && userToken) {
                injectUserToken(content.renderingContext, userToken, msdyn365Commerce.localCredentials?.customerAccountNumber);
            }
            // Modify the sign in and sign out url if local sign in is enabled to make use of the mockUser query param
            if (msdyn365Commerce.localCredentials && content.renderingContext.userContext) {
                content.renderingContext.userContext.signInUrl = modifiedSignInUrl;
                content.renderingContext.userContext.signOutUrl = modifiedSignOutUrl;
            }
        }
        res.locals.pageResponse = content;
    };
    /**
     * Controls the mock user token that is added to the rendering context to enable signed in behavior during local development
     * Uses ROPC auth flow to get an access token to impersonate signed in status. Retruns the user impersonation access token
     *
     * @param credentials Credentials config object containing config information required to make the ROPC request
     * @param query query param object
     */
    const getMockUserToken = async (credentials, query) => {
        // Flush token out if mockUser query param is set to false, otherwise use that to fetch the token for user
        if (query?.mockUser) {
            if (query.mockUser === 'false') {
                delete credentials.accessToken;
                return;
            }
            await getUserInformationROPC(credentials, query.mockUser);
            return credentials.accessToken;
        }
        // If access token has already been fetched and set, use it for any following requests until it is flushed out
        if (credentials.expiryDate && credentials.currentUser) {
            // If the token has expired, fetch the token again for current user
            if (Math.floor(Date.now() / 1000) >= credentials.expiryDate) {
                await getUserInformationROPC(credentials, credentials.currentUser);
            }
            return credentials.accessToken;
        }
    };
    // Injects the user token into rendering context user information if available
    const injectUserToken = (renderingContext, token, customerAccountNumber) => {
        const decodedToken = jwt_decode(token);
        renderingContext.userContext = {
            ...renderingContext.userContext,
            ...{
                token: token,
                isAuthenticated: true,
                emailAddress: decodedToken.emails[0] || '',
                firstName: decodedToken.given_name || '',
                lastName: decodedToken.family_name || '',
                name: `${decodedToken.given_name} ${decodedToken.family_name}`,
                signinName: `${decodedToken.given_name} ${decodedToken.family_name}`,
                customerAccountNumber: customerAccountNumber || ''
            }
        };
    };
    /**
     * Retrieves a page response from server or Mock data
     */
    PageContractApiService.getPageResponse = async (telemetry, requestContext, idToken, userAgent, serverUrlConfigs, mockUser) => {
        if (requestContext && requestContext.query && requestContext.query.mock) {
            return PageContractApiService.getMockPayload(requestContext.query.mock);
        }
        if (!serverUrlConfigs.serverHost) {
            telemetry.log(LogLevel.Error, MESSAGE_NO_SERVER_ENDPOINT_SET);
        }
        const serverUrl = Url.format({ protocol: 'https', hostname: serverUrlConfigs.serverHost });
        const serverPageUrl = Url.format({
            protocol: 'https',
            hostname: serverUrlConfigs.serverHost,
            pathname: serverUrlConfigs.pathname,
            query: serverUrlConfigs.query
        });
        telemetry.log(LogLevel.Debug, MESSAGE_SERVER_ENDPOINT, { values: [asSystemMetadata(serverUrl)] });
        telemetry.log(LogLevel.Debug, MESSAGE_GETTING_PAGE_RESPONSE, { values: [asSystemMetadata(serverPageUrl)] });
        const resp = await PageContractApiService.getServerPageResponse(serverPageUrl, telemetry, requestContext, idToken, userAgent, mockUser);
        return PageContractApiService.parsePayload(resp);
    };
})(PageContractApiService || (PageContractApiService = {}));
export default PageContractApiService;
//# sourceMappingURL=temp-page-contract-api-service.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:max-func-body-length
import { ActionContext } from '@msdyn365-commerce/action-internal';
import { getGeoLookup, readCachedExperimentsEntries, saveCachedExperimentsEntries } from '@msdyn365-commerce/cache-internal';
import { CoreContext, CultureInfoFormatter, EXPERIMENTATION_DATAFILE_CACHE_TYPE, msdyn365Commerce, RefreshType } from '@msdyn365-commerce/core-internal';
import { asSystemMetadata, EVENT_LOAD_DATA_START, EVENT_LOAD_DATA_STOP, EVENT_SERVER_RENDER_START, EVENT_SERVER_RENDER_STOP, EXCEPTION_PAGERENDERING, InternalTelemetry, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import { safeFileExists, trace } from '@msdyn365-commerce/utilities-internal';
import { Provider } from 'mobx-react';
import { join } from 'path';
import * as React from 'react';
import { ReportChunks } from 'react-universal-component';
import { basePageTemplate } from '../components/base-page';
import SafeRenderModule from '../components/safe-render-module';
import { RETAIL_SERVER_BASE_URL_HEADER_KEY } from '../consts';
import { loadData } from '../data/load-data';
import { processComplexDataTypesAsync } from '../hydrators/process-page-response';
import { populateClientCache } from '../mock/action-mock-helper';
import paths from '../paths';
import { PageContext } from '../store/page-context';
import { getCurrencyCodeFromContext, patchedRenderToString } from '../utils/helpers';
import { refreshActionsAsync } from './action-refresher';
import { processClientStatsForChunking } from './chunking';
import { generateAssetUrls } from './statics-pipeline/statics-helpers';
import { getTheme } from './theming';
// TODO: refactor based on how site css should be served
const getSiteCss = async (context, telemetry) => {
    // always check to include site-level css as site.css
    const siteCssFileName = `css/site${context.params.isDebug ? '' : '.min'}.css`;
    const filePath = join(paths.KEYSTONE_STATIC_DIR, siteCssFileName);
    const siteCss = (await safeFileExists(filePath)) && siteCssFileName;
    if (!siteCss) {
        telemetry.log(LogLevel.Debug, 'Unable to resolve SiteCSS {FilePath}, {SiteCssFileName}', {
            values: [asSystemMetadata(filePath), asSystemMetadata(siteCssFileName)]
        });
    }
    return siteCss;
};
const makeLoadDataCalls = ({ internalTelemetry: telemetry, moduleTelemetry: moduleTelemetry, content, context, requestCache, appCache, allRefreshActions }, complexPromise) => {
    try {
        const correlationId = InternalTelemetry.generateGuid();
        telemetry.startTimer(correlationId);
        telemetry.trackEvent(EVENT_LOAD_DATA_START, {
            id: correlationId,
            initiator: 'MakeLoadDataCall'
        });
        return loadData(content.slots, context, telemetry, moduleTelemetry, requestCache, appCache, complexPromise).then((refreshActions) => {
            telemetry.trackEvent(EVENT_LOAD_DATA_STOP, { id: correlationId, initiator: 'MakeLoadDataCall' }, { time: telemetry.stopTimer(correlationId) });
            refreshActions = refreshActions || new Set();
            refreshActions.forEach(config => allRefreshActions.push(config));
        });
    }
    catch (e) {
        telemetry.log(LogLevel.Error, '', { exception: e });
        return Promise.resolve();
    }
};
/**
 * Performs a safe render module on each module defined inside a non-body slot
 * Returns the JSX from the safe render.
 *
 * @param coreContext The core context provided to the page
 * @param addChunk addChunk function
 * @param pageContext The page context object
 * @param currentModule The module that is being passed into safe render module
 */
const getSafeRenderModuleResultForSlotItem = (coreContext, pageContext, currentModule) => {
    // Use this method to perform a render for non body slots only
    // Setting isNotBodyModule true allows modules to have empty render results (valid for non body slots only)
    return (React.createElement(CoreContext.Provider, { value: coreContext },
        React.createElement(SafeRenderModule, Object.assign({}, currentModule, { store: pageContext, isNotBodyModule: true }))));
};
/**
 * Performs the render result of all the modules in a given slot
 * and returns the result of the render as an html string
 *
 * @param coreContext The core context provided to the page
 * @param addChunk addChunk function
 * @param pageContext The page context object
 * @param slot The slot (htmlHead, bodyBegin, etc) for which you are expecting the render to string result
 */
const getSlotRenderResult = (coreContext, pageContext, slot) => {
    let content = '';
    const shouldDisableServerSideErrorChecking = coreContext.request &&
        coreContext.request.app &&
        coreContext.request.app.platform &&
        coreContext.request.app.platform.disableServerSideErrorChecking;
    if (pageContext.pageRoot.modules && pageContext.pageRoot.modules[slot]) {
        for (let i = 0; i < pageContext.pageRoot.modules[slot].length; ++i) {
            content += patchedRenderToString(getSafeRenderModuleResultForSlotItem(coreContext, pageContext, pageContext.pageRoot.modules[slot][i]), shouldDisableServerSideErrorChecking);
        }
    }
    return content;
};
// tslint:disable:no-any
const getClientInitialConfigWithCache = async (retailServerBaseUrl, telemetry) => {
    const experimentConnector = msdyn365Commerce.experimentationConnector && msdyn365Commerce.experimentationConnector;
    if (!experimentConnector || !experimentConnector.provider) {
        return '';
    }
    const refreshOption = {
        refreshType: RefreshType.DataFile,
        parameters: []
    };
    const cacheKey = {
        typeName: EXPERIMENTATION_DATAFILE_CACHE_TYPE,
        key: experimentConnector.name
    };
    let expClientConfig = await readCachedExperimentsEntries(cacheKey, refreshOption, experimentConnector.provider, experimentConnector.name, retailServerBaseUrl);
    if (!expClientConfig) {
        try {
            const expClientConfigRaw = await experimentConnector.provider.getConfigForClientSideInit();
            if (expClientConfigRaw) {
                expClientConfig = JSON.stringify(expClientConfigRaw);
                await saveCachedExperimentsEntries(cacheKey, expClientConfig);
            }
        }
        catch (err) {
            telemetry.log(LogLevel.Error, 'Could not fetch exp data file for client side initalization', { exception: err });
        }
    }
    return expClientConfig || {};
};
const getBodyClassName = (pageConfig, context) => {
    const bodyClass = [];
    bodyClass.push(context.device.Type);
    pageConfig.className && bodyClass.push(pageConfig.className);
    context.params.theme && bodyClass.push(context.params.theme);
    return bodyClass.join(' ').toLowerCase();
};
const getPrefetchLinks = (context) => {
    const apiSettings = context.apiSettings;
    const endpoints = [
        apiSettings.baseUrl,
        apiSettings.baseImageUrl,
        apiSettings.ratingsReviewsEndpoint,
        ...(context.app.platform?.dnsPrefetchUrls ? context.app.platform.dnsPrefetchUrls : [])
    ];
    const linkEndpoints = endpoints.map(endpoint => {
        try {
            const url = new URL(endpoint);
            return `<link rel="preconnect" href="${url.origin}" />
                <link rel="dns-prefetch" href="${url.origin}"/>`;
        }
        catch {
            return '';
        }
    });
    return linkEndpoints.filter(link => link !== '').join('\n');
};
const serverRenderVnext = async ({ content, context, options: { clientStats }, pageConfig, telemetry, moduleTelemetry, requestCache, routeRefreshActions }) => {
    telemetry.trackEvent(EVENT_SERVER_RENDER_START);
    const serverRenderCorrelationId = InternalTelemetry.generateGuid();
    telemetry.startTimer(serverRenderCorrelationId);
    const correlationIdRequestPrep = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdRequestPrep);
    const chunkNames = {};
    const isDebug = context.params && context.params.isDebug;
    const isEditor = context.params && context.params.isEditor;
    const theme = context.params.theme || pageConfig.pageTheme;
    const addChunk = (chunkName) => {
        if (!chunkNames[chunkName]) {
            chunkNames[chunkName] = chunkName;
        }
    };
    await populateClientCache(context, content, requestCache, telemetry);
    // tslint:disable-next-line:no-any
    const appCache = msdyn365Commerce.getAppCache(context);
    // Set the expected actionCount to 5000
    // this will wait for the actionCount to be 5000 before call goes out
    // this will give us control to parallelize these calls and avoid redundancy
    const actionContext = new ActionContext({
        id: 'Server Action Context',
        requestContext: context,
        requestCache: requestCache,
        telemetry: moduleTelemetry,
        appCache,
        expectedActionCount: 5000
    });
    const timerRequestPrep = telemetry.stopTimer(correlationIdRequestPrep);
    const correlationIdComplexTypes = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdComplexTypes);
    const LAZYLOAD_ALL_SWITCH = context.features.lazyload_all;
    let complexDataTypesPromises;
    try {
        complexDataTypesPromises = processComplexDataTypesAsync(LAZYLOAD_ALL_SWITCH, "server" /* server */, content.slots, actionContext);
    }
    catch (e) {
        telemetry.log(LogLevel.Error, 'Could not process data types', { exception: e });
    }
    const timerComplexTypes = telemetry.stopTimer(correlationIdComplexTypes);
    const correlationIdloadData = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdloadData);
    const allRefreshActions = [];
    const loadDataPromise = makeLoadDataCalls({ content, context, requestCache, internalTelemetry: telemetry, moduleTelemetry: moduleTelemetry, appCache, allRefreshActions }, complexDataTypesPromises);
    let geoLocationPromise;
    if (context.clientIPAddress) {
        geoLocationPromise = getGeoLookup(context.clientIPAddress);
    }
    const [, geoLocation] = await Promise.all([loadDataPromise, geoLocationPromise]);
    if (geoLocation) {
        context.geoLocation = geoLocation;
    }
    const timerLoadData = telemetry.stopTimer(correlationIdloadData);
    const correlationIdRenderPage = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdRenderPage);
    const pageContext = new PageContext(content, context, requestCache, msdyn365Commerce.resourceManager);
    const coreContext = {
        actionContext: actionContext,
        app: context.app,
        telemetry: moduleTelemetry,
        // @ts-ignore
        internalTelemetry: telemetry,
        request: context,
        cultureFormatter: new CultureInfoFormatter(context.locale, getCurrencyCodeFromContext(context))
    };
    const pageRenderResult = (React.createElement(CoreContext.Provider, { value: coreContext },
        React.createElement(ReportChunks, { report: addChunk },
            React.createElement(Provider, { store: pageContext }, pageContext.pageRoot.modules && pageContext.pageRoot.modules.body ? (React.createElement(SafeRenderModule, Object.assign({}, pageContext.pageRoot.modules.body[0], { addChunk: addChunk, store: pageContext }))) : (React.createElement(SafeRenderModule, Object.assign({}, pageContext.pageRoot, { addChunk: addChunk, store: pageContext })))))));
    const timerRenderPage = telemetry.stopTimer(correlationIdRenderPage);
    let bodyContent = '';
    const correlationIdRenderToString = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdRenderToString);
    try {
        const shouldDisableServerSideErrorChecking = coreContext.request &&
            coreContext.request.app &&
            coreContext.request.app.platform &&
            coreContext.request.app.platform.disableServerSideErrorChecking;
        bodyContent = patchedRenderToString(pageRenderResult, shouldDisableServerSideErrorChecking);
    }
    catch (e) {
        if (process.env.NODE_ENV === 'development') {
            trace.error(EXCEPTION_PAGERENDERING);
            trace.error(e);
        }
        else {
            telemetry.log(LogLevel.Error, EXCEPTION_PAGERENDERING, { exception: e });
        }
        bodyContent = e;
    }
    const timerRenderToString = telemetry.stopTimer(correlationIdRenderToString);
    const correlationIdBasePageCreation = InternalTelemetry.generateGuid();
    telemetry.startTimer(correlationIdBasePageCreation);
    const [processedChunkInfo, siteCss] = await Promise.all([
        processClientStatsForChunking(context.url.staticCdnUrl, Object.keys(chunkNames), clientStats, telemetry, context),
        getSiteCss(context, telemetry)
    ]);
    const css = [siteCss].filter(Boolean);
    const bodyClass = getBodyClassName(pageConfig, context);
    // generate links to construct pre-fetch links to all endpoints
    const prefetchLinks = getPrefetchLinks(context);
    const retailServerBaseUrl = coreContext.request && coreContext.request.headers && coreContext.request.headers[RETAIL_SERVER_BASE_URL_HEADER_KEY];
    // get experiment data file.
    const expDataFile = await getClientInitialConfigWithCache(retailServerBaseUrl, telemetry);
    // Need to pull the requestUrl from rendering context
    const basePage = basePageTemplate({
        baseUrl: context.url.staticCdnUrl,
        requestUrl: context.url.requestUrl,
        bodyContent,
        headContent: getSlotRenderResult(coreContext, pageContext, 'htmlHead'),
        bodyBeginContent: getSlotRenderResult(coreContext, pageContext, 'bodyBegin'),
        bodyEndContent: getSlotRenderResult(coreContext, pageContext, 'bodyEnd'),
        chunks: processedChunkInfo,
        css,
        // @ts-ignore - ignore that the compiler complains types don't match
        initialData: pageContext,
        isDebug: isDebug,
        isEditor: isEditor,
        context: context,
        jsHashedUrls: generateAssetUrls(context.url.staticCdnUrl, processedChunkInfo),
        themeCss: getTheme(isDebug, theme, context.textDirection, telemetry),
        appData: { bv: msdyn365Commerce.buildVersion },
        telemetry,
        bodyClassName: bodyClass,
        experimentClientInitConfig: expDataFile,
        prefetchLinks: prefetchLinks
    }, telemetry);
    const timerBasePageCreation = telemetry.stopTimer(correlationIdBasePageCreation);
    // stop render server timer
    telemetry.trackEvent(EVENT_SERVER_RENDER_STOP, {}, {
        ServerRender: telemetry.stopTimer(serverRenderCorrelationId),
        RequestPrep: timerRequestPrep,
        ComplexTypes: timerComplexTypes,
        LoadData: timerLoadData,
        RenderPage: timerRenderPage,
        RenderToString: timerRenderToString,
        BasePageCreation: timerBasePageCreation
    });
    // don't await on refresh actions so that they can refresh in the background
    refreshActionsAsync(allRefreshActions, context, moduleTelemetry, appCache);
    return basePage;
};
export default serverRenderVnext;
//# sourceMappingURL=server-render.vnext.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { createObservableDataAction } from '@msdyn365-commerce/action-internal';
import { readAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { getProductRatingsAsync, searchByCriteriaAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import { getElementsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';
import * as semver from 'semver';
import { CATEGORY_PAGE_NAME, PDP_PAGE_NAME, PICKS_FOR_YOU_LIST } from '../../consts';
import { getProductImageUrls, orderProductSearchResults } from '../../utils/product-list-utils';
import getSimpleProducts, { ProductInput } from '../get-simple-products';
const actionInputError = (missingType) => {
    throw new Error(`Input ${missingType} is missing and required to run GetProductsByRecommendationId action`);
};
const MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS = '9.16.8';
/**
 * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context
 * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.
 *
 * @param recommendationCriteria The criteria that will be used for the recommendation API call
 * @param input The ProductListInput provided to the action
 * @param context The current action context
 */
const getCategoryIdForReco = (recommendationCriteria, input, context) => {
    let categoryIds = [];
    if (input.listMetadata.includePageContext || !input.listMetadata.categoryIds || input.listMetadata.categoryIds.length === 0) {
        const urlTokens = context.requestContext.urlTokens;
        if (urlTokens && urlTokens.pageType && urlTokens.pageType.toLowerCase() === CATEGORY_PAGE_NAME) {
            if (urlTokens.recordId) {
                categoryIds = [+urlTokens.recordId];
            }
        }
    }
    else {
        // Use category from a specific context if provided
        if (input.listMetadata.categoryIds && input.listMetadata.categoryIds.length > 0) {
            categoryIds = input.listMetadata.categoryIds;
        }
    }
    recommendationCriteria.CategoryIds = categoryIds;
};
/**
 * Fetches the current active cart to be used when cart context
 * is selected for a reco list
 *
 * @param ctx The current action context
 */
const getCart = async (ctx) => {
    let cart;
    if (ctx.requestContext && ctx.requestContext.cookies) {
        const cookies = ctx.requestContext && ctx.requestContext.cookies;
        const cartCookie = cookies.getCartCookie();
        const cartCookieParts = cartCookie.split(':');
        if (cartCookieParts && cartCookieParts.length === 2) {
            if ((ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === "t" /* Auth */) ||
                (!ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === "p" /* Anon */)) {
                const readCart = await readAsync({ callerContext: ctx }, cartCookieParts[1]);
                if (readCart && readCart.Id) {
                    cart = readCart;
                }
            }
        }
    }
    return cart;
};
/**
 * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will
 * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.
 * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.
 *
 * @param recommendationCriteria The criteria that will be used for the recommendation API call
 * @param input The ProductListInput provided to the action
 * @param context The current action context
 */
const getProductIdForReco = async (recommendationCriteria, input, context) => {
    let productIds = [];
    // If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call
    if (input.listMetadata.includeCart) {
        const cart = await getCart(context);
        if (cart && cart.CartLines) {
            const validCartLines = cart.CartLines.filter(element => element.ProductId !== undefined);
            const cartProductIds = validCartLines.map(product => product.ProductId);
            context.telemetry.debug(`Products in cart: ${cartProductIds}`);
            // If the cart isn't empty, assign the products in the cart to the productIds for seeding
            if (cartProductIds && cartProductIds.length > 0) {
                // @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]
                // however, we filter on undefined product ids first before mapping on product ids so each element must be defined
                productIds = cartProductIds;
            }
        }
    }
    else if (input.listMetadata.includePageContext || !input.listMetadata.productIds || input.listMetadata.productIds.length === 0) {
        const urlTokens = context.requestContext.urlTokens;
        if (urlTokens && urlTokens.recordId && urlTokens.pageType && urlTokens.pageType.toLowerCase() === PDP_PAGE_NAME) {
            productIds = [+urlTokens.recordId];
        }
    }
    else {
        // Use the product from specfic context
        if (input.listMetadata.productIds && input.listMetadata.productIds.length > 0) {
            productIds = [input.listMetadata.productIds[0]];
        }
    }
    recommendationCriteria.ProductIds = productIds;
};
// tslint:disable-next-line: max-func-body-length
export const getProductsByRecommendationList = async (input, context) => {
    // If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products
    const customerAccountNumber = context.requestContext && context.requestContext.user && context.requestContext.user.customerAccountNumber;
    if (input.listMetadata.recommendationListId === PICKS_FOR_YOU_LIST && !customerAccountNumber) {
        return [];
    }
    const recommendationCriteria = {};
    const proxyContext = { callerContext: context, queryResultSettings: { Paging: { Top: input.listMetadata.pageSize || 10 } } };
    recommendationCriteria.CatalogId = input.catalogId;
    let reccomendationListId;
    if (input.listMetadata.recommendationListId) {
        reccomendationListId = input.listMetadata.recommendationListId;
    }
    else {
        actionInputError(`recommendationListId (from listmetadata)`);
    }
    getCategoryIdForReco(recommendationCriteria, input, context);
    await getProductIdForReco(recommendationCriteria, input, context);
    if ((input.listMetadata.personalization || reccomendationListId === PICKS_FOR_YOU_LIST) && customerAccountNumber) {
        recommendationCriteria.CustomerAccountNumber = customerAccountNumber;
        proxyContext.bypassCache = 'get';
    }
    context.telemetry.debug(`Recommendation Criteria: ${JSON.stringify(recommendationCriteria)}`);
    return getElementsAsync(proxyContext, reccomendationListId, recommendationCriteria)
        .then(async (recommendedElements) => {
        if (recommendedElements) {
            const productInputs = [];
            const productTypeId = [];
            // Grab all the elements that are products and store the product ids
            for (let i = 0; i < recommendedElements.length; i++) {
                const element = recommendedElements[i];
                // Element type value of 1 indicates product type
                if (element.ElementId && element.ElementTypeValue === 1) {
                    productInputs[i] = new ProductInput(+element.ElementId, context.requestContext.apiSettings);
                    productTypeId[i] = element.ElementId;
                }
            }
            context.telemetry.debug(`Running recommendation action for list ${input.listMetadata.recommendationListId}`);
            context.telemetry.debug(`Number of products returned: ${productTypeId.length}`);
            context.telemetry.debug('Product ids returned', productTypeId);
            if (productInputs.length) {
                // Check to see if retail proxy version is greater than min version required for new API
                if (semver.gte(semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion) || '', MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS)) {
                    const itemIds = productInputs.map(value => value.productId);
                    const productSearchCriteria = {
                        Ids: itemIds,
                        Context: {
                            ChannelId: +context.requestContext.apiSettings.channelId,
                            CatalogId: +context.requestContext.apiSettings.catalogId
                        }
                    };
                    try {
                        let productSearchResults = await searchByCriteriaAsync({ callerContext: context }, productSearchCriteria);
                        // If the ProductSearchResult API finds the products then populate the product image urls and return
                        // otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons
                        context.telemetry.debug('Product search results returned', JSON.stringify(productSearchResults));
                        if (productSearchResults.length > 0) {
                            getProductImageUrls(productSearchResults, context.requestContext.apiSettings);
                            productSearchResults = orderProductSearchResults(itemIds, productSearchResults);
                            return productSearchResults;
                        }
                    }
                    catch (e) {
                        // In case of an error fall back to legacy flow
                        context.telemetry.error(`Error while getting productSearchResult: ${e}`);
                    }
                }
                // Get Product Ratings Block (If needed)
                const productRatingsPromise = getProductRatingsAsync({ callerContext: context }, productInputs.map(productInput => productInput.productId));
                return getSimpleProducts(productInputs, context).then((products) => {
                    getProductImageUrls(products, context.requestContext.apiSettings);
                    products = orderProductSearchResults(productInputs.map(value => value.productId), products);
                    return productRatingsPromise.then(productRatings => {
                        productRatings.forEach(productRating => {
                            const unratedProduct = (products.find(mappedProduct => mappedProduct.RecordId === productRating.ProductId));
                            if (unratedProduct) {
                                unratedProduct.TotalRatings = productRating.TotalRatings;
                                unratedProduct.AverageRating = productRating.AverageRating;
                            }
                        });
                        return products;
                    });
                });
            }
        }
        return [];
    })
        .catch(error => {
        context.telemetry.error(`Error running productByRecommendation action: ${error}`);
        throw new Error(error);
    });
};
export const getProductsByRecommendationListAction = createObservableDataAction({
    action: getProductsByRecommendationList,
    id: '@msdyn365-commerce/products-by-recommendation'
});
//# sourceMappingURL=products-by-recommendation.action.js.map
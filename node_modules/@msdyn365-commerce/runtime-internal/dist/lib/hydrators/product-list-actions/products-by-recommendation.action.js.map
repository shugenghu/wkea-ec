{"version":3,"file":"products-by-recommendation.action.js","sourceRoot":"","sources":["../../../../src/hydrators/product-list-actions/products-by-recommendation.action.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { createObservableDataAction } from '@msdyn365-commerce/action-internal';\nimport { IAction, IActionContext } from '@msdyn365-commerce/core-internal';\nimport { readAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';\nimport { getProductRatingsAsync, searchByCriteriaAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';\nimport { getElementsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';\nimport {\n    Cart,\n    ProductSearchCriteria,\n    ProductSearchResult,\n    RecommendationCriteria,\n    RecommendedElement\n} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';\nimport { IContext } from '@msdyn365-commerce/retail-proxy/dist/Interfaces';\nimport * as semver from 'semver';\nimport { CATEGORY_PAGE_NAME, PDP_PAGE_NAME, PICKS_FOR_YOU_LIST } from '../../consts';\nimport { getProductImageUrls, orderProductSearchResults } from '../../utils/product-list-utils';\nimport getSimpleProducts, { ProductInput } from '../get-simple-products';\nimport { ProductListInput } from '../hydrator-action-inputs';\n\nconst actionInputError = (missingType: string) => {\n    throw new Error(`Input ${missingType} is missing and required to run GetProductsByRecommendationId action`);\n};\n\nconst enum CartTokenPrefix {\n    Auth = 't',\n    Anon = 'p'\n}\n\nconst MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS = '9.16.8';\n\n/**\n * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context\n * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getCategoryIdForReco = (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let categoryIds: number[] = [];\n\n    if (input.listMetadata.includePageContext || !input.listMetadata.categoryIds || input.listMetadata.categoryIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.pageType && urlTokens.pageType.toLowerCase() === CATEGORY_PAGE_NAME) {\n            if (urlTokens.recordId) {\n                categoryIds = [+urlTokens.recordId];\n            }\n        }\n    } else {\n        // Use category from a specific context if provided\n        if (input.listMetadata.categoryIds && input.listMetadata.categoryIds.length > 0) {\n            categoryIds = input.listMetadata.categoryIds;\n        }\n    }\n\n    recommendationCriteria.CategoryIds = categoryIds;\n};\n\n/**\n * Fetches the current active cart to be used when cart context\n * is selected for a reco list\n *\n * @param ctx The current action context\n */\nconst getCart = async (ctx: IActionContext): Promise<Cart | undefined> => {\n    let cart;\n    if (ctx.requestContext && ctx.requestContext.cookies) {\n        const cookies = ctx.requestContext && ctx.requestContext.cookies;\n        const cartCookie = cookies.getCartCookie();\n        const cartCookieParts = cartCookie.split(':');\n        if (cartCookieParts && cartCookieParts.length === 2) {\n            if (\n                (ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Auth) ||\n                (!ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Anon)\n            ) {\n                const readCart = await readAsync({ callerContext: ctx }, cartCookieParts[1]);\n                if (readCart && readCart.Id) {\n                    cart = readCart;\n                }\n            }\n        }\n    }\n    return cart;\n};\n\n/**\n * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will\n * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.\n * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getProductIdForReco = async (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let productIds: number[] = [];\n    // If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call\n    if (input.listMetadata.includeCart) {\n        const cart = await getCart(context);\n        if (cart && cart.CartLines) {\n            const validCartLines = cart.CartLines.filter(element => element.ProductId !== undefined);\n            const cartProductIds = validCartLines.map(product => product.ProductId);\n            context.telemetry.debug(`Products in cart: ${cartProductIds}`);\n            // If the cart isn't empty, assign the products in the cart to the productIds for seeding\n            if (cartProductIds && cartProductIds.length > 0) {\n                // @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]\n                // however, we filter on undefined product ids first before mapping on product ids so each element must be defined\n                productIds = cartProductIds;\n            }\n        }\n    } else if (input.listMetadata.includePageContext || !input.listMetadata.productIds || input.listMetadata.productIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.recordId && urlTokens.pageType && urlTokens.pageType.toLowerCase() === PDP_PAGE_NAME) {\n            productIds = [+urlTokens.recordId];\n        }\n    } else {\n        // Use the product from specfic context\n        if (input.listMetadata.productIds && input.listMetadata.productIds.length > 0) {\n            productIds = [input.listMetadata.productIds[0]];\n        }\n    }\n\n    recommendationCriteria.ProductIds = productIds;\n};\n\n// tslint:disable-next-line: max-func-body-length\nexport const getProductsByRecommendationList = async (input: ProductListInput, context: IActionContext): Promise<ProductSearchResult[]> => {\n    // If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products\n    const customerAccountNumber =\n        context.requestContext && context.requestContext.user && context.requestContext.user.customerAccountNumber;\n    if (input.listMetadata.recommendationListId === PICKS_FOR_YOU_LIST && !customerAccountNumber) {\n        return [];\n    }\n\n    const recommendationCriteria: RecommendationCriteria = {};\n    const proxyContext: IContext = { callerContext: context, queryResultSettings: { Paging: { Top: input.listMetadata.pageSize || 10 } } };\n    recommendationCriteria.CatalogId = input.catalogId;\n\n    let reccomendationListId;\n    if (input.listMetadata.recommendationListId) {\n        reccomendationListId = input.listMetadata.recommendationListId;\n    } else {\n        actionInputError(`recommendationListId (from listmetadata)`);\n    }\n\n    getCategoryIdForReco(recommendationCriteria, input, context);\n    await getProductIdForReco(recommendationCriteria, input, context);\n\n    if ((input.listMetadata.personalization || reccomendationListId === PICKS_FOR_YOU_LIST) && customerAccountNumber) {\n        recommendationCriteria.CustomerAccountNumber = customerAccountNumber;\n        proxyContext.bypassCache = 'get';\n    }\n\n    context.telemetry.debug(`Recommendation Criteria: ${JSON.stringify(recommendationCriteria)}`);\n\n    return getElementsAsync(proxyContext, reccomendationListId, recommendationCriteria)\n        .then(async (recommendedElements: RecommendedElement[]) => {\n            if (recommendedElements) {\n                const productInputs: ProductInput[] = [];\n                const productTypeId: string[] = [];\n                // Grab all the elements that are products and store the product ids\n                for (let i = 0; i < recommendedElements.length; i++) {\n                    const element = recommendedElements[i];\n                    // Element type value of 1 indicates product type\n                    if (element.ElementId && element.ElementTypeValue === 1) {\n                        productInputs[i] = new ProductInput(+element.ElementId, context.requestContext.apiSettings);\n                        productTypeId[i] = element.ElementId;\n                    }\n                }\n                context.telemetry.debug(`Running recommendation action for list ${input.listMetadata.recommendationListId}`);\n                context.telemetry.debug(`Number of products returned: ${productTypeId.length}`);\n                context.telemetry.debug('Product ids returned', productTypeId);\n\n                if (productInputs.length) {\n                    // Check to see if retail proxy version is greater than min version required for new API\n                    if (\n                        semver.gte(\n                            semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion) || '',\n                            MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS\n                        )\n                    ) {\n                        const itemIds: number[] = productInputs.map(value => value.productId);\n                        const productSearchCriteria: ProductSearchCriteria = {\n                            Ids: itemIds,\n                            Context: {\n                                ChannelId: +context.requestContext.apiSettings.channelId,\n                                CatalogId: +context.requestContext.apiSettings.catalogId\n                            }\n                        };\n                        try {\n                            let productSearchResults = await searchByCriteriaAsync({ callerContext: context }, productSearchCriteria);\n                            // If the ProductSearchResult API finds the products then populate the product image urls and return\n                            // otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons\n                            context.telemetry.debug('Product search results returned', JSON.stringify(productSearchResults));\n                            if (productSearchResults.length > 0) {\n                                getProductImageUrls(productSearchResults, context.requestContext.apiSettings);\n                                productSearchResults = orderProductSearchResults(itemIds, productSearchResults);\n                                return productSearchResults;\n                            }\n                        } catch (e) {\n                            // In case of an error fall back to legacy flow\n                            context.telemetry.error(`Error while getting productSearchResult: ${e}`);\n                        }\n                    }\n\n                    // Get Product Ratings Block (If needed)\n                    const productRatingsPromise = getProductRatingsAsync(\n                        { callerContext: context },\n                        productInputs.map(productInput => productInput.productId)\n                    );\n\n                    return getSimpleProducts(productInputs, context).then((products: ProductSearchResult[]) => {\n                        getProductImageUrls(products, context.requestContext.apiSettings);\n                        products = orderProductSearchResults(\n                            productInputs.map(value => value.productId),\n                            products\n                        );\n                        return productRatingsPromise.then(productRatings => {\n                            productRatings.forEach(productRating => {\n                                const unratedProduct: ProductSearchResult = <ProductSearchResult>(\n                                    products.find(mappedProduct => mappedProduct.RecordId === productRating.ProductId)\n                                );\n                                if (unratedProduct) {\n                                    unratedProduct.TotalRatings = productRating.TotalRatings;\n                                    unratedProduct.AverageRating = productRating.AverageRating;\n                                }\n                            });\n\n                            return products;\n                        });\n                    });\n                }\n            }\n            return [];\n        })\n        .catch(error => {\n            context.telemetry.error(`Error running productByRecommendation action: ${error}`);\n            throw new Error(error);\n        });\n};\n\nexport const getProductsByRecommendationListAction = createObservableDataAction({\n    action: <IAction<ProductSearchResult[]>>getProductsByRecommendationList,\n    id: '@msdyn365-commerce/products-by-recommendation'\n});\n"]}
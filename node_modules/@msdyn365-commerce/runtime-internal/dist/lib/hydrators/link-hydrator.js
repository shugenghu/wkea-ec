/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { appendQueryParams, getUrlSync } from '@msdyn365-commerce/core-internal';
import { EXCEPTION_LINK_ACTION } from '@msdyn365-commerce/telemetry-internal';
import { CategoryLinkInput, ProductLinkInput } from './hydrator-action-inputs';
import { getPageTypeContextByIdAction } from './link-actions/page-type-context-by-id';
/**
 * Takes a Link object from the Page Response and uses URL Builder to construct a destination url and transform the
 * existing link structure to expose two porperties type and destinationUrl
 *
 * @param linkObject The current link object being modified
 * @param context The current action context
 */
export const hydrateLink = async (linkObject, context) => {
    let destinationUrl;
    // In each switch case if the required information is not present to construct the URL
    // The object will be return unmodified
    switch (linkObject.type) {
        // In the case of internal and external links, no transform is needed
        // If destination url is present set the destination url and break
        case 'internalLink':
        case 'externalLink':
            if (linkObject.destinationUrl) {
                // Append the pass through query parameters
                const queryParams = (context.requestContext && context.requestContext.query) || {};
                destinationUrl = appendQueryParams(linkObject.destinationUrl, queryParams);
                break;
            }
            return;
        case 'productLink':
            // To build the url for a productLink we need the product and category ids
            if (linkObject.productId && linkObject.categoryId) {
                // Grab the route context using the action
                let routeContext;
                try {
                    routeContext = await getPageTypeContextByIdAction(new ProductLinkInput(context.requestContext.apiSettings, linkObject.categoryId, linkObject.productId), context);
                    // Create the URL and break
                    destinationUrl = getUrlSync('product', context, routeContext);
                }
                catch (err) {
                    context.telemetry.error(EXCEPTION_LINK_ACTION);
                    context.telemetry.exception(err);
                    linkObject.destinationUrl = '';
                    linkObject.error = EXCEPTION_LINK_ACTION;
                    return;
                }
                break;
            }
            return;
        case 'categoryLink':
            // To build the url for the categoryLink we need the category id
            if (linkObject.categoryId) {
                // Grab the route context using the action
                let routeContext;
                try {
                    routeContext = await getPageTypeContextByIdAction(new CategoryLinkInput(context.requestContext.apiSettings, linkObject.categoryId), context);
                    // Create the URL and break
                    destinationUrl = getUrlSync('category', context, routeContext);
                }
                catch (err) {
                    context.telemetry.error(EXCEPTION_LINK_ACTION);
                    context.telemetry.exception(err);
                    linkObject.destinationUrl = '';
                    linkObject.error = EXCEPTION_LINK_ACTION;
                    return;
                }
                break;
            }
            return;
        default:
            // If it is not one of these types or does not contain the information required for the link
            // building do not modify the data
            return;
    }
    // Set the computed destinationUrl and delete the other properties
    linkObject.destinationUrl = destinationUrl;
    delete linkObject.categoryId;
    delete linkObject.productId;
};
//# sourceMappingURL=link-hydrator.js.map
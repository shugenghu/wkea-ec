/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import 'jest';
import { buildMockActionContext } from '@msdyn365-commerce/core';
import { EXCEPTION_PRODUCT_LIST_ACTION, INVALID_PRODUCT_LIST_TYPE } from '@msdyn365-commerce/telemetry-internal';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getProductsByCategoryListAction } from '../product-list-actions/products-by-category.action';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getProductsByRecommendationListAction } from '../product-list-actions/products-by-recommendation.action';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getProductsByRelationshipIdListAction } from '../product-list-actions/products-by-relationship-id.action';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getProductsBySearchListAction } from '../product-list-actions/products-by-search.action';
import { hydrateProductList } from '../product-list-hydrator';
describe('product list hydrator tests', () => {
    const actionContext = buildMockActionContext();
    it('should call getProductsByCategory action for productByCategory list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByCategoryListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'productByCategory',
            categoryIds: [123]
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsByCategoryListAction).toHaveBeenCalledTimes(1);
    });
    it('should call getProductsBySearch action for productBySearch list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsBySearchListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'productBySearch'
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsBySearchListAction).toHaveBeenCalledTimes(1);
    });
    it('should call getRelatedProducts action for relatedProducts list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByRelationshipIdListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'relatedProducts'
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsByRelationshipIdListAction).toHaveBeenCalledTimes(1);
    });
    it('should call getProductsByRecommendationListAction for editorial list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByRecommendationListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'editorial'
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsByRecommendationListAction).toHaveBeenCalledTimes(1);
    });
    it('should call getProductsByRecommendationListAction for recommendation list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByRecommendationListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'recommendation'
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsByRecommendationListAction).toHaveBeenCalledTimes(1);
    });
    it('should call getProductsByRecommendationListAction for algo list type', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByRecommendationListAction = jest.fn().mockResolvedValue([{ recordId: 1234 }]);
        const listMetadata = {
            listType: 'algo'
        };
        await hydrateProductList(listMetadata, actionContext);
        expect(listMetadata.products[0]).toEqual({ recordId: 1234 });
        expect(getProductsByRecommendationListAction).toHaveBeenCalledTimes(1);
    });
    it('Should fail on invalid list type', async () => {
        const listMetadata = {
            listType: 'badListType'
        };
        await hydrateProductList(listMetadata, actionContext);
        // No products should be returned
        expect(listMetadata.products).toEqual([]);
        expect(listMetadata.listMetadata.error).toEqual(INVALID_PRODUCT_LIST_TYPE);
    });
    it('Should fail on error during hydration action', async () => {
        const listMetadata = {
            listType: 'productByCategory',
            categoryIds: [123]
        };
        // @ts-ignore: Jest Mocking Confuses TS Complier
        getProductsByCategoryListAction = jest.fn().mockRejectedValue(new Error('ERROR'));
        await hydrateProductList(listMetadata, actionContext);
        // No products should be returned
        expect(listMetadata.products).toEqual([]);
        expect(listMetadata.listMetadata.error).toEqual(EXCEPTION_PRODUCT_LIST_ACTION);
    });
});
//# sourceMappingURL=product-list-hydrator.test.js.map
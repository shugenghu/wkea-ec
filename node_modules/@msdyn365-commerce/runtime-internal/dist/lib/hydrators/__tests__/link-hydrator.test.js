/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ActionContext } from '@msdyn365-commerce/action-internal';
import { RequestCache } from '@msdyn365-commerce/cache-internal';
import { buildMockActionContext, buildMockRequest } from '@msdyn365-commerce/core-internal';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getCategoriesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CategoriesDataActions.g';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getByIdAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import 'jest';
import { CategoryLinkInput, ProductLinkInput } from '../hydrator-action-inputs';
// @ts-ignore: compiler will complain that we aren't using these imports when in fact they are being used to mock return values
import { getCategorySlug, getPageTypeContextByIdAction } from '../link-actions/page-type-context-by-id';
import { hydrateLink } from '../link-hydrator';
describe('link hydrator tests', () => {
    const queryParamsWithPreview = { preview: 'inprogress', locale: 'en-us', market: 'us', item: 'nodeserviceproxy:false' };
    const queryParamsWithoutPreview = { locale: 'en-us', market: 'us', item: 'nodeserviceproxy:false' };
    const requestContextWithSite = buildMockRequest({ sitePath: '/contoso', query: queryParamsWithoutPreview });
    const requestContextWithSiteWithPreviewQueryParam = buildMockRequest({ sitePath: '/contoso', query: queryParamsWithPreview });
    const actionContextWithSite = buildMockActionContext({ requestContext: requestContextWithSite });
    const actionContextWithSiteWithPreviewQueryParam = buildMockActionContext({
        requestContext: requestContextWithSiteWithPreviewQueryParam
    });
    describe('get page type context by id action tests', () => {
        let actionInputForCategory;
        let actionInputForProduct;
        const actionContext = new ActionContext({
            id: 'T1',
            requestContext: {},
            requestCache: new RequestCache(),
            appCache: null,
            expectedActionCount: 1
        });
        const getProductByIdResult = {
            Name: 'My Awesome Product',
            RecordId: 2256223231321
        };
        const getCategoriesAsyncResult = [
            {
                RecordId: 1234,
                Name: 'Cat 3',
                ParentCategory: 1235
            },
            {
                RecordId: 1235,
                Name: 'Cat 2',
                ParentCategory: 1236
            },
            {
                RecordId: 1236,
                Name: 'Cat 1'
            }
        ];
        beforeEach(() => {
            actionInputForCategory = new CategoryLinkInput(buildMockRequest().apiSettings, 1234);
            actionInputForProduct = new ProductLinkInput(buildMockRequest().apiSettings, 1234, 2256223231321);
            jest.clearAllMocks();
        });
        it('returns a correct route context for category', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getCategoriesAsync = jest.fn().mockResolvedValueOnce(getCategoriesAsyncResult);
            const routeContext = await getPageTypeContextByIdAction(actionInputForCategory, actionContext);
            expect(routeContext.product).toBeUndefined();
            expect(routeContext.category).toBeDefined();
            expect(routeContext.category && routeContext.category.Slug).toBe('/cat-1/cat-2/cat-3');
            expect(routeContext.category && routeContext.category.RecordId).toBe(1234);
        });
        it('returns a correct route context for product', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getCategoriesAsync = jest.fn().mockResolvedValueOnce(getCategoriesAsyncResult);
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getByIdAsync = jest.fn().mockResolvedValueOnce(getProductByIdResult);
            const routeContext = await getPageTypeContextByIdAction(actionInputForProduct, actionContext);
            expect(routeContext.product).toBeDefined();
            expect(routeContext.category).toBeDefined();
            expect(routeContext.product && routeContext.product.Name).toBe('My Awesome Product');
            expect(routeContext.product && routeContext.product.RecordId).toBe(2256223231321);
            expect(routeContext.category && routeContext.category.Slug).toBe('/cat-1/cat-2/cat-3');
            expect(routeContext.category && routeContext.category.RecordId).toBe(1234);
        });
    });
    describe('construct external link tests', () => {
        let testExternalLink;
        beforeEach(() => {
            testExternalLink = {
                type: 'externalLink',
                destinationUrl: 'www.example.com'
            };
        });
        it('should leave external links as is', async () => {
            await hydrateLink(testExternalLink, actionContextWithSite);
            expect(testExternalLink.type).toBe('externalLink');
            expect(testExternalLink.destinationUrl).toBe('www.example.com');
        });
        it('should not modify external links object if it does not contain a destination url', async () => {
            const testExternalLinkWithoutDestinationUrl = {
                type: 'externalLink',
                property1: 'prop1'
            };
            await hydrateLink(testExternalLinkWithoutDestinationUrl, actionContextWithSite);
            expect(testExternalLinkWithoutDestinationUrl.type).toBe('externalLink');
            expect(testExternalLinkWithoutDestinationUrl.property1).toBe('prop1');
            // @ts-ignore - want to test that this property wasnt added - expect undefined
            expect(testExternalLinkWithoutDestinationUrl.destinationUrl).toBeUndefined();
        });
        it('should leave external links as is and not append allowed query params when preview is false', async () => {
            await hydrateLink(testExternalLink, actionContextWithSite);
            expect(testExternalLink.type).toBe('externalLink');
            expect(testExternalLink.destinationUrl).toBe('www.example.com');
        });
        it('should leave external links as is and append allowed query parameters when preview is set to true', async () => {
            await hydrateLink(testExternalLink, actionContextWithSiteWithPreviewQueryParam);
            expect(testExternalLink.type).toBe('externalLink');
            expect(testExternalLink.destinationUrl).toBe('www.example.com?preview=inprogress&locale=en-us&market=us');
        });
    });
    describe('construct internal link tests', () => {
        let testInternalLink;
        beforeEach(() => {
            testInternalLink = {
                type: 'internalLink',
                destinationUrl: '/site-path/url-path'
            };
        });
        it('should leave internal links as is', async () => {
            await hydrateLink(testInternalLink, actionContextWithSite);
            expect(testInternalLink.type).toBe('internalLink');
            expect(testInternalLink.destinationUrl).toBe('/site-path/url-path');
        });
        it('should leave internal links as is and append allowed query parameters when preview is set to true', async () => {
            await hydrateLink(testInternalLink, actionContextWithSiteWithPreviewQueryParam);
            expect(testInternalLink.type).toBe('internalLink');
            expect(testInternalLink.destinationUrl).toBe('/site-path/url-path?preview=inprogress&locale=en-us&market=us');
        });
    });
    describe('construct category link tests', () => {
        let testCategoryLink;
        const categoryRouteContext = {
            category: {
                Slug: 'cat-1/cat-2',
                RecordId: 1234
            }
        };
        beforeEach(() => {
            testCategoryLink = {
                type: 'categoryLink',
                categoryId: 1234
            };
        });
        it('should construct category links using url builder', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getPageTypeContextByIdAction = jest.fn().mockResolvedValueOnce(categoryRouteContext);
            await hydrateLink(testCategoryLink, actionContextWithSite);
            expect(testCategoryLink.type).toBe('categoryLink');
            expect(testCategoryLink.destinationUrl).toBe('/contoso/cat-1/cat-2/1234.c');
            expect(testCategoryLink.categoryId).toBeUndefined();
        });
        it('should return unmodified object if the link object does not contain category ID', async () => {
            const testCategoryLinkWithExtraProps = {
                type: 'categoryLink',
                property1: 'prop1'
            };
            await hydrateLink(testCategoryLinkWithExtraProps, actionContextWithSite);
            expect(testCategoryLinkWithExtraProps.type).toBe('categoryLink');
            expect(testCategoryLinkWithExtraProps.property1).toBe('prop1');
            // @ts-ignore - want to test that this property wasnt added
            expect(testCategoryLinkWithExtraProps.destinationUrl).toBeUndefined();
        });
        it('should construct category links using url builder with query params', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getPageTypeContextByIdAction = jest.fn().mockResolvedValueOnce(categoryRouteContext);
            await hydrateLink(testCategoryLink, actionContextWithSiteWithPreviewQueryParam);
            expect(testCategoryLink.type).toBe('categoryLink');
            expect(testCategoryLink.destinationUrl).toBe('/contoso/cat-1/cat-2/1234.c?preview=inprogress&locale=en-us&market=us');
            expect(testCategoryLink.categoryId).toBeUndefined();
        });
    });
    describe('construct product link tests', () => {
        let testProductLink;
        const productRouteContext = {
            product: {
                Name: 'My Awesome Product',
                RecordId: 2256223231321
            },
            category: {
                Slug: 'cat-1/cat-2',
                RecordId: 1234
            }
        };
        beforeEach(() => {
            testProductLink = {
                type: 'productLink',
                categoryId: 1234,
                productId: 2256223231321
            };
        });
        it('should construct product links using url builder', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getPageTypeContextByIdAction = jest.fn().mockResolvedValueOnce(productRouteContext);
            await hydrateLink(testProductLink, actionContextWithSite);
            expect(testProductLink.type).toBe('productLink');
            expect(testProductLink.destinationUrl).toBe('/contoso/cat-1/cat-2/my-awesome-product/2256223231321.p');
            expect(testProductLink.categoryId).toBeUndefined();
            expect(testProductLink.productId).toBeUndefined();
        });
        it('should construct product links using url builder with query params', async () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            getPageTypeContextByIdAction = jest.fn().mockResolvedValueOnce(productRouteContext);
            await hydrateLink(testProductLink, actionContextWithSiteWithPreviewQueryParam);
            expect(testProductLink.type).toBe('productLink');
            expect(testProductLink.destinationUrl).toBe('/contoso/cat-1/cat-2/my-awesome-product/2256223231321.p?preview=inprogress&locale=en-us&market=us');
            expect(testProductLink.categoryId).toBeUndefined();
            expect(testProductLink.productId).toBeUndefined();
        });
        it('should return an unmodifed object if the object does not contain the required information', async () => {
            const testProductLinkWithExtraProps = {
                type: 'productLink',
                property1: 'prop1',
                categoryId: 2256223231321
            };
            await hydrateLink(testProductLinkWithExtraProps, actionContextWithSite);
            expect(testProductLinkWithExtraProps.type).toBe('productLink');
            expect(testProductLinkWithExtraProps.property1).toBe('prop1');
            expect(testProductLinkWithExtraProps.categoryId).toBe(2256223231321);
            // @ts-ignore - want to test that this property wasnt added - expect undefined
            expect(testProductLinkWithExtraProps.destinationUrl).toBeUndefined();
        });
    });
    describe('construct category slug tests', () => {
        const parentCategories = [
            {
                Name: 'Test Category 2',
                RecordId: 1235,
                ParentCategory: 1236
            },
            {
                Name: 'Test Category 3',
                RecordId: 1236
            }
        ];
        it('should construct the slug for one category', () => {
            const currentCategoryResult = {
                Name: 'Test Category 1',
                RecordId: 1234
            };
            expect(getCategorySlug(currentCategoryResult, [])).toBe('/test-category-1');
        });
        it('should construct the slug for one category if it cant find parent categories', () => {
            const currentCategoryResult = {
                Name: 'Test Category 1',
                RecordId: 1234,
                ParentCategory: 5633
            };
            expect(getCategorySlug(currentCategoryResult, parentCategories)).toBe('/test-category-1');
        });
        it('should construct the slug recursively when parent categories are found', async () => {
            const currentCategoryResult = {
                Name: 'Test Category 1',
                RecordId: 1234,
                ParentCategory: 1235
            };
            expect(getCategorySlug(currentCategoryResult, parentCategories)).toBe('/test-category-3/test-category-2/test-category-1');
        });
    });
});
//# sourceMappingURL=link-hydrator.test.js.map
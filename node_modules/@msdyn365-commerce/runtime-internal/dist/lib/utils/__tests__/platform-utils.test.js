/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { buildMockRequest } from '@msdyn365-commerce/core';
import { buildMockTelemetry, msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import * as CategoryDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CategoriesDataActions.g';
import * as ProductDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import 'jest';
import { Request } from 'jest-express/lib/request';
import { Response } from 'jest-express/lib/response';
import { loadFeatureFlags, setCorsHeaders, setResponseHeaders, validateRouteAndChannelConfig } from '../platform-utils';
const noop = () => null;
describe('platform utilities', () => {
    describe('Validate Routes', () => {
        afterEach(() => {
            jest.restoreAllMocks();
        });
        describe('pdp', () => {
            it('Should return 404 if no product is found in url', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 500 if the data action throws', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                // @ts-ignore
                getProduct.mockRejectedValue();
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5, pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(500);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 404 if no product is found on the server', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                // @ts-ignore
                getProduct.mockResolvedValue([]);
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5, pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
        });
        describe('category', () => {
            it('Should return 404 if no category is found in url', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 500 if the data action throws', async () => {
                const getCategories = jest.spyOn(CategoryDataActions, 'getCategoriesAsync');
                // @ts-ignore
                getCategories.mockRejectedValue();
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5, pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(500);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 404 if no category is found on the server', async () => {
                const getCategories = jest.spyOn(CategoryDataActions, 'getCategoriesAsync');
                // @ts-ignore
                getCategories.mockResolvedValue([]);
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5, pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
        });
        describe('list', () => {
            it('Should return 404 if no list is found', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'list' }, pageData: { list: 'invalid' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
        });
        describe('invalid', () => {
            it('should pass through when page type is unknown', async () => {
                jest.setTimeout(10000);
                // @ts-ignore
                msdyn365Commerce.getAppCache = jest.fn(null);
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'invalid' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(next).toHaveBeenCalled();
                expect(getProduct).not.toHaveBeenCalled();
            });
            it('should pass through when page type is not defined', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest());
                // @ts-ignore
                mockRes.setLocals('telemetry', buildMockTelemetry());
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(next).toHaveBeenCalled();
                expect(getProduct).not.toHaveBeenCalled();
            });
        });
    });
    describe('Set Cors Headers', () => {
        it('Should not set access control headers if flights are not loaded', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {},
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
        it('Should not set access control headers if allowAllCors is false', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {
                    features: {
                        allowAllCors: false
                    }
                },
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
        it('Should set access control headers if allowAllCors is true', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {
                    features: {
                        allowAllCors: true
                    }
                },
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
    });
    describe('Set Response Headers', () => {
        const oldEnv = process.env;
        beforeEach(() => {
            jest.resetModules();
            // shallow copy
            process.env = { ...oldEnv };
        });
        afterAll(() => {
            process.env = oldEnv;
        });
        it('Should not set cache control if process is in production mode', done => {
            const setHeader = jest.fn();
            const mockRes = {
                setHeader
            };
            process.env.NODE_ENV = 'production';
            // @ts-ignore
            setResponseHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Cache-Control', 'max-age=1');
                done();
            });
        });
        it('Should set cache control if process is in development mode', done => {
            const setHeader = jest.fn();
            const mockRes = {
                setHeader
            };
            process.env.NODE_ENV = 'development';
            // @ts-ignore
            setResponseHeaders({}, mockRes, () => {
                expect(setHeader).toHaveBeenCalledWith('Cache-Control', 'max-age=1');
                done();
            });
        });
    });
    describe('Load Feature Flags', () => {
        it('Should set features to an empty object if they are not specified', done => {
            const mockReq = {
                body: {}
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.features).toMatchObject({});
                done();
            });
        });
        it('SHould set features to the rendering context features', done => {
            const mockReq = {
                body: {
                    renderingContext: {
                        features: {
                            special_feature_one: true
                        }
                    }
                }
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.features).toMatchObject({ special_feature_one: true });
                done();
            });
        });
        it('Should set the page response from the request body', done => {
            const mockReq = {
                body: {
                    pageValue: 1235
                }
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.pageResponse).toMatchObject({ pageValue: 1235 });
                done();
            });
        });
    });
});
//# sourceMappingURL=platform-utils.test.js.map
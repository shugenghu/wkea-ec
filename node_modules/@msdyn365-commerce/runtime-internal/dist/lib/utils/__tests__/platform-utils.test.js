/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { AppCache } from '@msdyn365-commerce/cache-internal';
import { buildMockRequest } from '@msdyn365-commerce/core';
import { buildMockTelemetry, msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import * as CategoryDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CategoriesDataActions.g';
import * as ProductDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import 'jest';
import { Request } from 'jest-express/lib/request';
import { Response } from 'jest-express/lib/response';
import { loadFeatureFlags, setCorsHeaders, setResponseHeaders, validateRouteAndChannelConfig } from '../platform-utils';
// tslint:disable no-string-based-set-timeout
const noop = () => null;
const mockTelemetryObject = {
    ...buildMockTelemetry(),
    startTimer: (correlationId) => null,
    stopTimer: (correlationId) => null
};
const appCache = new AppCache({
    ttrInSeconds: {
        __VALIDATE_ROUTE_PDP__: 2,
        __VALIDATE_ROUTE_CATEGORY__: 2
    }
});
describe('platform utilities', () => {
    describe('Validate Routes', () => {
        afterEach(() => {
            jest.restoreAllMocks();
        });
        describe('pdp', () => {
            // tslint:disable-next-line:mocha-avoid-only
            it('Should return 404 if no product is found in url', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            // tslint:disable-next-line:mocha-avoid-only
            it('Should return 500 if the data action throws and not cache the error', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                // @ts-ignore
                getProduct.mockRejectedValue();
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5002, pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(500);
                expect(next).not.toHaveBeenCalled();
                // should not cache 500 error, so subsequent call should invoke getCategories again
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 404 if no product is found on the server when disable_routeerrors_cache is true', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                // @ts-ignore
                getProduct.mockResolvedValue([]);
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                mockRes.setLocals('requestContext', 
                // tslint:disable-next-line:no-any
                buildMockRequest({
                    urlTokens: { recordId: '5', pageType: 'product' },
                    features: { disable_routeerrors_cache: true }
                }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            // tslint:disable-next-line:mocha-avoid-only
            it('Should return 404 and then return product once cached validate route error expires', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                // @ts-ignore
                getProduct.mockResolvedValue([]);
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5000, pageType: 'product' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
                // should return same error since ttr (2 seconds) is not expired
                getProduct.mockReset();
                // tslint:disable-next-line:no-any
                getProduct.mockResolvedValue({ RecordId: 5000 });
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).not.toHaveBeenCalled();
                expect(next).not.toHaveBeenCalled();
                // sleep for 3 seconds until ttr for the validate route error expires
                await new Promise(r => setTimeout(r, 3000));
                getProduct.mockReset();
                // tslint:disable-next-line:no-any
                getProduct.mockResolvedValue({ RecordId: 5000 });
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getProduct).toHaveBeenCalled();
            });
        });
        describe('category', () => {
            it('Should return 404 if no category is found in url', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 500 if the data action throws and not cache the error', async () => {
                const getCategories = jest.spyOn(CategoryDataActions, 'getCategoriesAsync');
                // @ts-ignore
                getCategories.mockRejectedValue();
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5001, pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(500);
                expect(next).not.toHaveBeenCalled();
                // should not cache 500 error, so subsequent call should invoke getCategories again
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 404 if no category is found on the server when disable_routeerrors_cache is true', async () => {
                const getCategories = jest.spyOn(CategoryDataActions, 'getCategoriesAsync');
                // @ts-ignore
                getCategories.mockResolvedValue([]);
                // tslint:disable-next-line:no-any
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                mockRes.setLocals('requestContext', 
                // tslint:disable-next-line:no-any
                buildMockRequest({
                    urlTokens: { recordId: '5', pageType: 'category' },
                    features: { disable_routeerrors_cache: true }
                }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
            it('Should return 404 if no category is found on the server and execute getCategories once route error cache ttr expires', async () => {
                const getCategories = jest.spyOn(CategoryDataActions, 'getCategoriesAsync');
                // @ts-ignore
                getCategories.mockResolvedValue([]);
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { recordId: 5000, pageType: 'category' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
                // should return same error since ttr (2 seconds) is not expired and not call getCategories
                getCategories.mockReset();
                // tslint:disable-next-line:no-any
                getCategories.mockResolvedValue([{ RecordId: 5000 }]);
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).not.toHaveBeenCalled();
                expect(next).not.toHaveBeenCalled();
                // sleep for 3 seconds until ttr for the validate route error expires
                await new Promise(r => setTimeout(r, 3000));
                getCategories.mockReset();
                // tslint:disable-next-line:no-any
                getCategories.mockResolvedValue([{ RecordId: 5000 }]);
                // tslint:disable-next-line:no-any
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(getCategories).toHaveBeenCalled();
            });
        });
        describe('list', () => {
            it('Should return 404 if no list is found', async () => {
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'list' }, pageData: { list: 'invalid' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(mockRes.status).toBeCalledWith(404);
                expect(next).not.toHaveBeenCalled();
            });
        });
        describe('invalid', () => {
            it('should pass through when page type is unknown', async () => {
                jest.setTimeout(10000);
                // @ts-ignore
                msdyn365Commerce.getAppCache = () => appCache;
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', buildMockRequest({ urlTokens: { pageType: 'invalid' } }));
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(next).toHaveBeenCalled();
                expect(getProduct).not.toHaveBeenCalled();
            });
            it('should pass through when page type is not defined', async () => {
                const getProduct = jest.spyOn(ProductDataActions, 'getByIdAsync');
                const mockReq = new Request();
                const mockRes = new Response();
                // @ts-ignore
                mockRes.setLocals('requestContext', { ...buildMockRequest() });
                // @ts-ignore
                mockRes.setLocals('telemetry', mockTelemetryObject);
                // @ts-ignore
                const next = jest.fn();
                // @ts-ignore
                await validateRouteAndChannelConfig(mockReq, mockRes, next);
                expect(next).toHaveBeenCalled();
                expect(getProduct).not.toHaveBeenCalled();
            });
        });
    });
    describe('Set Cors Headers', () => {
        it('Should not set access control headers if flights are not loaded', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {},
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
        it('Should not set access control headers if allowAllCors is false', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {
                    features: {
                        allowAllCors: false
                    }
                },
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).not.toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
        it('Should set access control headers if allowAllCors is true', done => {
            const setHeader = jest.fn();
            const mockRes = {
                locals: {
                    features: {
                        allowAllCors: true
                    }
                },
                setHeader
            };
            // @ts-ignore
            setCorsHeaders({}, mockRes, () => {
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Origin', '*');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
                expect(setHeader).toHaveBeenCalledWith('Access-Control-Allow-Credentials', 'true');
                done();
            });
        });
    });
    describe('Set Response Headers', () => {
        const oldEnv = process.env;
        beforeEach(() => {
            jest.resetModules();
            // shallow copy
            process.env = { ...oldEnv };
        });
        afterAll(() => {
            process.env = oldEnv;
        });
        it('Should not set cache control if process is in production mode', done => {
            const setHeader = jest.fn();
            const mockRes = {
                setHeader
            };
            process.env.NODE_ENV = 'production';
            // @ts-ignore
            setResponseHeaders({}, mockRes, () => {
                expect(setHeader).not.toHaveBeenCalledWith('Cache-Control', 'max-age=1');
                done();
            });
        });
        it('Should set cache control if process is in development mode', done => {
            const setHeader = jest.fn();
            const mockRes = {
                setHeader
            };
            process.env.NODE_ENV = 'development';
            // @ts-ignore
            setResponseHeaders({}, mockRes, () => {
                expect(setHeader).toHaveBeenCalledWith('Cache-Control', 'max-age=1');
                done();
            });
        });
    });
    describe('Load Feature Flags', () => {
        it('Should set features to an empty object if they are not specified', done => {
            const mockReq = {
                body: {}
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.features).toMatchObject({});
                done();
            });
        });
        it('SHould set features to the rendering context features', done => {
            const mockReq = {
                body: {
                    renderingContext: {
                        features: {
                            special_feature_one: true
                        }
                    }
                }
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.features).toMatchObject({ special_feature_one: true });
                done();
            });
        });
        it('Should set the page response from the request body', done => {
            const mockReq = {
                body: {
                    pageValue: 1235
                }
            };
            const mockRes = {
                locals: {}
            };
            // @ts-ignore
            loadFeatureFlags(mockReq, mockRes, () => {
                // @ts-ignore
                expect(mockRes.locals.pageResponse).toMatchObject({ pageValue: 1235 });
                done();
            });
        });
    });
});
//# sourceMappingURL=platform-utils.test.js.map
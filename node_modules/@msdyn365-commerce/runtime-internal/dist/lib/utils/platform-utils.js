/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ActionContext } from '@msdyn365-commerce/action-internal';
import { DEFAULT_EXPERIMENT_DATAFILE_TTL, DEFAULT_EXPERIMENT_DATAFILE_TTR, DEFAULT_EXPERIMENT_TTL, DEFAULT_EXPERIMENT_TTR, RequestCache } from '@msdyn365-commerce/cache-internal';
import { EXPERIMENTATION_CACHE_TYPE, EXPERIMENTATION_DATAFILE_CACHE_TYPE, msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { getCategoriesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CategoriesDataActions.g';
import { getOrgUnitConfigurationAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/OrgUnitsDataActions.g';
import { getByIdAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import { expAttributeRenderer, GenericConsoleLogger, InternalTelemetry, LogLevel, PageLogger, RetainLogger, StaticTelemetry, Telemetry } from '@msdyn365-commerce/telemetry-internal';
import { AppInsightsNodeLogger } from '@msdyn365-commerce/telemetry-internal/dist/lib/server';
import { safeReadJsonSync } from '@msdyn365-commerce/utilities-internal';
import axios from 'axios';
import { merge as _merge } from 'lodash';
import { resolve } from 'path';
import { parseRequest } from '../_server/parse-request';
import { handleServerException, renderDefaultRouter } from '../_server/request-routers';
import { CATEGORY_PAGE_NAME, DEFAULT_PROXY_HOST, DEFAULT_PROXY_PORT, GLIMPSE_LOGGER_NAME, LIST_PAGE_NAME, PAGE_LOGGER_NAME, PDP_PAGE_NAME } from '../consts';
import keystonePaths from '../paths';
import defaultCacheSettings from '../settings/cache.settings.json';
import { ACCESS_TOKEN_SECRET_CACHE_TYPE, DEFAULT_ACCESS_TOKEN_SECRET_TTL, DEFAULT_ACCESS_TOKEN_SECRET_TTR, DEFAULT_KV_SECRET_TTL, DEFAULT_KV_SECRET_TTR, KEY_VAULT_SECRET_CACHE_TYPE } from '../utils/secret-manager';
const CONNECTOR_SETTINGS = 'connector.settings';
const cacheSettingsPath = resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, 'cache.settings.json');
const overrideCacheSettings = safeReadJsonSync(cacheSettingsPath, console);
const experimentsSettings = safeReadJsonSync(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `${CONNECTOR_SETTINGS}.json`));
const DESTINATIONURL = 'destinationUrl';
export const KEYSTONE_ENVIRONMENT = Object.keys(process.env)
    .filter((processKeyName) => processKeyName.startsWith('MSDyn365_'))
    .reduce((env, key) => {
    env[key] = process.env[key];
    return env;
}, {
    NODE_ENV: process.env.NODE_ENV,
    HOST: process.env.HOST,
    PORT: process.env.PORT,
    PUBLIC_PATH: process.env.PUBLIC_PATH,
    PUBLIC_DIR: process.env.PUBLIC_DIR,
    Views: process.env.Dynamic_View
});
export const loadFeatureFlags = (req, res, next) => {
    // initialize pageResponse default to request.body
    res.locals.pageResponse = req.body;
    if (req.body && req.body.renderingContext && req.body.renderingContext.features) {
        res.locals.features = req.body.renderingContext.features;
    }
    else {
        res.locals.features = {};
    }
    next();
};
export const setCorsHeaders = (req, res, next) => {
    // FEATURE FLAG TO ALLOW ALL CORS REQUESTS
    const allowAllCors = res.locals && res.locals.features && res.locals.features.allowAllCors;
    if (allowAllCors) {
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
        res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
        res.setHeader('Access-Control-Allow-Credentials', 'true');
    }
    next();
};
export const setResponseHeaders = (req, res, next) => {
    if (process.env.NODE_ENV === 'development') {
        // cache bust in local dev scenarios without passing build #
        res.setHeader('Cache-Control', 'max-age=1');
    }
    next();
};
export const getPlatformSettingsSync = () => {
    const platFormSettings = safeReadJsonSync(resolve(keystonePaths.KEYSTONE_APP_SETTINGS_DIR, `platform.settings.json`));
    return platFormSettings ? platFormSettings : {};
};
export const registerAttributeRenderers = (instanceTelemetryClient, moduleInstanceTelemetryClient, requestContext) => {
    // If enable data analytics is turned on, update telemetry objects accordingly
    instanceTelemetryClient.enableDataAnalytics(requestContext.features.enableDataAnalytics);
    moduleInstanceTelemetryClient.enableDataAnalytics(requestContext.features.enableDataAnalytics);
    // Register the exp attribute renderers
    instanceTelemetryClient.registerAttributeRenderer(expAttributeRenderer);
    moduleInstanceTelemetryClient.registerAttributeRenderer(expAttributeRenderer);
};
export const setTelemetryObject = (appInsightsTelemetryClient) => {
    let hasRun = false;
    return (req, res, next) => {
        const requestContext = parseRequest(req);
        const { isDebug } = requestContext.params;
        const options = { isDebug };
        // initialize the static telemetry object only once
        if (!hasRun) {
            hasRun = true;
            StaticTelemetry.registerTraceLogger({ traceLogger: new AppInsightsNodeLogger(appInsightsTelemetryClient) });
        }
        const instanceTelemetryClient = new InternalTelemetry();
        const moduleInstanceTelemetryClient = new Telemetry();
        instanceTelemetryClient.registerTraceLogger({ traceLogger: new AppInsightsNodeLogger(appInsightsTelemetryClient) });
        if (process.env.NODE_ENV === 'development') {
            instanceTelemetryClient.registerTraceLogger({ traceLogger: GenericConsoleLogger, options });
            moduleInstanceTelemetryClient.registerTraceLogger({ traceLogger: GenericConsoleLogger, options });
        }
        if (isDebug) {
            instanceTelemetryClient.registerTraceLogger({ traceLogger: new RetainLogger(), name: GLIMPSE_LOGGER_NAME });
            const pageLogger = new PageLogger();
            moduleInstanceTelemetryClient.registerTraceLogger({ traceLogger: pageLogger, options, name: PAGE_LOGGER_NAME });
            instanceTelemetryClient.registerTraceLogger({ traceLogger: pageLogger, options, name: PAGE_LOGGER_NAME });
        }
        res.locals.telemetry = instanceTelemetryClient;
        res.locals.moduleTelemetry = moduleInstanceTelemetryClient;
        next();
    };
};
/**
 * Page render method, used on pageResponse and request context have been parsed/calulated
 */
export const renderPage = (req, res, next, { clientStats }) => {
    try {
        return renderDefaultRouter(req, res, next, res.locals.pageResponse, res.locals.requestContext, { clientStats });
    }
    catch (e) {
        handleServerException(res, 'Server Exception', e, res.locals.telemetry);
    }
};
/**
 * Helper function to await a promise and wrap in try/catch - used for getting channel configuration. Also sets the
 * `res.local.getOrgUnitConfigurationAsyncResult` property with the actual channel config so it can be retrieved as part
 * of this request
 * @param promiseToAwait
 */
export const awaitChannelConfigPromise = async (res, promiseToAwait, telemetry) => {
    try {
        res.locals.getOrgUnitConfigurationAsyncResult = await promiseToAwait;
    }
    catch (e) {
        if (telemetry && typeof telemetry.log === 'function') {
            telemetry.log(LogLevel.Error, 'error in getting channel configuration', { exception: e });
        }
    }
};
/**
 * Logs an error to application insights and terminates the request
 * @param res               - Express response object
 * @param httpErrorCode     - Http Error code
 * @param message           - Http message
 * @param telemetry         - current internal telemetry
 * @param error             - optional Error object
 */
const sendErrorAndLogToTelemetry = (res, httpErrorCode, message, telemetry, error) => {
    telemetry.log(LogLevel.Error, message, { exception: error });
    res.status(httpErrorCode).send(message);
};
/**
 * Middleware that performs validation logic based on the type of page being rendered
 * @param pageResponse The page response
 */
// tslint:disable-next-line:max-func-body-length cyclomatic-complexity
export const validateRouteAndChannelConfig = async (_req, res, next) => {
    const requestContext = res.locals.requestContext;
    // re-use the request cache for any lookups we do here
    res.locals.requestCache = new RequestCache();
    const actionContext = new ActionContext({
        id: 'Validation Context',
        requestContext: requestContext,
        requestCache: res.locals.requestCache,
        telemetry: res.locals.telemetry,
        // tslint:disable-next-line:no-any
        appCache: msdyn365Commerce.getAppCache(requestContext)
    });
    // kick off the call but dont await it yet
    const getOrgUnitConfigurationAsyncPromise = getOrgUnitConfigurationAsync({ callerContext: actionContext });
    if (!requestContext.urlTokens.pageType) {
        // we always look up channel config
        await awaitChannelConfigPromise(res, getOrgUnitConfigurationAsyncPromise, res.locals.telemetry);
        return next();
    }
    // Validate the page has a page type
    const internalTelemetry = res.locals.telemetry;
    switch (requestContext.urlTokens.pageType.toLowerCase()) {
        // PDP Route Validation
        case PDP_PAGE_NAME:
            // @ts-ignore: recordId URLToken not yet typed
            if (requestContext.urlTokens.recordId) {
                try {
                    // tslint:disable-next-line:prefer-const
                    let product = await getByIdAsync({ callerContext: actionContext }, 
                    // @ts-ignore: recordId URLToken not yet typed
                    +requestContext.urlTokens.recordId, requestContext.apiSettings.channelId);
                    // Array Bug
                    product = Array.isArray(product) ? product[0] : product;
                    if (!(product instanceof Error) && product && product.RecordId) {
                        // await only if we have a successful result
                        await awaitChannelConfigPromise(res, getOrgUnitConfigurationAsyncPromise, res.locals.telemetry);
                        return next();
                    }
                    // Bad Product Response from Retail Server
                    sendErrorAndLogToTelemetry(res, 404, 'Invalid PDP Route: Product Not Found.', internalTelemetry);
                    return;
                }
                catch (error) {
                    sendErrorAndLogToTelemetry(res, 500, 'Invalid PDP Route: Error Validating Product', internalTelemetry, error);
                    return;
                }
            }
            sendErrorAndLogToTelemetry(res, 404, 'Invalid PDP Route: No ProductId Detected', internalTelemetry);
            return;
        // Category Route validation
        case CATEGORY_PAGE_NAME:
            // @ts-ignore: recordId URLToken not yet typed
            const activeCategoryRecordId = +requestContext.urlTokens.recordId;
            if (activeCategoryRecordId) {
                try {
                    const requestedCategory = await getCategoriesAsync({ callerContext: actionContext }, requestContext.apiSettings.channelId)
                        .then(async (response) => {
                        const result = response.find(category => {
                            if (category.RecordId) {
                                return category.RecordId === activeCategoryRecordId;
                            }
                            return false;
                        });
                        if (result) {
                            // await only if we have a successful result
                            return awaitChannelConfigPromise(res, getOrgUnitConfigurationAsyncPromise, res.locals.telemetry).then(() => {
                                return result;
                            });
                        }
                    })
                        .catch(e => {
                        res.locals.telemetry.log(LogLevel.Error, `Error validating category`, { exception: e });
                        throw e;
                    });
                    if (!requestedCategory) {
                        sendErrorAndLogToTelemetry(res, 404, 'Invalid Category Route: Category Not Found', internalTelemetry);
                        return;
                    }
                    return next();
                }
                catch (e) {
                    sendErrorAndLogToTelemetry(res, 500, 'Invalid Category Route: Error Validating Category', internalTelemetry, e);
                    return;
                }
            }
            sendErrorAndLogToTelemetry(res, 404, 'Invalid Category Route: No Categories Found In URL', internalTelemetry);
            return;
        // List Route Validation
        // Strictly Prop Checks: If valid data is provided by CMS, route is good
        case LIST_PAGE_NAME:
            const listData = requestContext.pageData.list;
            if (listData && listData.content && listData.content.items && listData.content.title && listData._id) {
                // await only if we have a successful result
                return awaitChannelConfigPromise(res, getOrgUnitConfigurationAsyncPromise, res.locals.telemetry).then(() => {
                    return next();
                });
            }
            sendErrorAndLogToTelemetry(res, 404, 'Invalid List Route: List Data Invalid', internalTelemetry);
            return;
        default:
            return awaitChannelConfigPromise(res, getOrgUnitConfigurationAsyncPromise, res.locals.telemetry).then(() => {
                return next();
            });
    }
};
/**
 * Checks if a proxy is available while in debug mode and routes all outgoing requests to proxy if possible
 * @param req The Request Object
 * @param res The Response Object
 * @param next The next function
 */
export const detectProxy = (req, res, next) => {
    // Only allow proxy rerouting when in debug mode
    if (process.env.NODE_ENV === 'development' && req.query.debug) {
        axios
            .get(`${DEFAULT_PROXY_HOST}:${DEFAULT_PROXY_PORT}`)
            .then((response) => {
            if (response.status === 200) {
                console.log('Debug Proxy Detected and Enabled for External Requests');
                // This Env variable allows to go through proxy
                // ONLY ENABLE THIS IN DEBUG
                process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
                process.env.NODE_USE_DEBUG_PROXY = '1';
            }
            next();
        })
            .catch((error) => {
            // Reset to defaults if no proxy is detected
            process.env.NODE_TLS_REJECT_UNAUTHORIZED = '1';
            process.env.NODE_USE_DEBUG_PROXY = '0';
            next();
        });
    }
    else {
        // Reset to defaults if debug flag turned off
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = '1';
        process.env.NODE_USE_DEBUG_PROXY = '0';
        next();
    }
};
/**
 * Creates and returns the app cache settings to be used to cache app and key vault secrets
 */
export const getAppSecretsCacheSetings = () => {
    const appSecretsCacheSettings = { ttlInSeconds: {}, ttrInSeconds: {} };
    if (appSecretsCacheSettings.ttlInSeconds) {
        appSecretsCacheSettings.ttlInSeconds[ACCESS_TOKEN_SECRET_CACHE_TYPE] = DEFAULT_ACCESS_TOKEN_SECRET_TTL;
        appSecretsCacheSettings.ttlInSeconds[KEY_VAULT_SECRET_CACHE_TYPE] = DEFAULT_KV_SECRET_TTL;
    }
    if (appSecretsCacheSettings.ttrInSeconds) {
        appSecretsCacheSettings.ttrInSeconds[ACCESS_TOKEN_SECRET_CACHE_TYPE] = DEFAULT_ACCESS_TOKEN_SECRET_TTR;
        appSecretsCacheSettings.ttrInSeconds[KEY_VAULT_SECRET_CACHE_TYPE] = DEFAULT_KV_SECRET_TTR;
    }
    return appSecretsCacheSettings;
};
export const getExperimentsCacheSettings = () => {
    const experimentsCacheSettings = (experimentsSettings && experimentsSettings.experimentation && experimentsSettings.experimentation.cacheConfig) || {};
    if (experimentsCacheSettings.ttlInSeconds) {
        const upperCasedTTLSettings = {};
        Object.keys(experimentsCacheSettings.ttlInSeconds).forEach(entity => {
            // @ts-ignore: TS Compiler not recognizing if check correctly
            upperCasedTTLSettings[entity.toUpperCase()] = experimentsCacheSettings.ttlInSeconds[entity];
        });
        experimentsCacheSettings.ttlInSeconds = upperCasedTTLSettings;
    }
    if (experimentsCacheSettings.ttrInSeconds) {
        const upperCasedTTRSettings = {};
        Object.keys(experimentsCacheSettings.ttrInSeconds).forEach(entity => {
            // @ts-ignore: TS Compiler not recognizing if check correctly
            upperCasedTTRSettings[entity.toUpperCase()] = experimentsCacheSettings.ttrInSeconds[entity];
        });
        experimentsCacheSettings.ttrInSeconds = upperCasedTTRSettings;
    }
    // make sure ttrInSeconds and ttlInSeconds property exist in cache setting with default value
    experimentsCacheSettings.ttlInSeconds = experimentsCacheSettings.ttlInSeconds ? experimentsCacheSettings.ttlInSeconds : {};
    experimentsCacheSettings.ttrInSeconds = experimentsCacheSettings.ttrInSeconds ? experimentsCacheSettings.ttrInSeconds : {};
    experimentsCacheSettings.ttlInSeconds[EXPERIMENTATION_CACHE_TYPE] =
        experimentsCacheSettings.ttlInSeconds[EXPERIMENTATION_CACHE_TYPE] || DEFAULT_EXPERIMENT_TTL;
    experimentsCacheSettings.ttrInSeconds[EXPERIMENTATION_CACHE_TYPE] =
        experimentsCacheSettings.ttrInSeconds[EXPERIMENTATION_CACHE_TYPE] || DEFAULT_EXPERIMENT_TTR;
    experimentsCacheSettings.ttlInSeconds[EXPERIMENTATION_DATAFILE_CACHE_TYPE] =
        experimentsCacheSettings.ttlInSeconds[EXPERIMENTATION_DATAFILE_CACHE_TYPE] || DEFAULT_EXPERIMENT_DATAFILE_TTL;
    experimentsCacheSettings.ttrInSeconds[EXPERIMENTATION_DATAFILE_CACHE_TYPE] =
        experimentsCacheSettings.ttrInSeconds[EXPERIMENTATION_DATAFILE_CACHE_TYPE] || DEFAULT_EXPERIMENT_DATAFILE_TTR;
    return experimentsCacheSettings;
};
export const getCacheSettings = () => {
    const cacheSettings = _merge({}, defaultCacheSettings, overrideCacheSettings);
    if (cacheSettings.ttlInSeconds) {
        const upperCasedTTLSettings = {};
        Object.keys(cacheSettings.ttlInSeconds).forEach(entity => {
            // @ts-ignore: TS Compiler not recognizing if check correctly
            upperCasedTTLSettings[entity.toUpperCase()] = cacheSettings.ttlInSeconds[entity];
        });
        cacheSettings.ttlInSeconds = upperCasedTTLSettings;
    }
    if (cacheSettings.ttrInSeconds) {
        const upperCasedTTRSettings = {};
        Object.keys(cacheSettings.ttrInSeconds).forEach(entity => {
            // @ts-ignore: TS Compiler not recognizing if check correctly
            upperCasedTTRSettings[entity.toUpperCase()] = cacheSettings.ttrInSeconds[entity];
        });
        cacheSettings.ttrInSeconds = upperCasedTTRSettings;
    }
    // make sure ttrInSeconds and ttlInSeconds property exist in cache setting
    cacheSettings.ttlInSeconds = cacheSettings.ttlInSeconds ? cacheSettings.ttlInSeconds : {};
    cacheSettings.ttrInSeconds = cacheSettings.ttrInSeconds ? cacheSettings.ttrInSeconds : {};
    return cacheSettings;
};
export const getRequestUrl = (res) => {
    try {
        if (res.locals &&
            res.locals.pageResponse &&
            res.locals.pageResponse.renderingContext &&
            res.locals.pageResponse.renderingContext.requestUrl) {
            return new URL(res.locals.pageResponse.renderingContext.requestUrl);
        }
        // tslint:disable-next-line:no-empty
    }
    catch { }
    return undefined;
};
export const sanitizeUrlForLogging = (requestUrl) => {
    if (!requestUrl) {
        return '';
    }
    if (requestUrl.pathname.endsWith('.p')) {
        return `${requestUrl.hostname}/~.p`;
    }
    else if (requestUrl.pathname.endsWith('.c')) {
        return `${requestUrl.hostname}~/.c`;
    }
    return requestUrl.href;
};
export const resolveRouteInformation = (res, requestUrl) => {
    const pageType = res.locals.requestContext.urlTokens && res.locals.requestContext.urlTokens.pageType;
    const pageTypeLower = !!pageType ? pageType.toLowerCase() : undefined;
    const originalUrl = requestUrl ? requestUrl.href : '';
    if (originalUrl.endsWith('.p') || pageTypeLower === PDP_PAGE_NAME) {
        return 'PRODUCT_ROUTE';
    }
    else if (originalUrl.endsWith('.c') || pageTypeLower === CATEGORY_PAGE_NAME) {
        return 'CATEGORY_ROUTE';
    }
    else {
        const routeMap = res.locals.pageResponse && res.locals.pageResponse.appContext && res.locals.pageResponse.appContext.routes;
        if (routeMap && requestUrl && requestUrl.pathname) {
            const routeUrl = requestUrl.pathname.toLowerCase();
            for (const key of Object.keys(routeMap)) {
                const routeDestinationUrl = (routeMap[key][DESTINATIONURL] || '').toLowerCase();
                if (routeUrl === routeDestinationUrl) {
                    // Processing request for {route} route
                    return key;
                }
            }
        }
        return 'UNKNOWN_ROUTE';
    }
};
export const getCheckoutRoute = (res) => {
    const routeMap = res.locals.pageResponse && res.locals.pageResponse.appContext && res.locals.pageResponse.appContext.routes;
    if (routeMap && routeMap.checkout && routeMap.checkout[DESTINATIONURL]) {
        return routeMap.checkout[DESTINATIONURL];
    }
    return 'CHECKOUT_ROUTE_UNAVAILABLE';
};
//# sourceMappingURL=platform-utils.js.map
{"version":3,"file":"secret-manager.js","sourceRoot":"","sources":["../../../src/utils/secret-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { ICache, ICacheKey } from '@msdyn365-commerce/cache-internal';\nimport { IDictionary, ISecretManager, ISecretValue } from '@msdyn365-commerce/core-internal';\nimport { LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport axios, { AxiosResponse } from 'axios';\nimport { coerce, lt } from 'semver';\n\n// Cache timings for access and key vault secrets\nexport const DEFAULT_ACCESS_TOKEN_SECRET_TTL = 86400;\nexport const DEFAULT_ACCESS_TOKEN_SECRET_TTR = 500;\nexport const DEFAULT_KV_SECRET_TTL = 86400;\nexport const DEFAULT_KV_SECRET_TTR = 500;\nexport const ACCESS_TOKEN_SECRET_CACHE_TYPE = 'ACCESSTOKEN';\nexport const KEY_VAULT_SECRET_CACHE_TYPE = 'KEYVAULT';\nexport const ACCESS_TOKEN_SECRET_KEY = 'RETAIL_SERVER';\nconst X_IDENTITY_HEADER = 'X-IDENTITY-HEADER';\n\nconst MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS = '9.24.2';\n\nexport enum AppSecretRefreshType {\n    ACCESS_TOKEN = 'ACCESSTOKEN',\n    KEY_VAULT = 'KEYVAULT'\n}\n\nexport interface IAppSecretRefreshOptions {\n    refreshType: AppSecretRefreshType;\n    parameters: string[];\n}\n\n/**\n * SecretManager class exposes one public method used to access customer secrets from key-vault\n * Access token (used to talk to the RS API that will retrive customer secrets) and secrets are cached in\n * an app-cache entry. The instantiated class is available on the global msdyn365Commerce object but only server-side\n */\nexport class SecretManager implements ISecretManager {\n    private _appSecretsCache: ICache;\n    private _localSecrets: IDictionary<string> | undefined;\n\n    constructor(appSecretsCache: ICache, localSecrets?: IDictionary<string>) {\n        this._appSecretsCache = appSecretsCache;\n        this._localSecrets = localSecrets;\n    }\n\n    /**\n     * Returns the customer defined secret value given a secret key.\n     * If the secret key could not be found an empty string is returned\n     *\n     * @param secretKey The secret key\n     */\n    public async getSecretValue(secretKey: string, baseRetailServerURL: string): Promise<ISecretValue> {\n        // In local dev scenario, read the secrets from the local secrets file\n        if (process.env.NODE_ENV === 'development') {\n            return this._localSecrets && this._localSecrets[secretKey]\n                ? { value: this._localSecrets[secretKey], expiresOn: 1 }\n                : {\n                      value: '',\n                      error: new Error(`Unable to find local secrets file or secrey key does not exist in local secrets file.`),\n                      expiresOn: 1\n                  };\n        }\n        // Non web app deployments are not supported for KV access at this time\n        if (process.env.DEPLOYMENT_ENV !== 'WEBAPP') {\n            return { value: '', error: new Error(`KeyVault Access only supported in App Service Environments`), expiresOn: 1 };\n        }\n\n        // If the current retail-proxy version does not support this API return error response\n        if (lt(coerce(process.env.MSDyn365Commerce_RSVERSION) || '', MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS)) {\n            return {\n                value: '',\n                error: new Error(`Retail Proxy version ${MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS} or greater is required`),\n                expiresOn: 1\n            };\n        }\n        const accessTokenCacheKey: ICacheKey = {\n            typeName: ACCESS_TOKEN_SECRET_CACHE_TYPE,\n            key: ACCESS_TOKEN_SECRET_KEY\n        };\n        const keyVaultSecretCacheKey: ICacheKey = {\n            typeName: KEY_VAULT_SECRET_CACHE_TYPE,\n            key: secretKey.toUpperCase()\n        };\n        // Get the cached access token or fetch the new token if it does not exist in the cache/has expired\n        let rsAccessToken = await this._readCachedAppSecrets(accessTokenCacheKey, {\n            refreshType: AppSecretRefreshType.ACCESS_TOKEN,\n            parameters: []\n        });\n        // expiresOn property is the unix timestamp in seconds when token will expire\n        if (!rsAccessToken || rsAccessToken.error || rsAccessToken.expiresOn <= Math.floor(Date.now() / 1000) || rsAccessToken.error) {\n            rsAccessToken = await this._getRSAccessToken();\n            if (rsAccessToken.error) {\n                return rsAccessToken;\n            } else {\n                this._appSecretsCache.put<ISecretValue>(accessTokenCacheKey, { item: rsAccessToken });\n            }\n        }\n        // Use the access token to call the retail server API to retrive customer secret\n        let customerSecretValue = await this._readCachedAppSecrets(keyVaultSecretCacheKey, {\n            refreshType: AppSecretRefreshType.KEY_VAULT,\n            parameters: [rsAccessToken.value, secretKey, baseRetailServerURL]\n        });\n        if (!customerSecretValue || customerSecretValue.error || customerSecretValue.expiresOn <= Math.floor(Date.now() / 1000)) {\n            customerSecretValue = await this._getKVSecretValue(rsAccessToken.value, secretKey, baseRetailServerURL);\n            if (customerSecretValue.error) {\n                return customerSecretValue;\n            } else {\n                this._appSecretsCache.put<ISecretValue>(keyVaultSecretCacheKey, { item: customerSecretValue });\n            }\n        }\n        // Return the secret value\n        return customerSecretValue;\n    }\n\n    private async _readCachedAppSecrets(\n        cacheKey: ICacheKey,\n        appSecretRefreshOptions: IAppSecretRefreshOptions\n    ): Promise<ISecretValue | undefined> {\n        let appSecretsEntry: ISecretValue | undefined;\n        const appSecretsItem = this._appSecretsCache.get<ISecretValue>(cacheKey);\n        if (appSecretsItem && appSecretsItem.shouldRefresh) {\n            // doing background refresh here.\n            // tslint:disable-next-line:no-any\n            const refresh = new Promise<any>((res, rej) => {\n                let newAppSecretsItem;\n                switch (appSecretRefreshOptions.refreshType) {\n                    case AppSecretRefreshType.ACCESS_TOKEN:\n                        newAppSecretsItem = this._getRSAccessToken();\n                        break;\n                    case AppSecretRefreshType.KEY_VAULT:\n                        newAppSecretsItem = this._getKVSecretValue(\n                            appSecretRefreshOptions.parameters[0],\n                            appSecretRefreshOptions.parameters[1],\n                            appSecretRefreshOptions.parameters[2]\n                        );\n                        break;\n                    default:\n                }\n                res(newAppSecretsItem);\n            });\n            refresh\n                .then((newSecretValue: ISecretValue) => {\n                    this._appSecretsCache.put<ISecretValue>(cacheKey, { item: newSecretValue });\n                })\n                .catch(err => {\n                    StaticTelemetry.log(\n                        LogLevel.Error,\n                        `Background refresh for secret manager type ${appSecretRefreshOptions.refreshType.toString()} failed`,\n                        { exception: err }\n                    );\n                });\n        }\n        appSecretsEntry = appSecretsItem ? appSecretsItem.item : undefined;\n        return appSecretsEntry;\n    }\n\n    /**\n     * Fetches the bearer access token that Node will use to authenticate with retail server\n     */\n    private async _getRSAccessToken(): Promise<ISecretValue> {\n        let response: AxiosResponse;\n        try {\n            const clientId = process.env.IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC;\n            if (!clientId) {\n                throw new Error(\n                    `User Assigned MSI Client ID env variable is missing. IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC is not defined`\n                );\n            }\n            const headers: IDictionary<string> = {};\n            headers[X_IDENTITY_HEADER] = `${process.env.IDENTITY_HEADER}`;\n            response = await axios.get(\n                `${process.env.IDENTITY_ENDPOINT}/?resource=https://commerce.dynamics.com&api-version=2019-08-01&client_id=${clientId}`,\n                {\n                    headers: headers\n                }\n            );\n        } catch (err) {\n            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n        if (response && response.data && response.status === 200) {\n            const data = response.data;\n            return { value: data.access_token, expiresOn: data.expires_on };\n        } else {\n            const err = new Error(`Access Token Fetch failed with response ${response?.status}`);\n            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n    }\n\n    /**\n     * Returns the secret value for the given secret key\n     *\n     * @param accessToken The access token obtained from user assigned identity\n     * @param secretKey The secret key\n     * @param baseRsURL The base retail server url where the key was configured\n     */\n    private async _getKVSecretValue(accessToken: string, secretKey: string, baseRsURL: string): Promise<ISecretValue> {\n        let response: AxiosResponse;\n        try {\n            response = await axios.get(`${baseRsURL}Commerce/GetUserDefinedSecretString(secretName='${secretKey}')`, {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`,\n                    OUN: '128'\n                }\n            });\n        } catch (err) {\n            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {\n                exception: err\n            });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n        if (response && response.data && response.status === 200) {\n            const data = response.data;\n            return { value: data.value, expiresOn: Math.floor((Date.now() + 86400000) / 1000) };\n        } else {\n            const err = new Error(`Key value fetch failed with response ${response?.status}`);\n            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {\n                exception: err\n            });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n    }\n}\n"]}
import { cloneDeep as _cloneDeep, get as _get } from 'lodash';
import { MODULE_ACTION_KEY, MODULE_CACHE_KEY, MODULE_CONFIG_ERRORS_KEY, MODULE_CONFIG_KEY, MODULE_DATA_KEY, MODULE_DEFERRED_KEY } from '../consts';
/**
 * Resolves any image/video types in the module config as given by authoring in a fragment or a module
 * into what is required to render these images/videos on SDK side
 */
export const resolveTypesInConfig = (config, moduleId, moduleType, moduleLayout, themeSettings) => {
    resolveTypesInConfigHelper(config, moduleId, moduleType, moduleLayout, [], themeSettings);
};
const resolveTypesInConfigHelper = (obj, moduleId, moduleType, moduleLayout, pathToField, themeSettings) => {
    if (!obj) {
        return;
    }
    else if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
            resolveTypesInConfigHelper(obj[i], moduleId, moduleType, moduleLayout, pathToField.concat([`${i}`]), themeSettings);
        }
    }
    else if (typeof obj === 'object' && obj) {
        Object.keys(obj).forEach((value) => {
            const updatedPathToField = pathToField.concat([`${value}`]);
            if (obj[value].type === 'imageFileData') {
                const imageData = obj[value];
                // Construct the viewport image settings information using the current theme and module
                const viewportInfo = constructViewportInformationForImage(moduleType, moduleLayout, updatedPathToField, imageData.binaryMetadata?.quality || 80, themeSettings, imageData.binaryMetadata?.focalRegion, imageData.binaryMetadata?.cropRegions, imageData.binaryMetadata?.extension).viewports;
                obj[value] = {
                    src: imageData.publicUrl,
                    $type: 'image',
                    altText: imageData.variantInfo?.variantProperties?.altText,
                    title: imageData.variantInfo?.variantProperties?.title,
                    imageSettings: {
                        quality: imageData.binaryMetadata?.quality,
                        viewports: viewportInfo
                    }
                };
            }
            else if (obj[value].type === 'videoFileData') {
                const authoringVideoData = obj[value];
                const videoData = {
                    binaryReferences: authoringVideoData.binaryMetadata?.binaryReferences,
                    title: authoringVideoData.binaryMetadata?.title,
                    playTime: authoringVideoData.binaryMetadata?.playtime,
                    fileName: authoringVideoData.sourceUrl,
                    interactiveTriggersEnabled: authoringVideoData.variantProperties?.interactiveTriggersEnabled,
                    thumbnail: {
                        $type: 'image',
                        source: authoringVideoData.thumbnailUrl,
                        imageQuality: '80',
                        altText: authoringVideoData.binaryMetadata?.thumbnail?.title,
                        title: authoringVideoData.binaryMetadata?.thumbnail?.altText
                    }
                };
                obj[value] = constructVideoInformation(videoData, moduleId);
            }
            else {
                resolveTypesInConfigHelper(obj[value], moduleId, moduleType, moduleLayout, updatedPathToField, themeSettings);
            }
        });
    }
};
/**
 * Constructs the viewport information for an image using the current module and theme settings
 * Also constructs the query string for the image resizer
 *
 * @param moduleId The id of the module
 * @param moduleConfig The config object for the module
 * @param pathToField The path to the image the field
 * @param quality The image quality selected
 * @param themeSettings The current theme settings
 * @param focalRegion The image focal region settings
 * @param cropRegions The image crop region per layout/viewport settings
 * @param format The image format
 */
export const constructViewportInformationForImage = (moduleName, moduleLayout, pathToField, quality, themeSettings, focalRegion = {}, cropRegions = [], format) => {
    const imageSettings = {
        viewports: {
            xs: {
                width: 800,
                height: 600
            },
            sm: {
                width: 1200,
                height: 900
            },
            md: {
                width: 1600,
                height: 900
            },
            lg: {
                width: 1600,
                height: 700
            },
            xl: {
                width: 1600,
                height: 700
            }
        }
    };
    // Drill down into the theme settings object for the current module, current module layout and image property name
    if (themeSettings && themeSettings.modules && moduleLayout) {
        const themeSettingsForModule = themeSettings.modules[moduleName];
        if (themeSettingsForModule) {
            const themeSettingsForLayout = themeSettingsForModule.properties[moduleLayout];
            if (themeSettingsForLayout) {
                const imageViewportProperties = _get(themeSettingsForLayout.properties, pathToField, { properties: imageSettings })
                    .properties;
                // Clone the image viewport properties from theme settings
                // so that the proxy traps do not affect the global themesettings
                imageSettings.viewports = _cloneDeep(imageViewportProperties);
            }
        }
    }
    // Construct the query string to use for the image resizer given the width, height and quality selected
    Object.keys(imageSettings.viewports).forEach((viewport) => {
        const currentViewport = imageSettings.viewports[viewport];
        const width = getWidth(currentViewport);
        const height = getHeight(currentViewport);
        currentViewport.q = constructImageQueryString(width, height, quality, focalRegion, cropRegions, moduleName, moduleLayout, pathToField, viewport, format);
    });
    return imageSettings;
};
const getWidth = (currentViewport) => {
    if (currentViewport.w) {
        return currentViewport.w;
    }
    else if (currentViewport.width) {
        return currentViewport.width;
    }
    return undefined;
};
const getHeight = (currentViewport) => {
    if (currentViewport.h) {
        return currentViewport.h;
    }
    else if (currentViewport.height) {
        return currentViewport.height;
    }
    return undefined;
};
/**
 * Constructs the image resizer query param string
 * taking into account width, height, quality, focal point and crop regions
 */
const constructImageQueryString = (width, height, quality, focalRegion, cropRegions, moduleName, moduleLayout, pathToField, viewport, format) => {
    // Set the base properties
    const resizerProperties = {
        w: width,
        h: height,
        q: quality,
        m: '6'
    };
    // If focal region properties exist set the focal point information
    if (focalRegion && focalRegion.x1 && focalRegion.y1) {
        resizerProperties.o = 't';
        resizerProperties.x = `${focalRegion.x1}`;
        resizerProperties.y = `${focalRegion.y1}`;
    }
    const pathToFieldString = pathToField.join('|');
    const cropRegion = cropRegions.find((value) => value.name === `${moduleName}|${moduleLayout}|${pathToFieldString}|${viewport}|${width}x${height}`);
    // If crop region exists for the particular viewport and layout
    // If both focal and crop region information exist, crop region takes precedence
    if (cropRegion) {
        resizerProperties.o = undefined;
        resizerProperties.m = '8';
        resizerProperties.x = `${cropRegion.left}`;
        resizerProperties.y = `${cropRegion.top}`;
        resizerProperties.s = `${cropRegion.width}`;
        resizerProperties.d = `${cropRegion.height}`;
    }
    // Add format information if available
    if (format) {
        resizerProperties.f = format.slice(1);
    }
    let queryString = '';
    Object.keys(resizerProperties).forEach((key) => {
        if (resizerProperties[key]) {
            queryString += `${key}=${resizerProperties[key]}&`;
        }
    });
    // Remove trailing ampersand if length greater than 0
    return queryString.length > 0 ? queryString.slice(0, -1) : queryString;
};
// Moves an element in the given array to the newIndex,
// pushing all elements after the new index to the right
export const moveArrayItem = (array, newIndex, newElement) => {
    array.splice(newIndex, 0, newElement);
};
/**
 * Deletes all the cache entries for a specific module id
 *
 * @param moduleId The module id of the module whose cache entries are to be deleted
 * @param cache The cache object
 */
export const deleteCacheEntriesForModuleId = (moduleId, cache) => {
    // Delete module from all cache types
    cache.del({ typeName: MODULE_CONFIG_ERRORS_KEY, key: moduleId });
    cache.del({ typeName: MODULE_CONFIG_KEY, key: moduleId });
    cache.del({ typeName: MODULE_CACHE_KEY, key: moduleId });
    cache.del({ typeName: MODULE_ACTION_KEY, key: moduleId });
    cache.del({ typeName: MODULE_DATA_KEY, key: moduleId });
    cache.del({ typeName: MODULE_DEFERRED_KEY, key: moduleId });
};
/**
 * Constructs a video object used to render a video using data given by authoring
 *
 * @param videoData The video data given by authoring
 * @param moduleId The module id of the module for which this information is being constructed
 */
export const constructVideoInformation = (videoData, moduleId, id) => {
    // Used to generate unique keys so that even reused module ID will still trigger re-render of player component
    const uniqueTime = new Date().getTime();
    return {
        $type: 'video',
        id: `${moduleId}:${uniqueTime}`,
        _links: {
            binaryReferences: videoData.binaryReferences
        },
        playTime: videoData.playTime,
        title: videoData.title,
        fileName: videoData.fileName,
        thumbnail: {
            $type: 'image',
            src: videoData.thumbnail.source,
            title: videoData.thumbnail.title,
            quality: videoData.thumbnail.imageQuality
        },
        interactiveTriggersEnabled: videoData.interactiveTriggersEnabled || false
    };
};
/**
 * Gets the property value of the specified property key
 * from a data-i attribute string
 *
 * @param dataIAttribute data-i attribute string
 * @param key property key
 */
export const getPropertyFromDataIAttribute = (dataIAttribute, key) => {
    dataIAttribute = dataIAttribute.slice(1, -1);
    const properties = dataIAttribute?.split(',');
    const obj = {};
    properties?.forEach((property) => {
        const keyValuePairs = property.split(':');
        obj[keyValuePairs[0]] = keyValuePairs[1];
    });
    return obj[key];
};
//# sourceMappingURL=authoring-tools-helper-utils.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { msdyn365Commerce, SDK_FRAGMENT_NAME, SDK_FRAGMENT_NAME_REGEX } from '@msdyn365-commerce/core-internal';
import { EXCEPTION_EXPECTED501, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import * as fs from 'fs';
import { getCurrency } from 'locale-currency';
import { escape } from 'lodash';
import * as path from 'path';
import { renderToString } from 'react-dom/server';
import * as semver from 'semver';
import { HttpException } from '../_server/error';
export const MODULE_ERROR_TYPE_NAME_FOR_CACHE = '__ME';
export const EMPTY_MODULE_RESULT_VALUE = 'empty-module-result';
export const UNREGISTERED_MODULE_VALUE = 'unregistered-module';
// Used to deprecate older modules starting SSK V2
export const SSK2_VERSION = '2.0.0';
/**
 * Creates and returns an ICacheKey object for storing
 * results of module render errors inside the RequestCache
 *
 * @param id The id of the module that encountered an error
 */
export const createCacheKeyForModuleError = (id) => {
    return { typeName: MODULE_ERROR_TYPE_NAME_FOR_CACHE, key: id };
};
/**
 * Creates and returns an ICacheItem object that inidcates
 * a module render result was null or empty
 */
export const createCacheValueForEmptyModule = () => {
    return { item: EMPTY_MODULE_RESULT_VALUE };
};
/**
 * Creates and returns an ICacheItem object that inidcates
 * a module was unregistered and thus not rendered
 */
export const createCacheValueForUnregisteredModule = () => {
    return { item: UNREGISTERED_MODULE_VALUE };
};
/**
 * Utility function to async check if file exists
 * @param filePath file path to check
 */
export const fileExists = async (filePath, telemetry) => {
    return new Promise((resolve, reject) => {
        if (!filePath) {
            resolve(undefined);
        }
        fs.access(filePath, fs.constants.R_OK, (err) => {
            if (err) {
                resolve(undefined);
            }
            resolve(filePath);
        });
    });
};
/**
 * Utility function to access the site builder rendering helper
 */
export const getRenderingHelper = () => {
    // @ts-ignore
    return window._msdyn365.authoringHelper && window._msdyn365.authoringHelper.renderingHelper;
};
/**
 * Converts a readable stream (that has yet to emit 'data') to a string
 *
 * @param stream Stream-like object
 */
export const streamToString = (stream) => {
    return new Promise((resolve) => {
        const stringParts = [];
        stream.on('data', (buffer) => {
            stringParts.push(buffer.toString());
        });
        stream.on('end', () => {
            resolve(stringParts.join(''));
        });
    });
};
/**
 * Checks is value is truthy
 * @param value value to check
 */
export const isTruthy = (value) => {
    if (value === undefined || value === null) {
        return false;
    }
    switch (String(value).toLocaleLowerCase()) {
        case '1':
        case 'true':
        case 'yes':
            return true;
        case '0':
        case 'false':
        case 'no':
        case 'undefined':
        case '':
            return false;
        default:
            return !!value;
    }
};
/**
 * Checks optional QSP value and returns as a structured type
 *
 * @param qspValue QSP value to check
 */
export const parseToQSPObject = (qspValue) => {
    return {
        hasValue: qspValue !== undefined,
        isTruthy: isTruthy(String(qspValue)),
        value: qspValue
    };
};
/**
 * Server has whitelisting of QSPs, so QSPs going through Server have be put beind a whitelisted QSP such as item.
 *
 * Example:
 *  In localhost, we'll have `?debug=true` but when running through Server, this is equivalent to ?item=debug:true
 *
 * This method also supports parsing out a comma separated item list, makes assumption that everything is properly URIEncoded
 *  e.g. ?item=debug:true,foo:bar,bar:123
 *
 * @param itemQueryString the `item` query string value
 */
export const parseItemQSP = (itemQueryString) => {
    const result = {};
    if (itemQueryString === undefined || itemQueryString === null) {
        return result;
    }
    const decodedUriParts = decodeURIComponent(itemQueryString).split(',');
    decodedUriParts.forEach((qsp) => {
        const qspParts = qsp.split(':');
        if (qspParts && qspParts.length === 2) {
            const [key, value] = qspParts;
            if (key.length && value.length) {
                result[key] = value;
            }
        }
    });
    return result;
};
export const LinkTag = (baseUrl, preloadAttribute) => (src) => `<link rel="stylesheet" href="${baseUrl}${src}" ${preloadAttribute} crossOrigin="anonymous" />`;
export const CommentTag = (comment) => {
    if (typeof comment === 'object') {
        return Object.keys(comment)
            .map(key => `<!-- key: ${escape(key)}, value: ${escape(JSON.stringify(comment[key]))} -->`)
            .join('');
    }
    return `<!-- ${escape(comment)} -->`;
};
// tslint:disable:no-any
/**
 * Wraps express routes and makes sure to catch & rethrow any errors.
 * Actual handling will be done by the handlerServerError method that logs error and sends response
 * @param fn Function for wrapped route
 */
export const safeRoute = fn => (...args) => fn(...args).catch((error) => {
    args[2] && args[2](error);
});
// tslint:enable:no-any
/**
 * Sample helper
 * @param res Response
 */
export const throwHelper = (req, res, next, message) => {
    throw new HttpException(501, StaticTelemetry.stringFormat(EXCEPTION_EXPECTED501, [message]));
};
export const getAbsoluteUri = (req) => {
    return `${req.protocol}://${req.get('host')}${req.originalUrl}`;
};
/**
 * Wrapped render to string method that replaces the SDK Fragment element with nothing
 * used as a drop-in for renderToString on elements where we blindly set innerHTML.
 *
 * @param element the element to render
 */
// tslint:disable-next-line:no-any
export const patchedRenderToString = (element, disableServerSideErrorChecking) => {
    const renderResult = renderToString(element);
    if (disableServerSideErrorChecking || !renderResult.startsWith(`<${SDK_FRAGMENT_NAME}`)) {
        return renderResult;
    }
    return renderResult.replace(SDK_FRAGMENT_NAME_REGEX, '');
};
export const CurrencyCodeIdentifier = 'cc';
export const getCurrencyCodeFromContext = (requestContext) => {
    return ((requestContext && requestContext.query && requestContext.query[CurrencyCodeIdentifier]) ||
        (requestContext.cookies && requestContext.cookies.get(CurrencyCodeIdentifier).value) ||
        (requestContext.channel && requestContext.channel.Currency) ||
        getCurrency(requestContext.locale));
};
/**
 * Extracts the name of the module from the path to its definition file
 * @param definitionPath path to the definition file
 */
export const getModuleName = (definitionPath) => {
    if (!definitionPath || definitionPath === '') {
        return '';
    }
    return path.basename(definitionPath, ".definition.json" /* DEFINITION_FILE */);
};
/**
 * Returns the binder object for the given module
 * @param typeName name of the module
 */
export const getModuleBinder = (typeName) => msdyn365Commerce.moduleBinder(typeName);
/**
 * Returns name of the parent module for given module name
 * @param moduleName name of the module
 */
export const getParentModuleName = (moduleName) => {
    const moduleBinder = getModuleBinder(moduleName);
    if (!moduleBinder) {
        return '';
    }
    return getModuleName(moduleBinder.parentDefinitionPath);
};
export const isSSK2App = () => {
    const sskVersion = !process.env.MSDyn365Commerce_SSK_VERSION || process.env.MSDyn365Commerce_SSK_VERSION === '--'
        ? '0.0'
        : process.env.MSDyn365Commerce_SSK_VERSION;
    return semver.gt(semver.coerce(sskVersion) || '', SSK2_VERSION);
};
//# sourceMappingURL=helpers.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import axios from 'axios';
import { coerce, lt } from 'semver';
// Cache timings for access and key vault secrets
export const DEFAULT_ACCESS_TOKEN_SECRET_TTL = 86400;
export const DEFAULT_ACCESS_TOKEN_SECRET_TTR = 500;
export const DEFAULT_KV_SECRET_TTL = 86400;
export const DEFAULT_KV_SECRET_TTR = 500;
export const ACCESS_TOKEN_SECRET_CACHE_TYPE = 'ACCESSTOKEN';
export const KEY_VAULT_SECRET_CACHE_TYPE = 'KEYVAULT';
export const ACCESS_TOKEN_SECRET_KEY = 'RETAIL_SERVER';
const X_IDENTITY_HEADER = 'X-IDENTITY-HEADER';
const MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS = '9.24.2';
export var AppSecretRefreshType;
(function (AppSecretRefreshType) {
    AppSecretRefreshType["ACCESS_TOKEN"] = "ACCESSTOKEN";
    AppSecretRefreshType["KEY_VAULT"] = "KEYVAULT";
})(AppSecretRefreshType || (AppSecretRefreshType = {}));
/**
 * SecretManager class exposes one public method used to access customer secrets from key-vault
 * Access token (used to talk to the RS API that will retrive customer secrets) and secrets are cached in
 * an app-cache entry. The instantiated class is available on the global msdyn365Commerce object but only server-side
 */
export class SecretManager {
    constructor(appSecretsCache, localSecrets) {
        this._appSecretsCache = appSecretsCache;
        this._localSecrets = localSecrets;
    }
    /**
     * Returns the customer defined secret value given a secret key.
     * If the secret key could not be found an empty string is returned
     *
     * @param secretKey The secret key
     */
    async getSecretValue(secretKey, baseRetailServerURL) {
        // In local dev scenario, read the secrets from the local secrets file
        if (process.env.NODE_ENV === 'development') {
            return this._localSecrets && this._localSecrets[secretKey]
                ? { value: this._localSecrets[secretKey], expiresOn: 1 }
                : {
                    value: '',
                    error: new Error(`Unable to find local secrets file or secrey key does not exist in local secrets file.`),
                    expiresOn: 1
                };
        }
        // Non web app deployments are not supported for KV access at this time
        if (process.env.DEPLOYMENT_ENV !== 'WEBAPP') {
            return { value: '', error: new Error(`KeyVault Access only supported in App Service Environments`), expiresOn: 1 };
        }
        // If the current retail-proxy version does not support this API return error response
        if (lt(coerce(process.env.MSDyn365Commerce_RSVERSION) || '', MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS)) {
            return {
                value: '',
                error: new Error(`Retail Proxy version ${MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS} or greater is required`),
                expiresOn: 1
            };
        }
        const accessTokenCacheKey = {
            typeName: ACCESS_TOKEN_SECRET_CACHE_TYPE,
            key: ACCESS_TOKEN_SECRET_KEY
        };
        const keyVaultSecretCacheKey = {
            typeName: KEY_VAULT_SECRET_CACHE_TYPE,
            key: secretKey.toUpperCase()
        };
        // Get the cached access token or fetch the new token if it does not exist in the cache/has expired
        let rsAccessToken = await this._readCachedAppSecrets(accessTokenCacheKey, {
            refreshType: AppSecretRefreshType.ACCESS_TOKEN,
            parameters: []
        });
        // expiresOn property is the unix timestamp in seconds when token will expire
        if (!rsAccessToken || rsAccessToken.error || rsAccessToken.expiresOn <= Math.floor(Date.now() / 1000) || rsAccessToken.error) {
            rsAccessToken = await this._getRSAccessToken();
            if (rsAccessToken.error) {
                return rsAccessToken;
            }
            else {
                this._appSecretsCache.put(accessTokenCacheKey, { item: rsAccessToken });
            }
        }
        // Use the access token to call the retail server API to retrive customer secret
        let customerSecretValue = await this._readCachedAppSecrets(keyVaultSecretCacheKey, {
            refreshType: AppSecretRefreshType.KEY_VAULT,
            parameters: [rsAccessToken.value, secretKey, baseRetailServerURL]
        });
        if (!customerSecretValue || customerSecretValue.error || customerSecretValue.expiresOn <= Math.floor(Date.now() / 1000)) {
            customerSecretValue = await this._getKVSecretValue(rsAccessToken.value, secretKey, baseRetailServerURL);
            if (customerSecretValue.error) {
                return customerSecretValue;
            }
            else {
                this._appSecretsCache.put(keyVaultSecretCacheKey, { item: customerSecretValue });
            }
        }
        // Return the secret value
        return customerSecretValue;
    }
    async _readCachedAppSecrets(cacheKey, appSecretRefreshOptions) {
        let appSecretsEntry;
        const appSecretsItem = this._appSecretsCache.get(cacheKey);
        if (appSecretsItem && appSecretsItem.shouldRefresh) {
            // doing background refresh here.
            // tslint:disable-next-line:no-any
            const refresh = new Promise((res, rej) => {
                let newAppSecretsItem;
                switch (appSecretRefreshOptions.refreshType) {
                    case AppSecretRefreshType.ACCESS_TOKEN:
                        newAppSecretsItem = this._getRSAccessToken();
                        break;
                    case AppSecretRefreshType.KEY_VAULT:
                        newAppSecretsItem = this._getKVSecretValue(appSecretRefreshOptions.parameters[0], appSecretRefreshOptions.parameters[1], appSecretRefreshOptions.parameters[2]);
                        break;
                    default:
                }
                res(newAppSecretsItem);
            });
            refresh
                .then((newSecretValue) => {
                this._appSecretsCache.put(cacheKey, { item: newSecretValue });
            })
                .catch(err => {
                StaticTelemetry.log(LogLevel.Error, `Background refresh for secret manager type ${appSecretRefreshOptions.refreshType.toString()} failed`, { exception: err });
            });
        }
        appSecretsEntry = appSecretsItem ? appSecretsItem.item : undefined;
        return appSecretsEntry;
    }
    /**
     * Fetches the bearer access token that Node will use to authenticate with retail server
     */
    async _getRSAccessToken() {
        let response;
        try {
            const clientId = process.env.IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC;
            if (!clientId) {
                throw new Error(`User Assigned MSI Client ID env variable is missing. IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC is not defined`);
            }
            const headers = {};
            headers[X_IDENTITY_HEADER] = `${process.env.IDENTITY_HEADER}`;
            response = await axios.get(`${process.env.IDENTITY_ENDPOINT}/?resource=https://commerce.dynamics.com&api-version=2019-08-01&client_id=${clientId}`, {
                headers: headers
            });
        }
        catch (err) {
            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });
            return { value: '', error: err, expiresOn: 1 };
        }
        if (response && response.data && response.status === 200) {
            const data = response.data;
            return { value: data.access_token, expiresOn: data.expires_on };
        }
        else {
            const err = new Error(`Access Token Fetch failed with response ${response?.status}`);
            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });
            return { value: '', error: err, expiresOn: 1 };
        }
    }
    /**
     * Returns the secret value for the given secret key
     *
     * @param accessToken The access token obtained from user assigned identity
     * @param secretKey The secret key
     * @param baseRsURL The base retail server url where the key was configured
     */
    async _getKVSecretValue(accessToken, secretKey, baseRsURL) {
        let response;
        try {
            response = await axios.get(`${baseRsURL}Commerce/GetUserDefinedSecretString(secretName='${secretKey}')`, {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    OUN: '128'
                }
            });
        }
        catch (err) {
            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {
                exception: err
            });
            return { value: '', error: err, expiresOn: 1 };
        }
        if (response && response.data && response.status === 200) {
            const data = response.data;
            return { value: data.value, expiresOn: Math.floor((Date.now() + 86400000) / 1000) };
        }
        else {
            const err = new Error(`Key value fetch failed with response ${response?.status}`);
            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {
                exception: err
            });
            return { value: '', error: err, expiresOn: 1 };
        }
    }
}
//# sourceMappingURL=secret-manager.js.map
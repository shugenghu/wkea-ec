/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
'use strict';
import { asSystemMetadata, EXCEPTION_BADCONFIGPASSED, EXCEPTION_JSONPARSEFAILED, EXCEPTION_NOTYPEQUERY, LogLevel, MESSAGE_INVALIDJSONPATH, MESSAGE_MOCKSNOTFOUND, MESSAGE_NEWCHILDPROP, MESSAGE_OVERRIDE_MODULE_CONFIG, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { safeFileExists, safeGetAllFilesPath, safeReadJson } from '@msdyn365-commerce/utilities-internal';
import * as JsonPointer from 'jsonpointer';
import { memoize } from 'lodash';
import path from 'path';
import keystonePaths from '../paths';
import { MODULE_QUERY_PARAMETER_SEPARATOR, MODULE_QUERY_PROPERTY_SEPARATOR, validateAndGetOverrideData } from '../utils/query-utils';
/**
 * Captures mock ids from query parameters
 * @param query Dictionary of query parameters
 * @returns array of module mock ids
 */
export const getMockIdFromRequest = (query) => {
    const typeQuery = query.type;
    if (!typeQuery) {
        throw new Error(EXCEPTION_NOTYPEQUERY);
    }
    return typeQuery.split(MODULE_QUERY_PARAMETER_SEPARATOR);
};
/**
 * Parses the payload
 * @param content stringified version of paryload
 * @returns JSON object
 */
export const parsePayload = (content) => {
    try {
        return typeof content === 'string' ? JSON.parse(content) : content;
    }
    catch (error) {
        StaticTelemetry.log(LogLevel.Debug, EXCEPTION_JSONPARSEFAILED, { values: [asSystemMetadata(content)] });
        throw new Error(EXCEPTION_JSONPARSEFAILED);
    }
};
export const getOverrideProperties = (query, telemetry) => {
    try {
        if (query.config) {
            const configQuery = decodeURIComponent(query.config);
            return validateAndGetOverrideData(configQuery, telemetry);
        }
    }
    catch (e) {
        telemetry.log(LogLevel.Error, telemetry.stringFormat(EXCEPTION_BADCONFIGPASSED, [query.config]), { exception: e });
        return null;
    }
    return null;
};
export const overrideMockDataIfNeeded = (mockId, mockModule, queryStrings, telemetry) => {
    const overrideProp = getOverrideProperties(queryStrings, telemetry);
    // Expected pattern to edit a property of a module is <module_name>/<json_pointer_path>/<value>
    // eg1: partner-hero/dataBinder/BannerDataBinder
    // eg2: partner-hero/dataProviders/0/data/Items/0/PrimaryImage/Width/200
    if (overrideProp) {
        if (mockId === overrideProp.moduleName && JsonPointer.get(mockModule, overrideProp.jsonPath)) {
            JsonPointer.set(mockModule, overrideProp.jsonPath, overrideProp.value);
            telemetry.log(LogLevel.Debug, telemetry.stringFormat(MESSAGE_OVERRIDE_MODULE_CONFIG, [overrideProp.jsonPath, overrideProp.value, mockId]));
        }
        else {
            // Get the parent json pointer path
            // eg: parent path of partner-hero/config/size is partner-hero/config
            const parentPathPosition = overrideProp.jsonPath.lastIndexOf(MODULE_QUERY_PROPERTY_SEPARATOR);
            const parentPath = overrideProp.jsonPath.substring(0, parentPathPosition);
            const parentValue = JsonPointer.get(mockModule, parentPath);
            if (parentValue) {
                const newChildProperty = overrideProp.jsonPath.substring(parentPathPosition + 1, overrideProp.jsonPath.length);
                parentValue[`${newChildProperty}`] = overrideProp.value;
                JsonPointer.set(mockModule, parentPath, parentValue);
                telemetry.log(LogLevel.Debug, telemetry.stringFormat(MESSAGE_NEWCHILDPROP, [newChildProperty, parentPath, mockId]));
            }
            else {
                telemetry.log(LogLevel.Debug, telemetry.stringFormat(MESSAGE_INVALIDJSONPATH, [parentPath, mockId]));
            }
        }
    }
    return mockModule;
};
const readMockFile = async (mockFilePath) => {
    let mockFile;
    try {
        mockFile = await safeReadJson(mockFilePath);
    }
    catch {
        return undefined;
    }
    return mockFile;
};
/**
 * Searches for mock regiserted under module name. First checks partner mocks from source then microsoft-modules.
 * @param moduleName
 * @param mock
 */
export const searchForMock = async (moduleName, mock) => {
    const partnerModuleMockPath = path.resolve(keystonePaths.KEYSTONE_MODULE_MOCKS_DIR, `${moduleName}/`, `${mock}.json`);
    if (await safeFileExists(partnerModuleMockPath)) {
        return partnerModuleMockPath;
    }
    const moduleRoot = path.resolve(keystonePaths.KEYSTONE_NODE_MODULES_DIR, `${moduleName}`);
    const mockPattern = `@(dist|build|src)/**/mocks/${mock}.json`;
    const opts = {
        cwd: moduleRoot
    };
    const mocks = await safeGetAllFilesPath(mockPattern, opts);
    if (mocks.length) {
        // file has been found
        return path.resolve(keystonePaths.KEYSTONE_NODE_MODULES_DIR, `${moduleName}`, mocks[0]);
    }
    return false;
};
/**
 * Retrives a mocked module from file without overrides
 * @returns Parsed module if found otherwise false.
 */
let getMockModule = async (moduleName, mock) => {
    const moduleMockFilePathForModule = await searchForMock(moduleName, mock);
    if (!moduleMockFilePathForModule) {
        return false;
    }
    const moduleFile = await readMockFile(moduleMockFilePathForModule);
    if (!moduleFile || moduleFile.length <= 0) {
        return false;
    }
    return parsePayload(moduleFile);
};
export const getV3mockPageJson = () => {
    return parsePayload({
        pageRoot: {
            bodyClass: 'this should be body class',
            modules: {
                htmlHead: [],
                bodyBegin: [],
                body: [
                    {
                        modules: {
                            primary: [
                                {
                                    modules: {
                                        content: []
                                    },
                                    id: 'primaryRegion',
                                    typeName: 'default-container'
                                }
                            ]
                        },
                        id: 'page',
                        config: {},
                        typeName: 'default-page'
                    }
                ],
                bodyEnd: [],
                app: []
            },
            id: 'coreroot',
            typeName: 'core-root'
        },
        renderingContext: {
            gridSettings: {
                xs: { w: 768 },
                sm: { w: 992 },
                md: { w: 1200 },
                lg: { w: 1600 },
                xl: { w: 1800 }
            }
        }
    });
};
const getMockModuleWithOverride = async (mockId, index, mocksNotFound, idSet, queryStrings, telemetry) => {
    const mockIdString = mockId.toString();
    const queryArg = mockIdString.split(':');
    const moduleName = queryArg[0];
    const mock = queryArg[1] || moduleName;
    let mockModule = await getMockModule(moduleName, mock);
    if (!mockModule) {
        mocksNotFound.push(mockId);
        return;
    }
    // any necessary here as type varies by module
    mockModule = overrideMockDataIfNeeded(mock, mockModule, queryStrings, telemetry);
    // Populate page with mock
    const id = mockModule.id;
    if (id && idSet.has(id)) {
        mockModule.id = mockModule.id.concat(index.toString());
    }
    idSet.add(mockModule.id);
    return mockModule;
};
let getMockDataBasedOnRequestQueryString = async (queryStrings, telemetry) => {
    const mockIds = getMockIdFromRequest(queryStrings);
    if (mockIds.length < 1 || (mockIds.length === 1 && mockIds[0] === '')) {
        throw new Error(EXCEPTION_NOTYPEQUERY);
    }
    // Get the default mock page json
    const pageJsonV3 = getV3mockPageJson();
    const idSet = new Set();
    // For each mock id, populate page
    const mocksNotFound = [];
    // Create a list of promises to fetch the module mocks and then resolve all using Promise all
    const modulePromises = mockIds.map((mockId, index) => {
        return getMockModuleWithOverride(mockId, index, mocksNotFound, idSet, queryStrings, telemetry);
    });
    return Promise.all(modulePromises).then(mockModules => {
        // Loop through the list of returned mock modules, if the module is defined
        // add it to the page json
        for (let i = 0; i < mockModules.length; i++) {
            const curModule = mockModules[i];
            if (curModule) {
                // @ts-ignore
                pageJsonV3.pageRoot.modules.body[0].modules.primary[0].modules.content.push(curModule);
                // Add properties from module mocks rendering context if provided
                pageJsonV3.renderingContext = { ...pageJsonV3.renderingContext, ...curModule.renderingContext };
            }
        }
        // If there were mocks that weren't found, add those at the end and log an error message
        if (mocksNotFound.length > 0 && queryStrings.debug) {
            mocksNotFound.forEach((mockNotFound, index) => {
                // @ts-ignore
                pageJsonV3.pageRoot.modules.body[0].modules.primary[0].modules.content.push({
                    id: `${mockNotFound}-${index}`,
                    typeName: mockNotFound,
                    data: {},
                    dataActions: [],
                    config: {}
                });
            });
            telemetry.log(LogLevel.Warning, telemetry.stringFormat(MESSAGE_MOCKSNOTFOUND, [mocksNotFound.join()]));
        }
        return pageJsonV3;
    });
};
if (process.env.NODE_ENV === 'production') {
    getMockModule = memoize(getMockModule, (moduleName, mock) => {
        return `${moduleName}${mock}`;
    });
    getMockDataBasedOnRequestQueryString = memoize(getMockDataBasedOnRequestQueryString, (queryString) => {
        return JSON.stringify(queryString);
    });
}
export { getMockModule, getMockDataBasedOnRequestQueryString };
//# sourceMappingURL=mock-helper.js.map
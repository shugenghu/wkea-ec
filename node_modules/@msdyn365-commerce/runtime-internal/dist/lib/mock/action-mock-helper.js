/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { safeFileExists, safeGetAllFilesPath, safeReadJson } from '@msdyn365-commerce/utilities-internal';
import { each as _each, flatten as _flatten, get as _get } from 'lodash';
import { resolve } from 'path';
import { EXCEPTION_NO_MOCKS_FOUND, LogLevel } from '@msdyn365-commerce/telemetry-internal';
import keystonePaths from '../paths';
/**
 * Searches a module contract for all listed action mocks
 * @param module module or array of modules to search for
 * @param mocks Array of mocks that have been found. This array will be modified
 */
export const searchPage = (module, mocks) => {
    if (Array.isArray(module)) {
        _each(module, value => searchPage(value, mocks));
    }
    else if (module.modules) {
        _each(module.modules, value => {
            if (Array.isArray(value)) {
                searchPage(value, mocks);
            }
        });
    }
    else if (module.actionMock) {
        mocks.push(module.actionMock);
    }
};
/**
 * Captures all action mocks from a page context
 * @param pageResponse Current page context
 */
export const getMockPathPageResponse = (pageResponse) => {
    const mocks = [];
    pageResponse.slots.forEach((moduleContract) => {
        const actionMock = _get(pageResponse, ['modules', moduleContract.id, 'actionMock']);
        if (actionMock) {
            mocks.concat(actionMock.split(','));
        }
    });
    return mocks;
};
/**
 * Formats the correct path and mock based from query string
 *  Looks for requestMock=moduleName:mockName,moduleName:mockName,moduleName
 *  where mock name is either a file or a directory
 */
export const getMockPathQuery = (query) => {
    const { actionMock } = query;
    if (!actionMock) {
        return [];
    }
    return actionMock.split(',');
};
/**
 * Searches file system for mocks
 * mockTuple = 'moduleName:mockName'
 */
export const findMockPaths = async (mockTuple) => {
    // tslint:disable-next-line:prefer-const -- tsc is confused about us having a const & a var on the same destruct
    let [moduleName, mockName] = mockTuple.split(':');
    if (!mockName) {
        mockName = moduleName;
    }
    const partnerModuleMockPath = resolve(keystonePaths.KEYSTONE_MODULE_MOCKS_DIR, `${moduleName}/`, `${mockName}.actionmock.json`);
    if (await safeFileExists(partnerModuleMockPath)) {
        return partnerModuleMockPath;
    }
    const moduleRoot = resolve(keystonePaths.KEYSTONE_NODE_MODULES_DIR, moduleName);
    const mockPattern = `@(dist|build|src)/**/${mockName}.actionmock.json`;
    const opts = {
        cwd: moduleRoot
    };
    const mocks = await safeGetAllFilesPath(mockPattern, opts);
    if (mocks.length) {
        // file has been found
        return resolve(keystonePaths.KEYSTONE_NODE_MODULES_DIR, `${moduleName}`, mocks[0]);
    }
    return false;
};
/**
 * Pulls mock data
 */
export const populateClientCache = async (context, pageResponse, clientCache, telemetry) => {
    let mocks = getMockPathQuery({ ...context.params, ...context.query });
    if (context.query && context.query.mock) {
        mocks = mocks.concat(getMockPathPageResponse(pageResponse));
    }
    if (!mocks || !mocks.length) {
        return;
    }
    const mockPaths = [];
    for (const mockPath of mocks) {
        const path = await findMockPaths(mockPath);
        if (path) {
            mockPaths.push(path);
        }
    }
    if (!mockPaths.length) {
        // no file found
        telemetry.log(LogLevel.Error, EXCEPTION_NO_MOCKS_FOUND);
        return;
    }
    // @ts-ignore
    const actionMocks = await Promise.all(mockPaths.map(safeReadJson));
    _flatten(actionMocks).forEach((mock) => {
        if (mock) {
            clientCache.put({ typeName: '__MOCK', key: `${mock.id || mock.CacheObjectType}:${mock.CacheKey || '*'}` }, { item: mock.Mock });
        }
    });
    return;
};
//# sourceMappingURL=action-mock-helper.js.map
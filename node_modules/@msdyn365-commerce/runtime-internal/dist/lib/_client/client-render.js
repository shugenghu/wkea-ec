/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ActionContext } from '@msdyn365-commerce/action-internal';
import { CoreContext, CultureInfoFormatter, msdyn365Commerce } from '@msdyn365-commerce/core-internal';
// tslint:enable:no-import-side-effect
import { AppInsightsJSLogger, EVENT_CLIENT_RENDER_START, EVENT_CLIENT_RENDER_STOP, EVENT_LOAD_DATA_START, EXCEPTION_CLIENT_CACHE_HYDRATE, EXCEPTION_LOAD_DATA_EXCEPTION, EXCEPTION_PRODUCT_LIST_CLIENTSIDE_HYDRATION, expAttributeRenderer, GenericConsoleLogger, LogLevel, MESSAGE_CLIENT_RENDER_ERROR, StaticTelemetry, Telemetry, TelemetryEvent } from '@msdyn365-commerce/telemetry-internal';
import axios from 'axios';
// tslint:disable:no-import-side-effect
import 'lazysizes';
import 'lazysizes/plugins/attrchange/ls.attrchange';
import { partition as _partition } from 'lodash';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { RSRequestInterceptor, RSRequestInterceptorErrorHandler, RSResponseInterceptor, RSResponseInterceptorErrorHandler } from '../_server/inteceptors/rs-logging-interceptor';
import SafeRenderModule from '../components/safe-render-module';
import { CLIENT_RENDER_COMPLETE_EVENT, CLIENT_RENDER_START_EVENT, DEPRECATED_CLIENT_RENDER_COMPLETE_EVENT, LAYOUT_MOUNT_POINT } from '../consts';
import { loadData } from '../data/load-data';
import { processComplexDataTypes } from '../hydrators/process-page-response';
import { PageContext } from '../store/page-context';
import { getCurrencyCodeFromContext } from '../utils/helpers';
import { SessionStorageContext } from '../utils/session-storage-utils';
import { AuthoringToolsHelper } from './../utils/authoring-tools-helper';
import { CookieContext } from './../utils/cookie-utils';
axios.interceptors.request.use(RSRequestInterceptor, RSRequestInterceptorErrorHandler);
axios.interceptors.response.use(RSResponseInterceptor, RSResponseInterceptorErrorHandler);
export const getRequestContext = (storeData) => {
    const requestContext = storeData.requestContext;
    // See if cookie compliance is disabled at the site level
    const disableCookieCompliance = (requestContext.app && requestContext.app.platform && requestContext.app.platform.disableCookieCompliance) || false;
    const cartSessionExpiration = (requestContext.app && requestContext.app.platform && requestContext.app.platform.cartSessionExpiration) || 0;
    const cookies = new CookieContext({
        isConsentRequired: !disableCookieCompliance,
        cartExpirationInDays: cartSessionExpiration,
        sameSiteRequired: requestContext.sameSiteRequired
    });
    requestContext.cookies = cookies;
    requestContext.sessionStorage = new SessionStorageContext(cookies);
    requestContext.headers = Object.freeze({});
    requestContext.url.requestUrl =
        typeof requestContext.url.requestUrl === 'string' ? new URL(requestContext.url.requestUrl) : requestContext.url.requestUrl;
    return requestContext;
};
const getPathName = (requestContextUrl) => {
    if (requestContextUrl && requestContextUrl.requestUrl && requestContextUrl.requestUrl.pathname) {
        return requestContextUrl.requestUrl.pathname;
    }
    return '';
};
const isPaymentVerification = (requestContext) => {
    return requestContext.query?.pv === '1';
};
const isCheckoutRoute = (requestContext) => {
    return (requestContext.app &&
        requestContext.app.routes &&
        requestContext.app.routes.checkout &&
        requestContext.app.routes.checkout.destinationUrl &&
        getPathName(requestContext.url) === requestContext.app.routes.checkout.destinationUrl);
};
const activateExperiments = (requestContext) => {
    // Activate experiment if an experimentation connector has been registered and active experiments are provided
    // In a preview scenario, OneRF will not send a user ID and which we will not active the experiment
    if (msdyn365Commerce.experimentationConnector &&
        requestContext.features.experimentation &&
        requestContext.experiments &&
        requestContext.experiments.userId &&
        requestContext.experiments.activeExperiments &&
        requestContext.experiments.activeExperiments.length > 0) {
        const experimentInfo = requestContext.experiments;
        // Split the experiment list into two lists, one whose experiments are coupled with a module and one whose experiments are not
        const [experimentsWithoutModuleId, experimentsWithModuleId] = _partition(experimentInfo.activeExperiments, (value) => {
            return !value.moduleId;
        });
        // Activate experiments not tied to a module id
        msdyn365Commerce.experimentationConnector.provider.activateExperiment(experimentInfo.userId, experimentsWithoutModuleId, {
            Type: requestContext.device.Type
        });
        // Activate experiments once 30% of the module is visible
        const options = {
            threshold: 0.3
        };
        const experimentMap = {};
        const experimentObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting && entry.intersectionRatio >= 0.3) {
                    const activatedExpId = entry.target.getAttribute(`data-exp`);
                    if (activatedExpId) {
                        // Find the experiment/variant combo associated with the experiment to activate
                        msdyn365Commerce.experimentationConnector?.provider.activateExperiment(experimentInfo.userId, [experimentMap[activatedExpId]], {
                            Type: requestContext.device.Type
                        });
                    }
                    // Once we the element has come into the view for the first time, we can stop observing it
                    observer.unobserve(entry.target);
                }
            });
            // tslint:disable-next-line: align
        }, options);
        for (let i = 0; i < experimentsWithModuleId.length; i++) {
            const currentExperiment = experimentsWithModuleId[i];
            const target = document.querySelector(`[data-exp="id:${currentExperiment.experimentId}"]`);
            if (target) {
                experimentMap[`id:${currentExperiment.experimentId}`] = currentExperiment;
                experimentObserver.observe(target);
            }
        }
    }
};
/**
 * Checks if client side hydration should happen before loadData
 * @param requestContext Request context object
 */
const shouldOptimizeHydrate = (requestContext) => {
    const clientRenderOptimizationEnabled = requestContext.app && requestContext.app.platform && !!requestContext.app.platform.enableClientRenderOptimization;
    const clientRenderQsp = requestContext.query && requestContext.query.optimize_hydrate === 'true';
    return clientRenderOptimizationEnabled || clientRenderQsp;
};
/**
 * Method to hydrate the markup returned by server on the client.
 * @param requestContext request context object
 * @param pageContext page context object
 * @param coreContext core context object
 */
const hydrateClient = (requestContext, pageContext, coreContext) => {
    const pageRoot = pageContext.pageRoot;
    const body = pageRoot.modules && pageRoot.modules.body;
    const props = body && body.length > 0 ? body[0] : pageRoot;
    try {
        ReactDOM.hydrate(React.createElement(CoreContext.Provider, { value: coreContext },
            React.createElement(SafeRenderModule, Object.assign({}, props, { store: pageContext, root: true }))), document.getElementById(LAYOUT_MOUNT_POINT));
    }
    catch (err) {
        // If in dev mode or debug mode, throw the error so it's visible on the page.
        if ((process.env.NODE_ENV === 'development' || requestContext.params.isDebug) && !requestContext.params.isEditor) {
            throw err;
            // In editor mode, catch the error but don't throw so that the page doesn't freeze up
        }
        else if (requestContext.params.isEditor) {
            console.log(`Error running editor (client) render: ${err}`);
        }
    }
};
/**
 * Method to initialize authoring helper and register event to receive list of disabled properties when rendered in the context of site builder
 * @param requestContext request context object
 * @param pageContext page context object
 * @param coreContext core context object
 * @param actionContext action context object
 * @param moduleTelemetry module telemetry object
 */
const initAuthoringHelper = (requestContext, pageContext, coreContext, actionContext, moduleTelemetry) => {
    const themeSettings = window.___initialData___.themeSettings ? window.___initialData___.themeSettings : {};
    const authoringHelper = new AuthoringToolsHelper(actionContext, themeSettings, coreContext, pageContext, moduleTelemetry);
    // @ts-ignore
    window._msdyn365.authoringHelper = authoringHelper;
    // @ts-ignore
    document.addEventListener('_msdyn365_client_disabled_properties', (dpEvent) => {
        if (dpEvent && dpEvent.detail && dpEvent.detail) {
            Object.keys(dpEvent.detail.modules).map(key => {
                authoringHelper.updateDisabledProperties(key, dpEvent.detail.modules[key]);
            });
        }
    });
};
// tslint:disable:max-func-body-length
export function clientRender() {
    const storeData = window.___initialData___;
    if (!storeData || typeof storeData !== 'object') {
        console.error(MESSAGE_CLIENT_RENDER_ERROR);
        return;
    }
    const removePlaceholderModules = (modulesDictionary) => {
        Object.keys(modulesDictionary || {}).forEach(slot => {
            modulesDictionary[slot] = modulesDictionary[slot].filter(a => a.typeName !== 'place-holder-for-container-preview');
            modulesDictionary[slot].forEach(module => module.modules && removePlaceholderModules(module.modules));
        });
    };
    const requestContext = getRequestContext(storeData);
    if (requestContext.params.isEditor) {
        removePlaceholderModules(storeData.pageRoot.modules);
    }
    // if request is not POST or is not a checkout route or is not a payment verification, clear all checkout session storage data.
    // TODO: Explore a way to move this logic to SSK
    if (!requestContext.requestFormData || !isCheckoutRoute(requestContext) || !isPaymentVerification(requestContext)) {
        requestContext.sessionStorage.removeCheckoutCartData();
    }
    // tslint:disable-next-line:no-any
    const appCache = msdyn365Commerce.getAppCache(requestContext);
    const pageContext = new PageContext(storeData, requestContext, appCache);
    // Get the 1DS instance from the browser client. Initialized as part of base-page
    // tslint:disable-next-line:no-any no-string-literal
    const oneDSWeb = window['oneDSWeb'];
    // Get the registered experiment listener
    const expListener = msdyn365Commerce.experimentationConnector?.listener;
    // Set up internal SDK telemetry
    const internalTelemetry = StaticTelemetry;
    internalTelemetry.enableDataAnalytics(requestContext.features.enableDataAnalytics);
    internalTelemetry.registerWebAnalyticsPlugin(oneDSWeb);
    internalTelemetry.registerAttributeRenderer(expAttributeRenderer);
    internalTelemetry.registerTraceLogger({ traceLogger: new AppInsightsJSLogger() });
    internalTelemetry.setTelemetryRequestContext({
        siteId: '[[Placeholder]]',
        channelId: requestContext.channel?.RecordId ? requestContext.channel.RecordId.toString() : 'Unavailable',
        pageType: requestContext.urlTokens.pageType,
        pageId: pageContext.pageRoot.id
    });
    // Set up external module telemetry
    const moduleTelemetry = new Telemetry();
    moduleTelemetry.enableDataAnalytics(requestContext.features.enableDataAnalytics);
    moduleTelemetry.registerWebAnalyticsPlugin(oneDSWeb);
    moduleTelemetry.registerAttributeRenderer(expAttributeRenderer);
    // If experimentaiton listener set up, add to event logging framework
    if (expListener && requestContext.features.experimentation) {
        internalTelemetry.registerExpLogger(expListener);
        moduleTelemetry.registerExpLogger(expListener);
    }
    // If in debug mode, add console loggers
    if (requestContext.params.isDebug) {
        internalTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: requestContext.params.isDebug } });
        moduleTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: requestContext.params.isDebug } });
    }
    pageContext
        .putRequestedModulesInCacheOnClient(storeData, moduleTelemetry)
        .catch(error => {
        internalTelemetry.log(LogLevel.Error, EXCEPTION_CLIENT_CACHE_HYDRATE, { exception: error });
    })
        .finally(() => {
        window._msdyn365 = {
            requestContext: requestContext,
            telemetry: internalTelemetry
        };
        const actionContext = new ActionContext({
            id: 'Client Action Context',
            requestContext: requestContext,
            requestCache: pageContext.requestCache,
            telemetry: moduleTelemetry,
            appCache: null,
            spawnChildOnExecute: true
        });
        if (requestContext.params.isDebug) {
            // @ts-ignore
            window._msdyn365.cache = pageContext.requestCache;
        }
        const coreContext = {
            actionContext: actionContext,
            app: requestContext.app,
            // @ts-ignore
            internalTelemetry: internalTelemetry,
            telemetry: moduleTelemetry,
            request: requestContext,
            cultureFormatter: new CultureInfoFormatter(requestContext.locale, getCurrencyCodeFromContext(requestContext))
        };
        const allModules = pageContext.allModules;
        if (shouldOptimizeHydrate(requestContext)) {
            hydrateClient(requestContext, pageContext, coreContext);
        }
        if (requestContext.params.isEditor) {
            initAuthoringHelper(requestContext, pageContext, coreContext, actionContext, moduleTelemetry);
        }
        const correlationId = Telemetry.generateGuid();
        // Fire event to let tooling know render starts. Tools on receiving this event, calls
        // initialziation and passes the rendering helper class instance that can be used by SDK to
        // get any information/context w.r.t tools
        const event = new Event(CLIENT_RENDER_START_EVENT);
        document.dispatchEvent(event);
        internalTelemetry.trackEvent(EVENT_CLIENT_RENDER_START, {
            id: correlationId
        });
        internalTelemetry.startTimer(correlationId);
        internalTelemetry.trackEvent(EVENT_LOAD_DATA_START, {
            id: correlationId,
            initiator: 'ClientRender'
        });
        let initialPromise = Promise.resolve();
        const LAZYLOAD_ALL_SWITCH = requestContext.features.lazyload_all;
        initialPromise = initialPromise.then(async () => {
            try {
                return processComplexDataTypes(LAZYLOAD_ALL_SWITCH, "client" /* client */, pageContext.allModules, actionContext);
            }
            catch (error) {
                internalTelemetry.log(LogLevel.Error, EXCEPTION_PRODUCT_LIST_CLIENTSIDE_HYDRATION, { exception: error });
            }
        });
        initialPromise.finally(() => {
            // tslint:disable-next-line:no-floating-promises -- we don't care about awaiting here on purpose
            loadData(allModules, requestContext, internalTelemetry, moduleTelemetry, pageContext.requestCache, null)
                .then(() => {
                internalTelemetry.trackEvent(EVENT_CLIENT_RENDER_STOP, {
                    id: correlationId
                }, {
                    success: 1,
                    time: internalTelemetry.stopTimer(correlationId)
                });
            })
                .catch(error => {
                internalTelemetry.trackEvent(EVENT_CLIENT_RENDER_STOP, {
                    id: correlationId
                }, {
                    success: 0,
                    time: internalTelemetry.stopTimer(correlationId)
                });
                internalTelemetry.log(LogLevel.Error, EXCEPTION_LOAD_DATA_EXCEPTION, { exception: error });
            })
                .finally(() => {
                // Gets a reference to the same Telemetry, so that we can route existing log calls to new back-end without changing front-end API
                if (!shouldOptimizeHydrate(requestContext)) {
                    hydrateClient(requestContext, pageContext, coreContext);
                }
                // Add the page view exp event id to the page level div
                const pageName = requestContext.telemetryPageName || requestContext.url.requestUrl.pathname;
                document.getElementById(LAYOUT_MOUNT_POINT)?.setAttribute('data-exp-event-id', `${pageName}.PageView`);
                // Activate any active experiments on the page
                activateExperiments(requestContext);
                // TODO (matt, 6/15/20): Manually firing page view event, undo once 1DS forwarding to framework implemented
                internalTelemetry.logEvent(TelemetryEvent.PageView, {
                    title: requestContext.telemetryPageName || requestContext.url.requestUrl.pathname
                });
                // Fire event to let tooling know render is complete
                const deprecatedEvent = new Event(DEPRECATED_CLIENT_RENDER_COMPLETE_EVENT);
                document.dispatchEvent(deprecatedEvent);
                document.dispatchEvent(new Event(CLIENT_RENDER_COMPLETE_EVENT));
            });
        });
    });
}
//# sourceMappingURL=client-render.js.map
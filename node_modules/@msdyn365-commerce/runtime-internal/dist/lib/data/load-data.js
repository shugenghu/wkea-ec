/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { ActionContext, addLocaleInformation } from '@msdyn365-commerce/action-internal';
import { msdyn365Commerce } from '@msdyn365-commerce/core-internal';
import { asSystemMetadata, EXCEPTION_DATAACTION_EXECUTION, EXCEPTION_LOADDATA_ACTION, EXCEPTION_LOADDATA_ACTION_0, EXCEPTION_LOADDATA_ACTION_1, EXCEPTION_LOADDATA_ACTION_2, LogLevel, MESSAGE_CREATE_INPUT_LOADDATA } from '@msdyn365-commerce/telemetry-internal';
import { ActionRuntime } from '../app-initialization/models';
import { LAZYLOAD_SWITCH_PREFIX } from '../consts';
import { combineExtendedDataActionToModule } from '../utils/data-action-extension-helper';
/**
 * Method which stores temporary async results in the cache for actions which
 * will be run at a later time
 * @param tempMetadataList The list of actions which need temporary AsyncResults
 * @param requestCache The request cache
 */
const storeTemporaryAsyncResults = (tempMetadataList, requestCache) => {
    const tempResultCacheItem = { item: { _type: 'AsyncResult', status: 'LOADING', runOn: 'client' } };
    // Insert fake temporary AsyncResults for actions that will be deferred to client
    tempMetadataList.forEach(tempMetadata => {
        // Non-observable and instance actions should not get a temp promise
        const firstInput = Array.isArray(tempMetadata.inputs) ? tempMetadata.inputs[0] : tempMetadata.inputs;
        if (!tempMetadata.dataActionFunction.prototype.isObservable ||
            !tempMetadata.inputs ||
            (firstInput && firstInput.dataCacheType && firstInput.dataCacheType() === 'instance')) {
            return;
        }
        if (!Array.isArray(tempMetadata.inputs)) {
            tempMetadata.inputs = [tempMetadata.inputs];
        }
        tempMetadata.inputs.forEach(tempInput => {
            // Don't add temp promise if there is a mock or if the resolved data has already been inserted into the cache
            if (requestCache.get({ key: `${tempInput.getCacheObjectType()}:${tempInput.getCacheKey()}`, typeName: '__MOCK' }) ===
                undefined &&
                requestCache.get({ key: `${tempInput.getCacheKey()}`, typeName: tempInput.getCacheObjectType() }) === undefined) {
                requestCache.put({ key: tempInput.getCacheKey(), typeName: tempInput.getCacheObjectType() }, tempResultCacheItem);
            }
        });
    });
};
/**
 * Runs all the data actions specificed in module definitions present on the page
 */
export const loadData = async (modules, context, internalTelemetry, moduleTelemetry, requestCache, appCache, complexDataTypesPromises) => {
    if (!modules || modules.length === 0) {
        return [];
    }
    const dataActionMetadataList = [];
    const lazyLoadModuleIds = {};
    const tempMetadataList = [];
    // Note: What modules will need to be lazyloaded due to feature switches
    storeLazyloadModuleId(context, lazyLoadModuleIds);
    loadDataProcessing(modules, lazyLoadModuleIds, context, internalTelemetry, dataActionMetadataList, tempMetadataList);
    storeTemporaryAsyncResults(tempMetadataList, requestCache);
    if (dataActionMetadataList.length === 0) {
        // When there is no data actions, we still need to resolve complexTypePromises
        if (complexDataTypesPromises) {
            await Promise.all(complexDataTypesPromises);
        }
        return [];
    }
    const actionContext = new ActionContext({
        id: 'T1',
        requestContext: context,
        requestCache: requestCache,
        expectedActionCount: dataActionMetadataList.length,
        telemetry: moduleTelemetry,
        appCache
    });
    const promises = processDataActionMetadataList(actionContext, dataActionMetadataList, internalTelemetry);
    if (complexDataTypesPromises) {
        promises.push(...complexDataTypesPromises);
    }
    await Promise.all(promises);
    return actionContext.getRefreshActions();
};
const fetchDataActionWithActionid = (lookupId) => {
    // @ts-ignore
    const dataActionFunction = msdyn365Commerce.dataAction(lookupId);
    if (dataActionFunction &&
        dataActionFunction.default &&
        dataActionFunction.default.prototype &&
        dataActionFunction.default.prototype.inputFunc &&
        typeof dataActionFunction.default.prototype.inputFunc === 'function') {
        return dataActionFunction;
    }
    return null;
};
const loadDataProcessing = (modules, lazyLoadModuleIds, context, internalTelemetry, dataActionMetadataList, tempMetadataList) => {
    modules.forEach((moduleContract) => {
        const moduleConfig = moduleContract.config;
        if (typeof moduleConfig === 'object' && moduleConfig && moduleConfig.hasOwnProperty('clientRender')) {
            lazyLoadModuleIds[moduleContract.id] = true;
        }
        // @ts-ignore
        const moduleBinderInitial = msdyn365Commerce.moduleBinder(moduleContract.typeName);
        const moduleBinder = context.params.theme
            ? combineExtendedDataActionToModule(moduleBinderInitial, moduleContract.typeName, context.params.theme)
            : moduleBinderInitial;
        if (moduleBinder && moduleBinder.dataActions && moduleBinder.dataActions.length > 0) {
            moduleBinder.dataActions.forEach((dataAction) => {
                const lookupId = dataAction.id || dataAction.path;
                if (dataAction.name && lookupId) {
                    // @ts-ignore: DataAction method is not typed
                    let dataActionFunction = msdyn365Commerce.dataAction(lookupId);
                    if (dataActionFunction &&
                        dataActionFunction.default &&
                        dataActionFunction.default.prototype &&
                        dataActionFunction.default.prototype.id) {
                        const newLookUpId = dataActionFunction.default.prototype.id;
                        // if the dataAction function's id is different with lookup id, try to fetch the dataAction based on its id again.
                        if (newLookUpId !== lookupId) {
                            dataActionFunction = fetchDataActionWithActionid(newLookUpId) || dataActionFunction;
                        }
                    }
                    if (dataActionFunction &&
                        dataActionFunction.default &&
                        dataActionFunction.default.prototype &&
                        dataActionFunction.default.prototype.inputFunc &&
                        typeof dataActionFunction.default.prototype.inputFunc === 'function') {
                        try {
                            processModuleDataAction(dataActionFunction, context, moduleContract, dataAction, dataActionMetadataList, internalTelemetry, lazyLoadModuleIds, tempMetadataList);
                        }
                        catch (e) {
                            internalTelemetry.log(LogLevel.Debug, internalTelemetry.stringFormat(EXCEPTION_LOADDATA_ACTION_0, [dataAction.name, moduleContract.id]));
                            internalTelemetry.log(LogLevel.Error, EXCEPTION_LOADDATA_ACTION, { exception: e });
                        }
                    }
                    else {
                        internalTelemetry.log(LogLevel.Debug, internalTelemetry.stringFormat(EXCEPTION_LOADDATA_ACTION_2, [dataAction.path, moduleContract.typeName]));
                        internalTelemetry.log(LogLevel.Error, '', { exception: new Error(EXCEPTION_LOADDATA_ACTION_1) });
                    }
                }
            });
            internalTelemetry.log(LogLevel.Debug, internalTelemetry.stringFormat(MESSAGE_CREATE_INPUT_LOADDATA, [
                (moduleContract.dataActions || []).map(d => d.name).join(' | '),
                moduleContract.typeName,
                moduleContract.id
            ]));
        }
    });
};
const processModuleDataAction = (dataActionFunction, context, moduleContract, dataAction, dataActionMetadataList, internalTelemetry, lazyLoadModuleIds, tempMetadataList) => {
    let inputs;
    try {
        inputs = dataActionFunction.default.prototype.inputFunc({
            requestContext: context,
            config: moduleContract.config,
            data: moduleContract.data
        });
        const isArray = Array.isArray(inputs);
        moduleContract.dataActions = moduleContract.dataActions || [];
        addLocaleInformation(inputs, context.locale);
        moduleContract.dataActions.push({
            name: dataAction.name,
            entity: isArray ? inputs[0].getCacheObjectType() : inputs.getCacheObjectType(),
            inputs: isArray ? inputs.map((input) => input.getCacheKey()) : inputs.getCacheKey()
        });
    }
    catch (e) {
        internalTelemetry.log(LogLevel.Debug, 'Unable to create input for Module: {id}, Action: {name}', {
            values: [asSystemMetadata(moduleContract.id), asSystemMetadata(dataAction.name)]
        });
        moduleContract.dataActions = moduleContract.dataActions || [];
        moduleContract.dataActions.push({
            name: dataAction.name,
            entity: undefined,
            inputs: undefined
        });
    }
    if (inputs && dataAction) {
        // Add run on information to data action input
        inputs.runOn = convertRunOnToString(dataAction.runOn);
    }
    if (msdyn365Commerce.isBrowser ||
        (!context.features.lazyload_all &&
            (dataAction.runOn === ActionRuntime.server || dataAction.runOn === ActionRuntime.serverOnly) &&
            !lazyLoadModuleIds[moduleContract.id] &&
            !lazyLoadModuleIds[moduleContract.typeName])) {
        dataActionMetadataList.push({
            name: dataAction.name,
            runOn: dataAction.runOn,
            id: dataAction.id,
            inputs: inputs,
            dataActionFunction: dataActionFunction.default,
            ...(dataAction.options && { options: dataAction.options })
        });
    }
    else {
        // If the data action is supposed to be run server only it should never
        // be placed in the temporary list that will eventually run client side.
        if (dataAction.runOn !== ActionRuntime.serverOnly) {
            tempMetadataList.push({
                name: dataAction.name,
                runOn: dataAction.runOn,
                id: dataAction.id,
                inputs: inputs,
                dataActionFunction: dataActionFunction.default
            });
        }
    }
};
//
const storeLazyloadModuleId = (renderingContext, lazyLoadModuleIds) => {
    if (renderingContext.features) {
        Object.keys(renderingContext.features).forEach(switchName => {
            if (switchName.startsWith(LAZYLOAD_SWITCH_PREFIX) && renderingContext.features[switchName]) {
                lazyLoadModuleIds[switchName.replace(LAZYLOAD_SWITCH_PREFIX, '')] = true;
            }
        });
    }
};
export const processDataActionMetadataList = (actionContext, dataActionMetadataList, internalTelemetry) => {
    return dataActionMetadataList
        .map((dataActionMetadata) => {
        // all client side actions are lazy loaded inorder not to interfere with the client hydrate.
        // therefore only return those promises that are non-observable and instance actions
        if (process.env.CURRENT_ENVIRONMENT === 'web') {
            const promise = actionContext
                .chainAction(dataActionMetadata.dataActionFunction, dataActionMetadata.inputs, dataActionMetadata.options)
                .catch(e => {
                internalTelemetry.log(LogLevel.Error, EXCEPTION_DATAACTION_EXECUTION, {
                    values: [asSystemMetadata(dataActionMetadata.id || dataActionMetadata.name)],
                    exception: (e && e.error) || e
                });
            });
            // We still need to await non-observable client-side data actions (public-preview)
            if (!dataActionMetadata.dataActionFunction.prototype.isObservable) {
                return promise;
            }
            // we should await on observable 'instance' actions that are configured to runOn 'server'
            if (actionContext.requestContext.features &&
                !actionContext.requestContext.features.disable_inst_action_await &&
                isServerInstanceAction(dataActionMetadata)) {
                return promise;
            }
        }
        else {
            return actionContext
                .chainAction(dataActionMetadata.dataActionFunction, dataActionMetadata.inputs, dataActionMetadata.options)
                .catch(e => {
                internalTelemetry.log(LogLevel.Error, EXCEPTION_DATAACTION_EXECUTION, {
                    values: [asSystemMetadata(dataActionMetadata.id || dataActionMetadata.name)],
                    exception: (e && e.error) || e
                });
            });
        }
    })
        .filter(Boolean);
};
const isServerInstanceAction = (dataActionMetadata) => {
    const firstInput = Array.isArray(dataActionMetadata.inputs) ? dataActionMetadata.inputs[0] : dataActionMetadata.inputs;
    return (dataActionMetadata.runOn === ActionRuntime.server &&
        dataActionMetadata.dataActionFunction.prototype.isObservable &&
        firstInput &&
        firstInput.dataCacheType &&
        firstInput.dataCacheType() === 'instance');
};
export const convertRunOnToString = (runtime) => {
    switch (runtime) {
        case ActionRuntime.client:
            return 'client';
        case ActionRuntime.server:
            return 'server';
        case ActionRuntime.serverOnly:
            return 'serverOnly';
        default:
            return 'server';
    }
};
//# sourceMappingURL=load-data.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { EditError, PROPERTY_INIT } from '@msdyn365-commerce/core-internal';
import { CLIENT_DATA_UPDATE_EVENT, MSDYN365_WYSIWYG_DISABLED_PROPS } from '../consts';
const MODULE_NAME_PATH = '__MODULE_NAME__';
const MODULE_TYPE_PATH = '__MODULE_TYPE__';
const PARENT_PROP_PATH = '__PARENT_PROP__';
export const getWrappedProxyObject = (config, moduleName, typeName) => {
    // tslint:disable-next-line:no-typeof-undefined
    if (typeof window === 'undefined') {
        return config;
    }
    return getProxyHandler(config, moduleName, typeName);
};
/**
 * Get parent module id
 */
export const disableChildModules = (parentModule, requestCache) => {
    const slotKeys = Object.keys(parentModule.modules || []);
    for (let i = 0; i < slotKeys.length; ++i) {
        const childModules = parentModule.modules[slotKeys[i]];
        for (let j = 0; j < childModules.length; ++j) {
            requestCache.put({ typeName: MSDYN365_WYSIWYG_DISABLED_PROPS, key: childModules[j].id }, { item: ['*'] });
            disableChildModules(childModules[j], requestCache);
        }
    }
};
/**
 * helper function to find module from page contract
 * @param moduleId module to be searched
 * @param pageRoot page root object
 */
export const findModule = (moduleId, pageRoot) => {
    if (pageRoot.id === moduleId) {
        return pageRoot;
    }
    const slotKeys = Object.keys(pageRoot.modules || []);
    for (let i = 0; i < slotKeys.length; ++i) {
        const childModules = pageRoot.modules[slotKeys[i]];
        for (let j = 0; j < childModules.length; ++j) {
            const res = findModule(moduleId, childModules[j]);
            if (res) {
                return res;
            }
        }
    }
    return undefined;
};
/**
 * Returns proxy object with get and set traps
 */
const getProxyHandler = (config, moduleName, moduleType) => {
    const handler = {
        get(target, key) {
            // store current module name on the proxy object
            if (!target[MODULE_NAME_PATH]) {
                target[MODULE_NAME_PATH] = moduleName;
            }
            if (!target[MODULE_TYPE_PATH]) {
                target[MODULE_TYPE_PATH] = moduleType;
            }
            if (typeof target[key] === 'object' && target[key] !== null) {
                // store current prop path as parent and return new proxy (for objects)
                target[key][PARENT_PROP_PATH] = target[PARENT_PROP_PATH] ? `${target[PARENT_PROP_PATH]}.${key}` : key;
                return new Proxy(target[key], handler);
            }
            else {
                return target[key];
            }
        },
        // tslint:disable-next-line:no-any
        set(target, key, newValue) {
            let disabledProperties = [];
            const moduleId = target[MODULE_NAME_PATH];
            const typeName = target[MODULE_TYPE_PATH];
            if (!moduleId || !typeName) {
                return true;
            }
            let propertyPath = [key];
            if (target[PARENT_PROP_PATH]) {
                // @ts-ignore
                const parentPath = target[PARENT_PROP_PATH].split('.');
                propertyPath = key === '$type' ? parentPath : parentPath.concat([key]);
            }
            // Check for disabled properties only during component initialization
            // MSDYN365_WYSIWYG_INIT is triggered on component mount and whenever
            // there is a change in component props (componentWillReceiveProps)
            if (newValue === '__MSDYN365_WYSIWYG_INIT__') {
                // @ts-ignore
                disabledProperties = window._msdyn365.authoringHelper.getDisabledProperties(moduleId);
                if ((disabledProperties || []).length > 0) {
                    // if the value is '*' all properties are disabled
                    if (disabledProperties.length === 1 && disabledProperties[0] === '*') {
                        throw new EditError('cannot set disabled property');
                    }
                    const fullPath = propertyPath.join('.');
                    // properties disabled in template are disabled at root property path - and will only contain part of the updated property's full path
                    // e.g. disabledProperties = ['heading','links'], updatedProperty = 'heading.text' and 'links.1.linkText' are disabled
                    // we check for fullPath.startsWith(`${p}.`) to handle cases where 'heading' prop is disabled and edited property is 'headingLink'
                    if (disabledProperties.filter(p => fullPath === p || fullPath.startsWith(`${p}.`)).length > 0) {
                        throw new EditError('cannot set disabled property');
                    }
                }
                // for events that are called as part of initialization, do no set any value
                // as the initialization is to check if a property is disabled
                const requiredProperties = getRequiredProperties(typeName) || [];
                throw new EditError('cannot set disabled property', PROPERTY_INIT, requiredProperties.includes(propertyPath.join('.')));
            }
            // If we reached here, it means component is not disabled, lets just
            // notify the site builder
            document.dispatchEvent(new CustomEvent(CLIENT_DATA_UPDATE_EVENT, {
                detail: { moduleId, value: newValue, property: propertyPath }
            }));
            return true;
        }
    };
    return new Proxy(config, handler);
};
/**
 * helper method to get required properties
 */
const getRequiredProperties = (typeName) => {
    if (!(typeof window === undefined)) {
        // @ts-ignore
        const authoringHelper = window._msdyn365.authoringHelper;
        return authoringHelper && authoringHelper.renderingHelper && authoringHelper.renderingHelper.moduleRequiredProperties(typeName);
    }
    return [];
};
//# sourceMappingURL=authoring-edit-helper.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import msdyn365Commerce, { isAuthoringEditEnabled, isEmptyOrNullObject } from '@msdyn365-commerce/core-internal';
import { AsyncResult, isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { EXCEPTION_BADPAGECONTEXT, EXCEPTION_INITIALDATAFAIL } from '@msdyn365-commerce/telemetry-internal';
import { isObservableArray, toJS, transaction } from 'mobx';
import { CACHE_SETTING, MODULE_ACTION_KEY, MODULE_CACHE_KEY, MODULE_CONFIG_ERRORS_KEY, MODULE_CONFIG_KEY, MODULE_DATA_KEY, MODULE_DEFERRED_KEY, MODULE_RESOURCES_KEY, MSDYN365_WYSIWYG_CANADDMODULE, MSDYN365_WYSIWYG_DISABLED_PROPS } from '../consts';
import { getParentModuleName } from '../utils/helpers';
import { getWrappedProxyObject } from './authoring-edit-helper';
/**
 * Class to hold the page view model, areas and regions
 */
export class PageContext {
    // tslint:disable-next-line:no-any
    constructor(pageData, requestContext, requestCache, resourceManager) {
        this._moduleList = [];
        this._themeModulesList = [];
        if (isEmptyOrNullObject(pageData)) {
            throw new Error(EXCEPTION_BADPAGECONTEXT);
        }
        this.requestContext = requestContext;
        this.requestCache = requestCache;
        this.pageRoot = pageData.pageRoot;
        // tslint:disable-next-line:no-typeof-undefined
        if (typeof window === 'undefined') {
            this._putRequestedModulesInCacheOnServer(pageData, resourceManager);
        }
        this._initThemeModulesList();
    }
    /**
     * Returns callback function that returns module rendering metadata for a given module
     */
    get modules() {
        return (name) => {
            const cacheItem = this.requestCache.getValue({ typeName: MODULE_CACHE_KEY, key: name });
            if (!cacheItem) {
                throw new Error(`requested module id [${name}] is not found in module dictionary of pageconfig`);
            }
            const data = { ...(this.requestCache.getValue({ typeName: MODULE_DATA_KEY, key: name }) || {}) };
            const actions = this.requestCache.getValue({ typeName: MODULE_ACTION_KEY, key: name });
            const resources = this.requestCache.getValue({ typeName: MODULE_RESOURCES_KEY, key: cacheItem.typeName });
            // toJS method
            if (actions && toJS(actions)) {
                for (const action of toJS(actions)) {
                    if (action.entity && action.inputs) {
                        data[action.name] =
                            Array.isArray(action.inputs) || isObservableArray(action.inputs)
                                ? action.inputs.map((cacheKey) => this._populateDataActionResultFromCache(action.entity, cacheKey))
                                : this._populateDataActionResultFromCache(action.entity, action.inputs);
                    }
                    else {
                        data[action.name] = AsyncResult.reject('Action Input Creation Failure');
                    }
                }
            }
            const config = this.requestCache.getValue({ typeName: MODULE_CONFIG_KEY, key: name }) || {};
            return {
                ...cacheItem,
                data: data,
                config: 
                // tslint:disable-next-line:no-typeof-undefined
                !(typeof window === 'undefined') && isAuthoringEditEnabled(this.requestContext)
                    ? getWrappedProxyObject(config, name, cacheItem.typeName)
                    : config,
                configErrors: this.requestCache.getValue({ typeName: MODULE_CONFIG_ERRORS_KEY, key: name }),
                resources: resources || {},
                disabledProperties: this.requestCache.getValue({ typeName: MSDYN365_WYSIWYG_DISABLED_PROPS, key: name }) || [],
                slotsForAddModule: this.requestCache.getValue({ typeName: MSDYN365_WYSIWYG_CANADDMODULE, key: name }) || []
            };
        };
    }
    /**
     * Get all the modules listed in the PageContext from the cache
     */
    get allModules() {
        return this._moduleList.map(moduleMetaData => {
            return this.modules(moduleMetaData.id);
        });
    }
    setAppCacheEntries(appCacheEntries) {
        this.requestCache.put({ typeName: CACHE_SETTING, key: 'APP_CACHE_ENTRIES' }, { item: appCacheEntries });
    }
    /**
     * Checkis if the given module is deferred module
     * @param name name of the module
     */
    deferred(name) {
        return !!this.requestCache.getValue({ typeName: MODULE_DEFERRED_KEY, key: name });
    }
    getResourceTextForPlaceholderPreview() {
        // tslint:disable-next-line:no-any
        const resourceItem = this.requestCache.get({ typeName: MODULE_RESOURCES_KEY, key: 'PLACE-HOLDER-FOR-CONTAINER-PREVIEW' });
        if (resourceItem && resourceItem.item && resourceItem.item.clickToConfigure) {
            return resourceItem.item.clickToConfigure;
        }
        else {
            return 'Click here to configure';
        }
    }
    /**
     * Marks module as deferred
     * @param name name of the module
     */
    markModuleAsDeferred(name) {
        this.requestCache.put({ typeName: MODULE_DEFERRED_KEY, key: name }, {
            item: true
        });
    }
    /**
     * Inserts requested modules into cache on client side
     * @param pageData page data object
     * @param telemetry telemetry object
     */
    // tslint:disable-next-line:no-any
    async putRequestedModulesInCacheOnClient(pageData, telemetry) {
        if (isEmptyOrNullObject(pageData.requestCache) || isEmptyOrNullObject(pageData.requestCache.internalCache)) {
            throw new Error(EXCEPTION_INITIALDATAFAIL);
        }
        for (const cacheType of Object.keys(pageData.requestCache.internalCache)) {
            const cacheBasedOnType = pageData.requestCache.internalCache[cacheType];
            if (!isEmptyOrNullObject(cacheBasedOnType)) {
                for (const cachekey of Object.keys(cacheBasedOnType)) {
                    const cacheItem = cacheBasedOnType[cachekey];
                    // AsyncResults sent from server to client get serialized into basic JS objects,
                    // They need to be "rehydrated" into actual AsyncResults to enable full functionality
                    if (cacheItem.item && cacheItem.item._type && cacheItem.item._type === 'AsyncResult') {
                        const metadata = cacheItem.item.metadata || {};
                        if (cacheItem.item.status && cacheItem.item.status === 'SUCCESS') {
                            cacheItem.item = AsyncResult.resolve(cacheItem.item.result);
                        }
                        else {
                            cacheItem.item = AsyncResult.reject(cacheItem.item.error || 'Unable to parse data action');
                        }
                        cacheItem.item.metadata = metadata;
                    }
                    this.requestCache.put({ typeName: cacheType, key: cachekey }, { item: cacheItem.item });
                    // Awaiting a rejected promise will throw, so we need to catch those errors.
                    try {
                        await cacheItem.item;
                    }
                    catch (e) {
                        telemetry.debug(`Error while hyrdating cache item, Type: ${cacheBasedOnType}, Key: ${cachekey}`);
                    }
                    if (cacheType === MODULE_CACHE_KEY) {
                        const moduleItem = cacheItem.item;
                        this._moduleList.push({
                            id: moduleItem.id,
                            typeName: moduleItem.typeName,
                            dataActions: moduleItem.dataActions || []
                        });
                    }
                }
            }
        }
    }
    /**
     * Populates data actions results from cache
     * @param cacheObjectType entity type
     * @param cacheKey cache key
     */
    // tslint:disable-next-line:no-any
    _populateDataActionResultFromCache(cacheObjectType, cacheKey) {
        const cachedValueBasedOnInput = this.requestCache.getValue({ typeName: cacheObjectType, key: cacheKey });
        if (!cachedValueBasedOnInput) {
            return;
        }
        // Ref resolution for promises needs to be delayed until the value is available
        if (isAsyncResult(cachedValueBasedOnInput)) {
            return transaction(() => {
                cachedValueBasedOnInput.then(promiseResult => {
                    // Directly set the result because we want a synchronous change
                    cachedValueBasedOnInput.result = this._resolveCacheRef(cacheObjectType, promiseResult);
                });
                return cachedValueBasedOnInput;
            });
        }
        return this._resolveCacheRef(cacheObjectType, cachedValueBasedOnInput);
    }
    /**
     * Resolves cache reference for the given entity type
     * @param cacheObjectType entity type that is cached
     * @param cacheRefInfo cache ref key
     */
    // tslint:disable-next-line:no-any
    _resolveCacheRef(cacheObjectType, cacheRefInfo) {
        // tslint:disable:no-string-literal
        if (typeof cacheRefInfo !== 'object' || cacheRefInfo['$ref'] !== true) {
            return cacheRefInfo;
        }
        const result = cacheRefInfo['key']
            .map(key => {
            const value = this.requestCache.getValue({ typeName: cacheObjectType, key });
            if (value) {
                return value;
            }
        })
            .filter(Boolean);
        return result && result.length > 0 ? (cacheRefInfo['isCollection'] ? result : result[0]) : null;
    }
    /**
     * Inserts requested modules in cache to prepare the initialData that will be sent to client
     * @param pageData pageData object with list of modules
     * @param resourceManager resourceManager that contains the localized strings
     */
    _putRequestedModulesInCacheOnServer(pageData, resourceManager) {
        const isEditor = (this.requestContext.params && this.requestContext.params.isEditor) || false;
        const themeName = this.requestContext.params?.theme;
        for (let i = 0; i < pageData.slots.length; ++i) {
            const moduleInstance = pageData.slots[i];
            const moduleId = moduleInstance.id;
            this._moduleList.push({
                id: moduleInstance.id,
                typeName: moduleInstance.typeName,
                dataActions: moduleInstance.dataActions
            });
            this.requestCache.put({ typeName: MODULE_CACHE_KEY, key: moduleId }, {
                item: { id: moduleInstance.id, typeName: moduleInstance.typeName }
            });
            this.requestCache.put({ typeName: MODULE_CONFIG_KEY, key: moduleId }, { item: moduleInstance.config });
            this.requestCache.put({ typeName: MODULE_CONFIG_ERRORS_KEY, key: moduleId }, { item: moduleInstance.configErrors });
            this.requestCache.put({ typeName: MODULE_DATA_KEY, key: moduleId }, { item: moduleInstance.data });
            this.requestCache.put({ typeName: MODULE_ACTION_KEY, key: moduleId }, { item: moduleInstance.dataActions });
            this.requestCache.put({ typeName: MSDYN365_WYSIWYG_DISABLED_PROPS, key: moduleId }, { item: [] });
            this.requestCache.put({ typeName: MSDYN365_WYSIWYG_CANADDMODULE, key: moduleId }, { item: [] });
            if (resourceManager && !isEditor) {
                this.requestCache.put({ typeName: MODULE_RESOURCES_KEY, key: moduleInstance.typeName }, { item: resourceManager.getModuleResources(moduleInstance.typeName, themeName, this.requestContext.locale) });
            }
        }
        // In editor mode, put the resources for all modules for the current locale into the cache
        if (isEditor && resourceManager && this.requestContext.features.enableAuthoringRemoveAndAddModule) {
            // tslint:disable-next-line: no-any
            const bindings = msdyn365Commerce.getAllModuleBinder();
            bindings.forEach((moduleBinder) => {
                this.requestCache.put({ typeName: MODULE_RESOURCES_KEY, key: moduleBinder.name }, { item: resourceManager.getModuleResources(moduleBinder.name, themeName, this.requestContext.locale) });
            });
        }
    }
    /**
     * Initializes theme modules list that need to be loaded on the client
     */
    _initThemeModulesList() {
        this._themeModulesList = [];
        if (this.requestContext.params.theme) {
            this._themeModulesList.push(this.requestContext.params.theme);
            this._themeModulesList.push(getParentModuleName(this.requestContext.params.theme));
        }
    }
}
//# sourceMappingURL=page-context.js.map
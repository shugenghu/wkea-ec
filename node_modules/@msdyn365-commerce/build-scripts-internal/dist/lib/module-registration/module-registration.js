"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
var jsonschema_1 = require("jsonschema");
var path = tslib_1.__importStar(require("path"));
var module_dapi_helper_1 = require("./module-dapi-helper");
var module_registration_helper_1 = require("./module-registration-helper");
var module_registration_model_1 = require("./module-registration-model");
var registration_utils_1 = require("./registration-utils");
var localNamespace = '__local__';
// Keeps track of which modules have already been registered to prevent duplicates
var registeredModules = {};
/**
 * Gets data actions for an individual module
 * @param moduleNamespace module definition json object
 * @param dataActions dictionary of data actions
 * @param definitionPath path to theme definition file
 * @param parentDefinitionPath path to parent definition file
 */
var getThemeDataActions = function (moduleNamespace, dataActions, definitionPath, parentDefinitionPath, themeDirectory) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var relativeGlobPattern, themeName, localThemeModuleDefinitionExtensionsPathPattern, ThemeDefinitionsPath, localThemeDefinitionPath, definitionsPaths, themeDefinitionExtension, themeDataActions;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                relativeGlobPattern = '**/*.definition.ext.json';
                themeName = getModuleName(definitionPath);
                localThemeModuleDefinitionExtensionsPathPattern = path.join(process.cwd(), 'src', '**', themeName, '**', '*.definition.ext.json');
                return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(themeDirectory + "/" + relativeGlobPattern)];
            case 1:
                ThemeDefinitionsPath = _a.sent();
                return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(localThemeModuleDefinitionExtensionsPathPattern)];
            case 2:
                localThemeDefinitionPath = _a.sent();
                definitionsPaths = module_registration_helper_1.pathArrayMergeWithBaseName(ThemeDefinitionsPath, localThemeDefinitionPath);
                return [4 /*yield*/, getAllDataActionsFromExtentionFiles(definitionsPaths)];
            case 3:
                themeDefinitionExtension = _a.sent();
                themeDataActions = [];
                //  get the data actions for each module definition extension file of current theme
                return [4 /*yield*/, utilities_internal_1.asyncForEach(Object.keys(themeDefinitionExtension), function (moduleName) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var definitionExtension, extendedModuleDataActions;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    definitionExtension = themeDefinitionExtension[moduleName];
                                    return [4 /*yield*/, getModuleDataActions(moduleNamespace, definitionExtension.definitionObj, dataActions, definitionExtension.definitionPath, parentDefinitionPath, moduleName)];
                                case 1:
                                    extendedModuleDataActions = _a.sent();
                                    themeDataActions.push.apply(themeDataActions, extendedModuleDataActions);
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            case 4:
                //  get the data actions for each module definition extension file of current theme
                _a.sent();
                return [2 /*return*/, Promise.resolve(themeDataActions)];
        }
    });
}); };
/**
 * Gets data actions for an individual module
 * @param definition module definition json object
 * @param dataActions dictionary of data actions
 * @param definitionPath path to definition file
 * @param parentDefinitionPath path to parent definition file
 */
var getModuleDataActions = function (moduleNamespace, definition, dataActions, definitionPath, parentDefinitionPath, moduleName) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var definitionDataActions, isLegacy, moduleDataActions;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (definition.dataActions && definition.module && definition.module.dataActions) {
                    throw new Error("Both parent and child modules should have dataActions as root level property. parentModule: " + parentDefinitionPath + " childModule: " + definitionPath);
                }
                definitionDataActions = definition.dataActions || (definition.module && definition.module.dataActions);
                if (!dataActions[definition.name] && !definitionDataActions) {
                    return [2 /*return*/, Promise.resolve([])];
                }
                if (definition.module && definition.module.dataActions) {
                    // @deprecated
                    utilities_internal_1.trace.warn("module.dataActions property in " + definition.name + " is deprecated. \"dataActions\" should be defined as a root level property of module definition");
                }
                isLegacy = false;
                if (definitionDataActions) {
                    isLegacy = true;
                }
                moduleDataActions = [];
                return [4 /*yield*/, utilities_internal_1.asyncForEach(Object.keys(isLegacy ? definitionDataActions : dataActions[definition.name] || {}), function (dataActionKey) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var dataAction, dataActionAbsolutePath, isHoisted, isNodeDataAction, hoistedRelativePath, fullyResolvedPath;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dataAction = isLegacy ? definitionDataActions[dataActionKey] : dataActions[definition.name][dataActionKey];
                                    if (dataAction.id) {
                                        moduleDataActions.push(tslib_1.__assign({ moduleName: moduleName, id: dataAction.id, name: dataActionKey, 
                                            // @ts-ignore: To cast the types properly
                                            runOn: module_registration_model_1.ActionRuntime[dataAction.runOn] || module_registration_model_1.ActionRuntime.server }, (dataAction.options && { options: dataAction.options })));
                                        return [2 /*return*/];
                                    }
                                    return [4 /*yield*/, registration_utils_1.resolvePathFromDefinition(parentDefinitionPath, dataAction.path, path.dirname(definitionPath))];
                                case 1:
                                    dataActionAbsolutePath = ((_a.sent()) || '').replace(/[\\/]/g, '/');
                                    isHoisted = (dataActionAbsolutePath || '').indexOf(registration_utils_1.hoistedPath) === 0;
                                    if (dataActionAbsolutePath) {
                                        isNodeDataAction = dataActionAbsolutePath.indexOf('node_modules') > -1;
                                        hoistedRelativePath = path.relative(path.resolve(process.cwd(), registration_utils_1.hoistedPath, moduleNamespace), dataActionAbsolutePath);
                                        fullyResolvedPath = isHoisted
                                            ? "hoisted/" + moduleNamespace + "/" + hoistedRelativePath
                                            : isNodeDataAction
                                                ? path.relative(path.join(module_registration_model_1.nodeModulePath), dataActionAbsolutePath)
                                                : path.relative(path.join(process.cwd(), 'src'), dataActionAbsolutePath);
                                        fullyResolvedPath = fullyResolvedPath.replace(/\\/g, '/');
                                        moduleDataActions.push(tslib_1.__assign({ moduleName: moduleName, name: dataActionKey, isNodeDataAction: isNodeDataAction, path: fullyResolvedPath, 
                                            // @ts-ignore: To cast the types properly
                                            runOn: module_registration_model_1.ActionRuntime[dataAction.runOn] || module_registration_model_1.ActionRuntime.server }, (dataAction.options && { options: dataAction.options })));
                                    }
                                    else {
                                        utilities_internal_1.trace.error("Invalid dataAction [" + dataAction.path + "] at " + path.dirname(definitionPath));
                                        process.exit(1);
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            case 1:
                _a.sent();
                return [2 /*return*/, Promise.resolve(moduleDataActions)];
        }
    });
}); };
/**
 * validates the runAt attribute in data definition file
 * @param dataDefinitionProperty json object of data definition
 */
var validateRunAtAttribute = function (dataDefinitionProperty) {
    if (!dataDefinitionProperty) {
        return false;
    }
    if (dataDefinitionProperty.runAt) {
        return (dataDefinitionProperty.runAt &&
            (dataDefinitionProperty.runAt.toString() === 'server' || dataDefinitionProperty.runAt.toString() === 'client'));
    }
    return true;
};
/**
 * Utility method to extract module name from module definition path
 * @param moduleDefinitionPath path to module definition
 */
var getModuleName = function (pathToDefinition) {
    return pathToDefinition ? path.basename(pathToDefinition, '.definition.json') : '';
};
/**
 * Checks if the given module definition is of type theme module
 * @param moduleDefinition module definition object
 */
var isThemeModule = function (moduleDefinition) {
    return moduleDefinition.$type === module_registration_model_1.THEME_MODULE_TYPE;
};
/**
 * Checks if given module definition object has required properties
 * @param definition module definition object
 * @param definitionPath path to module definition
 */
var isValidDefinition = function (definition, definitionPath) {
    if (!definition) {
        utilities_internal_1.trace.error("Invalid module definition");
        return false;
    }
    if (!definition.name) {
        utilities_internal_1.trace.error("Missing name properties in definition file:  [" + definitionPath + "]");
        return false;
    }
    if (isThemeModule(definition)) {
        return true;
    }
    return true;
};
/**
 * Resolves the paths to various theme module artifacts like pages, segments, definition extensions, etc
 * @param themeDirectory path to the theme module directory
 * @param relativeGlobPattern glob pattern for the corresponding artifact
 */
var resolveThemeModuleArtifacts = function (themeDirectory, relativeGlobPattern) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var definitions;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(themeDirectory + "/" + relativeGlobPattern)];
            case 1:
                definitions = _a.sent();
                return [2 /*return*/, definitions.map(function (definitionPath) { return module_registration_helper_1.fixPath(path.relative(themeDirectory, definitionPath)); })];
        }
    });
}); };
/**
 * Gets dictionary of all data actions by reading the definition extension files
 * @param dataDefinitionPaths list of paths to data definition files
 */
var getAllDataActionsFromExtentionFiles = function (moduleDefinitionExtensions) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var moduleDefinition, e_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                moduleDefinition = {};
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, Promise.all(moduleDefinitionExtensions.map(function (moduleDefinitionFilePath) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var moduleName, extendedModuleDefinition;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    utilities_internal_1.trace.info("processing file: [" + moduleDefinitionFilePath + "]");
                                    moduleName = path.basename(moduleDefinitionFilePath).split('.')[0];
                                    return [4 /*yield*/, utilities_internal_1.safeReadJson(moduleDefinitionFilePath, utilities_internal_1.trace)];
                                case 1:
                                    extendedModuleDefinition = _a.sent();
                                    if (extendedModuleDefinition) {
                                        moduleDefinition[moduleName] = {
                                            definitionObj: extendedModuleDefinition,
                                            definitionPath: moduleDefinitionFilePath
                                        };
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 2:
                _a.sent();
                return [3 /*break*/, 4];
            case 3:
                e_1 = _a.sent();
                utilities_internal_1.trace.error("Could not prepare list of data actions from data definition files");
                utilities_internal_1.trace.error(e_1);
                process.exit(1);
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/, Promise.resolve(moduleDefinition)];
        }
    });
}); };
/**
 * Gets dictionary of all data actions by reading the data definition files of all modules
 * @param dataDefinitionPaths list of paths to data definition files
 */
var getAllDataActions = function (dataDefinitionPaths) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var dataActions, e_2;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                dataActions = {};
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, Promise.all(dataDefinitionPaths.map(function (dataDefinitionFilePath) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var dataDefinition, moduleDataActions;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    utilities_internal_1.trace.info("processing file: [" + dataDefinitionFilePath + "]");
                                    return [4 /*yield*/, utilities_internal_1.safeReadJson(dataDefinitionFilePath, utilities_internal_1.trace)];
                                case 1:
                                    dataDefinition = _a.sent();
                                    moduleDataActions = {};
                                    if (dataDefinition && dataDefinition.properties) {
                                        Object.keys(dataDefinition.properties).map(function (propertyKey) {
                                            var dataDefinitionProperty = dataDefinition.properties[propertyKey];
                                            if (dataDefinitionProperty && typeof dataDefinitionProperty.dataAction === 'string') {
                                                if (validateRunAtAttribute(dataDefinitionProperty)) {
                                                    moduleDataActions["" + propertyKey] = {
                                                        path: dataDefinitionProperty.dataAction.replace(/['"]/gi, ''),
                                                        name: propertyKey,
                                                        isNodeDataAction: false,
                                                        runOn: dataDefinitionProperty.runAt
                                                    };
                                                }
                                                else {
                                                    utilities_internal_1.trace.error("Invalid data action runtime @runAt: [" + dataDefinitionProperty.runAt + "] at " + dataDefinitionFilePath);
                                                    process.exit(1);
                                                }
                                            }
                                        });
                                        if (moduleDataActions) {
                                            dataActions["" + dataDefinition.moduleName] = moduleDataActions;
                                        }
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 2:
                _a.sent();
                return [3 /*break*/, 4];
            case 3:
                e_2 = _a.sent();
                utilities_internal_1.trace.error("Could not prepare list of data actions from data definition files");
                utilities_internal_1.trace.error(e_2);
                process.exit(1);
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/, Promise.resolve(dataActions)];
        }
    });
}); };
/**
 * Maps definition to registration object
 * @param definition  definition json object
 * @param definitionPath  path to definition file
 * @param parentDefinitionPath  path to parent definition file
 * @param dataActions  dictionary of data actions indexed against module name
 */
var mapModuleRegistrationFromDefinition = function (packageName, moduleNamespace, definition, definitionPath, parentDefinitionPath, dataActions) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var forceRelativePathResolution, moduleViewRelativePath, parentModuleName, moduleViewAbsolutePath, componentRelativePathResult, themeModule, moduleDirectory, settings, _a, pageLayouts, _b, pages, dataActionsFromFile, _c, definitionExtensions, _d, segments, _e;
    return tslib_1.__generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                if (!isValidDefinition(definition, definitionPath)) {
                    return [2 /*return*/, null];
                }
                forceRelativePathResolution = false;
                moduleViewRelativePath = definition.module ? definition.module.view : null;
                if (!moduleViewRelativePath) {
                    parentModuleName = parentDefinitionPath ? getModuleName(parentDefinitionPath) : null;
                    // Resolve parentview first (for $ref scenario) and fallback to current module in case of independent module
                    moduleViewRelativePath = parentModuleName || definition.name;
                    forceRelativePathResolution = true;
                }
                return [4 /*yield*/, registration_utils_1.resolvePathFromDefinition(parentDefinitionPath, moduleViewRelativePath, path.dirname(definitionPath), forceRelativePathResolution)];
            case 1:
                moduleViewAbsolutePath = _f.sent();
                if (!moduleViewAbsolutePath) {
                    utilities_internal_1.trace.error("Couldn't find view file for module " + definition.name);
                    return [2 /*return*/, null];
                }
                componentRelativePathResult = registration_utils_1.getModuleFileRelativePath({ moduleFileAbsolutePath: moduleViewAbsolutePath, moduleNamespace: moduleNamespace });
                themeModule = isThemeModule(definition);
                moduleDirectory = module_registration_helper_1.fixPath(path.relative(process.cwd(), path.dirname(definitionPath)));
                if (!themeModule) return [3 /*break*/, 3];
                return [4 /*yield*/, resolveThemeModuleArtifacts(moduleDirectory, '/*.settings.json')];
            case 2:
                _a = _f.sent();
                return [3 /*break*/, 4];
            case 3:
                _a = null;
                _f.label = 4;
            case 4:
                settings = _a;
                if (!themeModule) return [3 /*break*/, 6];
                return [4 /*yield*/, resolveThemeModuleArtifacts(moduleDirectory, '**/*.page.json')];
            case 5:
                _b = _f.sent();
                return [3 /*break*/, 7];
            case 6:
                _b = [];
                _f.label = 7;
            case 7:
                pageLayouts = _b;
                pages = {};
                if (!themeModule) return [3 /*break*/, 9];
                return [4 /*yield*/, getThemeDataActions(moduleNamespace, dataActions, definitionPath, parentDefinitionPath, moduleDirectory)];
            case 8:
                _c = _f.sent();
                return [3 /*break*/, 11];
            case 9: return [4 /*yield*/, getModuleDataActions(moduleNamespace, definition, dataActions, definitionPath, parentDefinitionPath)];
            case 10:
                _c = _f.sent();
                _f.label = 11;
            case 11:
                dataActionsFromFile = _c;
                pageLayouts.map(function (pageLayout) {
                    var layoutType = path
                        .dirname(pageLayout)
                        .split('/')
                        .pop() || '';
                    pages[layoutType] = pages[layoutType] || [];
                    pages[layoutType].push(module_registration_helper_1.getRegistrationKey(pageLayout, ".page.json" /* PAGE_FILE */));
                });
                if (!themeModule) return [3 /*break*/, 13];
                return [4 /*yield*/, resolveThemeModuleArtifacts(moduleDirectory, '**/*.definition.ext.json')];
            case 12:
                _d = ((_f.sent()) || []).map(function (ext) {
                    return module_registration_helper_1.getRegistrationKey(ext, ".definition.ext.json" /* DEF_EXT_FILE */);
                });
                return [3 /*break*/, 14];
            case 13:
                _d = [];
                _f.label = 14;
            case 14:
                definitionExtensions = _d;
                if (!themeModule) return [3 /*break*/, 16];
                return [4 /*yield*/, resolveThemeModuleArtifacts(moduleDirectory, '**/*.segment.json')];
            case 15:
                _e = ((_f.sent()) || []).map(function (ext) {
                    return module_registration_helper_1.getRegistrationKey(ext, ".segment.json" /* SEGMENT_FILE */);
                });
                return [3 /*break*/, 17];
            case 16:
                _e = [];
                _f.label = 17;
            case 17:
                segments = _e;
                return [2 /*return*/, {
                        $type: definition.$type,
                        moduleNamespace: moduleNamespace,
                        packageName: packageName,
                        name: definition.name.toLowerCase(),
                        definitionPath: module_registration_helper_1.fixPath(path.relative(process.cwd(), definitionPath)),
                        parentDefinitionPath: parentDefinitionPath ? module_registration_helper_1.fixPath(path.relative(process.cwd(), parentDefinitionPath)) : '',
                        isNodeModule: componentRelativePathResult.isNodeModule,
                        path: componentRelativePathResult.fileRelativePath,
                        dataActions: dataActionsFromFile,
                        moduleDirectory: moduleDirectory,
                        definitionExtensions: definitionExtensions,
                        pages: pages,
                        segments: segments,
                        themeSettings: settings ? settings[0] : ''
                    }];
        }
    });
}); };
/**
 * Method to check duplicate registrations
 * @param moduleRegistrations module registration map
 */
exports.checkDuplicateRegistrations = function (moduleRegistrations) {
    var registrationJson = {};
    Object.keys(moduleRegistrations).forEach(function (key) {
        var existingRegistration = registrationJson[key];
        if (!existingRegistration || (existingRegistration.isNodeModule && utilities_internal_1.trace.info("WARNING - Overwrite external module [" + key + "]"))) {
            registrationJson[key] = moduleRegistrations[key];
        }
        else {
            utilities_internal_1.trace.error("module is already registered -> [" + key + "]");
        }
    });
    return registrationJson;
};
/**
 * Writes registration json files for both local/installed modules
 * @param moduleRegistrations dictionary of module registration objects
 * @param generateLocalModuleRegistration boolean to indicate if the registration is local or installed
 */
var writeRegistrationJson = function (moduleRegistrations, generateLocalModuleRegistration, actionRegistrations) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var registrationJson, modulesRegistration, keys, error_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                registrationJson = {};
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                registrationJson = exports.checkDuplicateRegistrations(moduleRegistrations);
                utilities_internal_1.trace.debug(registrationJson);
                modulesRegistration = [];
                keys = Object.keys(registrationJson);
                module_registration_helper_1.addRegistrationFunctionHeader(modulesRegistration);
                module_registration_helper_1.addRegistrationFunctionBody(keys, registrationJson, modulesRegistration, actionRegistrations);
                module_registration_helper_1.addRegistrationFunctionFooter(modulesRegistration);
                return [4 /*yield*/, module_dapi_helper_1.getModulesDAPIHelperSingleton().prepareModuleDefinitionsForDAPI(registrationJson)];
            case 2:
                _a.sent();
                return [2 /*return*/, utilities_internal_1.safeWriteJS("" + module_registration_model_1.getRegistrationOutputPath(module_registration_model_1.MODULE.registrationFileName) + (generateLocalModuleRegistration ? '.local.js' : '.js'), modulesRegistration)];
            case 3:
                error_1 = _a.sent();
                utilities_internal_1.trace.error(error_1);
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/, Promise.resolve(false)];
        }
    });
}); };
/**
 * Creates the resolved path used by webpack to import the file
 * @param dataActionAbsolutePath Absolute path to .action file
 */
var prepareActionDefinitionPath = function (dataActionAbsolutePath) {
    var isHoisted = (dataActionAbsolutePath || '').indexOf(registration_utils_1.hoistedPath) === 0;
    var isNodeDataAction = dataActionAbsolutePath.indexOf('node_modules') > -1;
    var hoistedRelativePath = path.relative(path.resolve(process.cwd(), registration_utils_1.hoistedPath), dataActionAbsolutePath);
    var fullyResolvedPath = (isHoisted
        ? "hoisted/" + hoistedRelativePath
        : isNodeDataAction
            ? path.relative(path.join(module_registration_model_1.nodeModulePath), dataActionAbsolutePath)
            : path.relative(path.join(process.cwd(), 'src'), dataActionAbsolutePath))
        .split('.')
        .slice(0, -1)
        .join('.');
    var aliasedPath = path.join(!isNodeDataAction && !isHoisted ? 'partner' : '', fullyResolvedPath);
    return { path: fullyResolvedPath, aliasedPath: aliasedPath };
};
var validateSelectedConnectors = function (connectorDefinition, connectorSettings) {
    var _a, _b;
    if (((_a = connectorSettings.experimentation) === null || _a === void 0 ? void 0 : _a.config) && connectorDefinition.name === ((_b = connectorSettings.experimentation) === null || _b === void 0 ? void 0 : _b.name)) {
        if (connectorDefinition.configSchema && Object.keys(connectorDefinition.configSchema).length !== 0) {
            var validateResult = jsonschema_1.validate(connectorSettings.experimentation.config, connectorDefinition.configSchema);
            if (validateResult.errors.length > 0) {
                utilities_internal_1.trace.error("Config provided for " + connectorDefinition.name + " in connector settings does not validate with connector schema. Terminating build.");
                utilities_internal_1.trace.error("Error: " + validateResult.errors);
                process.exit(1);
            }
        }
        else {
            utilities_internal_1.trace.warn("Empty or no config schema provided for " + connectorDefinition.name + ". Skipping JSON schema validation");
        }
    }
};
/**
 * Resolves the path to the connector implementation based of the location of the connector definition file
 */
var prepareConnectorDefinitionPath = function (connectorDefinitionAbsolutePath, connectorSettings) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var connectorDefinition, isHoisted, isNodeDataAction, hoistedRelativePath, fullyResolvedPath, aliasedPath;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utilities_internal_1.safeReadJson(connectorDefinitionAbsolutePath)];
            case 1:
                connectorDefinition = _a.sent();
                if (!connectorDefinition) {
                    throw new Error("Connector definition at " + connectorDefinitionAbsolutePath + " is missing name");
                }
                // If name matches selected connector in connector settings validate its config against connector config schema
                if (connectorSettings && connectorSettings.experimentation) {
                    validateSelectedConnectors(connectorDefinition, connectorSettings);
                }
                isHoisted = (connectorDefinitionAbsolutePath || '').indexOf(registration_utils_1.hoistedPath) === 0;
                isNodeDataAction = connectorDefinitionAbsolutePath.indexOf('node_modules') > -1;
                hoistedRelativePath = path.relative(path.resolve(process.cwd(), registration_utils_1.hoistedPath), connectorDefinitionAbsolutePath);
                fullyResolvedPath = (isHoisted
                    ? "hoisted/" + hoistedRelativePath
                    : isNodeDataAction
                        ? path.relative(path.join(module_registration_model_1.nodeModulePath), connectorDefinitionAbsolutePath)
                        : path.relative(path.join(process.cwd(), 'src'), connectorDefinitionAbsolutePath)).replace('.connector.json', '');
                // If the connector type is experimentation it must provide a .provider file
                if (connectorDefinition.$type === 'experimentationConnector') {
                    aliasedPath = path.join(!isNodeDataAction && !isHoisted ? 'partner' : '', "" + fullyResolvedPath);
                    return [2 /*return*/, {
                            name: connectorDefinition.name,
                            aliasedPaths: { provider: aliasedPath + ".provider", listener: aliasedPath + ".listener" },
                            type: connectorDefinition.$type
                        }];
                }
                else {
                    throw new Error("Unsupported connector type: " + connectorDefinition.$type + " for connector " + connectorDefinition.name);
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Gets module details (packageName and module name space)
 * Local modules are defaulted to __local__ packagename and namespace
 * @param filePath path to the file
 */
var getModuleDetails = function (filePath) {
    var moduleNamespace = localNamespace;
    var packageName = localNamespace;
    var isHoisted = false;
    for (var i = 0; i < registration_utils_1.MODULE_DETAILS_REGEX.length; ++i) {
        var matchResult = filePath.match(registration_utils_1.MODULE_DETAILS_REGEX[i]);
        if (matchResult !== null && matchResult.groups && matchResult.groups.namespace && matchResult.groups.packageName) {
            moduleNamespace = matchResult.groups.namespace;
            packageName = matchResult.groups.packageName;
            isHoisted = (filePath || '').indexOf(registration_utils_1.hoistedPath) === 0;
            return {
                moduleNamespace: moduleNamespace,
                packageName: packageName,
                isHoisted: isHoisted
            };
        }
    }
    return {
        moduleNamespace: moduleNamespace,
        packageName: packageName,
        isHoisted: isHoisted
    };
};
/**
 * Checks for duplicate module and warn if finds a duplicate module
 * @param definitionName name of the module definition
 * @param definitionFilePath path to the definition file path
 * @param isLocalModule indicates if local module
 */
var validateAndWarnIfDuplicateModule = function (definitionName, definitionFilePath, isLocalModule) {
    if (utilities_internal_1.isPartnerApp()) {
        if (registeredModules[definitionName]) {
            utilities_internal_1.trace.warn("Encountered duplicate module " + definitionName + ". At " + definitionFilePath);
            utilities_internal_1.trace.warn((isLocalModule ? 'Local' : 'Installed') + " module " + definitionName + " clashes with " + (registeredModules[definitionName] ? 'local' : 'installed') + " module " + definitionName);
            utilities_internal_1.trace.warn(module_registration_helper_1.DUPLICATE_MODULE_REGISTRAION_ERROR(definitionName));
        }
        else {
            registeredModules[definitionName] = isLocalModule;
        }
    }
};
/**
 * sorts the module registration object
 * @param moduleregistrations map of module registrations
 */
var sortRegistrationObject = function (moduleregistrations) {
    var sortedRegistrationObject = {};
    Object.keys(moduleregistrations)
        .sort()
        .forEach(function (moduleName) {
        sortedRegistrationObject[moduleName] = moduleregistrations[moduleName];
    });
    return sortedRegistrationObject;
};
/* generate view registration from allview.tsx in @msdyn365-commerce-module packages
 * @param isLocal indicates if the registration is for local or installed modules
 */
exports.generateViewRegistration = function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var viewPromises, viewFilePaths, jsToWrite, i, viewFilePath, _a, moduleNamespace, packageName, isHoisted, viewPathForKey, viewRegistrationKey, alias, componentRelativePath, chunkNames, component;
    return tslib_1.__generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                viewPromises = [
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.VIEW.fromLocalModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.VIEW.fromInstalledModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.VIEW.fromHoistedModule, { follow: false })
                ].filter(Boolean);
                return [4 /*yield*/, Promise.all(viewPromises).then(function (result) {
                        return result[0]
                            .concat(result[1])
                            .concat(result[2])
                            .filter(Boolean);
                    })];
            case 1:
                viewFilePaths = _b.sent();
                if (viewFilePaths.length === 0) {
                    utilities_internal_1.trace.info('No view found');
                    return [2 /*return*/];
                }
                jsToWrite = [
                    "/**\n* Copyright (c) 2018 Microsoft Corporation\n* Modules Registration\n* THIS FILE IS AUTO-GENERATED - MANUAL MODIFICATIONS WILL BE LOST\n*/\n\nconst universal = require('react-universal-component').default;\n\nexport const viewDictionary = {};\n"
                ];
                for (i = 0; i < viewFilePaths.length; i++) {
                    viewFilePath = viewFilePaths[i];
                    _a = getModuleDetails(viewFilePath), moduleNamespace = _a.moduleNamespace, packageName = _a.packageName, isHoisted = _a.isHoisted;
                    viewPathForKey = path.join(path.dirname(viewFilePath), path.basename(viewFilePath, ".view" + path.extname(viewFilePath)));
                    viewRegistrationKey = moduleNamespace === localNamespace
                        ? localNamespace + "|" + localNamespace + "|" + module_registration_helper_1.fixPath(path.relative(path.join(process.cwd(), 'src'), viewPathForKey), '|')
                        : moduleNamespace + "|" + packageName + "|" + module_registration_helper_1.fixPath(path.relative(path.join(isHoisted ? module_registration_model_1.resolvedHoistedPath : process.cwd(), 'node_modules', moduleNamespace, packageName, 'dist', 'lib'), viewPathForKey), '|');
                    alias = moduleNamespace === localNamespace ? 'partner/' : "" + (isHoisted ? 'hoisted/' : '');
                    componentRelativePath = module_registration_helper_1.fixPath(moduleNamespace === localNamespace
                        ? path.relative(path.join(process.cwd(), 'src'), viewFilePath)
                        : path.relative(path.join(isHoisted ? module_registration_model_1.resolvedHoistedPath : process.cwd(), 'node_modules'), viewFilePath));
                    chunkNames = ("" + alias + componentRelativePath).replace(/[\\/]/g, '-');
                    component = "viewDictionary['" + viewRegistrationKey + "'] = {\ncomponent: universal(\n   () => import(/* webpackInclude: /.(t|j)sx?$/ */ " + (process.env.NODE_ENV === 'development' ? '\n/* webpackMode: "eager" */' : '') + "\n         /* webpackExclude: /.data.|.autogenerated.|.test.|.field.|.data-model./ */\n         '" + alias + componentRelativePath + "'),\n         {\n            chunkName: () => '" + chunkNames + "',\n            ignoreBabelRename: true\n         }\n    )};";
                    jsToWrite.push(component);
                }
                return [4 /*yield*/, utilities_internal_1.safeWriteJS(module_registration_model_1.getRegistrationOutputPath('view-registration') + ".js", jsToWrite)];
            case 2:
                _b.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * generate connector registration
 */
// tslint:disable-next-line:max-func-body-length
exports.generateConnectorRegistration = function (connectorsConfig) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var promises, connectorFilePaths, jsToWrite, connectors, i, connectorFilePath, connectorRegistrationDetails, connectorValidateCode;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                promises = [
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.CONNECTOR.fromLocalModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.CONNECTOR.fromInstalledModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.CONNECTOR.fromHoistedModule, { follow: false })
                ].filter(Boolean);
                return [4 /*yield*/, Promise.all(promises).then(function (result) {
                        return result[0]
                            .concat(result[1])
                            .concat(result[2])
                            .filter(Boolean);
                    })];
            case 1:
                connectorFilePaths = _a.sent();
                if (connectorFilePaths.length === 0) {
                    utilities_internal_1.trace.info('No connectors found');
                }
                if (!connectorsConfig) {
                    utilities_internal_1.trace.info('Connector settings file missing');
                }
                jsToWrite = [
                    "/**\n* Copyright (c) 2018 Microsoft Corporation\n* Modules Registration\n* THIS FILE IS AUTO-GENERATED - MANUAL MODIFICATIONS WILL BE LOST\n*/\nconst { log, error }  = console;\nconst detailedWebpackError = (msg, errorObject) => { error(msg); error(errorObject); process.env.NODE_ENV !== 'development' && error('Run in dev mode to see full list of errors'); process.exit(50); }\nconst handleError = (modPath, errObject) => {\n    detailedWebpackError('Error with path: ' + modPath, errObject);\n}\n\nconst handleMissingImplementationDetails = (functionName, connectorName, connectorType) => {\n    error('----ERROR: CONNECTOR MISSING IMPLEMENTATION DETAILS-----');\n    error('Missing function ' + functionName + ' from ' + connectorType + ' implementation for experimentation connector ' + connectorName);\n    throw new Error('Connector missing implementation details');\n}\n\nconst verifyExperimentationReigstration = (connectorName) => {\n    const connectorImpl = connectorDictionary[connectorName].provider;\n    const connectorListenerImpl = connectorDictionary[connectorName].listener;\n    try {\n        if (!connectorImpl.__proto__.initialize) {\n            handleMissingImplementationDetails('initialize', connectorName, 'provider');\n        }\n        if (!connectorImpl.__proto__.getConfigForClientSideInit) {\n            handleMissingImplementationDetails('getConfigForClientSideInit', connectorName, 'provider');\n        }\n        if (!connectorImpl.__proto__.initializeClientSide) {\n            handleMissingImplementationDetails('initializeClientSide', connectorName, 'provider');\n        }\n        if (!connectorImpl.__proto__.getExperiments) {\n            handleMissingImplementationDetails('getExperiments', connectorName, 'provider');\n        }\n        if (!connectorImpl.__proto__.getVariantsForUser) {\n            handleMissingImplementationDetails('getVariantsForUser', connectorName, 'provider');\n        }\n        if (!connectorImpl.__proto__.activateExperiment) {\n            handleMissingImplementationDetails('activateExperiment', connectorName, 'provider');\n        }\n        if (!connectorListenerImpl.__proto__.initializeClientSide) {\n            handleMissingImplementationDetails('initializeClientSide', connectorName, 'listener');\n        }\n        if (!connectorListenerImpl.__proto__.logEvent) {\n            handleMissingImplementationDetails('logEvent', connectorName, 'listener');\n        }\n    } catch (e) {\n        // Connector has not implemented all the required methods, setting registration as undefined\n        connectorDictionary[connectorName] = undefined;\n        throw e;\n    }\n}\n\nexport const connectorDictionary = {};\n"
                ];
                connectors = [];
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < connectorFilePaths.length)) return [3 /*break*/, 5];
                connectorFilePath = connectorFilePaths[i];
                return [4 /*yield*/, prepareConnectorDefinitionPath(connectorFilePath, connectorsConfig)];
            case 3:
                connectorRegistrationDetails = _a.sent();
                connectors.push(connectorRegistrationDetails);
                _a.label = 4;
            case 4:
                i++;
                return [3 /*break*/, 2];
            case 5:
                module_registration_helper_1.sortConnectors(connectors);
                jsToWrite.push.apply(jsToWrite, connectors.map(function (connector) {
                    return module_registration_helper_1.prepareConnectorRegistration(connector);
                }));
                return [4 /*yield*/, module_registration_helper_1.generateConnectorValidateMethods(connectors, connectorsConfig)];
            case 6:
                connectorValidateCode = _a.sent();
                jsToWrite.push("\nexport const validateConnectorRegistration = () => {\n    " + connectorValidateCode + "\n};");
                return [4 /*yield*/, utilities_internal_1.safeWriteJS(module_registration_model_1.getRegistrationOutputPath('connector-registration') + ".js", jsToWrite)];
            case 7:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/* generate view registration from allview.tsx in @msdyn365-commerce-module packages
 * @param isLocal indicates if the registration is for local or installed modules
 */
exports.generateComponentRegistration = function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var promises, componentFilePaths, jsToWrite, i, componentFilePath, _a, moduleNamespace, packageName, isHoisted, componentPathForKey, componentRegistrationKey, alias, componentRelativePath, chunkNames, component;
    return tslib_1.__generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                promises = [
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.COMPONENT.fromLocalModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.COMPONENT.fromInstalledModule),
                    utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.COMPONENT.fromHoistedModule, { follow: false })
                ].filter(Boolean);
                return [4 /*yield*/, Promise.all(promises).then(function (result) {
                        return result[0]
                            .concat(result[1])
                            .concat(result[2])
                            .concat(result[3])
                            .concat(result[4])
                            .filter(Boolean);
                    })];
            case 1:
                componentFilePaths = _b.sent();
                if (componentFilePaths.length === 0) {
                    utilities_internal_1.trace.info('No view found');
                    return [2 /*return*/];
                }
                jsToWrite = [
                    "/**\n* Copyright (c) 2018 Microsoft Corporation\n* Modules Registration\n* THIS FILE IS AUTO-GENERATED - MANUAL MODIFICATIONS WILL BE LOST\n*/\n\nconst universal = require('react-universal-component').default;\nexport const componentDictionary = {};\n"
                ];
                for (i = 0; i < componentFilePaths.length; i++) {
                    componentFilePath = componentFilePaths[i];
                    _a = getModuleDetails(componentFilePath), moduleNamespace = _a.moduleNamespace, packageName = _a.packageName, isHoisted = _a.isHoisted;
                    componentPathForKey = path.join(path.dirname(componentFilePath), path.basename(path.basename(componentFilePath, '.component.js'), '.component.tsx'));
                    componentRegistrationKey = moduleNamespace === localNamespace
                        ? localNamespace + "|" + localNamespace + "|" + module_registration_helper_1.fixPath(path.relative(path.join(process.cwd(), 'src'), componentPathForKey), '|')
                        : moduleNamespace + "|" + packageName + "|" + module_registration_helper_1.fixPath(path.relative(path.join(isHoisted ? module_registration_model_1.resolvedHoistedPath : process.cwd(), 'node_modules', moduleNamespace, packageName, 'dist', 'lib'), componentPathForKey), '|');
                    alias = moduleNamespace === localNamespace ? 'partner/' : "" + (isHoisted ? 'hoisted/' : '');
                    componentRelativePath = module_registration_helper_1.fixPath(moduleNamespace === localNamespace
                        ? path.relative(path.join(process.cwd(), 'src'), componentFilePath)
                        : path.relative(path.join(isHoisted ? module_registration_model_1.resolvedHoistedPath : process.cwd(), 'node_modules'), componentFilePath));
                    chunkNames = ("" + alias + componentRelativePath).replace(/[\\/]/g, '-');
                    component = "componentDictionary['" + componentRegistrationKey + "'] = {\ncomponent: universal(\n   () => import(/* webpackInclude: /.(t|j)sx?$/ */ " + (process.env.NODE_ENV === 'development' ? '\n/* webpackMode: "eager" */' : '') + "\n         /* webpackExclude: /.data.|.autogenerated.|.test.|.field.|.data-model./ */\n         '" + alias + componentRelativePath + "'),\n         {\n            chunkName: () => '" + chunkNames + "',\n            ignoreBabelRename: true\n         }\n    )};";
                    jsToWrite.push(component);
                }
                return [4 /*yield*/, utilities_internal_1.safeWriteJS(module_registration_model_1.getRegistrationOutputPath('component-registration') + ".js", jsToWrite)];
            case 2:
                _b.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * generate module registration from all module definition in @msdyn365-commerce-module packages
 * @param isLocal indicates if the registration is for local or installed modules
 */
// tslint:disable-next-line:max-func-body-length
exports.generateModuleRegistration = function (isLocal) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var promises, definitionFilePaths, dataDefinitionPaths, actionDefinitionPaths, dataActions, moduleRegistrations_1, _a, _b, e_3;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                promises = ([
                    utilities_internal_1.safeGetAllFilesPath(registration_utils_1.msdyn365ModuleDefinitionGlobPattern(isLocal)),
                    !isLocal && utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.DEFINITION.fromHoistedModule, { follow: false })
                ].filter(Boolean));
                return [4 /*yield*/, Promise.all(promises).then(function (result) { return result[0].concat(result[1]).filter(Boolean); })];
            case 1:
                definitionFilePaths = _c.sent();
                if (definitionFilePaths.length === 0) {
                    utilities_internal_1.trace.info("No module found at '" + registration_utils_1.msdyn365ModuleDefinitionGlobPattern + "'");
                }
                promises = [
                    utilities_internal_1.safeGetAllFilesPath(registration_utils_1.msdyn365ModuleDataDefinitionGlobPattern(isLocal)),
                    !isLocal && utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.DATADEFINITION.fromHoistedModule, { follow: false })
                ];
                return [4 /*yield*/, Promise.all(promises).then(function (result) { return result[0].concat(result[1]).filter(Boolean); })];
            case 2:
                dataDefinitionPaths = _c.sent();
                if (dataDefinitionPaths.length === 0) {
                    utilities_internal_1.trace.info("No data definition files found at " + registration_utils_1.msdyn365ModuleDataDefinitionGlobPattern);
                }
                promises = [
                    utilities_internal_1.safeGetAllFilesPath(registration_utils_1.msdyn365ActionDefinitionGlobPattern(isLocal)),
                    !isLocal && utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.ACTION.fromHoistedModule, { follow: false })
                ];
                return [4 /*yield*/, Promise.all(promises).then(function (result) {
                        return result[0]
                            .concat(result[1])
                            .filter(Boolean)
                            .map(prepareActionDefinitionPath);
                    })];
            case 3:
                actionDefinitionPaths = _c.sent();
                return [4 /*yield*/, getAllDataActions(dataDefinitionPaths)];
            case 4:
                dataActions = _c.sent();
                _c.label = 5;
            case 5:
                _c.trys.push([5, 8, , 9]);
                moduleRegistrations_1 = {};
                return [4 /*yield*/, Promise.all(definitionFilePaths.map(function (definitionFilePath) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                        var definition, _a, moduleNamespace, packageName, referencedOutput, parentDefinitionPath, moduleDefinition, _b, moduleRegObj, e_4;
                        return tslib_1.__generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    utilities_internal_1.trace.info("processing def file: [" + definitionFilePath + "]");
                                    return [4 /*yield*/, utilities_internal_1.safeReadJson(definitionFilePath, utilities_internal_1.trace)];
                                case 1:
                                    definition = _c.sent();
                                    _a = getModuleDetails(definitionFilePath), moduleNamespace = _a.moduleNamespace, packageName = _a.packageName;
                                    _c.label = 2;
                                case 2:
                                    _c.trys.push([2, 8, , 9]);
                                    if (!definition) return [3 /*break*/, 7];
                                    return [4 /*yield*/, utilities_internal_1.resolveRef(definition, definitionFilePath, utilities_internal_1.trace)];
                                case 3:
                                    referencedOutput = _c.sent();
                                    parentDefinitionPath = null;
                                    // Resolve view from parent definition if there is no view override in current definition file
                                    if (definition.$ref) {
                                        parentDefinitionPath = definition.$ref;
                                        // resolve parent definition path with respect to current module definition or node_modules
                                        parentDefinitionPath = utilities_internal_1.resolveParentDefinitionPath(parentDefinitionPath, path.dirname(definitionFilePath));
                                    }
                                    moduleDefinition = referencedOutput;
                                    if (!(moduleDefinition && moduleDefinition.name)) return [3 /*break*/, 7];
                                    moduleDefinition.name = moduleDefinition.name.toLowerCase();
                                    _b = moduleDefinition.$type;
                                    switch (_b) {
                                        case 'definitionExtension': return [3 /*break*/, 4];
                                    }
                                    return [3 /*break*/, 5];
                                case 4: 
                                // skip registration of definition overrides
                                return [3 /*break*/, 7];
                                case 5:
                                    validateAndWarnIfDuplicateModule(definition.name, definitionFilePath, isLocal);
                                    return [4 /*yield*/, mapModuleRegistrationFromDefinition(packageName, moduleNamespace, moduleDefinition, definitionFilePath, parentDefinitionPath || '', dataActions)];
                                case 6:
                                    moduleRegObj = _c.sent();
                                    if (moduleRegObj) {
                                        moduleRegistrations_1[moduleDefinition.name] = moduleRegObj;
                                    }
                                    _c.label = 7;
                                case 7: return [3 /*break*/, 9];
                                case 8:
                                    e_4 = _c.sent();
                                    utilities_internal_1.trace.error(e_4);
                                    utilities_internal_1.trace.error("error in processing file [" + definitionFilePath + "]");
                                    return [2 /*return*/, Promise.resolve()];
                                case 9: return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 6:
                _c.sent();
                _b = (_a = Promise).all;
                return [4 /*yield*/, writeRegistrationJson(sortRegistrationObject(moduleRegistrations_1), isLocal, actionDefinitionPaths)];
            case 7: return [2 /*return*/, _b.apply(_a, [[_c.sent()]])];
            case 8:
                e_3 = _c.sent();
                utilities_internal_1.trace.error(e_3);
                process.exit(1);
                return [3 /*break*/, 9];
            case 9: return [2 /*return*/, Promise.resolve()];
        }
    });
}); };
// tslint:disable-next-line:no-any
exports.buildModuleRegistration = function (isLocal) {
    var timerName = "generateModuleRegistration" + (isLocal ? '-local' : '');
    utilities_internal_1.trace.startTimer(timerName);
    return exports.generateModuleRegistration(isLocal)
        .catch(function (err) {
        utilities_internal_1.trace.error(err);
    })
        .then(function () { return utilities_internal_1.trace.stopTimer(timerName, 'Module registration generation completed'); });
};
//# sourceMappingURL=module-registration.js.map
"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
var path = tslib_1.__importStar(require("path"));
var module_registration_helper_1 = require("./module-registration-helper");
var module_registration_model_1 = require("./module-registration-model");
exports.getRegistrationOutputPath = function (fileName) { return path.resolve(path.join(process.cwd(), 'lib', fileName)); };
exports.msdyn365ModuleDefinitionGlobPattern = function (generateLocalModuleRegistration) {
    return generateLocalModuleRegistration ? module_registration_model_1.DEFINITION.fromLocalModule : module_registration_model_1.DEFINITION.fromInstalledModule;
};
exports.msdyn365ModuleDataDefinitionGlobPattern = function (generateLocalModuleRegistration) {
    return generateLocalModuleRegistration ? module_registration_model_1.DATADEFINITION.fromLocalModule : module_registration_model_1.DATADEFINITION.fromInstalledModule;
};
exports.msdyn365ActionDefinitionGlobPattern = function (generateLocalModuleRegistration) {
    return generateLocalModuleRegistration ? module_registration_model_1.ACTION.fromLocalModule : module_registration_model_1.ACTION.fromInstalledModule;
};
exports.MODULE_DETAILS_REGEX = utilities_internal_1.getSupportedNamespaces().map(function (packageNamespace) { return new RegExp("/node_modules/(?<namespace>" + packageNamespace + ")/(?<packageName>.*)/dist/lib/.*"); });
/**
 * @description Constant for hoisted path to node_modules
 * @internal
 */
exports.hoistedPath = module_registration_helper_1.fixPath(path.resolve('../../node_modules'));
/**
 * @description Helper function to get component relative path
 * @internal
 */
exports.getModuleFileRelativePath = function (_a) {
    var moduleFileAbsolutePath = _a.moduleFileAbsolutePath, moduleNamespace = _a.moduleNamespace;
    var isNodeModule = moduleFileAbsolutePath.indexOf('node_modules') > -1;
    var isHoisted = module_registration_helper_1.fixPath(moduleFileAbsolutePath).indexOf(exports.hoistedPath) === 0;
    var componentRelativePath = module_registration_helper_1.fixPath(isNodeModule
        ? isHoisted
            ? path.relative(path.resolve(process.cwd(), exports.hoistedPath, moduleNamespace), moduleFileAbsolutePath)
            : path.relative(path.join(module_registration_model_1.nodeModulePath, moduleNamespace), moduleFileAbsolutePath)
        : path.relative(path.join(process.cwd(), 'src'), moduleFileAbsolutePath));
    return {
        fileRelativePath: componentRelativePath,
        isNodeModule: isNodeModule
    };
};
/**
 * Utility function to check if a path exists w.r.t partner app root.
 * @param filePath path to file that needs to be verified
 * @param directory directory w.r.t partner app root where file needs to be searched
 */
var getPathIfExists = function (filePath, directory, forceRelativePathResolution) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var relativePath, componentPath, isPathExist, _a;
    return tslib_1.__generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!filePath) {
                    return [2 /*return*/, null];
                }
                relativePath = filePath.startsWith('.') || forceRelativePathResolution;
                componentPath = relativePath ? path.resolve(path.join(directory, filePath)) : path.resolve(path.join(module_registration_model_1.nodeModulePath, filePath));
                if (!relativePath) return [3 /*break*/, 2];
                return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(componentPath + ".+(js|ts|tsx)")];
            case 1:
                _a = _b.sent();
                return [3 /*break*/, 4];
            case 2: return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(componentPath + ".+(js)")];
            case 3:
                _a = _b.sent();
                _b.label = 4;
            case 4:
                isPathExist = _a;
                return [2 /*return*/, isPathExist.length > 0 ? componentPath : null];
        }
    });
}); };
/**
 * Resolves module view/dataAction from the path specified in definition file. In case if a
 * definition is inherited, the path is resolved against parent definition path
 * @param parentDefinitionPath path to parent definition file - for scenarios where definition file is inherited
 * @param moduleFileRelativePath file to be resolved (view/dataAction)
 * @param moduleDirectoryPath path to module directory
 */
exports.resolvePathFromDefinition = function (parentDefinitionPath, moduleFileRelativePath, moduleDirectoryPath, forceRelativePathResolution) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var fileAbsolutePath, definitionHoistedPath, hoistedPathExists, requirePath, absoluteRequirePath;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, getPathIfExists(moduleFileRelativePath, moduleDirectoryPath, forceRelativePathResolution)];
            case 1:
                fileAbsolutePath = _a.sent();
                if (fileAbsolutePath) {
                    return [2 /*return*/, fileAbsolutePath];
                }
                definitionHoistedPath = path
                    .resolve(process.cwd(), path.join('../../node_modules', path.dirname(moduleFileRelativePath), path.basename(moduleFileRelativePath, '.js') + ".js"))
                    .replace(/[\\/]/g, '/');
                return [4 /*yield*/, utilities_internal_1.safeFileExists(definitionHoistedPath)];
            case 2:
                hoistedPathExists = _a.sent();
                utilities_internal_1.trace.debug("Hoisted path [" + definitionHoistedPath + "] " + (hoistedPathExists ? 'exists' : 'does not exist'));
                if (hoistedPathExists) {
                    return [2 /*return*/, definitionHoistedPath];
                }
                // finally try node resolution
                try {
                    requirePath = require.resolve(moduleFileRelativePath);
                    absoluteRequirePath = path.resolve(path.relative(process.cwd(), requirePath)).replace(/[\\/]/g, '/');
                    utilities_internal_1.trace.debug("Node require path resolved: " + absoluteRequirePath);
                    return [2 /*return*/, absoluteRequirePath];
                }
                catch (_b) {
                    // eat error
                    utilities_internal_1.trace.debug("Node was not able to resolve " + moduleFileRelativePath);
                }
                if (!parentDefinitionPath) {
                    utilities_internal_1.trace.error("Could not resolve file: [" + moduleFileRelativePath + "] at " + moduleDirectoryPath);
                    return [2 /*return*/, null];
                }
                // Could not resolve component w.r.t current definition path folder
                // Let us try to resolve it against the parent definition folder
                utilities_internal_1.trace.info("Could not resolve file: [" + moduleFileRelativePath + "] at " + moduleDirectoryPath + "\n    Attempting to resolve component [" + moduleFileRelativePath + "] w.r.t parent definition " + parentDefinitionPath);
                return [4 /*yield*/, getPathIfExists(moduleFileRelativePath, path.dirname(parentDefinitionPath), forceRelativePathResolution)];
            case 3:
                fileAbsolutePath = _a.sent();
                if (!fileAbsolutePath) {
                    utilities_internal_1.trace.error("Could not resolve file: [" + moduleFileRelativePath + "] at parent definition " + parentDefinitionPath);
                }
                return [2 /*return*/, fileAbsolutePath || null];
        }
    });
}); };
//# sourceMappingURL=registration-utils.js.map
"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
var path = tslib_1.__importStar(require("path"));
var module_registration_model_1 = require("./module-registration-model");
/**
 * merge two path arrays, elements in array B will replace elements in array A if the file names are same
 *
 * @param pathArrayA An array of file paths
 * @param pathArrayB An array of file paths
 */
exports.pathArrayMergeWithBaseName = function (pathArrayA, pathArrayB) {
    return pathArrayA.filter(function (pathA) { return !pathArrayB.find(function (pathB) { return path.basename(pathA) === path.basename(pathB); }); }).concat(pathArrayB);
};
/**
 * Normalizes slashes to `/` to make them uniform
 *
 * @param pathToFile A path string
 * @param replaceWith The slash to normalize the path with
 * @internal
 */
exports.fixPath = function (pathToFile, replaceWith) {
    if (replaceWith === void 0) { replaceWith = '/'; }
    return pathToFile && pathToFile.replace(/\/|\\/g, replaceWith);
};
/**
 * Verifies whether the object array has elements.
 * @param array
 * @return {boolean} True if the object has elements, false otherwise.
 */
// tslint:disable-next-line:no-any
var hasElements = function (array) {
    return !!array && array.length > 0;
};
/**
 * sorts the connectors array so that entries in registration file are written in sorted order
 */
exports.sortConnectors = function (connectors) {
    return (connectors || []).sort(function (a, b) {
        if (!a || !b) {
            return 0;
        }
        if (a.name < b.name) {
            return -1;
        }
        if (a.name > b.name) {
            return 1;
        }
        return 0;
    });
};
/**
 * sorts the data actions array so that entries in registration file are written in sorted order
 */
var sortDataActions = function (dataActions) {
    return (dataActions || []).sort(function (a, b) {
        if (!a || !b) {
            return 0;
        }
        if (a.path < b.path) {
            return -1;
        }
        if (a.path > b.path) {
            return 1;
        }
        return 0;
    });
};
/**
 * Prepares a registration key for the given file path
 * @param filePath path to the file that needs to be registered in the module registration object
 * @return {string} Returns the key generated by replacing the file extensions and slashes
 */
exports.getRegistrationKey = function (filePath, ext) {
    return filePath ? path.basename(filePath, ext).replace(/[\\/\.]/g, '-') : '';
};
/**
 * Method to add the module-registration.js file header that initializes bindings object
 * and adds handleError and isNotRegistered utility methods
 * @param modulesRegistration array of module registration objects
 */
exports.addRegistrationFunctionHeader = function (modulesRegistration) {
    var header = "\n/**\n * Copyright (c) 2018 Microsoft Corporation\n * Modules Registration\n * THIS FILE IS AUTO-GENERATED - MANUAL MODIFICATIONS WILL BE LOST\n */\n\nconst universal = require('react-universal-component').default;\n\n/**\n * Register all available modules\n */\nexport const registerAllModules = (requiredModules) => {\n    let binding = { modules: {}, dataActions: {} };\n    const { log, error }  = console;\n    const detailedWebpackError = (msg, errorObject) => { error(msg); error(errorObject); process.env.NODE_ENV !== 'development' && error('Run in dev mode to see full list of errors'); process.exit(50); }\n    const handleError = (modPath, errObject) => {\n        detailedWebpackError('Error with path: ' + modPath, errObject);\n    }\n    if (requiredModules) {\n        requiredModules = requiredModules.map((module) => module.toLowerCase());\n    }\n    const isNotRegistered = (moduleName) => {\n        return !requiredModules || requiredModules.length <= 0 || requiredModules.findIndex((module) => module === moduleName) !== -1;\n    };\n\n    " + (process.env.NODE_ENV !== 'development' ? 'try {' : '') + "\n";
    modulesRegistration.push(header);
};
// tslint:disable-next-line: max-func-body-length
exports.addRegistrationFunctionBody = function (keys, registrationJson, modulesRegistration, actionRegistrations) {
    var prepareDataActionPreRegistration = function (action) {
        var actionPath = exports.fixPath(action.path);
        var aliasedPath = exports.fixPath(action.aliasedPath);
        var loadActionScript = "\n            const actionPath = '" + actionPath + "';\n            binding.dataActions[actionPath] = require('" + aliasedPath + "');\n            if (binding.dataActions[actionPath] &&\n                binding.dataActions[actionPath].default &&\n                binding.dataActions[actionPath].default.prototype &&\n                binding.dataActions[actionPath].default.prototype.id) {\n                binding.dataActions[binding.dataActions[actionPath].default.prototype.id] = binding.dataActions[actionPath];\n            }\n        ";
        if (process.env.NODE_ENV === 'development') {
            loadActionScript = "\n            try {\n" + loadActionScript + "\n            } catch(e) {\n                binding.dataActions[actionPath] = undefined;\n                handleError(actionPath, e);\n            }\n           ";
        }
        return "\n        {\n            " + loadActionScript + "\n        }";
    };
    var prepareModuleRegistrationOutput = function (key, isNodeModule) {
        var isHoisted = registrationJson[key].definitionPath.startsWith('../../node_modules/@msdyn365-commerce-modules');
        var alias = !isNodeModule
            ? 'partner/'
            : isHoisted
                ? "hoisted/" + registrationJson[key].moduleNamespace + "/"
                : registrationJson[key].moduleNamespace + "/";
        var dataActions = registrationJson[key].dataActions
            .sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            }
            else if (a.name > b.name) {
                return 1;
            }
            else {
                return a.path < b.path ? -1 : 1;
            }
        })
            .map(function (dataAction) {
            var dataActionPath = exports.fixPath(dataAction.path);
            return "{name:'" + dataAction.name + "', " + (dataAction.id ? "id: '" + dataAction.id + "'," : '') + " path:'" + dataActionPath + "', " + (registrationJson[key].$type === 'themeModule' ? "moduleName: '" + dataAction.moduleName + "'," : '') + "runOn: " + dataAction.runOn + (dataAction.options ? ",options: " + JSON.stringify(dataAction.options) : '') + "}";
        })
            .join();
        var chunkNames = ("" + alias + exports.fixPath(registrationJson[key].path)).replace(/[\\/]/g, '-');
        var component = registrationJson[key].path
            ? "component: universal(\n            () =>\n                import(/* webpackInclude: /.(t|j)sx?$/ */ " + (process.env.NODE_ENV === 'development' ? '\n/* webpackMode: "eager" */' : '') + "\n                /* webpackExclude: /.data.|.autogenerated.|.test.|.field.|.data-model./ */\n                '" + alias + exports.fixPath(registrationJson[key].path) + "'),\n            {\n                chunkName: () => '" + chunkNames + "',\n                ignoreBabelRename: true\n            }\n        ),"
            : '';
        var pages = registrationJson[key].pages && Object.keys(registrationJson[key].pages || {}).length
            ? "pages: {" + Object.keys(registrationJson[key].pages || {})
                .map(function (layoutType) {
                return "'" + layoutType + "': [" + registrationJson[key]
                    .pages[layoutType].map(function (layout) { return "'" + exports.getRegistrationKey(layout, '.page.json') + "'"; })
                    .join() + "]";
            })
                .join() + "},"
            : '';
        var segments = hasElements(registrationJson[key].segments)
            ? "segments: [" + registrationJson[key].segments.map(function (segment) { return "'" + exports.getRegistrationKey(segment, '.segment.json') + "'"; }).join() + "],"
            : '';
        var definitionExtensions = hasElements(registrationJson[key].definitionExtensions)
            ? "definitionExtensions: [" + registrationJson[key]
                .definitionExtensions.map(function (defExt) { return "'" + exports.getRegistrationKey(defExt, '.definition.ext.json') + "'"; })
                .join() + "],"
            : '';
        var settings = registrationJson[key].themeSettings ? "themeSettings: '" + registrationJson[key].themeSettings + "'," : '';
        var moduleDirectory = registrationJson[key].moduleDirectory ? "moduleDirectory: '" + registrationJson[key].moduleDirectory + "'" : '';
        return "\n    isNotRegistered('" + key + "') && (binding.modules['" + key + "'] = {\n        " + component + "\n        $type: '" + registrationJson[key].$type + "',\n        dataActions: [" + dataActions + "],\n        " + definitionExtensions + "\n        definitionPath: '" + registrationJson[key].definitionPath + "',\n        isNodeModule: " + registrationJson[key].isNodeModule + ",\n        moduleNamespace: '" + registrationJson[key].moduleNamespace + "',\n        name: '" + registrationJson[key].name + "',\n        packageName: '" + registrationJson[key].packageName + "',\n        " + pages + "\n        parentDefinitionPath: '" + registrationJson[key].parentDefinitionPath + "',\n        " + segments + "\n        " + settings + "\n        " + moduleDirectory + "\n    });\n            ";
    };
    keys.sort().forEach(function (key) {
        return modulesRegistration.push(prepareModuleRegistrationOutput(key, registrationJson[key].isNodeModule));
    });
    var prepareDataActionRegistrationOutput = function (dataAction, key, isNodeDataAction) {
        if (dataAction.id) {
            return '';
        }
        var isAlreadyAliased = dataAction.path.startsWith('hoisted');
        var alias = !isNodeDataAction && !isAlreadyAliased ? 'partner/' : '';
        if (process.env.NODE_ENV === 'development') {
            return "\n    try {\n        if (isNotRegistered('" + key + "')) {\n            const sanitizedActionPath = '" + exports.fixPath(dataAction.path) + "';\n            let dataAction = require('" + alias + exports.fixPath(dataAction.path) + "');\n            if (!dataAction.default) {\n                throw new Error('Data action path does not have a default export');\n            }\n            if (!(dataAction.default.prototype.id && binding.dataActions[dataAction.default.prototype.id]) || !binding.dataActions[sanitizedActionPath]) {\n                binding.dataActions[sanitizedActionPath] = dataAction;\n            }\n        }\n    } catch(e) {\n        binding.dataActions['" + exports.fixPath(dataAction.path) + "'] = undefined;\n        handleError('" + exports.fixPath(dataAction.path) + "', e);\n    }\n    ";
        }
        else {
            return "\n        if (isNotRegistered('" + key + "')) {\n            const sanitizedActionPath = '" + exports.fixPath(dataAction.path) + "';\n            binding.dataActions[sanitizedActionPath] = require('" + alias + exports.fixPath(dataAction.path) + "');\n            if (!binding.dataActions[sanitizedActionPath].default) {\n                throw new Error('Data action path ' + sanitizedActionPath + ' does not have a default export');\n            }\n            binding.dataActions[sanitizedActionPath].default.prototype.RegistrationId = sanitizedActionPath;\n            if (binding.dataActions[sanitizedActionPath].default.prototype.id) {\n                binding.dataActions[binding.dataActions[sanitizedActionPath].default.prototype.id] = sanitizedActionPath;\n            }\n        }\n            ";
        }
    };
    var sortedActionRegistartions = sortDataActions(actionRegistrations || []);
    sortedActionRegistartions.forEach(function (action) {
        modulesRegistration.push(prepareDataActionPreRegistration(action));
    });
    var dataActionSet = {};
    keys.forEach(function (key) {
        if (registrationJson[key].dataActions && registrationJson[key].dataActions.length > 0) {
            var nodeDataActions = (registrationJson[key].dataActions || []).filter(function (dataAction) { return dataAction.isNodeDataAction; });
            sortDataActions(nodeDataActions).forEach(function (dataAction) {
                modulesRegistration.push(prepareDataActionRegistrationOutput(dataAction, key, dataAction.isNodeDataAction));
                var actionName = dataAction.id || dataAction.path;
                if (dataActionSet[actionName] && dataActionSet[actionName] !== module_registration_model_1.ActionRuntime[dataAction.runOn].toLowerCase()) {
                    utilities_internal_1.trace.warn("Multiple data action definition for " + actionName + " with conflicting 'runOn' configuration (server/client/serverOnly) found. Action will be run on server by default");
                }
                else {
                    dataActionSet[actionName] = module_registration_model_1.ActionRuntime[dataAction.runOn].toLowerCase();
                }
            });
            var partnerDataActions = (registrationJson[key].dataActions || []).filter(function (dataAction) { return !dataAction.isNodeDataAction; });
            sortDataActions(partnerDataActions).forEach(function (dataAction) {
                modulesRegistration.push(prepareDataActionRegistrationOutput(dataAction, key, dataAction.isNodeDataAction));
                var actionName = dataAction.id || dataAction.path;
                if (dataActionSet[actionName] && dataActionSet[actionName] !== module_registration_model_1.ActionRuntime[dataAction.runOn].toLowerCase()) {
                    utilities_internal_1.trace.warn("Multiple data action definition for " + actionName + " with conflicting 'runOn' configuration (server/client/serverOnly) found. Action will be run on server by default");
                }
                else {
                    dataActionSet[actionName] = module_registration_model_1.ActionRuntime[dataAction.runOn].toLowerCase();
                }
            });
        }
    });
};
exports.addRegistrationFunctionFooter = function (modulesRegistration) {
    var returnStatement = "\n    " + (process.env.NODE_ENV !== 'development'
        ? "\n    } catch (e) {\n        handleError('-', e);\n    }\n    "
        : '') + "\n    return binding;\n};";
    modulesRegistration.push(returnStatement);
};
var getLoadConnectorScriptByType = function (name, connectorType, paths) {
    var providerPath;
    var listenerPath;
    switch (connectorType) {
        case 'experimentationConnector':
            providerPath = exports.fixPath(paths.provider);
            listenerPath = exports.fixPath(paths.listener);
            return "\n        let connectorProviderImpl = require('" + providerPath + "');\n        let connectorListenerImpl = require('" + listenerPath + "');\n        if (!connectorProviderImpl.default) {\n            throw new Error('Exp Connector provider " + name + " does not have a default export. Check the provider file of the connector for a default export.');\n        }\n        if (!connectorListenerImpl.default) {\n            throw new Error('Exp Connector listener " + name + " does not have a default export. Check the listener file of the connector for a default export.');\n        }\n        connectorDictionary[connectorName] = {provider: connectorProviderImpl.default, listener: connectorListenerImpl.default};";
        case 'geoLookupConnector':
            providerPath = exports.fixPath(paths.provider);
            return "\n        let connectorProviderImpl = require('" + providerPath + "');\n        if (!connectorProviderImpl.default) {\n            throw new Error('Exp Connector provider " + name + " does not have a default export. Check the provider file of the connector for a default export.');\n        }\n        connectorDictionary[connectorName] = {provider: connectorProviderImpl.default};";
        default:
            return '';
    }
};
/**
 * Prepares the registraion JS code for a single connector
 * Additionally creates the logic necessary for validating the connector follows any required implementation
 */
exports.prepareConnectorRegistration = function (connector) {
    var connectorName = connector.name;
    // Generate the script to load the connector
    var loadConnectorScript = getLoadConnectorScriptByType(connector.name, connector.type, connector.aliasedPaths);
    if (process.env.NODE_ENV === 'development') {
        loadConnectorScript = "\n        try {\n" + loadConnectorScript + "\n        } catch(e) {\n            connectorDictionary[connectorName] = undefined;\n            handleError(connectorName, e);\n        }\n       ";
    }
    return "\n    {\n        const connectorName = '" + connectorName + "';\n        " + loadConnectorScript + "\n    }";
};
exports.generateConnectorValidateMethods = function (connectors, connectorsConfig) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        return [2 /*return*/, connectors
                .map(function (connector) {
                switch (connector.type) {
                    case 'experimentationConnector': {
                        if (connectorsConfig && connectorsConfig.experimentation && connectorsConfig.experimentation.name === connector.name) {
                            return "\n    verifyExperimentationReigstration('" + connector.name + "');";
                        }
                        break;
                    }
                    case 'geoLookupConnector': {
                        if (connectorsConfig && connectorsConfig.geoLookup && connectorsConfig.geoLookup.name === connector.name) {
                            return "\n    verifyGeoLookupRegistration('" + connector.name + "');";
                        }
                        break;
                    }
                    default: {
                        throw new Error("Unsupported type connector encountered. Connector " + connector.name + " with type " + connector.type);
                    }
                }
            })
                .join('\n')];
    });
}); };
exports.DUPLICATE_MODULE_REGISTRAION_ERROR = function (moduleName) {
    return "Duplicate module encountered. Module with name " + moduleName + " already exists";
};
//# sourceMappingURL=module-registration-helper.js.map
{"version":3,"file":"registration-utils.js","sourceRoot":"","sources":["../../../src/module-registration/registration-utils.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { getSupportedNamespaces, safeFileExists, safeGetAllFilesPath, trace } from '@msdyn365-commerce/utilities-internal';\nimport * as path from 'path';\nimport { IGetRelativePathOptions, IGetRelativePathResult } from '../models';\nimport { fixPath } from './module-registration-helper';\nimport { ACTION, DATADEFINITION, DEFINITION, nodeModulePath } from './module-registration-model';\n\nexport const getRegistrationOutputPath = (fileName: string) => path.resolve(path.join(process.cwd(), 'lib', fileName));\n\nexport const msdyn365ModuleDefinitionGlobPattern = (generateLocalModuleRegistration: Boolean) =>\n    generateLocalModuleRegistration ? DEFINITION.fromLocalModule : DEFINITION.fromInstalledModule;\n\nexport const msdyn365ModuleDataDefinitionGlobPattern = (generateLocalModuleRegistration: Boolean) =>\n    generateLocalModuleRegistration ? DATADEFINITION.fromLocalModule : DATADEFINITION.fromInstalledModule;\n\nexport const msdyn365ActionDefinitionGlobPattern = (generateLocalModuleRegistration: Boolean) =>\n    generateLocalModuleRegistration ? ACTION.fromLocalModule : ACTION.fromInstalledModule;\n\nexport const MODULE_DETAILS_REGEX = getSupportedNamespaces().map(\n    packageNamespace => new RegExp(`/node_modules\\/(?<namespace>${packageNamespace})\\/(?<packageName>.*)\\/dist\\/lib\\/.*`)\n);\n\n/**\n * @description Constant for hoisted path to node_modules\n * @internal\n */\nexport const hoistedPath = fixPath(path.resolve('../../node_modules'));\n\n/**\n * @description Helper function to get component relative path\n * @internal\n */\nexport const getModuleFileRelativePath = ({ moduleFileAbsolutePath, moduleNamespace }: IGetRelativePathOptions): IGetRelativePathResult => {\n    const isNodeModule = moduleFileAbsolutePath.indexOf('node_modules') > -1;\n    const isHoisted = fixPath(moduleFileAbsolutePath).indexOf(hoistedPath) === 0;\n    const componentRelativePath = fixPath(\n        isNodeModule\n            ? isHoisted\n                ? path.relative(path.resolve(process.cwd(), hoistedPath, moduleNamespace), moduleFileAbsolutePath)\n                : path.relative(path.join(nodeModulePath, moduleNamespace), moduleFileAbsolutePath)\n            : path.relative(path.join(process.cwd(), 'src'), moduleFileAbsolutePath)\n    );\n    return {\n        fileRelativePath: componentRelativePath,\n        isNodeModule\n    };\n};\n\n/**\n * Utility function to check if a path exists w.r.t partner app root.\n * @param filePath path to file that needs to be verified\n * @param directory directory w.r.t partner app root where file needs to be searched\n */\nconst getPathIfExists = async (filePath: string, directory: string, forceRelativePathResolution?: boolean): Promise<string | null> => {\n    if (!filePath) {\n        return null;\n    }\n    const relativePath = filePath.startsWith('.') || forceRelativePathResolution;\n    const componentPath = relativePath ? path.resolve(path.join(directory, filePath)) : path.resolve(path.join(nodeModulePath, filePath));\n    const isPathExist = relativePath\n        ? await safeGetAllFilesPath(`${componentPath}.+(js|ts|tsx)`)\n        : await safeGetAllFilesPath(`${componentPath}.+(js)`);\n    return isPathExist.length > 0 ? componentPath : null;\n};\n\n/**\n * Resolves module view/dataAction from the path specified in definition file. In case if a\n * definition is inherited, the path is resolved against parent definition path\n * @param parentDefinitionPath path to parent definition file - for scenarios where definition file is inherited\n * @param moduleFileRelativePath file to be resolved (view/dataAction)\n * @param moduleDirectoryPath path to module directory\n */\nexport const resolvePathFromDefinition = async (\n    parentDefinitionPath: string | null,\n    moduleFileRelativePath: string,\n    moduleDirectoryPath: string,\n    forceRelativePathResolution?: boolean\n): Promise<string | null> => {\n    let fileAbsolutePath = await getPathIfExists(moduleFileRelativePath, moduleDirectoryPath, forceRelativePathResolution);\n\n    if (fileAbsolutePath) {\n        return fileAbsolutePath;\n    }\n    // Attempt explicit hoisted scenario -- from local module root to where it should be hoisted in mono-repo node_modules\n    const definitionHoistedPath = path\n        .resolve(\n            process.cwd(),\n            path.join('../../node_modules', path.dirname(moduleFileRelativePath), `${path.basename(moduleFileRelativePath, '.js')}.js`)\n        )\n        .replace(/[\\\\/]/g, '/');\n    const hoistedPathExists = await safeFileExists(definitionHoistedPath);\n    trace.debug(`Hoisted path [${definitionHoistedPath}] ${hoistedPathExists ? 'exists' : 'does not exist'}`);\n\n    if (hoistedPathExists) {\n        return definitionHoistedPath;\n    }\n\n    // finally try node resolution\n    try {\n        const requirePath = require.resolve(moduleFileRelativePath);\n        const absoluteRequirePath = path.resolve(path.relative(process.cwd(), requirePath)).replace(/[\\\\/]/g, '/');\n        trace.debug(`Node require path resolved: ${absoluteRequirePath}`);\n        return absoluteRequirePath;\n    } catch {\n        // eat error\n        trace.debug(`Node was not able to resolve ${moduleFileRelativePath}`);\n    }\n\n    if (!parentDefinitionPath) {\n        trace.error(`Could not resolve file: [${moduleFileRelativePath}] at ${moduleDirectoryPath}`);\n        return null;\n    }\n\n    // Could not resolve component w.r.t current definition path folder\n    // Let us try to resolve it against the parent definition folder\n    trace.info(`Could not resolve file: [${moduleFileRelativePath}] at ${moduleDirectoryPath}\n    Attempting to resolve component [${moduleFileRelativePath}] w.r.t parent definition ${parentDefinitionPath}`);\n    fileAbsolutePath = await getPathIfExists(moduleFileRelativePath, path.dirname(parentDefinitionPath), forceRelativePathResolution);\n\n    if (!fileAbsolutePath) {\n        trace.error(`Could not resolve file: [${moduleFileRelativePath}] at parent definition ${parentDefinitionPath}`);\n    }\n\n    return fileAbsolutePath || null;\n};\n"]}
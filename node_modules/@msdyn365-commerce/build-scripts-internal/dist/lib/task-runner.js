#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
// tslint:disable:non-literal-require
var utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
var path = tslib_1.__importStar(require("path"));
var identifiedTasks = [];
var runner = function (options) {
    if (options === void 0) { options = {}; }
    var prefix = "[MSDyn365 Script Runner] ";
    var taskDir = path.join(__dirname, 'tasks');
    utilities_internal_1.trace.info(prefix + "Starting task runner");
    utilities_internal_1.trace.debug(prefix + "Current task directory: " + taskDir);
    if (!identifiedTasks.length) {
        identifiedTasks = utilities_internal_1.getFilesInDirSync(taskDir).filter(function (fileName) { return fileName.toLocaleLowerCase().endsWith('.js'); });
    }
    var allTasks = tslib_1.__spreadArrays(identifiedTasks);
    utilities_internal_1.trace.info(prefix + "Found " + allTasks.length + " tasks.");
    utilities_internal_1.trace.info(allTasks.map(function (taskFileName) { return path.basename(taskFileName); }));
    var tasksToRun = allTasks.filter(function (taskName) {
        var actualTaskName = path.basename(taskName, '.js');
        // default it to run all tasks if we don't get explicit options for
        var shouldExecute = options[actualTaskName] !== undefined && options[actualTaskName].shouldExecute !== undefined
            ? options[actualTaskName].shouldExecute
            : true;
        !shouldExecute && utilities_internal_1.trace.debug("Skipping task '" + actualTaskName + "'.");
        return shouldExecute;
    });
    var runTask = function (taskName) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var timerName, stopTimer, task, taskOptions;
        return tslib_1.__generator(this, function (_a) {
            timerName = "task-" + taskName;
            utilities_internal_1.trace.info(prefix + "Starting task " + taskName);
            utilities_internal_1.trace.startTimer(timerName);
            stopTimer = function () { return utilities_internal_1.trace.stopTimer(timerName); };
            task = require("./tasks/" + taskName);
            if (!task || !task.default) {
                utilities_internal_1.trace.info(prefix + "Unable to run " + taskName + " as it has no default export");
                stopTimer();
                return [2 /*return*/];
            }
            taskOptions = options[path.basename(taskName, '.js')] || { options: {} };
            return [2 /*return*/, task.default(taskOptions.options).then(function (taskResult) {
                    stopTimer();
                    utilities_internal_1.trace.info(prefix + "Finished task " + taskName + " " + (taskResult.success ? 'successfully' : 'with errors'));
                })];
        });
    }); };
    // TODO: currently we don't have any tasks with config, but could in the future so this signature would change
    return Promise.all(tasksToRun.map(runTask));
};
exports.default = runner;
//# sourceMappingURL=task-runner.js.map
"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
var fs = tslib_1.__importStar(require("fs-extra"));
var path = tslib_1.__importStar(require("path"));
var module_registration_model_1 = require("./module-registration/module-registration-model");
var getModuleNameFromRegistration = function (moduleRegistrationPath) { return path.basename(moduleRegistrationPath, '.definition.json'); };
/**
 * Gets all registered modules and some metadata about them
 */
exports.getAllRegisteredModulePaths = function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        return [2 /*return*/, Promise.all([utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.DEFINITION.fromLocalModule), utilities_internal_1.safeGetAllFilesPath(module_registration_model_1.DEFINITION.fromInstalledModule)]).then(function (_a) {
                var localModules = _a[0], installedModules = _a[1];
                var modules = localModules.concat(installedModules);
                return Promise.all(modules.map(function (moduleRegistrationPath) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                    var containingFolder, name, _a;
                    return tslib_1.__generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                containingFolder = path.dirname(moduleRegistrationPath);
                                name = getModuleNameFromRegistration(moduleRegistrationPath);
                                _a = {
                                    name: name,
                                    containingFolder: containingFolder,
                                    registrationPath: moduleRegistrationPath
                                };
                                return [4 /*yield*/, utilities_internal_1.safeFileExists(path.join(containingFolder, name + ".scss"))];
                            case 1: return [2 /*return*/, (_a.hasStyles = _b.sent(),
                                    _a)];
                        }
                    });
                }); }));
            })];
    });
}); };
/**
 * Makes a copy of the .definition.json into /dist
 */
// tslint:disable-next-line:no-any
function copyDefinitionFilesIntoDist(params) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            params.map(function (param) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var connectorPackage, definitionFilePaths;
                var _this = this;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(path.join(process.cwd(), '**', 'connectors', '*', '*.connector.json'))];
                        case 1:
                            connectorPackage = _a.sent();
                            return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(param.fromPath)];
                        case 2:
                            definitionFilePaths = _a.sent();
                            if (!connectorPackage.length) {
                                if (definitionFilePaths.length === 0) {
                                    utilities_internal_1.trace.info("No definitions found at '[" + param.fromPath + "]'");
                                    return [2 /*return*/];
                                }
                            }
                            try {
                                return [2 /*return*/, Promise.all(definitionFilePaths.map(function (filePath) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                        var pathToFileIfExists, definitionFileName, moduleName, outputPath;
                                        return tslib_1.__generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, utilities_internal_1.safeFileExists(filePath)];
                                                case 1:
                                                    pathToFileIfExists = _a.sent();
                                                    if (!pathToFileIfExists) return [3 /*break*/, 3];
                                                    definitionFileName = path.basename(filePath);
                                                    moduleName = path.basename(path.dirname(filePath));
                                                    outputPath = path.join(param.toPath, moduleName, definitionFileName);
                                                    // Resolve any refs and copy the definition json to the output path
                                                    return [4 /*yield*/, resolveRefsInDefinitionAndCopyToOutput(filePath, outputPath)];
                                                case 2:
                                                    // Resolve any refs and copy the definition json to the output path
                                                    _a.sent();
                                                    _a.label = 3;
                                                case 3: return [2 /*return*/];
                                            }
                                        });
                                    }); }))];
                            }
                            catch (e) {
                                utilities_internal_1.trace.error(e);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/];
        });
    });
}
exports.copyDefinitionFilesIntoDist = copyDefinitionFilesIntoDist;
/**
 * Uses the ref parser to resolve any refs in the module's definition json and copys the
 * resolved json to the output (build) path
 *
 * @param defJsonPath The path to the definition json which may or may not have refs
 * @param outputPath The path to the output folder where the resolved json with no refs will be written
 */
function resolveRefsInDefinitionAndCopyToOutput(defJsonPath, outputPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var defJson, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, utilities_internal_1.safeReadJson(defJsonPath)];
                case 1:
                    defJson = (_b.sent()) || {};
                    if (!(defJson.$type !== 'themeModule')) return [3 /*break*/, 3];
                    return [4 /*yield*/, utilities_internal_1.resolveRef(defJson, defJsonPath, utilities_internal_1.trace)];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _a = defJson;
                    _b.label = 4;
                case 4:
                    // ignore resolving $ref for themeModule as $ref is needed to figure the parent theme Module
                    defJson = _a;
                    return [4 /*yield*/, fs.ensureDir(path.dirname(outputPath))];
                case 5:
                    _b.sent();
                    return [4 /*yield*/, utilities_internal_1.safeWriteJson(outputPath, defJson)];
                case 6:
                    _b.sent();
                    if (!(defJson && defJson.$type === module_registration_model_1.THEME_MODULE_TYPE)) return [3 /*break*/, 11];
                    return [4 /*yield*/, copyThemeModuleDefinitions(module_registration_model_1.themeModuleDefinitionExtensionsPathPattern, module_registration_model_1.THEME_MODULE_FILE_TYPE.DEFINITION_EXTENSIONS)];
                case 7:
                    _b.sent();
                    return [4 /*yield*/, copyThemeModuleDefinitions(module_registration_model_1.themeModuleLayoutsPathPattern, module_registration_model_1.THEME_MODULE_FILE_TYPE.LAYOUTS)];
                case 8:
                    _b.sent();
                    return [4 /*yield*/, copyThemeModuleDefinitions(module_registration_model_1.themeModuleStylesPathPattern, module_registration_model_1.THEME_MODULE_FILE_TYPE.STYLES)];
                case 9:
                    _b.sent();
                    return [4 /*yield*/, copyThemeModuleDefinitions(module_registration_model_1.themeModuleSettingsPathPattern, module_registration_model_1.THEME_MODULE_FILE_TYPE.SETTINGS)];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [2 /*return*/];
            }
        });
    });
}
/**
 * Uses the ref parser to resolve any refs in the module's definition json and copys the
 * resolved json to the output (build) path
 *
 * @param defJsonPath The path to the definition json which may or may not have refs
 * @param outputPath The path to the output folder where the resolved json with no refs will be written
 */
function copyThemeModuleDefinitions(moduleFileGlogPattern, fileType) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var themeModuleFilePaths, e_1;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, utilities_internal_1.safeGetAllFilesPath(moduleFileGlogPattern)];
                case 1:
                    themeModuleFilePaths = _a.sent();
                    if (themeModuleFilePaths.length === 0) {
                        utilities_internal_1.trace.info("No theme " + fileType + " files found");
                        return [2 /*return*/];
                    }
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, Promise.all(themeModuleFilePaths.map(function (filePath) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var pathToFileIfExists, outputPath;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, utilities_internal_1.safeFileExists(filePath)];
                                    case 1:
                                        pathToFileIfExists = _a.sent();
                                        if (!(pathToFileIfExists && typeof pathToFileIfExists === 'string')) return [3 /*break*/, 4];
                                        outputPath = pathToFileIfExists.replace('/src/modules', '/dist/lib/modules');
                                        return [4 /*yield*/, fs.ensureDir(path.dirname(outputPath))];
                                    case 2:
                                        _a.sent();
                                        return [4 /*yield*/, fs.copyFile(pathToFileIfExists, outputPath)];
                                    case 3:
                                        _a.sent();
                                        _a.label = 4;
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _a.sent();
                    utilities_internal_1.trace.error("Error while copying theme module definitions: " + e_1);
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=helpers.js.map
{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../src/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { resolveRef, safeFileExists, safeGetAllFilesPath, safeReadJson, safeWriteJson, trace } from '@msdyn365-commerce/utilities-internal';\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { IModuleMetadata } from './models/IModuleMetadata';\nimport {\n    DEFINITION,\n    IModuleDefinition,\n    THEME_MODULE_FILE_TYPE,\n    THEME_MODULE_TYPE,\n    themeModuleDefinitionExtensionsPathPattern,\n    themeModuleLayoutsPathPattern,\n    themeModuleSettingsPathPattern,\n    themeModuleStylesPathPattern\n} from './module-registration/module-registration-model';\n\nconst getModuleNameFromRegistration = (moduleRegistrationPath: string) => path.basename(moduleRegistrationPath, '.definition.json');\n\nexport interface ICopyOptions {\n    fromPath: string;\n    toPath: string;\n}\n\n/**\n * Gets all registered modules and some metadata about them\n */\nexport const getAllRegisteredModulePaths = async (): Promise<IModuleMetadata[]> => {\n    return Promise.all([safeGetAllFilesPath(DEFINITION.fromLocalModule), safeGetAllFilesPath(DEFINITION.fromInstalledModule)]).then(\n        ([localModules, installedModules]: [string[], string[]]) => {\n            const modules = localModules.concat(installedModules);\n            return Promise.all(\n                modules.map(async (moduleRegistrationPath: string) => {\n                    const containingFolder = path.dirname(moduleRegistrationPath);\n                    const name = getModuleNameFromRegistration(moduleRegistrationPath);\n                    return {\n                        name,\n                        containingFolder,\n                        registrationPath: moduleRegistrationPath,\n                        hasStyles: await safeFileExists(path.join(containingFolder, `${name}.scss`))\n                    };\n                })\n            );\n        }\n    );\n};\n\n/**\n * Makes a copy of the .definition.json into /dist\n */\n// tslint:disable-next-line:no-any\nexport async function copyDefinitionFilesIntoDist(params: ICopyOptions[]): Promise<any> {\n    params.map(async param => {\n        const connectorPackage = await safeGetAllFilesPath(path.join(process.cwd(), '**', 'connectors', '*', '*.connector.json'));\n        const definitionFilePaths = await safeGetAllFilesPath(param.fromPath);\n        if (!connectorPackage.length) {\n            if (definitionFilePaths.length === 0) {\n                trace.info(`No definitions found at '[${param.fromPath}]'`);\n                return;\n            }\n        }\n\n        try {\n            return Promise.all(\n                definitionFilePaths.map(async (filePath: string) => {\n                    const pathToFileIfExists = await safeFileExists(filePath);\n                    if (pathToFileIfExists) {\n                        const definitionFileName = path.basename(filePath);\n                        const moduleName = path.basename(path.dirname(filePath));\n                        const outputPath = path.join(param.toPath, moduleName, definitionFileName);\n                        // Resolve any refs and copy the definition json to the output path\n                        await resolveRefsInDefinitionAndCopyToOutput(filePath, outputPath);\n                    }\n                })\n            );\n        } catch (e) {\n            trace.error(e);\n        }\n    });\n}\n\n/**\n * Uses the ref parser to resolve any refs in the module's definition json and copys the\n * resolved json to the output (build) path\n *\n * @param defJsonPath The path to the definition json which may or may not have refs\n * @param outputPath The path to the output folder where the resolved json with no refs will be written\n */\nasync function resolveRefsInDefinitionAndCopyToOutput(defJsonPath: string, outputPath: string): Promise<void> {\n    let defJson = (await safeReadJson<IModuleDefinition>(defJsonPath)) || <IModuleDefinition>{};\n\n    // ignore resolving $ref for themeModule as $ref is needed to figure the parent theme Module\n    defJson = defJson.$type !== 'themeModule' ? await resolveRef(defJson, defJsonPath, trace) : defJson;\n\n    await fs.ensureDir(path.dirname(outputPath));\n    await safeWriteJson(outputPath, defJson);\n\n    if (defJson && defJson.$type === THEME_MODULE_TYPE) {\n        await copyThemeModuleDefinitions(themeModuleDefinitionExtensionsPathPattern, THEME_MODULE_FILE_TYPE.DEFINITION_EXTENSIONS);\n        await copyThemeModuleDefinitions(themeModuleLayoutsPathPattern, THEME_MODULE_FILE_TYPE.LAYOUTS);\n        await copyThemeModuleDefinitions(themeModuleStylesPathPattern, THEME_MODULE_FILE_TYPE.STYLES);\n        await copyThemeModuleDefinitions(themeModuleSettingsPathPattern, THEME_MODULE_FILE_TYPE.SETTINGS);\n    }\n}\n\n/**\n * Uses the ref parser to resolve any refs in the module's definition json and copys the\n * resolved json to the output (build) path\n *\n * @param defJsonPath The path to the definition json which may or may not have refs\n * @param outputPath The path to the output folder where the resolved json with no refs will be written\n */\nasync function copyThemeModuleDefinitions(moduleFileGlogPattern: string, fileType: string): Promise<void> {\n    const themeModuleFilePaths = await safeGetAllFilesPath(moduleFileGlogPattern);\n    if (themeModuleFilePaths.length === 0) {\n        trace.info(`No theme ${fileType} files found`);\n        return;\n    }\n\n    try {\n        await Promise.all(\n            themeModuleFilePaths.map(async (filePath: string) => {\n                const pathToFileIfExists = await safeFileExists(filePath);\n                if (pathToFileIfExists && typeof pathToFileIfExists === 'string') {\n                    const outputPath = pathToFileIfExists.replace('/src/modules', '/dist/lib/modules');\n                    await fs.ensureDir(path.dirname(outputPath));\n                    await fs.copyFile(pathToFileIfExists, outputPath);\n                }\n            })\n        );\n    } catch (e) {\n        trace.error(`Error while copying theme module definitions: ${e}`);\n    }\n}\n"]}
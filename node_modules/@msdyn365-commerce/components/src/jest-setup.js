const Enzyme = require("enzyme");
const Adapter = require("enzyme-adapter-react-16");

Enzyme.configure({ adapter: new Adapter() });

global.window = global.document.defaultView;
global.document.body.innerHTML = '<div id="root"></div>';

global.window.resizeTo = (width, height) => {
  global.window.innerHeight = global.document.documentElement.mockClientHeight = height;
  global.window.innerWidth = global.document.documentElement.mockClientWidth = width;
  global.window.dispatchEvent(new Event('resize'));
};
global.window.resizeTo(1400, 1000);

global.updateClientDimensions = (e) => {
  let parentClientHeight;
  let parentClientWidth;
  if (e.parentElement) {
    updateClientDimensions(e.parentElement);
    parentClientHeight = e.parentElement.mockClientHeight;
    parentClientWidth = e.parentElement.mockClientWidth;
  } else {
    parentClientHeight = global.window.innerHeight;
    parentClientWidth = global.window.innerWidth;
  }
  const {height, width} = e.style;
  const percentHeight = (height || '').endsWith('%');
  const pixelHeight = (height || '').endsWith('px');
  const percentWidth = (width || '').endsWith('%');
  const pixelWidth = (width || '').endsWith('px');
  e.mockClientHeight = percentHeight ? parentClientHeight * parseFloat(height) / 100 : pixelHeight ? parseFloat(height) : e === document.documentElement ? parentClientHeight : 0;
  e.mockClientWidth = percentWidth ? parentClientWidth * parseFloat(width) / 100 : pixelWidth ? parseFloat(width) : parentClientWidth;

  if (!e.mockClientRect) {
    e.mockClientRect = true;
    Object.defineProperty(e, 'clientHeight', { get: () => { return e.mockClientHeight; } });
    Object.defineProperty(e, 'clientWidth', { get: () => { return e.mockClientWidth; } });
  }
};
global.updateClientDimensions(global.document.documentElement);
global.updateClientDimensions(global.document.body);

const _fullscreenEnabled = false;
Object.defineProperty(global.document, "fullscreenEnabled", {
    get: function() { return _fullscreenEnabled; },
    set: function(value) { _fullscreenEnabled = value; },
    configurable: true,
  });

const _shiftKey = false;
Object.defineProperty(global.window.Event, "shiftKey", {
  get: function() { return _shiftKey; },
  set: function(value) { _shiftKey = value; },
  configurable: true,
});

// Mocking the last condition in the Full Screen element to get complete coverage. 
global.window.document.webkitCancelFullScreen = () => {  return new Promise(function(resolve, reject) {
  resolve('');
  reject(new Error("Error: "));
});};

global.window.HTMLDivElement.prototype.webkitEnterFullScreen = () => {  return new Promise(function(resolve, reject) {
  resolve(new HTMLDivElement());
  reject(new Error("Error: "));
}); };

global.window.HTMLMediaElement.prototype.webkitEnterFullScreen = () => {  return new Promise(function(resolve, reject) {
  resolve(new HTMLMediaElement());
  reject(new Error("Error: "));
}); };

global.window.HTMLMediaElement.prototype.load = () => { /* do nothing */ };
global.window.HTMLMediaElement.prototype.addTextTrack = () => { /* do nothing */ };

global.window.HTMLMediaElement.prototype.pause = () => {
  const video = global.document.querySelector('video');
  if (video) {
    video.dispatchEvent(new Event('pause'));
    video.myPaused = true;
    if (!video.mypausedefined) {
      video.mypausedefined = true;
      Object.defineProperty(video, 'paused', { get: () => { return video.myPaused; } });
    }
  }
};
global.window.HTMLMediaElement.prototype.play = () => {
  return new Promise((resolve, reject) => {
    const video = global.document.querySelector('video');
    if (video) {
        video.dispatchEvent(new Event('play'));
        video.myPaused = false;
        if (!video.mypausedefined) {
          video.mypausedefined = true;
          Object.defineProperty(video, 'paused', { get: () => { return video.myPaused; } });
          Object.defineProperty(video, 'duration', { get: () => { return 1000; } });
          let buffered = {
            length : 1,
            start : function() { return 0; }, 
            end : function() { return 1000; } 
          }
          Object.defineProperty(video, 'buffered', { get: () => { return buffered } });
        }
      }
  });
};
global.window.getComputedStyle =(e) => {
  const computedStyle = {...e.computedStyle};
  for (let i = e.style.length; i--;) {
      const name = e.style[i];
      computedStyle[name] = e.style.name;
  }
  return computedStyle;
};

// App insights fix
global.define = () => {};
import { mount } from 'enzyme';
import * as React from 'react';

import ActionToggle from './ActionToggle';
import { UncontrolledActionToggle } from './UncontrolledActionToggle';

describe('ActionToggle', () => {
    it('componentDidUpdate doesn\'t throw when ref.current is undefined', () => {
        const wrapper = mount(
            <ActionToggle id='action-toggle-test'>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-play' />
                </button>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-pause' />
                </button>
            </ActionToggle>,
            { attachTo: document.body.firstElementChild as HTMLElement });
        const actionToggle = wrapper.instance() as ActionToggle;
        expect(() => { actionToggle.componentDidUpdate();}).not.toThrow();
        wrapper.unmount();
    });
});

describe('ActionToggle', () => {
    it('toggles correctly', () => {
        const wrapper = mount(
            <ActionToggle id='action-toggle-test'>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-play' />
                </button>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-pause' />
                </button>
            </ActionToggle>,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const actionToggle = wrapper.instance() as ActionToggle;
        const buttons = document.querySelectorAll('button');
        expect(buttons.length).toBe(2);
        const play = buttons[0];
        const pause = buttons[1];

        // Verify expected initial state
        expect(play.getAttribute('aria-hidden')).toBe('false');
        expect(pause.getAttribute('aria-hidden')).toBe('true');

        // Test having focus and rerendering when no focus change is required
        play.focus();
        expect(document.activeElement).toBe(play);
        actionToggle.getSnapshotBeforeUpdate();
        actionToggle.render();
        actionToggle.componentDidUpdate();
        expect(document.activeElement).toBe(play);

        expect(() => {
            if(play && play.click) {
                play.click();
            }
        }).not.toThrow();

        wrapper.unmount();
    });

    it('toggles correctly when onchange is passed to the component', () => {
        const spyChange = jest.fn();
        const wrapper = mount(
            <ActionToggle id='action-toggle-test' onChange={spyChange}>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-play' />
                </button>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-pause' />
                </button>
            </ActionToggle>,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const actionToggle = wrapper.instance() as ActionToggle;
        const buttons = document.querySelectorAll('button');
        expect(buttons.length).toBe(2);
        const play = buttons[0];
        const pause = buttons[1];

        // Verify expected initial state
        expect(play.getAttribute('aria-hidden')).toBe('false');
        expect(pause.getAttribute('aria-hidden')).toBe('true');

        // Test having focus and rerendering when no focus change is required
        play.focus();
        expect(document.activeElement).toBe(play);
        actionToggle.getSnapshotBeforeUpdate();
        actionToggle.render();
        actionToggle.componentDidUpdate();
        expect(document.activeElement).toBe(play);

        play.click();
        wrapper.update();
        expect(spyChange).toHaveBeenCalled();

        wrapper.unmount();
    });
});

describe('UncontrolledActionToggle', () => {
    it('toggles correctly', () => {
        const spyChange = jest.fn();
        const wrapper = mount(
            <UncontrolledActionToggle id='uncontrolled-action-toggle-test' onChange={spyChange}>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-play' />
                </button>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-pause' />
                </button>
            </UncontrolledActionToggle>,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const actionToggle = wrapper.instance() as UncontrolledActionToggle;
        const buttons = document.querySelectorAll('button');
        expect(buttons.length).toBe(2);
        const play = buttons[0];
        const pause = buttons[1];

        // Verify expected initial state
        expect(actionToggle.state.toggled).toBe(false);
        expect(play.getAttribute('aria-hidden')).toBe('false');
        expect(pause.getAttribute('aria-hidden')).toBe('true');
        expect(spyChange).not.toHaveBeenCalled();

        // Test clicking and rendering when we don't have focus
        play.click();
        wrapper.update();
        expect(actionToggle.state.toggled).toBe(true);
        expect(play.getAttribute('aria-hidden')).toBe('true');
        expect(pause.getAttribute('aria-hidden')).toBe('false');
        expect(spyChange).toHaveBeenCalledTimes(1);

        // Test clicking and rendering when we have focus and are toggled
        pause.focus();
        pause.click();
        wrapper.update();
        expect(document.activeElement).toBe(play);
        expect(actionToggle.state.toggled).toBe(false);
        expect(play.getAttribute('aria-hidden')).toBe('false');
        expect(pause.getAttribute('aria-hidden')).toBe('true');
        expect(spyChange).toHaveBeenCalledTimes(2);

        // Test clicking and rendering when we have focus and are not toggled
        play.click();
        wrapper.update();
        expect(actionToggle.state.toggled).toBe(true);
        expect(play.getAttribute('aria-hidden')).toBe('true');
        expect(pause.getAttribute('aria-hidden')).toBe('false');
        expect(spyChange).toHaveBeenCalledTimes(3);

        wrapper.unmount();
    });

    it('toggles correctly without onchange', () => {
        const wrapper = mount(
            <UncontrolledActionToggle id='uncontrolled-action-toggle-test'>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-play' />
                </button>
                <button
                    type='button'
                    className='btn btn-secondary btn-lg rounded-circle border-light'
                >
                    <i className='fa fa-pause' />
                </button>
            </UncontrolledActionToggle>,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const actionToggle = wrapper.instance() as UncontrolledActionToggle;
        const buttons = document.querySelectorAll('button');
        expect(buttons.length).toBe(2);
        const play = buttons[0];
        const pause = buttons[1];

        // Verify expected initial state
        expect(actionToggle.state.toggled).toBe(false);
        expect(play.getAttribute('aria-hidden')).toBe('false');
        expect(pause.getAttribute('aria-hidden')).toBe('true');

        // Test clicking and rendering when we don't have focus
        play.click();
        wrapper.update();
        expect(actionToggle.state.toggled).toBe(true);
        expect(play.getAttribute('aria-hidden')).toBe('true');
        expect(pause.getAttribute('aria-hidden')).toBe('false');

        wrapper.unmount();
    });
});

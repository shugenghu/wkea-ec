import * as React from 'react';
import { ICurrentClosedCaptionsSettings } from '../data/player-constants';
import { css, removeInnerHtml, selectElements, selectFirstElement } from '../utilities/htmlExtensions';
import { PlayerUtility } from '../utilities/player-utility';
import { format } from '../utilities/stringExtensions';
import { getDimensions, IDictionaryStringString } from '../utilities/utilities';
import { IClosedCaptionsProps } from './ClosedCaptionsProps';
import { ITtmlContext } from './ttml-context';
import { TtmlParser } from './ttml-parser';
import { ITtmlSettings } from './ttml-settings';
import { closedCaptionsSettingsMap, closedCaptionsSettingsOptions } from './video-closed-captions-settings';

/**
 *
 * closedCaptions React component for video player
 *
 */
export default class ClosedCaptions extends React.Component<IClosedCaptionsProps> {

    /**
     * @name - currentSettings
     * @description - The current closed captions settings.
     * @private
     * @type {IDictionaryStringString}
     */
    public currentSettings: ICurrentClosedCaptionsSettings | undefined;

    /**
     * @name - userPreferences
     * @description - The user preference overrides for the closed captions.
     * @static
     * @public
     * @type {ICcUserPreferences}
     */
    private userPreferences: ICcUserPreferences = {
        text: {},
        window: {}
    };

    private closedCaptionDiv: React.RefObject<HTMLDivElement> = React.createRef<HTMLDivElement>();

    /**
     * @name - lastPlayPosition
     * @description - The last player position passed to updateCaptions.
     *                This is used to call updateCaptions again when the cc language is changed.
     *                Play could be paused at that time.
     * @private
     * @type {number}
     */
    private lastPlayPosition: number = 0;

    /**
     * @name - ttmlContext
     * @description - The ttmlContext for the current ttml document.
     * @private
     * @type {ITtmlContext}
     */
    private ttmlContext: ITtmlContext | null = null;

    constructor(props: IClosedCaptionsProps) {
        super(props);
        this.resetCaptions();
        this.clicked = this.clicked.bind(this);
    }

    public render(): JSX.Element {
        const { className } = this.props;
        const closedCaptionDivStyle = {
            bottom: this.props.isVideoControlVisible ? '2.5em' : '0',
            transition: 'bottom 0.5s ease-in 0s'
        };
        return (
            // tslint:disable-next-line: jsx-self-close
            <div role='none' className={className} ref={this.closedCaptionDiv} aria-hidden={!this.props.showClosedCaptions} style={closedCaptionDivStyle} onClick={this.clicked}>
            </div>
        );
    }

    public clicked(): void {
        this.props.onClosedCaptionClick();
    }

    public componentDidMount(): void {
        if(this.props.ccURL) {
            this._setCcLanguage(this.props.ccURL);
        }
        window && window.addEventListener('resize', () => {
            if(this.props.showClosedCaptions) {
                this.updateCaptions(this.props.currentTime);
            }
        });
    }

    public shouldComponentUpdate(nextProps: IClosedCaptionsProps): boolean {
        let shouldRender = false;
        if(nextProps.showClosedCaptions || (this.props.showClosedCaptions !== nextProps.showClosedCaptions)) {
            shouldRender = true;
        }
        return shouldRender;
    }

    public componentWillUnmount(): void {
        window && window.removeEventListener('resize', () => {
            if(this.props.showClosedCaptions) {
                this.updateCaptions(this.props.currentTime);
            }
        });
    }

    public componentDidUpdate(prevProps: IClosedCaptionsProps): void {
        if(this.props.showClosedCaptions) {
            if(prevProps.ccLanguage! !== this.props.ccLanguage!) {
                if(this.props.ccURL) {
                    this._setCcLanguage(this.props.ccURL);
                }
            }
            this.applySettings();
            this.resetCaptions();
            this.updateCaptions(this.props.currentTime);
            if(prevProps.isVideoControlVisible !== this.props.isVideoControlVisible) {
                this.applySettings();
                this.resetCaptions();
                // Setting up a delay so that right height and width is calculated
                window.setTimeout(() => {
                this.updateCaptions(this.props.currentTime);
                },                500);
            }
        }
    }

    /**
     * @name - showSampleCaptions
     * @description - Displays a mocked caption container with content, used to show the caption preset preview
     * @public
     * @returns {void}
     */
    public showSampleCaptions(): void {
        this.ttmlContext = null;
        const mockCaptions: XMLDocument = new DOMParser().parseFromString(`<?xml version='1.0' encoding='utf-8'?>
<tt xml:lang='en-us' xmlns='http://www.w3.org/ns/ttml' xmlns:tts='http://www.w3.org/ns/ttml#styling'
xmlns:ttm='http://www.w3.org/ns/ttml#metadata'>
    <head>
    <metadata>
        <ttm:title>Media.wvx.aib</ttm:title>
        <ttm:copyright>Copyright (c) 2013 Microsoft Corporation.  All rights reserved.</ttm:copyright>
    </metadata>
    <styling>
        <style xml:id='Style1' tts:fontFamily='proportionalSansSerif' tts:fontSize='0.8c' tts:textAlign='center'
        tts:color='white' />
    </styling>
    <layout>
        <region style='Style1' xml:id='CaptionArea' tts:origin='0c 12.6c' tts:extent='32c 2.4c'
        tts:backgroundColor='rgba(0,0,0,160)' tts:displayAlign='center' tts:padding='0.3c 0.5c' />
    </layout>
    </head>
    <body region='CaptionArea'>
    <div>
        <p begin='00:00:01.140' end='99:99:99.999'>EXAMPLE CAPTIONS!</p>
    </div>
    </body>
</tt>`,                                                                   'text/xml');

        this._onClosedCaptionsLoaded(mockCaptions);
        const dimensions = getDimensions(this.closedCaptionDiv.current!);
        this.ttmlContext!.updateRelatedMediaObjectRegion(dimensions!);
        this.closedCaptionDiv.current!.style.bottom = '2.5rem';
    }

    /**
     * @name - updateCaptions
     * @description - Update the captionContainer with the captions that correspond to the current time
     * @public
     * @param {number} playPosition - The video's play position to sync the captions to.
     * @returns {void}
     */
// tslint:disable-next-line: max-func-body-length
    public updateCaptions(playPosition: number): void {
        let output: string = '';
        this.lastPlayPosition = playPosition;

        if (this.ttmlContext && this.ttmlContext.hasEvents()) {
            const tick = Math.floor(playPosition  * 1000);

            const dimensions = getDimensions(this.closedCaptionDiv.current!);
            if (this.ttmlContext.updateRelatedMediaObjectRegion(dimensions!)) {
                // Call resetCaptions to force an update since the relatedMediaObjectRegion size has changed.
                this.resetCaptions();
            }

            if (this.ttmlContext.updateCurrentEvents(tick)) {

                removeInnerHtml(this.closedCaptionDiv.current!);

                for (const cue of this.ttmlContext.getCues(tick)) {
                    this._applyUserPreferencesOverrides(cue);
                    // background color is not honored in high contrast mode,
                    // thus remove it from this wrapper div to avoid video not getting displayed in high contrast mode
                    // with close captions enabled
                    css(cue, 'background-color', '');
                    output = cue.outerHTML;
                }

                // tslint:disable-next-line: no-inner-html
                this.closedCaptionDiv.current!.innerHTML = output;
            }
        }
    }

    /**
     * @name - resetCaptions
     * @description - Resets the ttml caption container.
     *                This should be called when user preferences change.
     * @public
     * @returns {void}
     */
    public resetCaptions(): void {
        if (this.ttmlContext) {
            this.ttmlContext.resetCurrentEvents();
        }

        if (this.closedCaptionDiv.current!) {
            removeInnerHtml(this.closedCaptionDiv.current!);
        }
        this.applySettings();
    }

    /**
     * @name - applySettings
     * @description - Applies the closed captions settings.
     * @public
     * @returns {void}
     */
    public applySettings(): void {
        const prefs: IDictionaryStringString = {};

        const currentSettings = this.props.tempClosedCaptionsSettings ? this.props.tempClosedCaptionsSettings : this.props.currentClosedCaptionsSettings;
    // tslint:disable-next-line: no-for-in
        for (const settingKey in currentSettings) {
            if (currentSettings.hasOwnProperty(settingKey)) {
                const optionValue = this._getOptionValue(settingKey, currentSettings[settingKey]);

                if (optionValue) {
                    prefs[settingKey] = `${closedCaptionsSettingsMap[settingKey].value}${optionValue}`;
                }
            }
        }

        this.userPreferences.text = this._getPrefsCss(prefs, 'text');
        this.userPreferences.window = this._getPrefsCss(prefs, 'window');
    }

    /**
     * @name - loadClosedCaptions
     * @description - Loads the close captioning ttml file.
     * @private
     * @param {string} href - The cc href.
     * @returns {void}
     */
    private _loadClosedCaptions(href: string): void {
        // tslint:disable-next-line: no-any
        PlayerUtility.ajax(href, (result: any) => this._onClosedCaptionsLoaded(result), () => {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.loadClosedCaptions.ajax',
                    errorDesc: `Ajax call failed: ' ${href}`
                });
            }
        });
    }

    /**
     * @name - onClosedCaptionsLoaded
     * @description - Close captioning ttml file loaded handler.
     * @private
     * @param {XMLDocument} ttmlDocument - The ttml document containing the closed captions.
     * @returns {void}
     */
    private _onClosedCaptionsLoaded(ttmlDocument: XMLDocument): void {
        if (!ttmlDocument) {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.onClosedCaptionsLoaded.ttmlDoc',
                    errorDesc: 'No ttmlDocument found'
                });
            }
            return;
        }

        // this.closedCaptionDiv.current!.setAttribute(ClosedCaptions.ariaHidden, 'false');

        const id = this.closedCaptionDiv.current!.id ? (`${this.closedCaptionDiv.current!.id} '-'`) : '';
        const settingsOverrides: ITtmlSettings = {
            idPrefix: id,
            fontMap: { default: 'Segoe ui, Arial' },
            relatedMediaObjectRegion: getDimensions(this.closedCaptionDiv.current!)
        };

        try {
            this.ttmlContext = TtmlParser.parse(ttmlDocument, settingsOverrides);

            if (this.ttmlContext) {
                this.ttmlContext.setOwnerDocument(this.closedCaptionDiv.current!.ownerDocument!);

                if (this.ttmlContext.hasEvents()) {
                    this.updateCaptions(this.lastPlayPosition);
                }
            }
        } catch (e) {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.onClosedCaptionsLoaded.ttmlParser',
                    errorDesc: `'TtmlDocument parser error: ' ${e.message}`
                });
            }
        }
    }

    /**
     * @name - applyUserPreferencesOverrides
     * @description - Applies user preference overrides to the specified cue.
     * @private
     * @param {HTMLElement} cue - The cue to apply any overrides to.
     * @returns {void}
     */
    private _applyUserPreferencesOverrides(cue: HTMLElement): void {
        if (!this.userPreferences) {
            return;
        }

        if (this.userPreferences.text) {
            for (const element of selectElements('span, br', cue)) {
                // tslint:disable-next-line: no-for-in
                for (const property in this.userPreferences.text) {
                    if (this.userPreferences.text.hasOwnProperty(property)) {
                        css(element, property, this.userPreferences.text[property]);
                    }
                }
            }
        }

        if (this.userPreferences.window) {
            const winElement: HTMLElement | null = selectFirstElement('p', cue);
            if (winElement) {
                // tslint:disable-next-line: no-for-in
                for (const property in this.userPreferences.window) {
                    if (this.userPreferences.window.hasOwnProperty(property)) {
                        css(winElement, property, this.userPreferences.window[property]);
                    }
                }
            }
        }
    }

    /**
     * @name - setCcLanguage
     * @description - Updates the component if there is any change to its underlying DOM.
     * @private
     * @param {string} href - The ttml href.
     * @returns {void}
     */
    private _setCcLanguage(href: string): void {
        this.ttmlContext = null;
        this.resetCaptions();
        if (!href) {
            return;
        }
        this._loadClosedCaptions(href);
    }

    /**
     * @name - getOptionValue
     * @description - Gets the value of closed captions settings option.
     * @private
     * @param {string} settingKey - The closed ceptions settings key.
     * @param {string} optionKey - The closed captions option key.
     * @returns {void}
     */
    private _getOptionValue(settingKey: string, optionKey: string): string {
        const setting = closedCaptionsSettingsMap[settingKey];
        if (setting) {
            const option = closedCaptionsSettingsOptions[setting.option];
            return option && option.map[optionKey];
        }
        return '';
    }

    /**
     * @name - getPrefsCss
     * @description - Gets the css for the preferences.
     * @private
     * @param {IDictionaryStringString} pref - The preferences to get css for.
     * @param {string} prefix - The closed captions type (text/window).
     * @returns {IDictionaryStringString}
     */
    private _getPrefsCss(prefs: IDictionaryStringString, prefix: string): IDictionaryStringString {
        const prefsCss: IDictionaryStringString = {};

        //  First store all the non-transparency values
        // tslint:disable-next-line: no-for-in
        for (const pref in prefs) {
            if (prefs.hasOwnProperty(pref)) {
                const propVal = prefs[pref];

                if (pref.indexOf(prefix) === 0 && pref.indexOf('opacity') < 0) {
                    if (propVal && (propVal.length > 0)) {
                        const styles = propVal.split(';');

                        for (const style of styles) {
                            const pVal = style.split(':');

                            if (pVal.length > 1) {
                                prefsCss[pVal[0].trim()] = pVal[1].trim();
                            }
                        }
                    }
                }
            }
        }

        //  Then go through all the transparency values and
        //  map them onto their non-transparent color counterparts
        // tslint:disable-next-line: no-for-in
        for (const pref in prefs) {
            if (prefs.hasOwnProperty(pref)) {
                const propVal = prefs[pref];
                if (pref.indexOf(prefix) === 0 && pref.indexOf('opacity') > 0) {
                    const pVal = propVal.split(':');

                    if (pVal.length > 1) {
                        const colorValue = prefsCss[pVal[0].trim()];
                        const opacityValue = pVal[1].trim();
                        prefsCss[pVal[0].trim()] = this._formatAsRgba(colorValue, opacityValue);
                    }
                }
            }
        }

        return prefsCss;
    }

    /**
     * @name - formatAsRgba
     * @description - Formats the color value from css to rgba value.
     * @private
     * @param {string} cssColor - The css color value.
     * @param {string} opacity - The opacity value.
     * @returns {string}
     */
    private _formatAsRgba(cssColor: string, opacity: string): string {
        let result = format('rgba(0,0,0,{0})', opacity);
        const colorStart = cssColor ? cssColor.indexOf('#') : -1;

        if (colorStart >= 0) {
            const fullColorString = cssColor.substr(colorStart + 1);
            const colorLenght = (fullColorString.length) / 3;

            if (colorLenght > 0) {
                const red = parseInt(fullColorString.substr(0, colorLenght), 16);
                const green = parseInt(fullColorString.substr(colorLenght, colorLenght), 16);
                const blue = parseInt(fullColorString.substr(colorLenght * 2, colorLenght), 16);
                result = format('rgba({0},{1},{2},{3})', red, green, blue, opacity);
            }
        }

        return result;
    }
}

/**
 * @interface ICcUserPreferences
 * @classdesc - Describes the closed caption user preferences data structure.
 * @export
 */
export interface ICcUserPreferences {
    text: IDictionaryStringString;
    window: IDictionaryStringString;
}
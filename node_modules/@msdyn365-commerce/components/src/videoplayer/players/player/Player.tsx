/**
 * Copyright (c) 2018 Microsoft Corporation
 */
import { getPayloadObject, IPayLoad, ISliderChangeNotification, onTelemetryClick, Waiting } from '@msdyn365-commerce-modules/utilities';
import * as React from 'react';
import * as MsDyn365 from '@msdyn365-commerce/core';
import AgeGate from '../../components/age-gate/AgeGate';
import ClosedCaptions from '../../components/closed-captions/video-closed-captions';
import { closedCaptionsSettingDefaults, videoClosedCaptionsConstant } from '../../components/closed-captions/video-closed-captions-settings';
import {
    ICurrentClosedCaptionsSettings,
    IPlayerMenu,
    IPlayerMenuItemClickNotification,
    IPlayPosition,
    IVideoErrorData,
    IVideoErrorMessageData,
    MediaEvents,
    MenuCategories,
    PlayerConstants,
    PlayerStates,
    VideoErrorCodes,
    VideoPlayerNames
} from '../../components/data/player-constants';
import { ClosedCaptionTypes, ICCFile, IVideoMetadata } from '../../components/data/player-metadata';
import ClosedCaptionHelper from '../../components/helper/closedCaptionHelper';
import LocalizationHelper, { LocalizationConstants } from '../../components/helper/localization-helper';
import PlayerHelper from '../../components/helper/playerHelper';
import PlayPauseTrigger from '../../components/play-pause-trigger/PlayPauseTrigger';
import { KeyCodes } from '../../components/utilities/KeyCodes';
import { format, isNullOrWhiteSpace } from '../../components/utilities/stringExtensions';
import VideoControls from '../../components/video-controls/VideoControls';
import { IPlayerProps } from './Player.props';

/**
 * Player state interface
 */
export interface IPlayerState {
    playing: boolean;
    mouseHovered: boolean;
    isControlPanelVisible: boolean;
    doControlsHaveFocus: boolean;
    playPosition: IPlayPosition;
    currentVolume: number;
    isTriggerEnabled: boolean;
    previousVolume: number;
    isMuted: boolean;
    isInFullScreen: boolean;
    showSpinner: boolean;
    showErrorMessage: boolean;
    videoErrorMessage: IVideoErrorMessageData;
    screenReaderText: string;
    showClosedCaptions: boolean;
    isAgegateEnabled: boolean;
    currentAudioTrack: string;
    currentAudioTrackURL: string;
    closedCaptionLanguage: string;
    closedCaptionsURL: string;
    currentClosedCaptionsSettings: ICurrentClosedCaptionsSettings;
    mounted: boolean;
    tempClosedCaptionsSettings?: {};
}

/**
 *
 * Player component
 *
 */
export default class Player extends React.Component<IPlayerProps, IPlayerState> {
    public static defaultProps: Partial<IPlayerProps> = {
        playerData: {
            options: {
                autoplay: true,
                ageGate: false,
                mute: true,
                loop: false,
                playPauseTrigger: false,
                controls: true,
                hidePosterFrame: false,
                lazyLoad: true,
            },
            metaData: {
                playerName: 'videoPlayer',
                videoId: '',
                title: '',
                description: '',
                duration: 0,
                posterframeUrl: '',
                shareUrl: '',
                videoFiles: [],
                externalPlayerUrl: '',
                externalSourceId: '',
                videoBinaryReferences: []
            }
        },
        playerResources: {
            playAriaLabel: LocalizationConstants.playAriaLabel,
            pauseAriaLabel: LocalizationConstants.pauseAriaLabel,
            closeAriaLabel: LocalizationConstants.closeAriaLabel,
            muteAriaLabel: LocalizationConstants.muteAriaLabel,
            unMuteAriaLabel: LocalizationConstants.unMuteAriaLabel,
            fullScreenAriaLabel: LocalizationConstants.fullScreenAriaLabel,
            exitFullScreenAriaLabel: LocalizationConstants.exitFullScreenAriaLabel,
            pausedAriaLabel: LocalizationConstants.pausedAriaLabel,
            playingAriaLabel: LocalizationConstants.playingAriaLabel,
            seekBarLabel: LocalizationConstants.seekBarLabel,
            videoTimeDurationLabel: LocalizationConstants.videoTimeDurationLabel,
            closedCaptionLabel: LocalizationConstants.closedCaptionLabel
        },
    };

    private controlPanelTimer: number = 0;
    private playerId: string;
    private player: React.RefObject<HTMLVideoElement> = React.createRef<HTMLVideoElement>();
    private audio: React.RefObject<HTMLAudioElement> = React.createRef<HTMLAudioElement>();
    private playerContainer: React.RefObject<HTMLDivElement> = React.createRef<HTMLDivElement>();
    private videoControl: React.RefObject<VideoControls> = React.createRef<VideoControls>();
    private ClosedCaptions: React.RefObject<ClosedCaptions> = React.createRef<ClosedCaptions>();
    private ageGateContainer: React.RefObject<AgeGate> = React.createRef<AgeGate>();
    private videoUrl: string = '';
    private posterFrameUrl: string = '';
    private seekFrom: number | null = null;
    private playerState: PlayerStates;
    private playerHelper: PlayerHelper;
    private localizationHelper: LocalizationHelper;
    private closedCaptionHelper: ClosedCaptionHelper | null = null;
    private closedCaptionMenu: IPlayerMenu | null = null;
    private optionsMenu: IPlayerMenu | null = null;
    private selectedClosedCaptionsLocale: string | null = '';
    private isPlayerManuallyPaused: boolean = false;
    private isPlayerLoaded: boolean = false;
    private playerMetaData: IVideoMetadata;
    private isMobileDevice: boolean;
    private payLoad: IPayLoad;

    /*
    * @name - isNativeFullscreenEnabled
    * @description - Checks if fullscreen is supported by browser or not.
    * @private
    * @static
    * @returns {boolean}
    */
    private static _isNativeFullscreenEnabled(): boolean {
    // tslint:disable-next-line:no-any
    const doc = document as any;
    return doc.fullscreenEnabled || doc.mozFullScreenEnabled || doc.webkitFullscreenEnabled || doc.webkitSupportsFullscreen ||
        doc.msFullscreenEnabled;
    }

    /*
    * @name - getElementInFullScreen
    * @description - gets the current fullscreen element.
    * @private
    * @returns {any}
    */
    // tslint:disable-next-line:no-any
    private static _getElementInFullScreen(): any {
        // tslint:disable-next-line:no-any
        const doc = document as any;
        return doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;
    }

    // tslint:disable-next-line: cyclomatic-complexity max-func-body-length
    constructor(props: IPlayerProps) {
        super(props);
        this.isMobileDevice = this._isMobile();
        const state = {
            playing: false,
            mouseHovered: this.props.playerData.options.playPauseTrigger! || !this.props.playerData.options.autoplay!,
            isControlPanelVisible: !this.props.playerData.options.playPauseTrigger,
            doControlsHaveFocus: false,
            isTriggerEnabled: this.props.playerData.options.playPauseTrigger! && !this.props.playerData.options.autoplay! && this.props.playerData.options.controls!,
            currentVolume: this.props.playerData.options.mute && !this.isMobileDevice ? 0 : PlayerConstants.defaultVolume * 100,
            previousVolume: 0,
            isMuted: this.props.playerData.options.mute || false,
            isInFullScreen: false,
            showSpinner: false,
            isAgegateEnabled: this.props.playerData.options.ageGate! && !this.props.playerData.options.autoplay!,
            showErrorMessage: false,
            screenReaderText: '',
            closedCaptionLanguage: 'off',
            currentAudioTrack: 'default',
            currentAudioTrackURL: '',
            showClosedCaptions: false,
            mounted: false,
            currentClosedCaptionsSettings : {
                preset: closedCaptionsSettingDefaults.preset,
                text_font: closedCaptionsSettingDefaults.text_font,
                text_color: closedCaptionsSettingDefaults.text_color,
                text_opacity: closedCaptionsSettingDefaults.text_opacity,
                text_size: closedCaptionsSettingDefaults.text_size,
                text_edge_style: closedCaptionsSettingDefaults.text_edge_style,
                text_background_color: closedCaptionsSettingDefaults.text_background_color,
                text_background_opacity: closedCaptionsSettingDefaults.text_background_opacity,
                window_color: closedCaptionsSettingDefaults.window_color,
                window_opacity: closedCaptionsSettingDefaults.window_opacity
            } ,
            closedCaptionsURL: '',
            videoErrorMessage: {
                title: '',
                message: ''
            },
            playPosition: {
                currentTime: 0,
                startTime: 0,
                endTime: 0,
                bufferedDuration: 0
            },
            tempClosedCaptionsSettings: undefined
        };

        this.playerState = 'init';
        this._onTriggerClicked = this._onTriggerClicked.bind(this);
        this._onMouseEvent = this._onMouseEvent.bind(this);
        this._onPlay = this._onPlay.bind(this);
        this._onPause = this._onPause.bind(this);
        this._triggerEvents = this._triggerEvents.bind(this);
        this._triggerAudioEvents = this._triggerAudioEvents.bind(this);
        this._onProgressChange = this._onProgressChange.bind(this);
        this._setMuted = this._setMuted.bind(this);
        this._onVolumeChange = this._onVolumeChange.bind(this);
        this._onFullScreenChanged = this._onFullScreenChanged.bind(this);
        this._toggleFullScreen = this._toggleFullScreen.bind(this);
        this._showControlBar = this._showControlBar.bind(this);
        this._handleControlsKeyDownEvent = this._handleControlsKeyDownEvent.bind(this);
        this._onFullscreenError = this._onFullscreenError.bind(this);
        this._onPlayerKeyDown = this._onPlayerKeyDown.bind(this);
        this._onTriggerFocus = this._onTriggerFocus.bind(this);
        this._onTriggerBlur = this._onTriggerBlur.bind(this);
        this._onVideoControlsFocus = this._onVideoControlsFocus.bind(this);
        this._onVideoControlsBlur = this._onVideoControlsBlur.bind(this);
        this._onPlayerMenuItemClick = this._onPlayerMenuItemClick.bind(this);
        this._onPlayerMenuItemFocus = this._onPlayerMenuItemFocus.bind(this);
        this._onPlayerMenuItemBlur = this._onPlayerMenuItemBlur.bind(this);
        this._validateAgeSubmitHandler = this._validateAgeSubmitHandler.bind(this);
        this._onContextMenuClicked = this._onContextMenuClicked.bind(this);
        this.localizationHelper = new LocalizationHelper(this.props.playerResources!);
        this.playerHelper = new PlayerHelper(this.props,  this.localizationHelper);
        this.playerId = this.playerHelper.isEmptyOrUndefined(this.props.playerId) ? 'vid-0' : this.props.playerId!;
        this.playerMetaData = this.playerHelper.getMetadata();
        this.state = state;
        this.posterFrameUrl = this.playerHelper.getPosterFrameUrl();
        this.payLoad = getPayloadObject('click', this.props.telemetryContent!, '');
    }

    // tslint:disable-next-line: cyclomatic-complexity
    public render(): JSX.Element {
        const maskLevelStyle = {} as React.CSSProperties;
        if(this.state.isTriggerEnabled) {
            maskLevelStyle.backgroundColor = this._getMaskLevelStyle();
        }

        if (this.props.isEditor) {
            this.playerHelper.updatePlayerProps(this.props);
            this.playerMetaData = this.playerHelper.getMetadata();
            if (this.posterFrameUrl !== this.playerHelper.getPosterFrameUrl()) {
                this.posterFrameUrl = this.playerHelper.getPosterFrameUrl();
            }
            if (this.isPlayerLoaded && this.videoUrl !== this.playerHelper.getVideoFileToPlay().url) {
                this._loadPlayer();
            }
        }
        // Set play aria label
        let playAriaLabel: string = '';
        if(this.playerMetaData.title) {
            playAriaLabel = `${this.localizationHelper.getLocalizedValue('playAriaLabel')} ${this.playerMetaData.title}`;
        } else {
            playAriaLabel = LocalizationConstants.playVideoAriaLabel;
        }

        return (
            <div
                role='none'
                className={`${VideoPlayerNames.videoplayerContainer}`}
                ref={this.playerContainer}
                onKeyDown={this._onPlayerKeyDown}
                onMouseEnter={this._onMouseEvent}
                onMouseLeave={this._onMouseEvent}
                data-playerid={this.playerId}
            >
                <div className={`${VideoPlayerNames.videoplayerContainer}__wrapper`}>
                {(this.state.currentAudioTrack !== '' && this.state.currentAudioTrackURL !== '') && (
                        <audio
                            ref={this.audio}
                            preload='auto'
                            src={this.state.currentAudioTrackURL}
                            muted={this.state.isMuted}
                            loop={this.props.playerData.options.loop}
                        />
                    )}
                    <video
                        className={`${VideoPlayerNames.videoplayerContainer}__video`}
                        ref={this.player}
                        preload={'metadata'}
                        autoPlay={this.props.playerData.options.autoplay}
                        muted={this.state.isMuted}
                        loop={this.props.playerData.options.loop}
                        onPlay={this._onPlay}
                        onPause={this._onPause}
                        onClick={!this.state.isAgegateEnabled ? this._onTriggerClicked : this._onPause}
                        role='none'
                        src={this.state.mounted ? this.videoUrl : ''}
                        onContextMenu={this._onContextMenuClicked}
                        poster={this.state.mounted ? this.posterFrameUrl : ''}
                        playsInline={true}
                    />
                    <div className={`${VideoPlayerNames.videoplayerContainer}__errormessage`} role='status' aria-hidden={!this.state.showErrorMessage}>
                        <div className={`${VideoPlayerNames.videoplayerContainer}__errormessage__wrapper`}>
                            <p className={`${VideoPlayerNames.videoplayerContainer}__errormessage__heading`}>{this.state.videoErrorMessage.title}</p>
                        </div>
                    </div>
                    <div className={`${VideoPlayerNames.videoplayerContainer}__screenreader`} aria-live='assertive'>
                        {this.state.screenReaderText}
                    </div>
                    <div
                        className={`${VideoPlayerNames.videoplayerContainer}__spinner`}
                        role='status'
                        aria-hidden={!this.state.showSpinner}
                    >
                        <Waiting className={`${VideoPlayerNames.videoplayerContainer}__waiting`}/>
                    </div>
                    {(this.props.playerData.options.ageGate) && (
                            this._renderAgeGate()
                    )}
                    {(this.props.playerData.options.playPauseTrigger && !this.props.playerData.options.controls ||
                         this.state.isTriggerEnabled && !this.state.isAgegateEnabled) && (
                            this._renderPlayPauseTrigger(playAriaLabel, maskLevelStyle)
                    )}
                    {(this.state.showClosedCaptions) && this._renderClosedCaptions()}
                    {(this.props.playerData.options.controls &&
                         !this.state.isTriggerEnabled && !this.state.isAgegateEnabled) && (
                        this._renderVideoControls(playAriaLabel)
                    )}
                </div>
            </div>
        );
    }

    /*
     * @name - play
     * description - play the video
     * @public
     * @returns {void}
    */
   public play(): void {
        this.player.current!.play().catch(() => {
            this._onVideoError();
        });
        if(this.audio.current) {
            this.audio.current.play().catch(() => {
                this._onAudioError();
            });
        }
    }

    /*
     * @name - pause
     * description - pause the video
     * @public
     * @returns {void}
    */
   public pause(): void {
        this.player.current!.pause();
        if(this.audio.current) {
            this.audio.current.pause();
        }
    }

    public componentDidMount(): void {
        this.setState({mounted: true});
        if((this.props.playerData.options.autoplay) || (this.props.playerData.options.lazyLoad && !this.props.playerData.options.playPauseTrigger)
        || !this.props.playerData.options.lazyLoad) {
            this._loadPlayer();
        }
        document.addEventListener('fullscreenchange', this._onFullScreenChanged);
        document.addEventListener('mozfullscreenchange', this._onFullScreenChanged);
        document.addEventListener('webkitfullscreenchange', this._onFullScreenChanged);
        document.addEventListener('MSFullscreenChange', this._onFullScreenChanged);

        document.addEventListener('fullscreenerror', this._onFullscreenError);
        document.addEventListener('mozfullscreenerror', this._onFullscreenError);
        document.addEventListener('webkitfullscreenerror', this._onFullscreenError);
        document.addEventListener('MSFullscreenError', this._onFullscreenError);
    }

    public componentWillUnmount(): void {
        if (this.player.current) {
            for (const mediaEvent of MediaEvents) {
                this.player.current.removeEventListener(mediaEvent, this._triggerEvents);
            }
        }
        document.removeEventListener('fullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('mozfullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('webkitfullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('MSFullscreenChange', this._onFullScreenChanged);

        document.removeEventListener('fullscreenerror', this._onFullscreenError);
        document.removeEventListener('mozfullscreenerror', this._onFullscreenError);
        document.removeEventListener('webkitfullscreenerror', this._onFullscreenError);
        document.removeEventListener('MSFullscreenError', this._onFullscreenError);
    }

    private _renderClosedCaptions = ():  JSX.Element => {
        return (
            <ClosedCaptions
                ref={this.ClosedCaptions}
                className={`${VideoPlayerNames.videoplayerContainer}__ccoverlay`}
                showClosedCaptions={this.state.showClosedCaptions}
                currentTime={this.state.playPosition.currentTime}
                ccLanguage={this.state.closedCaptionLanguage}
                ccURL={this.state.closedCaptionsURL}
                errorCallback={this.playerHelper.onErrorCallback}
                isVideoControlVisible={this.state.isControlPanelVisible || this.state.doControlsHaveFocus}
                currentClosedCaptionsSettings={this.state.currentClosedCaptionsSettings}
                tempClosedCaptionsSettings={this.state.tempClosedCaptionsSettings}
                onClosedCaptionClick={this._onTriggerClicked}
            />
        );
    }

    private _renderPlayPauseTrigger = (playAriaLabel: string, maskLevelStyle: React.CSSProperties): JSX.Element => {
        return (
            <PlayPauseTrigger
                className={`${VideoPlayerNames.videoplayerContainer}__playpausetrigger`}
                style={maskLevelStyle}
                onChange={this._onTriggerClicked}
                toggled={this.state.playing}
                aria-hidden={!this.state.mouseHovered}
                playAriaLabel={playAriaLabel}
                pauseAriaLabel={this.localizationHelper.getLocalizedValue('pauseAriaLabel')}
                onFocus={this._onTriggerFocus}
                onBlur={this._onTriggerBlur}
                telemetryContent={this.props.telemetryContent}
            />
        );
    }

    private _renderVideoControls = (playAriaLabel: string): JSX.Element => {
        return (
            <VideoControls
                    ref={this.videoControl}
                    className={`${VideoPlayerNames.videoplayerContainer}__controls ${
                        (this.state.isControlPanelVisible || this.state.doControlsHaveFocus) ? 'show' : 'hide'
                    }`}
                    aria-hidden={!(this.state.isControlPanelVisible || this.state.doControlsHaveFocus)}
                    onPlayClick={this._onTriggerClicked}
                    playing={this.state.playing}
                    closedCaptionMenu={this.closedCaptionMenu!}
                    optionMenu = {this.optionsMenu!}
                    videoSeekSteps={PlayerConstants.defaultVideoSliderSteps}
                    volumeSeekSteps={PlayerConstants.defaultVolumeSliderSteps}
                    isMuted={this.state.isMuted}
                    onMuteClick={this._setMuted}
                    onVolumeChange={this._onVolumeChange}
                    onProgressChange={this._onProgressChange}
                    playPosition={this.state.playPosition}
                    currentClosedCaptionLanguage={this.state.closedCaptionLanguage}
                    currentVolume={this.state.currentVolume}
                    isInFullScreen={this.state.isInFullScreen}
                    toggleFullScreen={this._toggleFullScreen}
                    handleControlsKeyDownHandler={this._handleControlsKeyDownEvent}
                    isControlPanelVisible={this.state.isControlPanelVisible || this.state.doControlsHaveFocus}
                    onFocus={this._onVideoControlsFocus}
                    onBlur={this._onVideoControlsBlur}
                    onMenuItemClick={this._onPlayerMenuItemClick}
                    onMenuItemFocus={this._onPlayerMenuItemFocus}
                    onMenuItemBlur={this._onPlayerMenuItemBlur}
                    currentAudioTrack={this.state.currentAudioTrack}
                    currentAudioTrackURL={this.state.currentAudioTrackURL}
                    currentClosedCaptionsSetting={this.state.currentClosedCaptionsSettings}
                    isMobileDevice={this.isMobileDevice}
                    telemetryContent={this.props.telemetryContent}
                    resources={{
                        playAriaLabel: playAriaLabel,
                        pauseAriaLabel: this.localizationHelper.getLocalizedValue('pauseAriaLabel'),
                        muteAriaLabel: this.localizationHelper.getLocalizedValue('muteAriaLabel'),
                        unMuteAriaLabel: this.localizationHelper.getLocalizedValue('unMuteAriaLabel'),
                        fullScreenAriaLabel: this.localizationHelper.getLocalizedValue('fullScreenAriaLabel'),
                        exitFullScreenAriaLabel: this.localizationHelper.getLocalizedValue('exitFullScreenAriaLabel'),
                        seekBarLabel: this.localizationHelper.getLocalizedValue('seekBarLabel'),
                        videoTimeDurationLabel: this.localizationHelper.getLocalizedValue('videoTimeDurationLabel'),
                        closedCaptionLabel: this.localizationHelper.getLocalizedValue('closedCaptionLabel'),
                        optionButtonLabel: this.localizationHelper.getLocalizedValue('optionAriaLabel')
                    }}

            />
        );
    }

    /*
    * @name - _renderAgeGate
    * @description - Renders the age gate module
    * @private
    * @returns {void}
    */
   private _renderAgeGate = (): JSX.Element => {
        return (
        <AgeGate ref={this.ageGateContainer} onSubmitClick={this._validateAgeSubmitHandler} aria-hidden={!this.state.isAgegateEnabled} minmumAge={this.playerMetaData.minimumAge}/>
        );
    }

    private _loadPlayer(): void {
        if (this.player.current) {
            this.player.current.volume = this.state.currentVolume / 100;
            // Register the media events
            for (const mediaEvent of MediaEvents) {
                this.player.current.addEventListener(mediaEvent, this._triggerEvents);
            }
        }
        this.videoUrl = this.playerHelper.getVideoFileToPlay().url;
        this.player.current!.load();
        this.isPlayerLoaded = true;

        if(this.props.playerData.options.controls) {
            this.closedCaptionHelper = new ClosedCaptionHelper(this.playerMetaData, this.playerHelper, this.localizationHelper);
            this.closedCaptionMenu = this.closedCaptionHelper.getClosedCaptionMenu()!;
            this.optionsMenu = this.playerHelper.getOptionMenu();
            const ccFiles = this.playerMetaData.ccFiles!;
            if(ccFiles !== undefined && ccFiles.length > 0) {
                const autoCaptionsLang = this.props.playerData && this.props.playerData.options.autoCaptions;
                let autoCaptionsLocale: string | null = null;
                for (const ccFile of ccFiles) {

                    if (!autoCaptionsLocale && autoCaptionsLang && ccFile.locale.indexOf(autoCaptionsLang) > -1) {
                        autoCaptionsLocale = ccFile.locale;
                    }

                }
                this.selectedClosedCaptionsLocale = autoCaptionsLocale;
                if(!isNullOrWhiteSpace(this.selectedClosedCaptionsLocale!)) {
                    this.setState({
                        closedCaptionLanguage: this.selectedClosedCaptionsLocale!,
                        closedCaptionsURL: this.closedCaptionHelper.getClosedCaptionURLFromLocale(this.selectedClosedCaptionsLocale!),
                        showClosedCaptions: true
                    });
                }
            }
        }
    }

    /*
    * @name - _validateAgeSubmitHandler
    * @description - Validates the age submitted by the user
    * @private
    * @returns {void}
    */
    private _validateAgeSubmitHandler(): void {
        if(this.ageGateContainer.current!.getCalculatedAge()) {
            this.videoUrl = this.playerHelper.getVideoFileToPlay().url;
            this.setState({ isAgegateEnabled: false });
        } else {
            this.setState({ isAgegateEnabled: true });
            this._displayErrorMessage({ title: 'you are not allowed to watch video' });
        }
    }

    private _onVideoControlsFocus(): void {
        // No need to call showControlBar, this will make sure it shows
        this.setState({ doControlsHaveFocus: true});
    }

    private _onVideoControlsBlur(): void {
        // Call showControlBar to give it the 6 second timeout
        this._showControlBar(true);

        this.setState({ doControlsHaveFocus: false});
    }

    private _onPlayerMenuItemFocus(notification: IPlayerMenuItemClickNotification): void {

        if(notification.data && notification.data.indexOf(':') > 0) {
            const dataSplit = notification.data.split(':');
            const settingKey = dataSplit[0];
            if(settingKey === videoClosedCaptionsConstant.presetKey) {
                if(this.state.closedCaptionLanguage === 'off') {
                    this.setState({
                        showClosedCaptions: true
                    },            () => { this.ClosedCaptions.current!.showSampleCaptions();
                                          this._setCCSettings(notification, false);
                                        });
                } else {
                    this._setCCSettings(notification, false);
                }
            }
        } else {
            if(this.state.closedCaptionLanguage === 'off') {
                this.setState({
                    showClosedCaptions: false
                });
            }
        }
    }

    private _onPlayerMenuItemBlur(): void {
        this._setCCSettings({
           category: MenuCategories.ClosedCaptionSettings,
           id: '',
           data: 'current'
        });

    }

    private _onPlayerMenuItemClick(notification: IPlayerMenuItemClickNotification): void {
        // tslint:disable-next-line: switch-default
        switch (notification.category) {
            case MenuCategories.ClosedCaption: {
                this._setCC(notification.id);
                break;
            }

            case MenuCategories.ClosedCaptionSettings: {
                this._setCCSettings(notification);
                break;
            }

            case MenuCategories.AudioTracks: {
                this._setAudioTracks(notification);
            }
        }
    }

    /**
     * @name - setCC
     * @description - Sets the close captioning language/locale.
     * @public
     * @param {string} ccLanguageId - The desired new cc value.
     * @param {boolean} isUserInitiated - Value indicating if the action was trigger by user.
     * @returns {void}
     */
    private _setCC(ccLanguageId: string): void {
        ccLanguageId = this.playerHelper.removeIdPrefix(ccLanguageId);
        let selectedOption: ICCFile | null = null;

        if (ccLanguageId && this.playerMetaData.ccFiles) {
            for (const ccFile of this.playerMetaData.ccFiles) {
                if ((ccFile.locale === ccLanguageId) && (!ccFile.ccType || ccFile.ccType === ClosedCaptionTypes.TTML)) {
                    selectedOption = ccFile;
                    break;
                }
            }
        }

        if(ccLanguageId === 'off') {
            this.setState({
                closedCaptionLanguage: 'off',
                closedCaptionsURL: '',
                showClosedCaptions: false
            });
        } else {
            this.setState({
                closedCaptionLanguage: selectedOption!.locale,
                closedCaptionsURL: selectedOption!.url,
                showClosedCaptions: true
            });
        }
    }

    /**
     * @name - setCCSettings
     * @description - Sets the close caption settings.
     * @private
     * @param {IPlayerMenuItemClickNotification} notification - The desired new cc value.
     * @returns {void}
     */
    private _setCCSettings(notification: IPlayerMenuItemClickNotification, updatePreferences?: Boolean): void {
        if (notification.data === 'reset') {
            this.setState({
                currentClosedCaptionsSettings: closedCaptionsSettingDefaults
            },            () => {
                if(this.ClosedCaptions.current !== null) {
                    this.ClosedCaptions.current.applySettings();
                    this.ClosedCaptions.current.resetCaptions();
                    this.ClosedCaptions.current.updateCaptions(this.state.playPosition.currentTime);
                }
            });
        } else if(notification.data === 'current') {
            this.setState({
                tempClosedCaptionsSettings: undefined
            });

            if(this.state.closedCaptionLanguage === 'off') {
                this.setState({
                    showClosedCaptions: false
                });
            }
        } else {
            const dataSplit = notification.data!.split(':');
            if (!dataSplit) {
                return;
            }
            const settingKey = dataSplit[0];
            const optionKey = dataSplit[1];
            const currentSetting = this.closedCaptionHelper!.getUpdatedClosedCaptionSetting(this.state.currentClosedCaptionsSettings, settingKey, optionKey);
            if(updatePreferences === undefined || updatePreferences) {
                this.setState({
                    tempClosedCaptionsSettings: undefined,
                    currentClosedCaptionsSettings: currentSetting
                },            () => {
                        if(this.ClosedCaptions.current) {
                            this.ClosedCaptions.current.applySettings();
                            this.ClosedCaptions.current.resetCaptions();
                            this.ClosedCaptions.current.updateCaptions(this.state.playPosition.currentTime);
                        }
                });
            } else {
                this.setState({
                    tempClosedCaptionsSettings: currentSetting
                });
            }
        }
    }

    private _setAudioTracks(notification: IPlayerMenuItemClickNotification): void {
        const data = JSON.parse(notification.data!);
        if(data.lang === 'default') {
            this.setState({
                currentAudioTrack: 'default',
                currentAudioTrackURL: ''
            },            () => {
                this.player.current!.volume = this.state.currentVolume / 100;
            });
        } else {
            this.setState({
                currentAudioTrack: data.lang,
                currentAudioTrackURL: data.url
            },            () => {
                        this.audio.current!.currentTime = this.player.current!.currentTime;
                        this.audio.current!.volume = this.state.currentVolume / 100;
                        this.player.current!.volume = 0;
                        if(!this.player.current!.paused) {
                            this.audio.current!.load();
                            for(const mediaEvent of MediaEvents) {
                                this.audio.current!.addEventListener(mediaEvent, this._triggerAudioEvents);
                            }
                        }
            });
        }
    }

    // tslint:disable-next-line:cyclomatic-complexity
    private _triggerAudioEvents(event: Event): void {
        switch (event.type.toLowerCase()) {

            case 'error':
                this._onAudioError();
                break;
            case 'waiting':
                if(this.playerState === 'playing') {
                    this.isPlayerManuallyPaused = true;
                    this.pause();
                }
                break;

            case 'loadeddata':
                if(this.isPlayerManuallyPaused) {
                    this.isPlayerManuallyPaused = false;
                    this.play();
                }
                if(!this.player.current!.paused) {
                    this.play();
                }
                break;

            default:
        }
    }

    // tslint:disable-next-line:cyclomatic-complexity
    private _triggerEvents(event: Event): void {
        switch (event.type.toLowerCase()) {
            case 'canplay':
            case 'canplaythrough':
                break;

            case 'error':
                this._onVideoError();
                break;

            case 'play':
                break;

            case 'pause':
                this._updateState('paused');
                if(this.props.playerData.options.playPauseTrigger) {
                    this.setState({
                        mouseHovered: true
                    });
                }
                break;

            case 'seeking':
                if (this.playerState !== 'ended' && this.player.current!.seeking) {
                    this.seekFrom = this.player.current!.currentTime;
                    this._updateState('seeking');
                }
                break;

            case 'seeked':
                const currentPlayer = this.player.current;
                const currentTime = currentPlayer!.currentTime;
                if (this.playerState !== 'ended' && this.player.current!.seeking && this.seekFrom !== currentTime) {
                    this.seekFrom = null;
                }
                this._updateState(currentPlayer!.paused ? 'paused' : 'playing');
                break;

            case 'waiting':
                this._updateState('buffering');
                break;

            case 'loadedmetadata':
                break;

            case 'loadeddata':
                this._onVideoLoadedData();
                if (!this.props.playerData.options.autoplay) {
                    this._showControlBar(false);
                }
                break;

            case 'timeupdate':
                this._onTimeUpdate();
                break;

            case 'ended':
                this._updateState('ended');
                this._stop();
                break;

            case 'playing':
                this._updateState('playing');
                break;

            case 'volumechange':
                break;

            default:
        }
    }

    private _onAudioError(): void {
        this.pause();
        const errorMessage: IVideoErrorMessageData = { title: 'Error while playing audio Track. Switching back to default track' };
        this._displayErrorMessage(errorMessage);
        this._setAudioTracks({category: 'audioTracks', data: '{ "lang": "default", "url": ""}' , id: ''});
        setTimeout(() => {
            this.setState({
                showErrorMessage: false
            },            () => { this.play(); });
        },         2000);
    }

    // TODO : Need to localized the Error strings
    private _onVideoError(): void {
        this._updateState('error');
        const error: IVideoErrorData | null = this._getError();
        let errorMessage = '';
        if (error && error.errorCode) {
            switch (error.errorCode) {
                case VideoErrorCodes.MediaErrorAborted:
                    errorMessage = 'video playback was aborted';
                    break;
                case VideoErrorCodes.MediaErrorNetwork:
                    errorMessage = 'video failed to download';
                    break;
                case VideoErrorCodes.MediaErrorDecode:
                    errorMessage = 'video is not readable';
                    break;
                case VideoErrorCodes.MediaErrorSourceNotSupported:
                    errorMessage = 'video format is not supported';
                    break;
                default:
                    errorMessage = 'unknown error occurred';
            }

            this._stopMedia(errorMessage);
        } else {
            this._stopMedia();
        }
    }

    private _stopMedia(msgToDisplay?: string): void {
        if (msgToDisplay) {
            this._displayErrorMessage({ title: msgToDisplay });
            this._updateState('stopped');
        }
    }

    /*
    * @name - displayErrorMessage
    * @description - Create an error message overlay
    * @private
    * @param {IVideoErrorMessageData} - Error message content
    * @returns {void}
    */
    private _displayErrorMessage(errorMessage: IVideoErrorMessageData): void {
        this.setState({ videoErrorMessage: { title: errorMessage.title, message: errorMessage.message }});
        this.setState({ showErrorMessage: true});
    }

    /*
     * @name - getErrorCode
     * @description - gets the video error code of the current error.
     * @private
     * @returns {IVideoErrorData}
     */
    private _getError(): IVideoErrorData | null {
        let contentErrorCode: VideoErrorCodes;
        if(this.player.current!.error) {
            // video playback failed - show a message saying why
            switch (this.player.current!.error.code) {
                case this.player.current!.error.MEDIA_ERR_ABORTED:
                    contentErrorCode = VideoErrorCodes.MediaErrorAborted;
                    break;
                case this.player.current!.error.MEDIA_ERR_NETWORK:
                    contentErrorCode = VideoErrorCodes.MediaErrorNetwork;
                    break;
                case this.player.current!.error.MEDIA_ERR_DECODE:
                    contentErrorCode = VideoErrorCodes.MediaErrorDecode;
                    break;
                case this.player.current!.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    contentErrorCode = VideoErrorCodes.MediaErrorSourceNotSupported;
                    break;
                default:
                    contentErrorCode = VideoErrorCodes.MediaErrorUnknown;
            }
            return { errorCode: contentErrorCode };
        }
        return null;
    }

    private _handleControlsKeyDownEvent(e: React.KeyboardEvent): void {
        const keyBrdEvent = (e as unknown) as KeyboardEvent;
        const keycode = keyBrdEvent.keyCode;
        this._showControlBar(true);
        // const castTarget = e.target as HTMLElement;

        switch (keycode) {
            case KeyCodes.Home:
                e.stopPropagation();
                e.preventDefault();
                this.player.current!.currentTime = 0;
                if(this.audio.current) {
                    this.audio.current.currentTime = 0;
                }
                break;
            case KeyCodes.End:
                e.stopPropagation();
                e.preventDefault();
                this.player.current!.currentTime = this.state.playPosition.endTime;
                if(this.audio.current) {
                    this.audio.current.currentTime = this.state.playPosition.endTime;
                }
                break;
            case KeyCodes.ArrowLeft:
            case KeyCodes.ArrowRight:
                e.stopPropagation();
                e.preventDefault();
                let jumpToTime =
                    keycode === KeyCodes.ArrowLeft
                        ? this.state.playPosition.currentTime - PlayerConstants.defaultVideoSliderSteps
                        : this.state.playPosition.currentTime + PlayerConstants.defaultVideoSliderSteps;
                jumpToTime = Math.min(Math.max(this.state.playPosition.startTime, jumpToTime), this.state.playPosition.endTime);
                this.player.current!.currentTime = jumpToTime;
                if(this.audio.current) {
                    this.audio.current.currentTime = jumpToTime;
                }
                break;
            case KeyCodes.ArrowUp:
            case KeyCodes.ArrowDown:
                e.stopPropagation();
                e.preventDefault();
                this.videoControl.current!.showVolumeControl(true).call(this);
                const volume =
                    keycode === KeyCodes.ArrowDown
                        ? Math.max((this.state.currentVolume - PlayerConstants.defaultVolumeSliderSteps) / 100, 0)
                        : Math.min((this.state.currentVolume + PlayerConstants.defaultVolumeSliderSteps) / 100, 1);
                this.setState({ currentVolume: Math.round(volume * 100) });
                if(this.audio.current) {
                    this.audio.current.volume = volume;
                } else {
                    this.player.current!.volume = volume;
                }
                if (volume === 0) {
                    this.setState({ isMuted: true });
                } else {
                    this.setState({ isMuted: false });
                }
                break;
            default:
        }
    }

    private _onPlay(): void {
        this.setState({ playing: true });
    }

    private _onPause(): void {
        this.setState({ playing: false });
    }

    private _onVolumeChange(notification: ISliderChangeNotification): void {
        this.setState({ currentVolume: notification.firstThumbValue });
        if(this.audio.current) {
            this.audio.current.volume = notification.firstThumbValue / 100;
        } else {
            this.player.current!.volume = notification.firstThumbValue / 100;
        }

        if (notification.firstThumbValue === 0) {
            this.setState({ isMuted: true });
        } else {
            if (this.state.isMuted && notification.firstThumbValue > 0) {
                this.setState({ isMuted: false });
            }
        }
    }

    private _setMuted(): void {
        if (this.state.isMuted) {
            const newVolume = this.state.previousVolume === 0 ? PlayerConstants.defaultVolume * 100 : this.state.previousVolume;

            if(this.audio.current) {
                this.audio.current.volume = newVolume / 100;
            } else {
                this.player.current!.volume = newVolume / 100;
            }
            this.setState({ isMuted: false, currentVolume: newVolume });
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('unMuteAriaLabel'));
            onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.unMuteAriaLabel).call(this);
        } else {
            this.setState({ isMuted: true, previousVolume: this.player.current!.volume * 100, currentVolume: 0 });
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('muteAriaLabel'));
            onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.muteAriaLabel).call(this);
        }
    }

    private _onPlayerKeyDown(e: React.KeyboardEvent): void {
        const keyBrdEvent = (e as unknown) as KeyboardEvent;
        const keycode = keyBrdEvent.keyCode;
        // tslint:disable-next-line:switch-default
        switch (keycode) {
            case KeyCodes.Tab:
                this._showControlsBasedOnState();
        }
    }

    private _onMouseEvent(event: React.MouseEvent<HTMLDivElement>): void {
        if (this.props.playerData.options.controls) {
            this._showControlBar();
        }
        if(!this.state.isTriggerEnabled && this.state.playing) {
            this.setState({ mouseHovered: event.type === 'mouseenter' });
        }
    }

    private _showControlBar(autoHide: boolean = true): void {
        if(!this.state.isTriggerEnabled && !this.state.isAgegateEnabled) {
            if (!this.state.isControlPanelVisible) {
                this.setState({ isControlPanelVisible: true });
            }
            if (!!this.controlPanelTimer) {
                window && window.clearTimeout(this.controlPanelTimer);
                this.controlPanelTimer = 0;
            }
            if (autoHide) {
                this.controlPanelTimer = window && window.setTimeout(() => {
                    this._hideControlBar();
                },                                                   PlayerConstants.defaultControlPanelTimeout);
            }
        }
    }

    private _hideControlBar(): void {
        window && window.clearTimeout(this.controlPanelTimer);
        this.controlPanelTimer = 0;
        this.setState({ isControlPanelVisible: false });
    }

    private _onFullScreenChanged(): void {
        this.state.isInFullScreen ? this._onFullscreenExit() : this._onFullscreenEnter();
    }

    /*
    * @name - onFullscreenEnter
    * @description - Event handler for fullscreen enter.
    * @private
    * @returns {void}
    */
   private _onFullscreenEnter(): void {
       this.setState({
           isInFullScreen: true
       });
    }

    /*
    * @name - onFullscreenExit
    * @description - Event handler for fullscreen exit.
    * @private
    * @returns {void}
    */
   private _onFullscreenExit(): void {
        this.setState({
            isInFullScreen: false
        });
    }

    private _toggleFullScreen(): void {
        this.state.isInFullScreen ? this._exitFullScreen() : this._enterFullScreen();
    }

    private _onFullscreenError(): void {
        this.setState({
            isInFullScreen: false
        });
    }

    private _enterFullScreen(): void {
        if(!Player._isNativeFullscreenEnabled()) {
            return;
        }

        // tslint:disable-next-line:no-any
        const fullscreenElement = this.playerContainer.current! as any;
        const elementInFullScreen = Player._getElementInFullScreen();

        // We go to fullscreen only when there is no other element in fullscreen and browser supports fullscreen
        if (!!fullscreenElement && !elementInFullScreen) {
            const enterFullScreen = fullscreenElement.requestFullscreen ||
                fullscreenElement.msRequestFullscreen ||
                fullscreenElement.mozRequestFullScreen ||
                fullscreenElement.webkitRequestFullscreen ||
                fullscreenElement.webkitEnterFullScreen;

            enterFullScreen.call(fullscreenElement);
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('fullScreenLabel'));
            onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.fullScreenAriaLabel).call(this);
        }
    }

    private _exitFullScreen(): void {
        if(!Player._isNativeFullscreenEnabled()) {
            return;
        }

        // tslint:disable-next-line:no-any
        const fullscreenElement = this.playerContainer.current! as any;
        const elementInFullScreen = Player._getElementInFullScreen();

        // we only call cancel if we are in fullscreen. If another element went fullscreen that took the player with it then
        // we shouldn't call cancel fullscreen
        if (!!fullscreenElement && fullscreenElement === elementInFullScreen) {
            // tslint:disable-next-line:no-any
            const doc = document as any;
            const cancelFullScreen = doc.cancelFullScreen ||
                doc.msExitFullscreen ||
                doc.mozCancelFullScreen ||
                doc.webkitCancelFullScreen;

            cancelFullScreen.call(doc);
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('exitFullScreenLabel'));
            onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.exitFullScreenAriaLabel).call(this);
        }
    }

    private _onVideoLoadedData(): void {
        this._updateState('ready');
        if (this.props.playerData.options.controls) {
            const position = this._getPlayPosition();
            this.setState({ playPosition: position });
        }
    }

    private _onTimeUpdate(): void {
        if (this.props.playerData.options.controls) {
            const position = this._getPlayPosition();
            // EndTime changes after playing video for certain time. Keeping this constant.
            position.endTime = this.state.playPosition.endTime;
            this.setState({ playPosition: position});
            if(this.state.playing) {
                if(this.playerState === 'buffering') {
                    this._updateState('playing');
                }
            }
        }
    }

    private _getBufferedDuration(): number {
        let buffered = 0;
        if (this.player.current!.buffered && this.player.current!.buffered.length) {
            buffered = this.player.current!.buffered.end(this.player.current!.buffered.length - 1);
        }
        return buffered;
    }

    private _getPlayPosition(): IPlayPosition {
        const bufferedDuration = this._getBufferedDuration();
        return {
            currentTime: this.player.current!.currentTime,
            startTime: 0,
            endTime: this.player.current!.duration,
            bufferedDuration: bufferedDuration
        };
    }

    private _onProgressChange(notification: ISliderChangeNotification): void {
        let time = notification.firstThumbValue;
        const position = this._getPlayPosition();
        time = Math.max(position.startTime, Math.min(time, position.endTime));

        if (Math.abs(time - position.currentTime) >= PlayerConstants.defaultPositionUpdateThreshold) {
            this.player.current!.currentTime = time;
            if(this.audio.current) {
                this.audio.current.currentTime = time;
            }
        }
    }

    private _onTriggerClicked(): void {
        const currentPlayer = this.player.current;
        if(!this.isPlayerLoaded) {
            this._loadPlayer();
            this.player.current!.autoplay = true;
        } else {
            if (currentPlayer!.paused) {
                this.play();
                this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('playingAriaLabel'));
                onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.playAriaLabel).call(this);
            } else {
                this.pause();
                this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('pausedAriaLabel'));
                onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.pauseAriaLabel).call(this);
            }
        }

        if(this.state.isTriggerEnabled) {
            this.setState({ isTriggerEnabled: false }, () => { this.videoControl.current!.setFocusOnPlay(); });
            onTelemetryClick(this.props.telemetryContent!, this.payLoad, LocalizationConstants.pauseAriaLabel).call(this);
            if(this.props.playerData.options.playFullScreen) {
                this._enterFullScreen();
            }
        }
    }

    private _stop(): void {
        this._seek(0);
        if (this.props.playerData.options.controls) {
            this.pause();
            const playPosition = this._getPlayPosition();
            playPosition.endTime = this.state.playPosition.endTime;
            this.setState({ playPosition: playPosition});
            if(this.audio.current) {
                this.audio.current.pause();
            }
        }
    }

    private _seek(time: number): void {
        const position = this._getPlayPosition();
        time = Math.max(position.startTime, Math.min(time, position.endTime));

        if (Math.abs(time - position.currentTime) >= PlayerConstants.defaultPositionUpdateThreshold) {
            this.seekFrom = position.currentTime;
            this.player.current!.currentTime = time;
            if(this.audio.current) {
                this.audio.current.currentTime = time;
            }
        }
    }

    /*
     * @name - _getMaskLevelStyle
     * @description - Returns the mask level style
     * @private
     * @returns {string}
     */
    private _getMaskLevelStyle(): string {
        let result: string;
        const maskLevel = this.props.playerData.options.maskLevel || PlayerConstants.defaultMaskLevel;
        result = format('rgba(0,0,0,{0})', Number(maskLevel) / 100);
        return result;
    }

    /*
     * @name - updateState
     * @description - updates the current player state
     * @private
     * @param {string} newState - player state
     * @returns {void}
     */
    private _updateState(newState: PlayerStates): void {
        if (!newState || newState === this.playerState) {
            return;
        }

        this.playerState = newState;

        this._showControlsBasedOnState();
        this._showSpinnerBasedOnState();
    }

    /*
     * @name - showSpinnerBasedOnState
     * @description - Shows or hides the spinner based on player state
     * @private
     * @returns {void}
     */
    private _showSpinnerBasedOnState(): void {
        switch (this.playerState) {
            case 'ready':
            case 'playing':
            case 'paused':
            case 'ended':
            case 'stopped':
            case 'error':
                this._hideSpinner();
                break;
            default:
                this._showSpinner();
        }
    }

    /*
    * @name - showControlsBasedOnState
    * @description - Shows or hides the player controls based on player state
    * @private
    * @returns {void}
    */
    private _showControlsBasedOnState(): void {
        switch (this.playerState) {
            case 'error':
            case 'loading':
            case 'init':
                this._hideControlBar();
                break;
            case 'ended':
                this._showControlBar(false);
                break;
            case 'ready':
            case 'paused':
            case 'stopped':
                this._showControlBar(false);
                break;
            default:
            this._showControlBar(true);
        }
    }

    private _hideSpinner(): void {
        this.setState({ showSpinner: false });
    }

    private _showSpinner(): void {
        this.setState({ showSpinner: true });
    }

    /*
     * @name - _onTriggerFocus
     * description - Play Trigger focus event
     * @private
     * @returns {void}
    */
    private _onTriggerFocus(): void {
        this.setState({ mouseHovered: true});
    }

    /*
     * @name - _onTriggerBlur
     * description - Play Trigger Blur event
     * @private
     * @returns {void}
    */
    private _onTriggerBlur(): void {
        if(!this.state.isTriggerEnabled && this.state.playing) {
            this.setState({ mouseHovered: false});
        }
    }

    /*
     * @name - updateScreenReaderElement
     * description - updates the screen reader element
     * @private
     * @returns {void}
    */
   private _updateScreenReaderElement(text: string): void {
        this.setState({
            screenReaderText: text
        });

    }

     /*
     * @name - onContextMenuClicked
     * description - avoid opening context menu on righ click
     * @private
     * @returns {void}
    */
    private _onContextMenuClicked(e: React.MouseEvent): void {
        e.preventDefault();
    }

    /*
     * @name - _isMobile
     * description - check for mobile devices
     * @private
     * @returns {void}
    */
    private _isMobile(): boolean {
        if (MsDyn365.msdyn365Commerce.isBrowser) {
            const userAgent = window.navigator.userAgent;
            const isIphone = !!userAgent.match(/iPhone/i);
            const isSilk = !!userAgent.match(/Silk/i);
            const isWindowsPhone = !!userAgent.match(/Windows Phone/i);
            const isAndroid = !isWindowsPhone && (isSilk ||
                !!userAgent.match(/Android/i));
            return isIphone || isWindowsPhone || isAndroid;
        }
        return false;
    }
}
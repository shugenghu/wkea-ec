import { buildMockCoreContext, ICoreContext } from '@msdyn365-commerce/core';
import { mount, ReactWrapper} from 'enzyme';
import * as React from 'react';
import {RatingComponent} from '../index';

describe('star ratings', () => {
    const mockCoreContext = buildMockCoreContext({}) as ICoreContext<{}>;
    const filledStar = 'msc-rating__star';
    const halfFilledStar = 'msc-rating__half-star';
    const emptyStar = 'msc-rating__empty-star';
    const starGlyphProp = (stars: ReactWrapper, index: number) => {
        const star = stars.get(index);
        return star.props;
    };

    it('renders as a 4 star rating', () => {
        const wrapper = mount(
            <RatingComponent
                className='myClass'
                avgRating={3.75}
                ratingCount={'345'}
                readOnly={true}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />
        );
        const stars = wrapper.find('span');

        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(filledStar);
        expect(starGlyphProp(stars, 3).className).toContain(filledStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        wrapper.unmount();
    });

    it('renders as a 2.5 star rating', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.5}
                ratingCount={'345'}
                readOnly={true}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />
        );

        const stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(halfFilledStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        wrapper.unmount();
    });

    it('renders as a 2 star rating', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={true}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />
        );

        const stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        wrapper.unmount();
    });

    it('renders 0 filled in stars when the user can set the rating', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />
        );

        const stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toEqual(emptyStar);
        expect(starGlyphProp(stars, 1).className).toEqual(emptyStar);
        expect(starGlyphProp(stars, 2).className).toEqual(emptyStar);
        expect(starGlyphProp(stars, 3).className).toEqual(emptyStar);
        expect(starGlyphProp(stars, 4).className).toEqual(emptyStar);
        wrapper.unmount();
    });

    it('sets the rating and propogates the change when the rangeslider updates', () => {
        const event = {currentTarget: { value: '4'}, target: { value: '4'}};
        const onChange = jest.fn();
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                onChange={onChange}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        const input = wrapper.find('input');
        input.simulate('change', event);
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(filledStar);
        expect(starGlyphProp(stars, 3).className).toContain(filledStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        expect(onChange).toHaveBeenCalled();
        wrapper.unmount();
    });

    // expect(() => { actionToggle.componentDidUpdate();}).not.toThrow();
    it('does not throw error when input changes but no onChange is given', () => {
        const event = {currentTarget: { value: '4'}, target: { value: '4'}};
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const input = wrapper.find('input');
        expect(() => { input.simulate('change', event); wrapper.update();}).not.toThrow();
        wrapper.unmount();
    });

    it('sets the rating and propogates the click when the user sets the rating', () => {
        const onChange = jest.fn();
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                onChange={onChange}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );

        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        const starButtons = wrapper.find('span');
        mount(starButtons.get(2)).simulate('click')
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(filledStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        expect(onChange).toHaveBeenCalled();
        wrapper.unmount();
    });

    it('does not sets the rating when user clicks on static rating', () => {
        const onChange = jest.fn();
        const wrapper = mount(
            <RatingComponent
                avgRating={2}
                ratingCount={'345'}
                readOnly={true}
                onChange={onChange}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );

        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        const starButtons = wrapper.find('span');
        mount(starButtons.get(2)).simulate('click')
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        expect(onChange).not.toHaveBeenCalled();
        wrapper.unmount();
    });

    it('does not throw error when the user clicks and no onChange was given', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        const starButtons = wrapper.find('span');
        const mountedStar = mount(starButtons.get(2));
        expect(() => { mountedStar.simulate('click'); wrapper.update();}).not.toThrow();
        wrapper.unmount();
    });

    it('sets the displayed rating when the user hovers on a star when in a state where the user can set rating', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );
        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);

        const starWrapper = mount(wrapper.find('[data-index]').get(3));
        starWrapper.simulate('mouseOver');
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(filledStar);
        expect(starGlyphProp(stars, 3).className).toContain(filledStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        wrapper.unmount();
    });

    it('clears the rating when the users cursor exits the rating area', () => {
        const wrapper = mount(
            <RatingComponent
                avgRating={2.23}
                ratingCount={'345'}
                readOnly={false}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />,
            { attachTo: document.body.firstElementChild as HTMLElement }
        );

        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);

        const starWrapper = mount(wrapper.find('[data-index]').get(3));
        starWrapper.simulate('mouseOver');
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);
        expect(starGlyphProp(stars, 2).className).toContain(filledStar);
        expect(starGlyphProp(stars, 3).className).toContain(filledStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);

        const ratingContainerElement = wrapper.find('.msc-rating__group').first();
        ratingContainerElement.simulate('mouseLeave');
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 2).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 3).className).toContain(emptyStar);
        expect(starGlyphProp(stars, 4).className).toContain(emptyStar);
        wrapper.unmount();
    });

    it('rating updates when the props change', () => {
        const wrapper = mount(
            <RatingComponent
                className='myClass'
                avgRating={1}
                ratingCount={'345'}
                readOnly={true}
                context={mockCoreContext}
                ariaLabel={'my aria label'}
                id='foo'
                typeName='foo'
                data={{}}
            />
        );

        let stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(emptyStar);
        wrapper.setProps({avgRating: 2});
        wrapper.update();
        stars = wrapper.find('span');
        expect(starGlyphProp(stars, 0).className).toContain(filledStar);
        expect(starGlyphProp(stars, 1).className).toContain(filledStar);

        wrapper.unmount();
    });
});
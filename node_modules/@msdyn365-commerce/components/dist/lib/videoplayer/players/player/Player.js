import { getPayloadObject, onTelemetryClick, Waiting } from '@msdyn365-commerce-modules/utilities';
import * as React from 'react';
import * as MsDyn365 from '@msdyn365-commerce/core';
import AgeGate from '../../components/age-gate/AgeGate';
import ClosedCaptions from '../../components/closed-captions/video-closed-captions';
import { closedCaptionsSettingDefaults, videoClosedCaptionsConstant } from '../../components/closed-captions/video-closed-captions-settings';
import { MediaEvents, MenuCategories, PlayerConstants, VideoErrorCodes, VideoPlayerNames } from '../../components/data/player-constants';
import { ClosedCaptionTypes } from '../../components/data/player-metadata';
import ClosedCaptionHelper from '../../components/helper/closedCaptionHelper';
import LocalizationHelper, { LocalizationConstants } from '../../components/helper/localization-helper';
import PlayerHelper from '../../components/helper/playerHelper';
import PlayPauseTrigger from '../../components/play-pause-trigger/PlayPauseTrigger';
import { format, isNullOrWhiteSpace } from '../../components/utilities/stringExtensions';
import VideoControls from '../../components/video-controls/VideoControls';
export default class Player extends React.Component {
    constructor(props) {
        super(props);
        this.controlPanelTimer = 0;
        this.player = React.createRef();
        this.audio = React.createRef();
        this.playerContainer = React.createRef();
        this.videoControl = React.createRef();
        this.ClosedCaptions = React.createRef();
        this.ageGateContainer = React.createRef();
        this.videoUrl = '';
        this.posterFrameUrl = '';
        this.seekFrom = null;
        this.closedCaptionHelper = null;
        this.closedCaptionMenu = null;
        this.optionsMenu = null;
        this.selectedClosedCaptionsLocale = '';
        this.isPlayerManuallyPaused = false;
        this.isPlayerLoaded = false;
        this._renderClosedCaptions = () => {
            return (React.createElement(ClosedCaptions, { ref: this.ClosedCaptions, className: `${VideoPlayerNames.videoplayerContainer}__ccoverlay`, showClosedCaptions: this.state.showClosedCaptions, currentTime: this.state.playPosition.currentTime, ccLanguage: this.state.closedCaptionLanguage, ccURL: this.state.closedCaptionsURL, errorCallback: this.playerHelper.onErrorCallback, isVideoControlVisible: this.state.isControlPanelVisible || this.state.doControlsHaveFocus, currentClosedCaptionsSettings: this.state.currentClosedCaptionsSettings, tempClosedCaptionsSettings: this.state.tempClosedCaptionsSettings, onClosedCaptionClick: this._onTriggerClicked }));
        };
        this._renderPlayPauseTrigger = (playAriaLabel, maskLevelStyle) => {
            return (React.createElement(PlayPauseTrigger, { className: `${VideoPlayerNames.videoplayerContainer}__playpausetrigger`, style: maskLevelStyle, onChange: this._onTriggerClicked, toggled: this.state.playing, "aria-hidden": !this.state.mouseHovered, playAriaLabel: playAriaLabel, pauseAriaLabel: this.localizationHelper.getLocalizedValue('pauseAriaLabel'), onFocus: this._onTriggerFocus, onBlur: this._onTriggerBlur, telemetryContent: this.props.telemetryContent }));
        };
        this._renderVideoControls = (playAriaLabel) => {
            return (React.createElement(VideoControls, { ref: this.videoControl, className: `${VideoPlayerNames.videoplayerContainer}__controls ${(this.state.isControlPanelVisible || this.state.doControlsHaveFocus) ? 'show' : 'hide'}`, "aria-hidden": !(this.state.isControlPanelVisible || this.state.doControlsHaveFocus), onPlayClick: this._onTriggerClicked, playing: this.state.playing, closedCaptionMenu: this.closedCaptionMenu, optionMenu: this.optionsMenu, videoSeekSteps: PlayerConstants.defaultVideoSliderSteps, volumeSeekSteps: PlayerConstants.defaultVolumeSliderSteps, isMuted: this.state.isMuted, onMuteClick: this._setMuted, onVolumeChange: this._onVolumeChange, onProgressChange: this._onProgressChange, playPosition: this.state.playPosition, currentClosedCaptionLanguage: this.state.closedCaptionLanguage, currentVolume: this.state.currentVolume, isInFullScreen: this.state.isInFullScreen, toggleFullScreen: this._toggleFullScreen, handleControlsKeyDownHandler: this._handleControlsKeyDownEvent, isControlPanelVisible: this.state.isControlPanelVisible || this.state.doControlsHaveFocus, onFocus: this._onVideoControlsFocus, onBlur: this._onVideoControlsBlur, onMenuItemClick: this._onPlayerMenuItemClick, onMenuItemFocus: this._onPlayerMenuItemFocus, onMenuItemBlur: this._onPlayerMenuItemBlur, currentAudioTrack: this.state.currentAudioTrack, currentAudioTrackURL: this.state.currentAudioTrackURL, currentClosedCaptionsSetting: this.state.currentClosedCaptionsSettings, isMobileDevice: this.isMobileDevice, telemetryContent: this.props.telemetryContent, resources: {
                    playAriaLabel: playAriaLabel,
                    pauseAriaLabel: this.localizationHelper.getLocalizedValue('pauseAriaLabel'),
                    muteAriaLabel: this.localizationHelper.getLocalizedValue('muteAriaLabel'),
                    unMuteAriaLabel: this.localizationHelper.getLocalizedValue('unMuteAriaLabel'),
                    fullScreenAriaLabel: this.localizationHelper.getLocalizedValue('fullScreenAriaLabel'),
                    exitFullScreenAriaLabel: this.localizationHelper.getLocalizedValue('exitFullScreenAriaLabel'),
                    seekBarLabel: this.localizationHelper.getLocalizedValue('seekBarLabel'),
                    videoTimeDurationLabel: this.localizationHelper.getLocalizedValue('videoTimeDurationLabel'),
                    closedCaptionLabel: this.localizationHelper.getLocalizedValue('closedCaptionLabel'),
                    optionButtonLabel: this.localizationHelper.getLocalizedValue('optionAriaLabel')
                } }));
        };
        this._renderAgeGate = () => {
            return (React.createElement(AgeGate, { ref: this.ageGateContainer, onSubmitClick: this._validateAgeSubmitHandler, "aria-hidden": !this.state.isAgegateEnabled, minmumAge: this.playerMetaData.minimumAge }));
        };
        this.isMobileDevice = this._isMobile();
        const state = {
            playing: false,
            mouseHovered: this.props.playerData.options.playPauseTrigger || !this.props.playerData.options.autoplay,
            isControlPanelVisible: !this.props.playerData.options.playPauseTrigger,
            doControlsHaveFocus: false,
            isTriggerEnabled: this.props.playerData.options.playPauseTrigger && !this.props.playerData.options.autoplay && this.props.playerData.options.controls,
            currentVolume: this.props.playerData.options.mute && !this.isMobileDevice ? 0 : PlayerConstants.defaultVolume * 100,
            previousVolume: 0,
            isMuted: this.props.playerData.options.mute || false,
            isInFullScreen: false,
            showSpinner: false,
            isAgegateEnabled: this.props.playerData.options.ageGate && !this.props.playerData.options.autoplay,
            showErrorMessage: false,
            screenReaderText: '',
            closedCaptionLanguage: 'off',
            currentAudioTrack: 'default',
            currentAudioTrackURL: '',
            showClosedCaptions: false,
            mounted: false,
            currentClosedCaptionsSettings: {
                preset: closedCaptionsSettingDefaults.preset,
                text_font: closedCaptionsSettingDefaults.text_font,
                text_color: closedCaptionsSettingDefaults.text_color,
                text_opacity: closedCaptionsSettingDefaults.text_opacity,
                text_size: closedCaptionsSettingDefaults.text_size,
                text_edge_style: closedCaptionsSettingDefaults.text_edge_style,
                text_background_color: closedCaptionsSettingDefaults.text_background_color,
                text_background_opacity: closedCaptionsSettingDefaults.text_background_opacity,
                window_color: closedCaptionsSettingDefaults.window_color,
                window_opacity: closedCaptionsSettingDefaults.window_opacity
            },
            closedCaptionsURL: '',
            videoErrorMessage: {
                title: '',
                message: ''
            },
            playPosition: {
                currentTime: 0,
                startTime: 0,
                endTime: 0,
                bufferedDuration: 0
            },
            tempClosedCaptionsSettings: undefined
        };
        this.playerState = 'init';
        this._onTriggerClicked = this._onTriggerClicked.bind(this);
        this._onMouseEvent = this._onMouseEvent.bind(this);
        this._onPlay = this._onPlay.bind(this);
        this._onPause = this._onPause.bind(this);
        this._triggerEvents = this._triggerEvents.bind(this);
        this._triggerAudioEvents = this._triggerAudioEvents.bind(this);
        this._onProgressChange = this._onProgressChange.bind(this);
        this._setMuted = this._setMuted.bind(this);
        this._onVolumeChange = this._onVolumeChange.bind(this);
        this._onFullScreenChanged = this._onFullScreenChanged.bind(this);
        this._toggleFullScreen = this._toggleFullScreen.bind(this);
        this._showControlBar = this._showControlBar.bind(this);
        this._handleControlsKeyDownEvent = this._handleControlsKeyDownEvent.bind(this);
        this._onFullscreenError = this._onFullscreenError.bind(this);
        this._onPlayerKeyDown = this._onPlayerKeyDown.bind(this);
        this._onTriggerFocus = this._onTriggerFocus.bind(this);
        this._onTriggerBlur = this._onTriggerBlur.bind(this);
        this._onVideoControlsFocus = this._onVideoControlsFocus.bind(this);
        this._onVideoControlsBlur = this._onVideoControlsBlur.bind(this);
        this._onPlayerMenuItemClick = this._onPlayerMenuItemClick.bind(this);
        this._onPlayerMenuItemFocus = this._onPlayerMenuItemFocus.bind(this);
        this._onPlayerMenuItemBlur = this._onPlayerMenuItemBlur.bind(this);
        this._validateAgeSubmitHandler = this._validateAgeSubmitHandler.bind(this);
        this._onContextMenuClicked = this._onContextMenuClicked.bind(this);
        this.localizationHelper = new LocalizationHelper(this.props.playerResources);
        this.playerHelper = new PlayerHelper(this.props, this.localizationHelper);
        this.playerId = this.playerHelper.isEmptyOrUndefined(this.props.playerId) ? 'vid-0' : this.props.playerId;
        this.playerMetaData = this.playerHelper.getMetadata();
        this.state = state;
        this.posterFrameUrl = this.playerHelper.getPosterFrameUrl();
        this.payLoad = getPayloadObject('click', this.props.telemetryContent, '');
    }
    static _isNativeFullscreenEnabled() {
        const doc = document;
        return doc.fullscreenEnabled || doc.mozFullScreenEnabled || doc.webkitFullscreenEnabled || doc.webkitSupportsFullscreen ||
            doc.msFullscreenEnabled;
    }
    static _getElementInFullScreen() {
        const doc = document;
        return doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;
    }
    render() {
        const maskLevelStyle = {};
        if (this.state.isTriggerEnabled) {
            maskLevelStyle.backgroundColor = this._getMaskLevelStyle();
        }
        if (this.props.isEditor) {
            this.playerHelper.updatePlayerProps(this.props);
            this.playerMetaData = this.playerHelper.getMetadata();
            if (this.posterFrameUrl !== this.playerHelper.getPosterFrameUrl()) {
                this.posterFrameUrl = this.playerHelper.getPosterFrameUrl();
            }
            if (this.isPlayerLoaded && this.videoUrl !== this.playerHelper.getVideoFileToPlay().url) {
                this._loadPlayer();
            }
        }
        let playAriaLabel = '';
        if (this.playerMetaData.title) {
            playAriaLabel = `${this.localizationHelper.getLocalizedValue('playAriaLabel')} ${this.playerMetaData.title}`;
        }
        else {
            playAriaLabel = LocalizationConstants.playVideoAriaLabel;
        }
        return (React.createElement("div", { role: 'none', className: `${VideoPlayerNames.videoplayerContainer}`, ref: this.playerContainer, onKeyDown: this._onPlayerKeyDown, onMouseEnter: this._onMouseEvent, onMouseLeave: this._onMouseEvent, "data-playerid": this.playerId },
            React.createElement("div", { className: `${VideoPlayerNames.videoplayerContainer}__wrapper` },
                (this.state.currentAudioTrack !== '' && this.state.currentAudioTrackURL !== '') && (React.createElement("audio", { ref: this.audio, preload: 'auto', src: this.state.currentAudioTrackURL, muted: this.state.isMuted, loop: this.props.playerData.options.loop })),
                React.createElement("video", { className: `${VideoPlayerNames.videoplayerContainer}__video`, ref: this.player, preload: 'metadata', autoPlay: this.props.playerData.options.autoplay, muted: this.state.isMuted, loop: this.props.playerData.options.loop, onPlay: this._onPlay, onPause: this._onPause, onClick: !this.state.isAgegateEnabled ? this._onTriggerClicked : this._onPause, role: 'none', src: this.state.mounted ? this.videoUrl : '', onContextMenu: this._onContextMenuClicked, poster: this.state.mounted ? this.posterFrameUrl : '', playsInline: true }),
                React.createElement("div", { className: `${VideoPlayerNames.videoplayerContainer}__errormessage`, role: 'status', "aria-hidden": !this.state.showErrorMessage },
                    React.createElement("div", { className: `${VideoPlayerNames.videoplayerContainer}__errormessage__wrapper` },
                        React.createElement("p", { className: `${VideoPlayerNames.videoplayerContainer}__errormessage__heading` }, this.state.videoErrorMessage.title))),
                React.createElement("div", { className: `${VideoPlayerNames.videoplayerContainer}__screenreader`, "aria-live": 'assertive' }, this.state.screenReaderText),
                React.createElement("div", { className: `${VideoPlayerNames.videoplayerContainer}__spinner`, role: 'status', "aria-hidden": !this.state.showSpinner },
                    React.createElement(Waiting, { className: `${VideoPlayerNames.videoplayerContainer}__waiting` })),
                (this.props.playerData.options.ageGate) && (this._renderAgeGate()),
                (this.props.playerData.options.playPauseTrigger && !this.props.playerData.options.controls ||
                    this.state.isTriggerEnabled && !this.state.isAgegateEnabled) && (this._renderPlayPauseTrigger(playAriaLabel, maskLevelStyle)),
                (this.state.showClosedCaptions) && this._renderClosedCaptions(),
                (this.props.playerData.options.controls &&
                    !this.state.isTriggerEnabled && !this.state.isAgegateEnabled) && (this._renderVideoControls(playAriaLabel)))));
    }
    play() {
        this.player.current.play().catch(() => {
            this._onVideoError();
        });
        if (this.audio.current) {
            this.audio.current.play().catch(() => {
                this._onAudioError();
            });
        }
    }
    pause() {
        this.player.current.pause();
        if (this.audio.current) {
            this.audio.current.pause();
        }
    }
    componentDidMount() {
        this.setState({ mounted: true });
        if ((this.props.playerData.options.autoplay) || (this.props.playerData.options.lazyLoad && !this.props.playerData.options.playPauseTrigger)
            || !this.props.playerData.options.lazyLoad) {
            this._loadPlayer();
        }
        document.addEventListener('fullscreenchange', this._onFullScreenChanged);
        document.addEventListener('mozfullscreenchange', this._onFullScreenChanged);
        document.addEventListener('webkitfullscreenchange', this._onFullScreenChanged);
        document.addEventListener('MSFullscreenChange', this._onFullScreenChanged);
        document.addEventListener('fullscreenerror', this._onFullscreenError);
        document.addEventListener('mozfullscreenerror', this._onFullscreenError);
        document.addEventListener('webkitfullscreenerror', this._onFullscreenError);
        document.addEventListener('MSFullscreenError', this._onFullscreenError);
    }
    componentWillUnmount() {
        if (this.player.current) {
            for (const mediaEvent of MediaEvents) {
                this.player.current.removeEventListener(mediaEvent, this._triggerEvents);
            }
        }
        document.removeEventListener('fullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('mozfullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('webkitfullscreenchange', this._onFullScreenChanged);
        document.removeEventListener('MSFullscreenChange', this._onFullScreenChanged);
        document.removeEventListener('fullscreenerror', this._onFullscreenError);
        document.removeEventListener('mozfullscreenerror', this._onFullscreenError);
        document.removeEventListener('webkitfullscreenerror', this._onFullscreenError);
        document.removeEventListener('MSFullscreenError', this._onFullscreenError);
    }
    _loadPlayer() {
        if (this.player.current) {
            this.player.current.volume = this.state.currentVolume / 100;
            for (const mediaEvent of MediaEvents) {
                this.player.current.addEventListener(mediaEvent, this._triggerEvents);
            }
        }
        this.videoUrl = this.playerHelper.getVideoFileToPlay().url;
        this.player.current.load();
        this.isPlayerLoaded = true;
        if (this.props.playerData.options.controls) {
            this.closedCaptionHelper = new ClosedCaptionHelper(this.playerMetaData, this.playerHelper, this.localizationHelper);
            this.closedCaptionMenu = this.closedCaptionHelper.getClosedCaptionMenu();
            this.optionsMenu = this.playerHelper.getOptionMenu();
            const ccFiles = this.playerMetaData.ccFiles;
            if (ccFiles !== undefined && ccFiles.length > 0) {
                const autoCaptionsLang = this.props.playerData && this.props.playerData.options.autoCaptions;
                let autoCaptionsLocale = null;
                for (const ccFile of ccFiles) {
                    if (!autoCaptionsLocale && autoCaptionsLang && ccFile.locale.indexOf(autoCaptionsLang) > -1) {
                        autoCaptionsLocale = ccFile.locale;
                    }
                }
                this.selectedClosedCaptionsLocale = autoCaptionsLocale;
                if (!isNullOrWhiteSpace(this.selectedClosedCaptionsLocale)) {
                    this.setState({
                        closedCaptionLanguage: this.selectedClosedCaptionsLocale,
                        closedCaptionsURL: this.closedCaptionHelper.getClosedCaptionURLFromLocale(this.selectedClosedCaptionsLocale),
                        showClosedCaptions: true
                    });
                }
            }
        }
    }
    _validateAgeSubmitHandler() {
        if (this.ageGateContainer.current.getCalculatedAge()) {
            this.videoUrl = this.playerHelper.getVideoFileToPlay().url;
            this.setState({ isAgegateEnabled: false });
        }
        else {
            this.setState({ isAgegateEnabled: true });
            this._displayErrorMessage({ title: 'you are not allowed to watch video' });
        }
    }
    _onVideoControlsFocus() {
        this.setState({ doControlsHaveFocus: true });
    }
    _onVideoControlsBlur() {
        this._showControlBar(true);
        this.setState({ doControlsHaveFocus: false });
    }
    _onPlayerMenuItemFocus(notification) {
        if (notification.data && notification.data.indexOf(':') > 0) {
            const dataSplit = notification.data.split(':');
            const settingKey = dataSplit[0];
            if (settingKey === videoClosedCaptionsConstant.presetKey) {
                if (this.state.closedCaptionLanguage === 'off') {
                    this.setState({
                        showClosedCaptions: true
                    }, () => {
                        this.ClosedCaptions.current.showSampleCaptions();
                        this._setCCSettings(notification, false);
                    });
                }
                else {
                    this._setCCSettings(notification, false);
                }
            }
        }
        else {
            if (this.state.closedCaptionLanguage === 'off') {
                this.setState({
                    showClosedCaptions: false
                });
            }
        }
    }
    _onPlayerMenuItemBlur() {
        this._setCCSettings({
            category: MenuCategories.ClosedCaptionSettings,
            id: '',
            data: 'current'
        });
    }
    _onPlayerMenuItemClick(notification) {
        switch (notification.category) {
            case MenuCategories.ClosedCaption: {
                this._setCC(notification.id);
                break;
            }
            case MenuCategories.ClosedCaptionSettings: {
                this._setCCSettings(notification);
                break;
            }
            case MenuCategories.AudioTracks: {
                this._setAudioTracks(notification);
            }
        }
    }
    _setCC(ccLanguageId) {
        ccLanguageId = this.playerHelper.removeIdPrefix(ccLanguageId);
        let selectedOption = null;
        if (ccLanguageId && this.playerMetaData.ccFiles) {
            for (const ccFile of this.playerMetaData.ccFiles) {
                if ((ccFile.locale === ccLanguageId) && (!ccFile.ccType || ccFile.ccType === ClosedCaptionTypes.TTML)) {
                    selectedOption = ccFile;
                    break;
                }
            }
        }
        if (ccLanguageId === 'off') {
            this.setState({
                closedCaptionLanguage: 'off',
                closedCaptionsURL: '',
                showClosedCaptions: false
            });
        }
        else {
            this.setState({
                closedCaptionLanguage: selectedOption.locale,
                closedCaptionsURL: selectedOption.url,
                showClosedCaptions: true
            });
        }
    }
    _setCCSettings(notification, updatePreferences) {
        if (notification.data === 'reset') {
            this.setState({
                currentClosedCaptionsSettings: closedCaptionsSettingDefaults
            }, () => {
                if (this.ClosedCaptions.current !== null) {
                    this.ClosedCaptions.current.applySettings();
                    this.ClosedCaptions.current.resetCaptions();
                    this.ClosedCaptions.current.updateCaptions(this.state.playPosition.currentTime);
                }
            });
        }
        else if (notification.data === 'current') {
            this.setState({
                tempClosedCaptionsSettings: undefined
            });
            if (this.state.closedCaptionLanguage === 'off') {
                this.setState({
                    showClosedCaptions: false
                });
            }
        }
        else {
            const dataSplit = notification.data.split(':');
            if (!dataSplit) {
                return;
            }
            const settingKey = dataSplit[0];
            const optionKey = dataSplit[1];
            const currentSetting = this.closedCaptionHelper.getUpdatedClosedCaptionSetting(this.state.currentClosedCaptionsSettings, settingKey, optionKey);
            if (updatePreferences === undefined || updatePreferences) {
                this.setState({
                    tempClosedCaptionsSettings: undefined,
                    currentClosedCaptionsSettings: currentSetting
                }, () => {
                    if (this.ClosedCaptions.current) {
                        this.ClosedCaptions.current.applySettings();
                        this.ClosedCaptions.current.resetCaptions();
                        this.ClosedCaptions.current.updateCaptions(this.state.playPosition.currentTime);
                    }
                });
            }
            else {
                this.setState({
                    tempClosedCaptionsSettings: currentSetting
                });
            }
        }
    }
    _setAudioTracks(notification) {
        const data = JSON.parse(notification.data);
        if (data.lang === 'default') {
            this.setState({
                currentAudioTrack: 'default',
                currentAudioTrackURL: ''
            }, () => {
                this.player.current.volume = this.state.currentVolume / 100;
            });
        }
        else {
            this.setState({
                currentAudioTrack: data.lang,
                currentAudioTrackURL: data.url
            }, () => {
                this.audio.current.currentTime = this.player.current.currentTime;
                this.audio.current.volume = this.state.currentVolume / 100;
                this.player.current.volume = 0;
                if (!this.player.current.paused) {
                    this.audio.current.load();
                    for (const mediaEvent of MediaEvents) {
                        this.audio.current.addEventListener(mediaEvent, this._triggerAudioEvents);
                    }
                }
            });
        }
    }
    _triggerAudioEvents(event) {
        switch (event.type.toLowerCase()) {
            case 'error':
                this._onAudioError();
                break;
            case 'waiting':
                if (this.playerState === 'playing') {
                    this.isPlayerManuallyPaused = true;
                    this.pause();
                }
                break;
            case 'loadeddata':
                if (this.isPlayerManuallyPaused) {
                    this.isPlayerManuallyPaused = false;
                    this.play();
                }
                if (!this.player.current.paused) {
                    this.play();
                }
                break;
            default:
        }
    }
    _triggerEvents(event) {
        switch (event.type.toLowerCase()) {
            case 'canplay':
            case 'canplaythrough':
                break;
            case 'error':
                this._onVideoError();
                break;
            case 'play':
                break;
            case 'pause':
                this._updateState('paused');
                if (this.props.playerData.options.playPauseTrigger) {
                    this.setState({
                        mouseHovered: true
                    });
                }
                break;
            case 'seeking':
                if (this.playerState !== 'ended' && this.player.current.seeking) {
                    this.seekFrom = this.player.current.currentTime;
                    this._updateState('seeking');
                }
                break;
            case 'seeked':
                const currentPlayer = this.player.current;
                const currentTime = currentPlayer.currentTime;
                if (this.playerState !== 'ended' && this.player.current.seeking && this.seekFrom !== currentTime) {
                    this.seekFrom = null;
                }
                this._updateState(currentPlayer.paused ? 'paused' : 'playing');
                break;
            case 'waiting':
                this._updateState('buffering');
                break;
            case 'loadedmetadata':
                break;
            case 'loadeddata':
                this._onVideoLoadedData();
                if (!this.props.playerData.options.autoplay) {
                    this._showControlBar(false);
                }
                break;
            case 'timeupdate':
                this._onTimeUpdate();
                break;
            case 'ended':
                this._updateState('ended');
                this._stop();
                break;
            case 'playing':
                this._updateState('playing');
                break;
            case 'volumechange':
                break;
            default:
        }
    }
    _onAudioError() {
        this.pause();
        const errorMessage = { title: 'Error while playing audio Track. Switching back to default track' };
        this._displayErrorMessage(errorMessage);
        this._setAudioTracks({ category: 'audioTracks', data: '{ "lang": "default", "url": ""}', id: '' });
        setTimeout(() => {
            this.setState({
                showErrorMessage: false
            }, () => { this.play(); });
        }, 2000);
    }
    _onVideoError() {
        this._updateState('error');
        const error = this._getError();
        let errorMessage = '';
        if (error && error.errorCode) {
            switch (error.errorCode) {
                case VideoErrorCodes.MediaErrorAborted:
                    errorMessage = 'video playback was aborted';
                    break;
                case VideoErrorCodes.MediaErrorNetwork:
                    errorMessage = 'video failed to download';
                    break;
                case VideoErrorCodes.MediaErrorDecode:
                    errorMessage = 'video is not readable';
                    break;
                case VideoErrorCodes.MediaErrorSourceNotSupported:
                    errorMessage = 'video format is not supported';
                    break;
                default:
                    errorMessage = 'unknown error occurred';
            }
            this._stopMedia(errorMessage);
        }
        else {
            this._stopMedia();
        }
    }
    _stopMedia(msgToDisplay) {
        if (msgToDisplay) {
            this._displayErrorMessage({ title: msgToDisplay });
            this._updateState('stopped');
        }
    }
    _displayErrorMessage(errorMessage) {
        this.setState({ videoErrorMessage: { title: errorMessage.title, message: errorMessage.message } });
        this.setState({ showErrorMessage: true });
    }
    _getError() {
        let contentErrorCode;
        if (this.player.current.error) {
            switch (this.player.current.error.code) {
                case this.player.current.error.MEDIA_ERR_ABORTED:
                    contentErrorCode = VideoErrorCodes.MediaErrorAborted;
                    break;
                case this.player.current.error.MEDIA_ERR_NETWORK:
                    contentErrorCode = VideoErrorCodes.MediaErrorNetwork;
                    break;
                case this.player.current.error.MEDIA_ERR_DECODE:
                    contentErrorCode = VideoErrorCodes.MediaErrorDecode;
                    break;
                case this.player.current.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    contentErrorCode = VideoErrorCodes.MediaErrorSourceNotSupported;
                    break;
                default:
                    contentErrorCode = VideoErrorCodes.MediaErrorUnknown;
            }
            return { errorCode: contentErrorCode };
        }
        return null;
    }
    _handleControlsKeyDownEvent(e) {
        const keyBrdEvent = e;
        const keycode = keyBrdEvent.keyCode;
        this._showControlBar(true);
        switch (keycode) {
            case 36:
                e.stopPropagation();
                e.preventDefault();
                this.player.current.currentTime = 0;
                if (this.audio.current) {
                    this.audio.current.currentTime = 0;
                }
                break;
            case 35:
                e.stopPropagation();
                e.preventDefault();
                this.player.current.currentTime = this.state.playPosition.endTime;
                if (this.audio.current) {
                    this.audio.current.currentTime = this.state.playPosition.endTime;
                }
                break;
            case 37:
            case 39:
                e.stopPropagation();
                e.preventDefault();
                let jumpToTime = keycode === 37
                    ? this.state.playPosition.currentTime - PlayerConstants.defaultVideoSliderSteps
                    : this.state.playPosition.currentTime + PlayerConstants.defaultVideoSliderSteps;
                jumpToTime = Math.min(Math.max(this.state.playPosition.startTime, jumpToTime), this.state.playPosition.endTime);
                this.player.current.currentTime = jumpToTime;
                if (this.audio.current) {
                    this.audio.current.currentTime = jumpToTime;
                }
                break;
            case 38:
            case 40:
                e.stopPropagation();
                e.preventDefault();
                this.videoControl.current.showVolumeControl(true).call(this);
                const volume = keycode === 40
                    ? Math.max((this.state.currentVolume - PlayerConstants.defaultVolumeSliderSteps) / 100, 0)
                    : Math.min((this.state.currentVolume + PlayerConstants.defaultVolumeSliderSteps) / 100, 1);
                this.setState({ currentVolume: Math.round(volume * 100) });
                if (this.audio.current) {
                    this.audio.current.volume = volume;
                }
                else {
                    this.player.current.volume = volume;
                }
                if (volume === 0) {
                    this.setState({ isMuted: true });
                }
                else {
                    this.setState({ isMuted: false });
                }
                break;
            default:
        }
    }
    _onPlay() {
        this.setState({ playing: true });
    }
    _onPause() {
        this.setState({ playing: false });
    }
    _onVolumeChange(notification) {
        this.setState({ currentVolume: notification.firstThumbValue });
        if (this.audio.current) {
            this.audio.current.volume = notification.firstThumbValue / 100;
        }
        else {
            this.player.current.volume = notification.firstThumbValue / 100;
        }
        if (notification.firstThumbValue === 0) {
            this.setState({ isMuted: true });
        }
        else {
            if (this.state.isMuted && notification.firstThumbValue > 0) {
                this.setState({ isMuted: false });
            }
        }
    }
    _setMuted() {
        if (this.state.isMuted) {
            const newVolume = this.state.previousVolume === 0 ? PlayerConstants.defaultVolume * 100 : this.state.previousVolume;
            if (this.audio.current) {
                this.audio.current.volume = newVolume / 100;
            }
            else {
                this.player.current.volume = newVolume / 100;
            }
            this.setState({ isMuted: false, currentVolume: newVolume });
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('unMuteAriaLabel'));
            onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.unMuteAriaLabel).call(this);
        }
        else {
            this.setState({ isMuted: true, previousVolume: this.player.current.volume * 100, currentVolume: 0 });
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('muteAriaLabel'));
            onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.muteAriaLabel).call(this);
        }
    }
    _onPlayerKeyDown(e) {
        const keyBrdEvent = e;
        const keycode = keyBrdEvent.keyCode;
        switch (keycode) {
            case 9:
                this._showControlsBasedOnState();
        }
    }
    _onMouseEvent(event) {
        if (this.props.playerData.options.controls) {
            this._showControlBar();
        }
        if (!this.state.isTriggerEnabled && this.state.playing) {
            this.setState({ mouseHovered: event.type === 'mouseenter' });
        }
    }
    _showControlBar(autoHide = true) {
        if (!this.state.isTriggerEnabled && !this.state.isAgegateEnabled) {
            if (!this.state.isControlPanelVisible) {
                this.setState({ isControlPanelVisible: true });
            }
            if (!!this.controlPanelTimer) {
                window && window.clearTimeout(this.controlPanelTimer);
                this.controlPanelTimer = 0;
            }
            if (autoHide) {
                this.controlPanelTimer = window && window.setTimeout(() => {
                    this._hideControlBar();
                }, PlayerConstants.defaultControlPanelTimeout);
            }
        }
    }
    _hideControlBar() {
        window && window.clearTimeout(this.controlPanelTimer);
        this.controlPanelTimer = 0;
        this.setState({ isControlPanelVisible: false });
    }
    _onFullScreenChanged() {
        this.state.isInFullScreen ? this._onFullscreenExit() : this._onFullscreenEnter();
    }
    _onFullscreenEnter() {
        this.setState({
            isInFullScreen: true
        });
    }
    _onFullscreenExit() {
        this.setState({
            isInFullScreen: false
        });
    }
    _toggleFullScreen() {
        this.state.isInFullScreen ? this._exitFullScreen() : this._enterFullScreen();
    }
    _onFullscreenError() {
        this.setState({
            isInFullScreen: false
        });
    }
    _enterFullScreen() {
        if (!Player._isNativeFullscreenEnabled()) {
            return;
        }
        const fullscreenElement = this.playerContainer.current;
        const elementInFullScreen = Player._getElementInFullScreen();
        if (!!fullscreenElement && !elementInFullScreen) {
            const enterFullScreen = fullscreenElement.requestFullscreen ||
                fullscreenElement.msRequestFullscreen ||
                fullscreenElement.mozRequestFullScreen ||
                fullscreenElement.webkitRequestFullscreen ||
                fullscreenElement.webkitEnterFullScreen;
            enterFullScreen.call(fullscreenElement);
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('fullScreenLabel'));
            onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.fullScreenAriaLabel).call(this);
        }
    }
    _exitFullScreen() {
        if (!Player._isNativeFullscreenEnabled()) {
            return;
        }
        const fullscreenElement = this.playerContainer.current;
        const elementInFullScreen = Player._getElementInFullScreen();
        if (!!fullscreenElement && fullscreenElement === elementInFullScreen) {
            const doc = document;
            const cancelFullScreen = doc.cancelFullScreen ||
                doc.msExitFullscreen ||
                doc.mozCancelFullScreen ||
                doc.webkitCancelFullScreen;
            cancelFullScreen.call(doc);
            this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('exitFullScreenLabel'));
            onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.exitFullScreenAriaLabel).call(this);
        }
    }
    _onVideoLoadedData() {
        this._updateState('ready');
        if (this.props.playerData.options.controls) {
            const position = this._getPlayPosition();
            this.setState({ playPosition: position });
        }
    }
    _onTimeUpdate() {
        if (this.props.playerData.options.controls) {
            const position = this._getPlayPosition();
            position.endTime = this.state.playPosition.endTime;
            this.setState({ playPosition: position });
            if (this.state.playing) {
                if (this.playerState === 'buffering') {
                    this._updateState('playing');
                }
            }
        }
    }
    _getBufferedDuration() {
        let buffered = 0;
        if (this.player.current.buffered && this.player.current.buffered.length) {
            buffered = this.player.current.buffered.end(this.player.current.buffered.length - 1);
        }
        return buffered;
    }
    _getPlayPosition() {
        const bufferedDuration = this._getBufferedDuration();
        return {
            currentTime: this.player.current.currentTime,
            startTime: 0,
            endTime: this.player.current.duration,
            bufferedDuration: bufferedDuration
        };
    }
    _onProgressChange(notification) {
        let time = notification.firstThumbValue;
        const position = this._getPlayPosition();
        time = Math.max(position.startTime, Math.min(time, position.endTime));
        if (Math.abs(time - position.currentTime) >= PlayerConstants.defaultPositionUpdateThreshold) {
            this.player.current.currentTime = time;
            if (this.audio.current) {
                this.audio.current.currentTime = time;
            }
        }
    }
    _onTriggerClicked() {
        const currentPlayer = this.player.current;
        if (!this.isPlayerLoaded) {
            this._loadPlayer();
            this.player.current.autoplay = true;
        }
        else {
            if (currentPlayer.paused) {
                this.play();
                this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('playingAriaLabel'));
                onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.playAriaLabel).call(this);
            }
            else {
                this.pause();
                this._updateScreenReaderElement(this.localizationHelper.getLocalizedValue('pausedAriaLabel'));
                onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.pauseAriaLabel).call(this);
            }
        }
        if (this.state.isTriggerEnabled) {
            this.setState({ isTriggerEnabled: false }, () => { this.videoControl.current.setFocusOnPlay(); });
            onTelemetryClick(this.props.telemetryContent, this.payLoad, LocalizationConstants.pauseAriaLabel).call(this);
            if (this.props.playerData.options.playFullScreen) {
                this._enterFullScreen();
            }
        }
    }
    _stop() {
        this._seek(0);
        if (this.props.playerData.options.controls) {
            this.pause();
            const playPosition = this._getPlayPosition();
            playPosition.endTime = this.state.playPosition.endTime;
            this.setState({ playPosition: playPosition });
            if (this.audio.current) {
                this.audio.current.pause();
            }
        }
    }
    _seek(time) {
        const position = this._getPlayPosition();
        time = Math.max(position.startTime, Math.min(time, position.endTime));
        if (Math.abs(time - position.currentTime) >= PlayerConstants.defaultPositionUpdateThreshold) {
            this.seekFrom = position.currentTime;
            this.player.current.currentTime = time;
            if (this.audio.current) {
                this.audio.current.currentTime = time;
            }
        }
    }
    _getMaskLevelStyle() {
        let result;
        const maskLevel = this.props.playerData.options.maskLevel || PlayerConstants.defaultMaskLevel;
        result = format('rgba(0,0,0,{0})', Number(maskLevel) / 100);
        return result;
    }
    _updateState(newState) {
        if (!newState || newState === this.playerState) {
            return;
        }
        this.playerState = newState;
        this._showControlsBasedOnState();
        this._showSpinnerBasedOnState();
    }
    _showSpinnerBasedOnState() {
        switch (this.playerState) {
            case 'ready':
            case 'playing':
            case 'paused':
            case 'ended':
            case 'stopped':
            case 'error':
                this._hideSpinner();
                break;
            default:
                this._showSpinner();
        }
    }
    _showControlsBasedOnState() {
        switch (this.playerState) {
            case 'error':
            case 'loading':
            case 'init':
                this._hideControlBar();
                break;
            case 'ended':
                this._showControlBar(false);
                break;
            case 'ready':
            case 'paused':
            case 'stopped':
                this._showControlBar(false);
                break;
            default:
                this._showControlBar(true);
        }
    }
    _hideSpinner() {
        this.setState({ showSpinner: false });
    }
    _showSpinner() {
        this.setState({ showSpinner: true });
    }
    _onTriggerFocus() {
        this.setState({ mouseHovered: true });
    }
    _onTriggerBlur() {
        if (!this.state.isTriggerEnabled && this.state.playing) {
            this.setState({ mouseHovered: false });
        }
    }
    _updateScreenReaderElement(text) {
        this.setState({
            screenReaderText: text
        });
    }
    _onContextMenuClicked(e) {
        e.preventDefault();
    }
    _isMobile() {
        if (MsDyn365.msdyn365Commerce.isBrowser) {
            const userAgent = window.navigator.userAgent;
            const isIphone = !!userAgent.match(/iPhone/i);
            const isSilk = !!userAgent.match(/Silk/i);
            const isWindowsPhone = !!userAgent.match(/Windows Phone/i);
            const isAndroid = !isWindowsPhone && (isSilk ||
                !!userAgent.match(/Android/i));
            return isIphone || isWindowsPhone || isAndroid;
        }
        return false;
    }
}
Player.defaultProps = {
    playerData: {
        options: {
            autoplay: true,
            ageGate: false,
            mute: true,
            loop: false,
            playPauseTrigger: false,
            controls: true,
            hidePosterFrame: false,
            lazyLoad: true,
        },
        metaData: {
            playerName: 'videoPlayer',
            videoId: '',
            title: '',
            description: '',
            duration: 0,
            posterframeUrl: '',
            shareUrl: '',
            videoFiles: [],
            externalPlayerUrl: '',
            externalSourceId: '',
            videoBinaryReferences: []
        }
    },
    playerResources: {
        playAriaLabel: LocalizationConstants.playAriaLabel,
        pauseAriaLabel: LocalizationConstants.pauseAriaLabel,
        closeAriaLabel: LocalizationConstants.closeAriaLabel,
        muteAriaLabel: LocalizationConstants.muteAriaLabel,
        unMuteAriaLabel: LocalizationConstants.unMuteAriaLabel,
        fullScreenAriaLabel: LocalizationConstants.fullScreenAriaLabel,
        exitFullScreenAriaLabel: LocalizationConstants.exitFullScreenAriaLabel,
        pausedAriaLabel: LocalizationConstants.pausedAriaLabel,
        playingAriaLabel: LocalizationConstants.playingAriaLabel,
        seekBarLabel: LocalizationConstants.seekBarLabel,
        videoTimeDurationLabel: LocalizationConstants.videoTimeDurationLabel,
        closedCaptionLabel: LocalizationConstants.closedCaptionLabel
    },
};
//# sourceMappingURL=Player.js.map
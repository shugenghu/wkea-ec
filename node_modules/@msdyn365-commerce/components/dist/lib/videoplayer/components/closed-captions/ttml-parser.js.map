{"version":3,"file":"ttml-parser.js","sourceRoot":"./src/","sources":["videoplayer/components/closed-captions/ttml-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {nodeListToArray} from '../utilities/htmlExtensions';\nimport {format, trim} from '../utilities/stringExtensions';\nimport {IDictionaryStringString, IGrid} from '../utilities/utilities';\nimport {ITtmlContext, TtmlContext} from './ttml-context';\nimport {ITtmlSettings, TtmlSettings, xmlNS} from './ttml-settings';\nimport {TtmlTimeParser} from './ttml-time-parser';\n\n// Timed Text Markup Language (TTML).\n// See http://www.w3.org/TR/ttml1/ for more details.\n\n/*\n* @interface ITtmlEvent\n* @classdesc - The ITtmlEvent interface contract.\n* @export\n*/\nexport interface ITtmlEvent {\n    time: number;\n    element?: Element;\n}\n\n/*\n* @interface ITtmlTimingBounds\n* @classdesc - The ITtmlTimingBounds interface contract.\n* @export\n*/\ninterface ITtmlTimingBounds {\n    start: number;\n    end: number;\n}\n\n/**\n *\n * The TtmlParser class.\n *\n */\n// tslint:disable-next-line: no-unnecessary-class\nexport class TtmlParser {\n    /*\n    * @name - mediaStart\n    * @description - Used as the start time for applyTiming when applying to the entire document.\n    * @static\n    * @private\n    * @type {number}\n    */\n    private static mediaStart: number  = -1;\n\n    /*\n    * @name - mediaEnd\n    * @description - Used as the end time for applyTiming when applying to the entire document.\n    *                Picking a number that should always be greater than any real media end time.\n    * @static\n    * @private\n    * @type {number}\n    */\n    private static mediaEnd: number = 99999999;\n\n    /*\n    * @name - getLocalTagName\n    * @description - Gets the local tagName of a Node.\n    * @static\n    * @public\n    * @param {Node} node - The node to get the tagName of.\n    * @returns {string} - The tagName.\n    */\n   public static getLocalTagName(node: Node): string {\n        // tslint:disable-next-line: no-any\n        return (<Element>node).localName || (<any>node).baseName;\n    }\n\n    /*\n    * @name - getAttributeNS\n    * @description - Gets the value of a namespaced attribute. First tries element.getAttributeNS() but falls back\n    *                to scanning each attribute if that fails.\n    *                If you know which cases go into the fallback code please document it here.\n    * @static\n    * @public\n    * @param {Element} element - The element to get the attribute of.\n    * @param {string} name - The attribute name.\n    * @param {string} namespace - The attribute namespace.\n    * @returns {string} - The attribute value. or an empty string if a matching attribute is not found.\n    */\n   public static getAttributeNS(element: Element, name: string, namespace: string): string {\n        let result = element.getAttributeNS(namespace, name);\n\n        if (!result) {\n            // Go through all the attributes looking for a match.\n            for (const attribute of nodeListToArray(element.attributes)) {\n                // tslint:disable-next-line: no-any\n                if (((<any>attribute).localName === name) && (attribute.lookupNamespaceURI((<any>attribute).prefix) === namespace)) {\n                    // tslint:disable-next-line: no-any\n                    result = (<any>attribute).value;\n                    break;\n                }\n            }\n        }\n\n        return result!;\n    }\n\n    /*\n    * @name - parse\n    * @description - Parses a ttml document and builds a ttmlContext instance from it.\n    * @static\n    * @public\n    * @param {XMLDocument} ttmlDocument - The ttml document to parse.\n    * @param {ITtmlSettings} settingsOverrides - The ttml settings overrides to use.\n    * @returns {ITtmlContext} - The resulting ttmlContext instance that can be used to get cues by time.\n    */\n    public static parse(ttmlDocument: XMLDocument, settingsOverrides: ITtmlSettings): ITtmlContext {\n        ttmlDocument = (typeof ttmlDocument === 'string') ? TtmlParser._parseXml(ttmlDocument) : ttmlDocument;\n\n        const ttmlContext = new TtmlContext();\n\n        // Start initializing the context.\n        ttmlContext.settings = new TtmlSettings(settingsOverrides);\n        ttmlContext.root = TtmlParser._verifyRoot(ttmlDocument, ttmlContext);\n        ttmlContext.body = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'body', ttmlContext.settings.ttmlNamespace);\n        ttmlContext.events = [];\n        ttmlContext.styleSetCache = [];\n\n        if (ttmlContext.body) {\n            // Parse the root <tt> attributes.\n            TtmlParser._parseTtAttrs(ttmlContext);\n\n            // Set up our regions.\n            const head = TtmlParser._ensureRegions(ttmlContext);\n\n            const timeBase = TtmlParser.getAttributeNS(\n                ttmlContext.root,\n                'timeBase',\n                ttmlContext.settings.ttmlParameterNamespace) || 'media';\n\n            if (ttmlContext.settings.supportedTimeBase.indexOf(timeBase) !== -1) {\n                // Process textnodes into anonymous spans.\n                TtmlParser._processAnonymousSpans(ttmlContext, ttmlContext.body);\n\n                const timeParser = new TtmlTimeParser(ttmlContext.settings.mediaFrameRate, ttmlContext.settings.mediaTickRate);\n\n                // Apply the intervals over the tree.\n                TtmlParser._applyTiming(\n                    ttmlContext,\n                    ttmlContext.root,\n                    { start: TtmlParser.mediaStart, end: TtmlParser.mediaEnd },\n                    true,\n                    timeParser);\n\n                // Apply the style inheritance over the tree.\n                TtmlParser._applyStyling(ttmlContext, head);\n            }\n\n            // Add an dummy end event for the captions to appear until end of video.\n            // Not sure why we need to do this, please add to this comment if you know.\n            ttmlContext.events.push({ time: TtmlParser.mediaEnd, element: undefined });\n\n            // Sort events into temporal order.\n            ttmlContext.events.sort((event1: ITtmlEvent, event2: ITtmlEvent) => {\n                return event1.time - event2.time;\n            });\n        }\n\n        return ttmlContext;\n    }\n\n    /*\n    * @name - applyInlineStyles\n    * @description - Applies the elements inline styles into the styleSet.\n    * @static\n    * @public\n    * @param {TtmlSettings} settings - The TtmlSettings for this document.\n    * @param {IDictionaryStringString} styleSet - The styleSet to build upon.\n    * @param {Element} element - The element to apply the styles of.\n    * @returns {void}\n    */\n   public static applyInlineStyles(settings: TtmlSettings, styleSet: IDictionaryStringString, element: Element): void {\n        for (const attribute of nodeListToArray(element.attributes)) {\n            if (attribute.namespaceURI === settings.ttmlStyleNamespace) {\n                // trim() because we see lots of ttml attribute values with trailing space...\n                styleSet[TtmlParser.getLocalTagName(attribute)] = trim(attribute.nodeValue!);\n            }\n        }\n    }\n\n    /*\n    * @name - parseXml\n    * @description - Parses an xml document in string format to an XMLDocument.\n    * @static\n    * @private\n    * @param {string} xmlString - The xml string to parse.\n    * @returns {XMLDocument} - The resulting XMLDocument, or null if the xml string failed to parse.\n    */\n    private static _parseXml(xmlString: string): XMLDocument {\n        let xml: XMLDocument;\n\n        // tslint:disable-next-line: no-any\n        if ((<any>window).DOMParser) {\n            // tslint:disable-next-line: no-any\n            const domParser = new (<any>window).DOMParser();\n            xml = domParser.parseFromString(xmlString, 'application/xml');\n        } else {\n            // tslint:disable-next-line: no-any\n            const domParser = new (<any>window).ActiveXObject('Microsoft.XMLDOM');\n            domParser.async = false;\n            domParser.loadXML(xmlString);\n            xml = <XMLDocument>domParser;\n        }\n        return xml;\n    }\n\n    /*\n    * @name - verifyRoot\n    * @description - Verifies that root <tag> of the specified document is the expected ttml <tt> tagName and\n    *                updates the settings namespaces from it if they are non standard.\n    * @static\n    * @private\n    * @param {XMLDocument} ttmlDocument - The ttml document to verify.\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {Element} - The valid root Element, or or null if the root Element was not valid.\n    */\n    private static _verifyRoot(ttmlDocument: XMLDocument, ttmlContext: TtmlContext): Element {\n        let root: Element;\n        const candidate = ttmlDocument.documentElement;\n\n        if (TtmlParser.getLocalTagName(candidate) === 'tt') {\n            // tslint:disable-next-line: no-http-string\n            if (candidate.namespaceURI !== 'http://www.w3.org/ns/ttml') {\n                ttmlContext.settings.ttmlNamespace = candidate.namespaceURI!;\n                ttmlContext.settings.ttmlStyleNamespace = `${ttmlContext.settings.ttmlNamespace}#styling`;\n                ttmlContext.settings.ttmlParameterNamespace = `${ttmlContext.settings.ttmlNamespace}#parameter`;\n                ttmlContext.settings.ttmlMetaNamespace = `${ttmlContext.settings.ttmlNamespace}#metadata`;\n            }\n\n            root = candidate;\n        }\n\n        return root!;\n    }\n\n    /*\n    * @name - parseTtAttrs\n    * @description - Parses the <tt> tag attributes and initializes ttmlContext properties from them.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {void}\n    */\n    private static _parseTtAttrs(ttmlContext: TtmlContext): void {\n        const cellRes = TtmlParser.getAttributeNS(ttmlContext.root, 'cellResolution', ttmlContext.settings.ttmlParameterNamespace);\n        const extent = TtmlParser.getAttributeNS(ttmlContext.root, 'extent', ttmlContext.settings.ttmlStyleNamespace);\n        let cellGrid: IGrid | null = null;\n\n        if (cellRes) {\n            const parts = trim(cellRes).split(/\\s+/);\n\n            if (parts.length === 2) {\n                const columns = Math.round(parseFloat(parts[0]));\n                const rows = Math.round(parseFloat(parts[1]));\n\n                if ((rows > 0) && (columns > 0)) {\n                    cellGrid = { rows: rows, columns: columns };\n                }\n            }\n        }\n\n        if (cellGrid) {\n            ttmlContext.settings.cellResolution = cellGrid;\n        }\n\n        if (extent) {\n            if (extent !== 'auto') {\n                // Get the individual components.\n                const coords = extent.split(/\\s+/);\n\n                if ((coords.length === 2) &&\n                    (coords[0].substr(coords[0].length - 2) === 'px') &&\n                    (coords[1].substr(coords[1].length - 2) === 'px')) {\n                    const width = parseFloat(coords[0].substr(0, coords[0].length - 2));\n                    const height = parseFloat(coords[1].substr(0, coords[1].length - 2));\n\n                    // Round to integer.\n                    ttmlContext.settings.rootContainerRegionDimensions = { width: Math.round(width), height: Math.round(height) };\n                }\n            }\n        }\n\n    }\n\n    /*\n    * @name - ensureRegions\n    * @description - Ensures we have the elements/regions we require by either finding them or creating them if they are not present.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {Element} - The <head> element.\n    */\n    private static _ensureRegions(ttmlContext: TtmlContext): Element {\n        // Create our rootContainerRegion\n        ttmlContext.rootContainerRegion = <Element>ttmlContext.root.ownerDocument!.createElementNS(\n            ttmlContext.settings.ttmlNamespace, 'rootcontainerregion');\n\n        ttmlContext.root.appendChild(ttmlContext.rootContainerRegion);\n\n        const extents = ttmlContext.settings.rootContainerRegionDimensions ? format('{0}px {1}px',\n                                                                                    ttmlContext.settings.rootContainerRegionDimensions.width, ttmlContext.settings.rootContainerRegionDimensions.height) : 'auto';\n\n        ttmlContext.rootContainerRegion.setAttributeNS(ttmlContext.settings.ttmlStyleNamespace, 'extent', extents);\n\n        let head = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'head', ttmlContext.settings.ttmlNamespace);\n\n        // Ensure we have a <head>\n        if (!head) {\n            // No <head> so we need to create that now.\n            head = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'head');\n            ttmlContext.root.appendChild(head);\n        }\n\n        // Ensure we have a <layout>\n        ttmlContext.layout = TtmlParser._getFirstElementByTagNameNS(head, 'layout', ttmlContext.settings.ttmlNamespace);\n\n        if (!ttmlContext.layout) {\n            // No <layout> so we need to create that now.\n            ttmlContext.layout = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'layout');\n            ttmlContext.root.appendChild(ttmlContext.layout);\n        }\n\n        // Create an anonymous region if we have no regions.\n        const regions = ttmlContext.layout.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'region');\n\n        if (!regions.length) {\n            const anonymousRegion = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'region');\n\n            anonymousRegion.setAttributeNS(xmlNS, 'id', 'anonymous');\n            anonymousRegion.setAttribute('data-isanonymous', '1');\n            ttmlContext.layout.appendChild(anonymousRegion);\n\n            ttmlContext.body.setAttributeNS(ttmlContext.settings.ttmlNamespace, 'region', 'anonymous');\n        }\n\n        return head;\n    }\n\n    /*\n    * @name - processAnonymousSpans\n    * @description - Recurses through all the <p> elements in the document and groups all the contiguous TEXT_NODES together into <span>'s\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to process the TEXT_NODES of.\n    * @returns {void}\n    */\n    private static _processAnonymousSpans(ttmlContext: TtmlContext, element: Element): void {\n        // If this element is <p> then group all contiguous textnodes together in <span>\n        if (TtmlParser._isTagNS(element, 'p', ttmlContext.settings.ttmlNamespace)) {\n            const textNodeGroups: Node[][] = [];\n            let prevNodeType: number = 0;\n\n            for (const child of nodeListToArray(element.childNodes)) {\n                if (child.nodeType === Node.TEXT_NODE) {\n                    if (prevNodeType !== Node.TEXT_NODE) {\n                        textNodeGroups.push([]);\n                    }\n\n                    textNodeGroups[textNodeGroups.length - 1].push(child);\n                }\n\n                prevNodeType = child.nodeType;\n            }\n\n            for (const group of textNodeGroups) {\n                const anonSpan = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'span');\n\n                anonSpan.appendChild(group[0].parentNode!.replaceChild(anonSpan, group[0]));\n\n                for (let index = 1; index < group.length; index++) {\n                    anonSpan.appendChild(group[index]);\n                }\n            }\n        }\n\n        // Then recurse through the contents doing the same thing for those.\n        for (const child of nodeListToArray<Element>(element.childNodes)) {\n            this._processAnonymousSpans(ttmlContext, child);\n        }\n    }\n\n    /*\n    * @name - applyTiming\n    * @description - Recurses through the document element tree to determine the absolute start and end times of all the elements\n    *                using the TTML subset of the SMIL timing model. The reference times passed in 'bound' are absolute times.\n    *                The result of calling this is to set the local start time and end time to absolute times between these two\n    *                reference times, based on the begin, end and dur attributes and to recursively set all of the children.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to apply the timing to.\n    * @param {ITtmlTimingBounds} bound - The bounds for the timing.\n    * @param {boolean} isParallelContext - Indicates whether or not this element is in a parallel timing context.\n    * @param {TtmlTimeParser} timeParser - The TtmlTimeParser to use to parse this elements time attributes.\n    * @returns {void}\n    */\n    private static _applyTiming(\n        ttmlContext: TtmlContext,\n        element: Element,\n        bound: ITtmlTimingBounds,\n        isParallelContext: boolean,\n        timeParser: TtmlTimeParser): void {\n        const beginAttribute = TtmlParser.getAttributeNS(element, 'begin', ttmlContext.settings.ttmlNamespace);\n        let startTime = beginAttribute ? timeParser.parse(beginAttribute) : bound.start;\n        let endTime = 0;\n\n        // Compute the simple duration of the interval.\n        let duration = 0;\n        let end = 0;\n        const durationAttribute = TtmlParser.getAttributeNS(element, 'dur', ttmlContext.settings.ttmlNamespace);\n        const endAttribute = TtmlParser.getAttributeNS(element, 'end', ttmlContext.settings.ttmlNamespace);\n\n        if ((!durationAttribute) && (!endAttribute)) {\n            // No direct timing attested, so use default based on context.\n            // Parallel children have indefinite default duration, truncated by bounds.\n            if (isParallelContext) {\n                // Sequential children have zero default duration.\n                if (startTime <= bound.end) {\n                    endTime = bound.end;\n                } else {\n                    endTime = 0;\n                }\n            }\n        } else if (durationAttribute && endAttribute) {\n            // Both duration and end attested, the minimum interval applies.\n            duration = timeParser.parse(durationAttribute);\n            end = timeParser.parse(endAttribute);\n            const minEnd = Math.min(startTime + duration, bound.start + end);\n            endTime = Math.min(minEnd, bound.end);\n        } else if (endAttribute) {\n            // Only end attested.\n            end = timeParser.parse(endAttribute);\n            endTime = Math.min(bound.start + end, bound.end);\n        } else {\n            // Only dur attested.\n            duration = timeParser.parse(durationAttribute);\n            endTime = Math.min(startTime + duration, bound.end);\n        }\n\n        if (endTime < startTime) {\n            endTime = startTime;\n        }\n\n        startTime = Math.floor(startTime);\n        endTime = Math.floor(endTime);\n\n        element.setAttribute('data-time-start', startTime.toString());\n        element.setAttribute('data-time-end', endTime.toString());\n\n        if ((startTime >= 0) && (ttmlContext.events.filter((event) => { return event.time === startTime; }).length <= 0)) {\n            ttmlContext.events.push({ time: startTime, element: element });\n        }\n\n        let start = startTime;\n\n        for (const child of nodeListToArray<Element>(element.childNodes)) {\n            if (child.nodeType === Node.ELEMENT_NODE) {\n                // Parallel is the default so null is OK here.\n                if (TtmlParser.getAttributeNS(element, 'timeContainer', ttmlContext.settings.ttmlNamespace) !== 'seq') {\n                    this._applyTiming(ttmlContext, child, { start: startTime, end: endTime }, true, timeParser);\n                } else {\n                    this._applyTiming(ttmlContext, child, { start: start, end: endTime }, false, timeParser);\n                    start = parseInt(child.getAttribute('data-time-end')!, 10);\n                }\n            }\n        }\n    }\n\n    /*\n    * @name - applyStyling\n    * @description - Recurses through all the elements in <head> applying the ttml sytling to them based on the <style>'s.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} head - The element to process the TEXT_NODES of.\n    * @returns {void}\n    */\n    private static _applyStyling(ttmlContext: TtmlContext, head: Element): void {\n        // First find all the <style>'s\n        const styling = TtmlParser._getFirstElementByTagNameNS(head, 'styling', ttmlContext.settings.ttmlNamespace);\n        const styles = styling ? nodeListToArray(styling.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'style')) : [];\n\n        // Apply the styles to every element in the body\n        for (const element of nodeListToArray(ttmlContext.root.querySelectorAll('*'))) {\n            this._applyStyle(ttmlContext, <Element>element, <Element[]>styles);\n        }\n    }\n\n    /*\n    * @name - applyStyle\n    * @description - Applies the ttml styling to the specified element.\n    *                Apply styles in the correct order to element by building a styleSet, adding it\n    *                to the stlyeSetCache, and the adding reference to the cached styleSet to the element.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to apply the ttml styling to.\n    * @param {Element[]} styles - The set of styles to apply.\n    * @returns {void}\n    */\n    private static _applyStyle(ttmlContext: TtmlContext, element: Element, styles: Element[]): void {\n        const styleSet: IDictionaryStringString = {};\n\n        // Find all the applicable styles and set them as properties on styleSet.\n        this._applyStylesheet(ttmlContext.settings, styleSet, element, styles);\n        TtmlParser.applyInlineStyles(ttmlContext.settings, styleSet, element);\n\n        let empty = true;\n\n        // tslint:disable-next-line: no-for-in\n        for (const style in styleSet) {\n            // Just need to see if there's at least one.\n            if (styleSet.hasOwnProperty(style)) {\n                empty = false;\n                break;\n            }\n        }\n\n        if (!empty) {\n            // Record the applied set to the element.\n            element.setAttribute('data-styleSet', ttmlContext.styleSetCache.length.toString());\n            ttmlContext.styleSetCache.push(styleSet);\n        }\n    }\n\n    /*\n    * @name - applyStylesheet\n    * @description - For each style id on the element, find the corresponding style element and then\n    *                apply the stylesheet into styleset; this recurses over the tree of referenced styles.\n    * @static\n    * @private\n    * @param {TtmlSettings} settings - The TtmlSettings for this document.\n    * @param {IDictionaryStringString} styleSet - The styleSet to build upon.\n    * @param {Element} element - The element to apply the styles of.\n    * @param {Element[]} styles - The set of styles to apply.\n    * @returns {void}\n    */\n    private static _applyStylesheet(settings: TtmlSettings, styleSet: IDictionaryStringString, element: Element, styles: Element[]): void {\n        // Find all the style ID references.\n        const styleAttribute = TtmlParser.getAttributeNS(element, 'style', settings.ttmlNamespace);\n        const ids = styleAttribute ? styleAttribute.split(/\\s+/) : [];\n\n        for (const styleId of ids) {\n            for (const style of styles) {\n                // Filter on those whose id is the one we want.\n                if (TtmlParser.getAttributeNS(style, 'id', xmlNS) === styleId) {\n                    // Recurse into its style references.\n                    this._applyStylesheet(settings, styleSet, style, styles);\n\n                    // Do inline styles.\n                    TtmlParser.applyInlineStyles(settings, styleSet, style);\n                }\n            }\n        }\n\n        // If the element is a region do nested styles. NOTE regions can only be referenced from elements in the body.\n        if (TtmlParser._isTagNS(element, 'region', settings.ttmlNamespace)) {\n            // Find all the style elements in the TTML namespace.\n            for (const style of nodeListToArray(element.getElementsByTagNameNS(settings.ttmlNamespace, 'style'))) {\n                TtmlParser.applyInlineStyles(settings, styleSet, <Element>style);\n            }\n        }\n    }\n\n    /*\n    * @name - isTagNS\n    * @description - Determines whether or not the namespace and local tagName of an element matches\n    *                the specified namespace and tag name.\n    * @static\n    * @private\n    * @param {Element} element - The node to compare against.\n    * @param {string} tagName - The tag name.\n    * @param {string} namespace - The attribute namespace.\n    * @returns {boolean} - True if the elements ns/tagName match, otherwise false.\n    */\n    private static _isTagNS(element: Element, tagName: string, namespace: string): boolean {\n        return ((element.namespaceURI === namespace) && this.getLocalTagName(element) === tagName);\n    }\n\n    /*\n    * @name - getFirstElementByTagNameNS\n    * @description - Gets the first matching element that matches the specified tagName and namespace.\n    * @static\n    * @private\n    * @param {Element} context - The context to search within.\n    * @param {string} tagName - The tagName to match.\n    * @param {string} namespace - The namespace to match.\n    * @returns {Element} - The first matching element found, or null if there are no matches.\n    */\n    private static _getFirstElementByTagNameNS(context: Element, tagName: string, namespace: string): Element {\n        let result: Element;\n        if (context) {\n            const matches = context.getElementsByTagNameNS(namespace, tagName);\n\n            if (matches && matches.length) {\n                result = matches[0];\n            }\n        }\n\n        return result!;\n    }\n}"]}
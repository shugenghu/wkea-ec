import * as React from 'react';
import { css, removeInnerHtml, selectElements, selectFirstElement } from '../utilities/htmlExtensions';
import { PlayerUtility } from '../utilities/player-utility';
import { format } from '../utilities/stringExtensions';
import { getDimensions } from '../utilities/utilities';
import { TtmlParser } from './ttml-parser';
import { closedCaptionsSettingsMap, closedCaptionsSettingsOptions } from './video-closed-captions-settings';
export default class ClosedCaptions extends React.Component {
    constructor(props) {
        super(props);
        this.userPreferences = {
            text: {},
            window: {}
        };
        this.closedCaptionDiv = React.createRef();
        this.lastPlayPosition = 0;
        this.ttmlContext = null;
        this.resetCaptions();
        this.clicked = this.clicked.bind(this);
    }
    render() {
        const { className } = this.props;
        const closedCaptionDivStyle = {
            bottom: this.props.isVideoControlVisible ? '2.5em' : '0',
            transition: 'bottom 0.5s ease-in 0s'
        };
        return (React.createElement("div", { role: 'none', className: className, ref: this.closedCaptionDiv, "aria-hidden": !this.props.showClosedCaptions, style: closedCaptionDivStyle, onClick: this.clicked }));
    }
    clicked() {
        this.props.onClosedCaptionClick();
    }
    componentDidMount() {
        if (this.props.ccURL) {
            this._setCcLanguage(this.props.ccURL);
        }
        window && window.addEventListener('resize', () => {
            if (this.props.showClosedCaptions) {
                this.updateCaptions(this.props.currentTime);
            }
        });
    }
    shouldComponentUpdate(nextProps) {
        let shouldRender = false;
        if (nextProps.showClosedCaptions || (this.props.showClosedCaptions !== nextProps.showClosedCaptions)) {
            shouldRender = true;
        }
        return shouldRender;
    }
    componentWillUnmount() {
        window && window.removeEventListener('resize', () => {
            if (this.props.showClosedCaptions) {
                this.updateCaptions(this.props.currentTime);
            }
        });
    }
    componentDidUpdate(prevProps) {
        if (this.props.showClosedCaptions) {
            if (prevProps.ccLanguage !== this.props.ccLanguage) {
                if (this.props.ccURL) {
                    this._setCcLanguage(this.props.ccURL);
                }
            }
            this.applySettings();
            this.resetCaptions();
            this.updateCaptions(this.props.currentTime);
            if (prevProps.isVideoControlVisible !== this.props.isVideoControlVisible) {
                this.applySettings();
                this.resetCaptions();
                window.setTimeout(() => {
                    this.updateCaptions(this.props.currentTime);
                }, 500);
            }
        }
    }
    showSampleCaptions() {
        this.ttmlContext = null;
        const mockCaptions = new DOMParser().parseFromString(`<?xml version='1.0' encoding='utf-8'?>
<tt xml:lang='en-us' xmlns='http://www.w3.org/ns/ttml' xmlns:tts='http://www.w3.org/ns/ttml#styling'
xmlns:ttm='http://www.w3.org/ns/ttml#metadata'>
    <head>
    <metadata>
        <ttm:title>Media.wvx.aib</ttm:title>
        <ttm:copyright>Copyright (c) 2013 Microsoft Corporation.  All rights reserved.</ttm:copyright>
    </metadata>
    <styling>
        <style xml:id='Style1' tts:fontFamily='proportionalSansSerif' tts:fontSize='0.8c' tts:textAlign='center'
        tts:color='white' />
    </styling>
    <layout>
        <region style='Style1' xml:id='CaptionArea' tts:origin='0c 12.6c' tts:extent='32c 2.4c'
        tts:backgroundColor='rgba(0,0,0,160)' tts:displayAlign='center' tts:padding='0.3c 0.5c' />
    </layout>
    </head>
    <body region='CaptionArea'>
    <div>
        <p begin='00:00:01.140' end='99:99:99.999'>EXAMPLE CAPTIONS!</p>
    </div>
    </body>
</tt>`, 'text/xml');
        this._onClosedCaptionsLoaded(mockCaptions);
        const dimensions = getDimensions(this.closedCaptionDiv.current);
        this.ttmlContext.updateRelatedMediaObjectRegion(dimensions);
        this.closedCaptionDiv.current.style.bottom = '2.5rem';
    }
    updateCaptions(playPosition) {
        let output = '';
        this.lastPlayPosition = playPosition;
        if (this.ttmlContext && this.ttmlContext.hasEvents()) {
            const tick = Math.floor(playPosition * 1000);
            const dimensions = getDimensions(this.closedCaptionDiv.current);
            if (this.ttmlContext.updateRelatedMediaObjectRegion(dimensions)) {
                this.resetCaptions();
            }
            if (this.ttmlContext.updateCurrentEvents(tick)) {
                removeInnerHtml(this.closedCaptionDiv.current);
                for (const cue of this.ttmlContext.getCues(tick)) {
                    this._applyUserPreferencesOverrides(cue);
                    css(cue, 'background-color', '');
                    output = cue.outerHTML;
                }
                this.closedCaptionDiv.current.innerHTML = output;
            }
        }
    }
    resetCaptions() {
        if (this.ttmlContext) {
            this.ttmlContext.resetCurrentEvents();
        }
        if (this.closedCaptionDiv.current) {
            removeInnerHtml(this.closedCaptionDiv.current);
        }
        this.applySettings();
    }
    applySettings() {
        const prefs = {};
        const currentSettings = this.props.tempClosedCaptionsSettings ? this.props.tempClosedCaptionsSettings : this.props.currentClosedCaptionsSettings;
        for (const settingKey in currentSettings) {
            if (currentSettings.hasOwnProperty(settingKey)) {
                const optionValue = this._getOptionValue(settingKey, currentSettings[settingKey]);
                if (optionValue) {
                    prefs[settingKey] = `${closedCaptionsSettingsMap[settingKey].value}${optionValue}`;
                }
            }
        }
        this.userPreferences.text = this._getPrefsCss(prefs, 'text');
        this.userPreferences.window = this._getPrefsCss(prefs, 'window');
    }
    _loadClosedCaptions(href) {
        PlayerUtility.ajax(href, (result) => this._onClosedCaptionsLoaded(result), () => {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.loadClosedCaptions.ajax',
                    errorDesc: `Ajax call failed: ' ${href}`
                });
            }
        });
    }
    _onClosedCaptionsLoaded(ttmlDocument) {
        if (!ttmlDocument) {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.onClosedCaptionsLoaded.ttmlDoc',
                    errorDesc: 'No ttmlDocument found'
                });
            }
            return;
        }
        const id = this.closedCaptionDiv.current.id ? (`${this.closedCaptionDiv.current.id} '-'`) : '';
        const settingsOverrides = {
            idPrefix: id,
            fontMap: { default: 'Segoe ui, Arial' },
            relatedMediaObjectRegion: getDimensions(this.closedCaptionDiv.current)
        };
        try {
            this.ttmlContext = TtmlParser.parse(ttmlDocument, settingsOverrides);
            if (this.ttmlContext) {
                this.ttmlContext.setOwnerDocument(this.closedCaptionDiv.current.ownerDocument);
                if (this.ttmlContext.hasEvents()) {
                    this.updateCaptions(this.lastPlayPosition);
                }
            }
        }
        catch (e) {
            if (this.props.errorCallback) {
                this.props.errorCallback({
                    errorType: 'Player.error.onClosedCaptionsLoaded.ttmlParser',
                    errorDesc: `'TtmlDocument parser error: ' ${e.message}`
                });
            }
        }
    }
    _applyUserPreferencesOverrides(cue) {
        if (!this.userPreferences) {
            return;
        }
        if (this.userPreferences.text) {
            for (const element of selectElements('span, br', cue)) {
                for (const property in this.userPreferences.text) {
                    if (this.userPreferences.text.hasOwnProperty(property)) {
                        css(element, property, this.userPreferences.text[property]);
                    }
                }
            }
        }
        if (this.userPreferences.window) {
            const winElement = selectFirstElement('p', cue);
            if (winElement) {
                for (const property in this.userPreferences.window) {
                    if (this.userPreferences.window.hasOwnProperty(property)) {
                        css(winElement, property, this.userPreferences.window[property]);
                    }
                }
            }
        }
    }
    _setCcLanguage(href) {
        this.ttmlContext = null;
        this.resetCaptions();
        if (!href) {
            return;
        }
        this._loadClosedCaptions(href);
    }
    _getOptionValue(settingKey, optionKey) {
        const setting = closedCaptionsSettingsMap[settingKey];
        if (setting) {
            const option = closedCaptionsSettingsOptions[setting.option];
            return option && option.map[optionKey];
        }
        return '';
    }
    _getPrefsCss(prefs, prefix) {
        const prefsCss = {};
        for (const pref in prefs) {
            if (prefs.hasOwnProperty(pref)) {
                const propVal = prefs[pref];
                if (pref.indexOf(prefix) === 0 && pref.indexOf('opacity') < 0) {
                    if (propVal && (propVal.length > 0)) {
                        const styles = propVal.split(';');
                        for (const style of styles) {
                            const pVal = style.split(':');
                            if (pVal.length > 1) {
                                prefsCss[pVal[0].trim()] = pVal[1].trim();
                            }
                        }
                    }
                }
            }
        }
        for (const pref in prefs) {
            if (prefs.hasOwnProperty(pref)) {
                const propVal = prefs[pref];
                if (pref.indexOf(prefix) === 0 && pref.indexOf('opacity') > 0) {
                    const pVal = propVal.split(':');
                    if (pVal.length > 1) {
                        const colorValue = prefsCss[pVal[0].trim()];
                        const opacityValue = pVal[1].trim();
                        prefsCss[pVal[0].trim()] = this._formatAsRgba(colorValue, opacityValue);
                    }
                }
            }
        }
        return prefsCss;
    }
    _formatAsRgba(cssColor, opacity) {
        let result = format('rgba(0,0,0,{0})', opacity);
        const colorStart = cssColor ? cssColor.indexOf('#') : -1;
        if (colorStart >= 0) {
            const fullColorString = cssColor.substr(colorStart + 1);
            const colorLenght = (fullColorString.length) / 3;
            if (colorLenght > 0) {
                const red = parseInt(fullColorString.substr(0, colorLenght), 16);
                const green = parseInt(fullColorString.substr(colorLenght, colorLenght), 16);
                const blue = parseInt(fullColorString.substr(colorLenght * 2, colorLenght), 16);
                result = format('rgba({0},{1},{2},{3})', red, green, blue, opacity);
            }
        }
        return result;
    }
}
//# sourceMappingURL=video-closed-captions.js.map
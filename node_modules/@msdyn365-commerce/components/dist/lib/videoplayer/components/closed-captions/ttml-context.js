import { addClass, css, getText, nodeListToArray } from '../utilities/htmlExtensions';
import { format, isNullOrWhiteSpace, trim } from '../utilities/stringExtensions';
import { extend, getDimensions } from '../utilities/utilities';
import { TtmlParser } from './ttml-parser';
import { xmlNS } from './ttml-settings';
export class TtmlContext {
    constructor() {
        this.translateToHtml = (element, applicableStyleSet, preserveSpace) => {
            let translation;
            let innerNode;
            const name = this._getTagNameEquivalent(element);
            let htmlName = '';
            let htmlClass = '';
            switch (name) {
                case 'ttml:region':
                    htmlClass = 'cue ';
                case 'ttml:rootcontainerregion':
                case 'ttml:body':
                case 'ttml:div':
                    htmlName = 'div';
                    break;
                case 'ttml:p':
                    htmlName = 'p';
                    break;
                case 'ttml:span':
                    htmlName = 'span';
                    break;
                case 'ttml:br':
                    htmlName = 'br';
                    break;
                default:
            }
            const role = TtmlParser.getAttributeNS(element, 'role', this.settings.ttmlMetaNamespace);
            if (role) {
                htmlClass += ` ${role}`;
            }
            const agent = TtmlParser.getAttributeNS(element, 'agent', this.settings.ttmlMetaNamespace);
            if (agent) {
                htmlClass += ` ${agent}`;
            }
            if (role === 'x-ruby') {
                htmlName = ('ruby');
            }
            else if (role === 'x-rubybase') {
                htmlName = ('rb');
            }
            else if (role === 'x-rubytext') {
                htmlName = ('rt');
            }
            if (!isNullOrWhiteSpace(htmlName)) {
                translation = TtmlContext._defaultStyle(this.ownerDocument.createElement(htmlName));
                addClass(translation, trim(htmlClass));
                const title = TtmlParser.getAttributeNS(element, 'title', this.settings.ttmlMetaNamespace);
                if (title) {
                    translation.setAttribute('title', title);
                }
                const id = TtmlParser.getAttributeNS(element, 'id', xmlNS);
                if (id && this.settings.idPrefix) {
                    translation.setAttribute('id', this.settings.idPrefix + id);
                }
                if (name === 'ttml:region') {
                    innerNode = translation.appendChild(TtmlContext._defaultStyle(this.ownerDocument.createElement('div')));
                    innerNode.setAttribute('style', 'display:table; border-spacing:0; cell-spacing:0; cell-padding:0; width:100%; height:100%');
                    innerNode = innerNode.appendChild(TtmlContext._defaultStyle(this.ownerDocument.createElement('div')));
                    css(innerNode, 'display', 'table-cell');
                    if (applicableStyleSet.displayAlign) {
                        this._translateStyle(name, innerNode, { displayAlign: applicableStyleSet.displayAlign });
                        applicableStyleSet.displayAlign = '';
                    }
                }
                if (preserveSpace && (name === 'ttml:span')) {
                    innerNode = translation.appendChild(TtmlContext._defaultStyle(this.ownerDocument.createElement('span')));
                    css(innerNode, 'white-space', 'pre');
                }
                css(translation, 'position', 'static');
                css(translation, 'width', '100%');
                this._translateStyle(name, translation, applicableStyleSet);
            }
            return { outerNode: translation, innerNode: innerNode ? innerNode : translation };
        };
    }
    static _ttmlToCssTextDecoration(ttmlTextDecoration) {
        let textDecoration = '';
        const parts = ttmlTextDecoration.split(/\s+/);
        for (const value of parts) {
            switch (value) {
                case 'none':
                case 'noUnderline':
                case 'noLineThrough':
                case 'noOverline':
                    textDecoration = 'none';
            }
        }
        for (const value of parts) {
            switch (value) {
                case 'none':
                case 'noUnderline':
                case 'noLineThrough':
                case 'noOverline':
                    break;
                case 'lineThrough':
                    textDecoration += ' line-through';
                    break;
                default:
                    textDecoration += ` ${value}`;
            }
        }
        return trim(textDecoration);
    }
    static _ttmlToCssColor(color) {
        let mappedColor = color;
        color = color.toLowerCase();
        if (color.indexOf('rgba') === 0) {
            const parts = TtmlContext.rgbaRegEx.exec(color);
            if (parts && (parts.length === 5)) {
                const red = parts[1];
                const green = parts[2];
                const blue = parts[3];
                const alpha = parseInt(parts[4], 10);
                mappedColor = format('rgba({0},{1},{2},{3})', red, green, blue, Math.round(alpha * 100 / 255) / 100);
            }
        }
        else if ((color.charAt(0) === '#') && (color.length === 9)) {
            const red = parseInt(color.substr(1, 2), 16);
            const green = parseInt(color.substr(3, 2), 16);
            const blue = parseInt(color.substr(5, 2), 16);
            const alpha = parseInt(color.substr(7, 2), 16);
            mappedColor = format('rgba({0},{1},{2},{3})', red, green, blue, Math.round(alpha * 100 / 255) / 100);
        }
        else if (TtmlContext.TtmlNamedColorMap[color]) {
            mappedColor = TtmlContext.TtmlNamedColorMap[color];
        }
        return mappedColor;
    }
    static _defaultStyle(element) {
        css(element, 'background-color', TtmlContext.TtmlNamedColorMap.transparent);
        css(element, 'offset', '0');
        css(element, 'margin', '0');
        css(element, 'padding', '0');
        css(element, 'border', '0');
        return element;
    }
    setOwnerDocument(ownerDocument) {
        this.ownerDocument = ownerDocument;
    }
    updateRelatedMediaObjectRegion(dimensions) {
        if (dimensions !== null && (!this.settings.relatedMediaObjectRegion ||
            (dimensions.width !== this.settings.relatedMediaObjectRegion.width) ||
            (dimensions.height !== this.settings.relatedMediaObjectRegion.height))) {
            this.settings.relatedMediaObjectRegion = {
                width: dimensions.width,
                height: dimensions.height
            };
            return true;
        }
        return false;
    }
    hasEvents() {
        return this.events && !!this.events.length;
    }
    resetCurrentEvents() {
        this.currentEvents = [];
    }
    updateCurrentEvents(time) {
        const timeEvents = this._getTemporallyActiveEvents(time);
        const currentEventsLength = this.currentEvents ? this.currentEvents.length : 0;
        const timeEventsLength = timeEvents ? timeEvents.length : 0;
        if (currentEventsLength !== timeEventsLength) {
            this.currentEventsTime = time;
            this.currentEvents = timeEvents;
            return true;
        }
        if (this.currentEvents) {
            for (let index = 0; index < currentEventsLength; index++) {
                if (this.currentEvents[index].time !== timeEvents[index].time) {
                    this.currentEventsTime = time;
                    this.currentEvents = timeEvents;
                    return true;
                }
            }
        }
        return false;
    }
    getCues(time) {
        let cues = [];
        if (this.currentEventsTime !== time) {
            this.updateCurrentEvents(time);
        }
        const preserveSpace = (TtmlParser.getAttributeNS(this.root, 'space', xmlNS) === 'preserve');
        const regions = (this.layout ? this.layout.getElementsByTagNameNS(this.settings.ttmlNamespace, 'region') : []);
        for (const region of regions) {
            const regionId = TtmlParser.getAttributeNS(region, 'id', xmlNS);
            const anonymousId = region.getAttribute('data-isanonymous');
            if (anonymousId || regionId) {
                const translation = this._translate(region, this.settings.defaultRegionStyle, preserveSpace, time, this.translateToHtml);
                if (translation.outerNode && translation.innerNode) {
                    const innerNode = translation.innerNode;
                    const outerNode = translation.outerNode;
                    for (const event of this.events) {
                        if (event.element) {
                            if (this._isInRegion(event.element, anonymousId ? '' : regionId)) {
                                const pruneResult = this._prune(event.element, translation.inheritableStyleSet, preserveSpace, time, this.translateToHtml);
                                let cueBody = pruneResult.prunedElement;
                                if ((!pruneResult.hasPreservedContent) && cueBody && (!trim(getText(cueBody)).length)) {
                                    cueBody = null;
                                }
                                if (cueBody) {
                                    innerNode.appendChild(cueBody);
                                }
                            }
                        }
                    }
                    const showAlways = (outerNode.getAttribute('data-showBackground') === 'always');
                    if (showAlways || innerNode.children.length) {
                        if (showAlways) {
                            outerNode.removeAttribute('data-showBackground');
                        }
                        cues.push(outerNode);
                    }
                }
            }
        }
        if (cues.length) {
            const rcr = this._translate(this.rootContainerRegion, { overflow: 'hidden', padding: '0' }, false, time, this.translateToHtml);
            for (const cue of cues) {
                rcr.innerNode.appendChild(cue);
            }
            cues = [];
            cues.push(rcr.outerNode);
        }
        return cues;
    }
    _getTemporallyActiveEvents(time) {
        return this.events.filter((event) => {
            return event.element ? this._isTemporallyActive(event.element, time) : true;
        });
    }
    _isTemporallyActive(element, time) {
        return (((parseInt(element.getAttribute('data-time-start'), 10) || 0) <= time) &&
            (time < (parseInt(element.getAttribute('data-time-end'), 10) || 0)));
    }
    _translate(element, inheritedStyleSet, preserveSpace, time, translator) {
        let translation;
        let computedStyleSet;
        if (this._isTemporallyActive(element, time)) {
            const tag = this._getTagNameEquivalent(element);
            computedStyleSet = this._getComputedStyleSet(element, inheritedStyleSet, tag, time);
            if (computedStyleSet.display !== 'none') {
                const applicableStyleSet = this._getApplicableStyleSet(computedStyleSet, tag);
                translation = translator(element, applicableStyleSet, preserveSpace);
                return {
                    outerNode: translation.outerNode,
                    innerNode: translation.innerNode,
                    inheritableStyleSet: this._getInheritableStyleSet(computedStyleSet)
                };
            }
        }
        return { outerNode: null, innerNode: null, inheritableStyleSet: null };
    }
    _translateStyle(tagName, element, applicableStyleSet) {
        for (const style in applicableStyleSet) {
            if (applicableStyleSet[style]) {
                this._applyStyle(element, tagName, style, applicableStyleSet[style]);
            }
        }
    }
    _prune(element, inheritedStyleSet, preserveSpace, time, translator, ignoreAncestors = false) {
        let outerNode;
        let hasPreservedContent = false;
        let translation = this._translate(element, inheritedStyleSet, preserveSpace, time, translator);
        if (translation.outerNode !== null) {
            const tag = this._getTagNameEquivalent(element);
            outerNode = translation.outerNode;
            let innerNode = translation.innerNode;
            for (const child of nodeListToArray(element.childNodes)) {
                if (child.nodeType === Node.COMMENT_NODE) {
                }
                else if (child.nodeType === Node.TEXT_NODE) {
                    innerNode.appendChild(document.createTextNode(child.data));
                    if (preserveSpace && (tag === 'ttml:span')) {
                        hasPreservedContent = true;
                    }
                }
                else {
                    let childPreserveSpace = preserveSpace;
                    const spaceAttr = TtmlParser.getAttributeNS(child, 'space', xmlNS);
                    if (spaceAttr) {
                        childPreserveSpace = (spaceAttr === 'preserve');
                    }
                    const pruneRecord = this._prune(child, translation.inheritableStyleSet, childPreserveSpace, time, translator, true);
                    hasPreservedContent = hasPreservedContent || pruneRecord.hasPreservedContent;
                    if (pruneRecord.prunedElement) {
                        innerNode.appendChild(pruneRecord.prunedElement);
                    }
                }
            }
            if (!ignoreAncestors) {
                let ancestor = element.parentNode;
                while ((ancestor !== null) && (ancestor.nodeType === Node.ELEMENT_NODE) && (ancestor !== this.body)) {
                    translation = this._translate(ancestor, inheritedStyleSet, preserveSpace, time, translator);
                    if (translation.outerNode) {
                        innerNode = translation.innerNode;
                        innerNode.appendChild(outerNode);
                        outerNode = translation.outerNode;
                    }
                    else {
                        break;
                    }
                    ancestor = ancestor.parentNode;
                }
            }
        }
        return { prunedElement: outerNode, hasPreservedContent: hasPreservedContent };
    }
    _getComputedStyleSet(element, inheritedStyleSet, tagName, time) {
        const computedStyleSet = extend({}, inheritedStyleSet);
        extend(computedStyleSet, this.styleSetCache[parseInt(element.getAttribute('data-styleSet'), 10)]);
        const sets = element.getElementsByTagNameNS(this.settings.ttmlNamespace, 'set');
        for (const set of nodeListToArray(sets)) {
            if (this._isTemporallyActive(set, time)) {
                TtmlParser.applyInlineStyles(this.settings, computedStyleSet, set);
            }
        }
        if ((tagName === 'ttml:p') && (computedStyleSet.lineHeight === 'normal')) {
            const fontSizes = this._appendSpanFontSizes(element, this._getInheritableStyleSet(computedStyleSet), time, '');
            if (fontSizes) {
                computedStyleSet['computed-lineHeight'] = fontSizes;
            }
        }
        return computedStyleSet;
    }
    _getApplicableStyleSet(computedStyleSet, tagName) {
        const applicableStyleSet = {};
        if (computedStyleSet.extent && this._isStyleApplicable(tagName, 'extent')) {
            applicableStyleSet.extent = computedStyleSet.extent;
        }
        if (computedStyleSet.color && this._isStyleApplicable(tagName, 'color')) {
            applicableStyleSet.color = computedStyleSet.color;
        }
        for (const style in computedStyleSet) {
            if (this._isStyleApplicable(tagName, style)) {
                applicableStyleSet[style] = computedStyleSet[style];
            }
        }
        return applicableStyleSet;
    }
    _isStyleApplicable(tagName, style) {
        switch (style) {
            case 'backgroundColor':
            case 'display':
            case 'visibility':
                return (('ttml:body ttml:div ttml:p ttml:region ttml:rootcontainerregion ttml:span ttml:br').indexOf(tagName) >= 0);
            case 'fontFamily':
            case 'fontSize':
            case 'fontStyle':
            case 'fontWeight':
                return ('ttml:p ttml:span ttml:br'.indexOf(tagName) >= 0);
            case 'color':
            case 'textDecoration':
            case 'textOutline':
            case 'wrapOption':
                return ('ttml:span ttml:br'.indexOf(tagName) >= 0);
            case 'direction':
            case 'unicodeBidi':
                return ('ttml:p ttml:span ttml:br'.indexOf(tagName) >= 0);
            case 'displayAlign':
            case 'opacity':
            case 'origin':
            case 'overflow':
            case 'padding':
            case 'showBackground':
            case 'writingMode':
            case 'zIndex':
                return ('ttml:region ttml:rootcontainerregion'.indexOf(tagName) >= 0);
            case 'extent':
                return ('ttml:tt ttml:region ttml:rootcontainerregion'.indexOf(tagName) >= 0);
            case 'computed-lineHeight':
            case 'lineHeight':
            case 'textAlign':
                return ('ttml:p'.indexOf(tagName) >= 0);
            default: return false;
        }
    }
    _getInheritableStyleSet(computedStyleSet) {
        const inheritedStyleSet = {};
        for (const style in computedStyleSet) {
            if (computedStyleSet.hasOwnProperty(style)) {
                switch (style) {
                    case 'backgroundColor':
                    case 'computed-lineHeight':
                    case 'display':
                    case 'displayAlign':
                    case 'extent':
                    case 'opacity':
                    case 'origin':
                    case 'overflow':
                    case 'padding':
                    case 'showBackground':
                    case 'unicodeBidi':
                    case 'writingMode':
                    case 'zIndex':
                        break;
                    default:
                        inheritedStyleSet[style] = computedStyleSet[style];
                }
            }
        }
        return inheritedStyleSet;
    }
    _appendSpanFontSizes(element, inheritedStyleSet, time, value) {
        for (const child of nodeListToArray(element.childNodes)) {
            if ((child.nodeType === Node.ELEMENT_NODE)) {
                const tag = this._getTagNameEquivalent(child);
                if (tag === 'ttml:span') {
                    const computedStyleSet = this._getComputedStyleSet(child, inheritedStyleSet, 'ttml:span', time);
                    const fontSize = computedStyleSet.fontSize;
                    if (fontSize) {
                        value += ((value) ? ',' : '') + fontSize;
                    }
                    value = this._appendSpanFontSizes(child, this._getInheritableStyleSet(computedStyleSet), time, value);
                }
            }
        }
        return value;
    }
    _isInRegion(element, regionId) {
        if (!regionId) {
            return true;
        }
        const elemRegion = TtmlParser.getAttributeNS(element, 'region', this.settings.ttmlNamespace);
        if (elemRegion === regionId) {
            return true;
        }
        if (!elemRegion) {
            let ancestor = element.parentNode;
            while ((ancestor !== null) && (ancestor.nodeType === Node.ELEMENT_NODE)) {
                const id = this._getRegionId(ancestor);
                if (id) {
                    return id === regionId;
                }
                ancestor = ancestor.parentNode;
            }
            for (const node of nodeListToArray(element.getElementsByTagName('*'))) {
                if (this._getRegionId(node) === regionId) {
                    return true;
                }
            }
        }
        return false;
    }
    _getRegionId(element) {
        let regionId;
        if ((element.nodeType === Node.ELEMENT_NODE) && (element.namespaceURI === this.settings.ttmlNamespace)) {
            if (TtmlParser.getLocalTagName(element) === 'region') {
                regionId = TtmlParser.getAttributeNS(element, 'id', xmlNS);
            }
            else {
                regionId = TtmlParser.getAttributeNS(element, 'region', this.settings.ttmlNamespace);
            }
        }
        return regionId;
    }
    _getTagNameEquivalent(element) {
        const tagName = TtmlParser.getLocalTagName(element);
        const nameSpace = element.namespaceURI;
        if (nameSpace === this.settings.ttmlNamespace) {
            return `ttml:${tagName}`;
        }
        if (nameSpace === 'http://www.w3.org/1999/xhtml') {
            return tagName;
        }
        return '';
    }
    _applyStyle(element, tagName, style, value) {
        let mappedValue = value;
        switch (style) {
            case 'color':
            case 'backgroundColor': {
                mappedValue = TtmlContext._ttmlToCssColor(value);
                css(element, style, mappedValue);
                return;
            }
            case 'direction':
            case 'display': {
                css(element, style, mappedValue);
                return;
            }
            case 'displayAlign': {
                switch (value) {
                    case 'before':
                        mappedValue = 'top';
                        break;
                    case 'center':
                        mappedValue = 'middle';
                        break;
                    case 'after':
                        mappedValue = 'bottom';
                }
                css(element, 'vertical-align', mappedValue);
                return;
            }
            case 'extent': {
                let width;
                let height;
                if (value !== 'auto') {
                    const coords = (value.split(/\s+/));
                    if (coords.length === 2) {
                        width = this._ttmlToCssUnits(coords[0], true);
                        height = this._ttmlToCssUnits(coords[1], false);
                    }
                }
                if (!width) {
                    width = `${(this.settings.rootContainerRegionDimensions
                        ? this.settings.rootContainerRegionDimensions.width
                        : this.settings.relatedMediaObjectRegion.width).toString()}px`;
                    height = `${(this.settings.rootContainerRegionDimensions
                        ? this.settings.rootContainerRegionDimensions.height
                        : this.settings.relatedMediaObjectRegion.height).toString()}px`;
                }
                css(element, 'position', 'absolute');
                css(element, 'width', width);
                css(element, 'min-width', width);
                css(element, 'max-width', width);
                css(element, 'height', height);
                css(element, 'min-height', height);
                css(element, 'max-height', height);
                return;
            }
            case 'fontFamily': {
                if (this.settings.fontMap && this.settings.fontMap[value]) {
                    mappedValue = this.settings.fontMap[value];
                }
                if (value === 'smallCaps') {
                    css(element, 'fontVariant', 'small-caps');
                }
                css(element, style, mappedValue);
                return;
            }
            case 'fontSize': {
                const parts = value.split(/\s+/);
                const size = (parts.length > 1) ? parts[1] : parts[0];
                mappedValue = this._ttmlToCssFontSize(size, false, 0.75, tagName === 'ttml:region');
                css(element, style, mappedValue);
                return;
            }
            case 'fontStyle':
            case 'fontWeight': {
                css(element, style, mappedValue);
                return;
            }
            case 'lineHeight': {
                mappedValue = (value === 'normal') ? value : this._ttmlToCssFontSize(value, false);
                css(element, 'line-height', mappedValue);
                return;
            }
            case 'computed-lineHeight': {
                const values = value.split(',');
                let max = -1;
                for (const fontSize of values) {
                    mappedValue = this._ttmlToCssFontSize(fontSize, false);
                    if (mappedValue && (mappedValue.indexOf('px') === mappedValue.length - 2)) {
                        const height = parseFloat(mappedValue.substr(0, mappedValue.length - 2));
                        if (!isNaN(height) && (height > max)) {
                            max = height;
                        }
                    }
                }
                if (max >= 0) {
                    css(element, 'line-height', `${max}px`);
                }
                return;
            }
            case 'origin': {
                if (value !== 'auto') {
                    const coords = (value.split(/\s+/));
                    if (coords.length === 2) {
                        css(element, 'position', 'absolute');
                        css(element, 'left', this._ttmlToCssUnits(coords[0], true));
                        css(element, 'top', this._ttmlToCssUnits(coords[1], false));
                    }
                }
                return;
            }
            case 'opacity': {
                css(element, style, mappedValue);
                return;
            }
            case 'padding': {
                const contextRect = getDimensions(element);
                const parts = (value.split(/\s+/));
                let first;
                let second;
                let third;
                let forth;
                switch (parts.length) {
                    case 1:
                        first = this._ttmlToCssUnits(parts[0], false, contextRect);
                        second = this._ttmlToCssUnits(parts[0], true, contextRect);
                        mappedValue = format('{0} {1} {0} {1}', first, second);
                        break;
                    case 2:
                        first = this._ttmlToCssUnits(parts[0], false, contextRect);
                        second = this._ttmlToCssUnits(parts[1], true, contextRect);
                        mappedValue = format('{0} {1} {0} {1}', first, second);
                        break;
                    case 3:
                        first = this._ttmlToCssUnits(parts[0], false, contextRect);
                        second = this._ttmlToCssUnits(parts[1], true, contextRect);
                        third = this._ttmlToCssUnits(parts[2], false, contextRect);
                        mappedValue = format('{0} {1} {2} {1}', first, second, third);
                        break;
                    case 4:
                        first = this._ttmlToCssUnits(parts[0], false, contextRect);
                        second = this._ttmlToCssUnits(parts[1], true, contextRect);
                        third = this._ttmlToCssUnits(parts[2], false, contextRect);
                        forth = this._ttmlToCssUnits(parts[3], true, contextRect);
                        mappedValue = format('{0} {1} {2} {3}', first, second, third, forth);
                }
                css(element, 'box-sizing', 'border-box');
                css(element, 'border-style', 'solid');
                css(element, 'border-color', 'transparent');
                css(element, 'border-width', mappedValue);
                return;
            }
            case 'textAlign': {
                switch (value) {
                    case 'start':
                        mappedValue = 'left';
                        break;
                    case 'end':
                        mappedValue = 'right';
                }
                css(element, 'text-align', mappedValue);
                return;
            }
            case 'textDecoration': {
                mappedValue = TtmlContext._ttmlToCssTextDecoration(value);
                css(element, 'text-decoration', mappedValue);
                return;
            }
            case 'textOutline': {
                const defaultColor = css(element, 'color');
                css(element, 'text-shadow', this._ttmlToCssTextOutline(mappedValue, defaultColor));
                return;
            }
            case 'unicodeBidi': {
                switch (value) {
                    case 'bidiOverride':
                        mappedValue = 'bidi-override';
                }
                css(element, 'unicode-bidi', mappedValue);
                return;
            }
            case 'visibility': {
                css(element, style, mappedValue);
                return;
            }
            case 'writingMode': {
                switch (value) {
                    case 'lr':
                    case 'lrtb': {
                        css(element, 'writing-mode', 'horizontal-tb');
                        css(element, '-webkit-writing-mode', 'horizontal-tb');
                        css(element, 'writing-mode', 'lr-tb');
                        return;
                    }
                    case 'rl':
                    case 'rltb': {
                        css(element, 'writing-mode', 'horizontal-tb');
                        css(element, '-webkit-writing-mode', 'horizontal-tb');
                        css(element, 'writing-mode', 'rl-tb');
                        return;
                    }
                    case 'tblr': {
                        css(element, 'text-orientation', 'upright');
                        css(element, 'writing-mode', 'vertical-lr');
                        css(element, '-webkit-text-orientation', 'upright');
                        css(element, '-webkit-writing-mode', 'vertical-lr');
                        css(element, 'writing-mode', 'tb-lr');
                        return;
                    }
                    case 'tb':
                    case 'tbrl': {
                        css(element, 'text-orientation', 'upright');
                        css(element, 'writing-mode', 'vertical-rl');
                        css(element, '-webkit-text-orientation', 'upright');
                        css(element, '-webkit-writing-mode', 'vertical-rl');
                        css(element, 'writing-mode', 'tb-rl');
                        return;
                    }
                }
                return;
            }
            case 'wrapOption': {
                css(element, 'white-space', value === 'noWrap' ? 'nowrap' : (value === 'pre' ? 'pre' : 'normal'));
                return;
            }
            case 'zIndex': {
                css(element, style, mappedValue);
                return;
            }
            default: {
                css(element, style, mappedValue);
                return;
            }
        }
    }
    _ttmlToCssUnits(ttmlUnits, width, contextRect) {
        let cssUnits = ttmlUnits;
        if (ttmlUnits) {
            const unit = ttmlUnits.charAt(ttmlUnits.length - 1);
            if ((unit === 'c') || (unit === '%')) {
                const container = this.settings.rootContainerRegionDimensions
                    ? this.settings.rootContainerRegionDimensions
                    : this.settings.relatedMediaObjectRegion;
                const length = parseFloat(ttmlUnits.substr(0, ttmlUnits.length - 1));
                let containerSize = width ? container.width : container.height;
                let value;
                if (unit === 'c') {
                    const gridSize = width ? this.settings.cellResolution.columns : this.settings.cellResolution.rows;
                    value = length * containerSize / gridSize;
                }
                else if (unit === '%') {
                    if (contextRect) {
                        containerSize = width ? contextRect.width : contextRect.height;
                    }
                    value = containerSize * length / 100;
                }
                value = Math.round(value * 10) / 10;
                cssUnits = `${value}px`;
            }
        }
        return cssUnits;
    }
    _ttmlToCssFontSize(ttmlUnits, width, scaleFactor = 1, isRegion = false) {
        let cssUnits = ttmlUnits;
        if (ttmlUnits) {
            const unit = ttmlUnits.charAt(ttmlUnits.length - 1);
            if ((unit === 'c') || (isRegion && (unit === '%'))) {
                const container = this.settings.rootContainerRegionDimensions
                    ? this.settings.rootContainerRegionDimensions
                    : this.settings.relatedMediaObjectRegion;
                const length = parseFloat(ttmlUnits.substr(0, ttmlUnits.length - 1));
                const containerSize = width ? container.width : container.height;
                const gridSize = width ? this.settings.cellResolution.columns : this.settings.cellResolution.rows;
                let value = length * containerSize / gridSize;
                if (unit === '%') {
                    value /= 100;
                }
                value = Math.floor(value * scaleFactor * 10) / 10;
                cssUnits = `${value}px`;
            }
        }
        return cssUnits;
    }
    _ttmlToCssTextOutline(textOutline, defaultColor) {
        let textShadow = 'none';
        if (!isNullOrWhiteSpace(textOutline) && (textOutline !== 'none')) {
            let parts = textOutline.split(/\s+/);
            let color = '';
            let thickness = '';
            let blur = '';
            if (parts.length === 1) {
                color = defaultColor;
                thickness = parts[0];
                blur = '';
            }
            else if (parts.length === 3) {
                color = parts[0];
                thickness = parts[1];
                blur = parts[2];
            }
            else if (parts.length === 2) {
                const firstChar = parts[0].charAt(0);
                if ((firstChar >= '0') && (firstChar <= '9')) {
                    color = defaultColor;
                    thickness = parts[0];
                    blur = parts[1];
                }
                else {
                    color = parts[0];
                    thickness = parts[1];
                    blur = '';
                }
            }
            blur = this._ttmlToCssFontSize(blur, false, 0.75);
            thickness = this._ttmlToCssFontSize(thickness, false, 0.75);
            parts = TtmlContext.lengthRegEx.exec(thickness);
            if (parts && (parts.length === 3)) {
                const width = Math.round(parseFloat(parts[1]));
                const units = parts[2];
                textShadow = '';
                for (let x = -width; x <= width; x++) {
                    for (let y = -width; y <= width; y++) {
                        if ((x !== 0) || (y !== 0)) {
                            textShadow += format('{0}{4} {1}{4} {2} {3}, ', x, y, blur, TtmlContext._ttmlToCssColor(color), units);
                        }
                    }
                }
                if (textShadow) {
                    textShadow = textShadow.substr(0, textShadow.length - 2);
                }
            }
        }
        return textShadow;
    }
}
TtmlContext.lengthRegEx = /\s*(\d+\.*\d*)(.*)\s*/;
TtmlContext.rgbaRegEx = /\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*/;
TtmlContext.TtmlNamedColorMap = {
    transparent: 'rgba(0,0,0,0)',
    black: 'rgba(0,0,0,1)',
    silver: 'rgba(192,192,192,1)',
    gray: 'rgba(128,128,128,1)',
    white: 'rgba(255,255,255,1)',
    maroon: 'rgba(128,0,0,1)',
    red: 'rgba(255,0,0,1)',
    purple: 'rgba(128,0,128,1)',
    fuchsia: 'rgba(255,0,255,1)',
    magenta: 'rgba(255,0,255,1)',
    green: 'rgba(0,128,0,1)',
    lime: 'rgba(0,255,0,1)',
    olive: 'rgba(128,128,0,1)',
    yellow: 'rgba(255,255,0,1)',
    navy: 'rgba(0,0,128,1)',
    blue: 'rgba(0,0,255,1)',
    teal: 'rgba(0,128,128,1)',
    aqua: 'rgba(0,255,255,1)',
    cyan: 'rgba(0,255,255,1)'
};
//# sourceMappingURL=ttml-context.js.map
import { nodeListToArray } from '../utilities/htmlExtensions';
import { format, trim } from '../utilities/stringExtensions';
import { TtmlContext } from './ttml-context';
import { TtmlSettings, xmlNS } from './ttml-settings';
import { TtmlTimeParser } from './ttml-time-parser';
export class TtmlParser {
    static getLocalTagName(node) {
        return node.localName || node.baseName;
    }
    static getAttributeNS(element, name, namespace) {
        let result = element.getAttributeNS(namespace, name);
        if (!result) {
            for (const attribute of nodeListToArray(element.attributes)) {
                if ((attribute.localName === name) && (attribute.lookupNamespaceURI(attribute.prefix) === namespace)) {
                    result = attribute.value;
                    break;
                }
            }
        }
        return result;
    }
    static parse(ttmlDocument, settingsOverrides) {
        ttmlDocument = (typeof ttmlDocument === 'string') ? TtmlParser._parseXml(ttmlDocument) : ttmlDocument;
        const ttmlContext = new TtmlContext();
        ttmlContext.settings = new TtmlSettings(settingsOverrides);
        ttmlContext.root = TtmlParser._verifyRoot(ttmlDocument, ttmlContext);
        ttmlContext.body = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'body', ttmlContext.settings.ttmlNamespace);
        ttmlContext.events = [];
        ttmlContext.styleSetCache = [];
        if (ttmlContext.body) {
            TtmlParser._parseTtAttrs(ttmlContext);
            const head = TtmlParser._ensureRegions(ttmlContext);
            const timeBase = TtmlParser.getAttributeNS(ttmlContext.root, 'timeBase', ttmlContext.settings.ttmlParameterNamespace) || 'media';
            if (ttmlContext.settings.supportedTimeBase.indexOf(timeBase) !== -1) {
                TtmlParser._processAnonymousSpans(ttmlContext, ttmlContext.body);
                const timeParser = new TtmlTimeParser(ttmlContext.settings.mediaFrameRate, ttmlContext.settings.mediaTickRate);
                TtmlParser._applyTiming(ttmlContext, ttmlContext.root, { start: TtmlParser.mediaStart, end: TtmlParser.mediaEnd }, true, timeParser);
                TtmlParser._applyStyling(ttmlContext, head);
            }
            ttmlContext.events.push({ time: TtmlParser.mediaEnd, element: undefined });
            ttmlContext.events.sort((event1, event2) => {
                return event1.time - event2.time;
            });
        }
        return ttmlContext;
    }
    static applyInlineStyles(settings, styleSet, element) {
        for (const attribute of nodeListToArray(element.attributes)) {
            if (attribute.namespaceURI === settings.ttmlStyleNamespace) {
                styleSet[TtmlParser.getLocalTagName(attribute)] = trim(attribute.nodeValue);
            }
        }
    }
    static _parseXml(xmlString) {
        let xml;
        if (window.DOMParser) {
            const domParser = new window.DOMParser();
            xml = domParser.parseFromString(xmlString, 'application/xml');
        }
        else {
            const domParser = new window.ActiveXObject('Microsoft.XMLDOM');
            domParser.async = false;
            domParser.loadXML(xmlString);
            xml = domParser;
        }
        return xml;
    }
    static _verifyRoot(ttmlDocument, ttmlContext) {
        let root;
        const candidate = ttmlDocument.documentElement;
        if (TtmlParser.getLocalTagName(candidate) === 'tt') {
            if (candidate.namespaceURI !== 'http://www.w3.org/ns/ttml') {
                ttmlContext.settings.ttmlNamespace = candidate.namespaceURI;
                ttmlContext.settings.ttmlStyleNamespace = `${ttmlContext.settings.ttmlNamespace}#styling`;
                ttmlContext.settings.ttmlParameterNamespace = `${ttmlContext.settings.ttmlNamespace}#parameter`;
                ttmlContext.settings.ttmlMetaNamespace = `${ttmlContext.settings.ttmlNamespace}#metadata`;
            }
            root = candidate;
        }
        return root;
    }
    static _parseTtAttrs(ttmlContext) {
        const cellRes = TtmlParser.getAttributeNS(ttmlContext.root, 'cellResolution', ttmlContext.settings.ttmlParameterNamespace);
        const extent = TtmlParser.getAttributeNS(ttmlContext.root, 'extent', ttmlContext.settings.ttmlStyleNamespace);
        let cellGrid = null;
        if (cellRes) {
            const parts = trim(cellRes).split(/\s+/);
            if (parts.length === 2) {
                const columns = Math.round(parseFloat(parts[0]));
                const rows = Math.round(parseFloat(parts[1]));
                if ((rows > 0) && (columns > 0)) {
                    cellGrid = { rows: rows, columns: columns };
                }
            }
        }
        if (cellGrid) {
            ttmlContext.settings.cellResolution = cellGrid;
        }
        if (extent) {
            if (extent !== 'auto') {
                const coords = extent.split(/\s+/);
                if ((coords.length === 2) &&
                    (coords[0].substr(coords[0].length - 2) === 'px') &&
                    (coords[1].substr(coords[1].length - 2) === 'px')) {
                    const width = parseFloat(coords[0].substr(0, coords[0].length - 2));
                    const height = parseFloat(coords[1].substr(0, coords[1].length - 2));
                    ttmlContext.settings.rootContainerRegionDimensions = { width: Math.round(width), height: Math.round(height) };
                }
            }
        }
    }
    static _ensureRegions(ttmlContext) {
        ttmlContext.rootContainerRegion = ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace, 'rootcontainerregion');
        ttmlContext.root.appendChild(ttmlContext.rootContainerRegion);
        const extents = ttmlContext.settings.rootContainerRegionDimensions ? format('{0}px {1}px', ttmlContext.settings.rootContainerRegionDimensions.width, ttmlContext.settings.rootContainerRegionDimensions.height) : 'auto';
        ttmlContext.rootContainerRegion.setAttributeNS(ttmlContext.settings.ttmlStyleNamespace, 'extent', extents);
        let head = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'head', ttmlContext.settings.ttmlNamespace);
        if (!head) {
            head = ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace, 'head');
            ttmlContext.root.appendChild(head);
        }
        ttmlContext.layout = TtmlParser._getFirstElementByTagNameNS(head, 'layout', ttmlContext.settings.ttmlNamespace);
        if (!ttmlContext.layout) {
            ttmlContext.layout = ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace, 'layout');
            ttmlContext.root.appendChild(ttmlContext.layout);
        }
        const regions = ttmlContext.layout.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'region');
        if (!regions.length) {
            const anonymousRegion = ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace, 'region');
            anonymousRegion.setAttributeNS(xmlNS, 'id', 'anonymous');
            anonymousRegion.setAttribute('data-isanonymous', '1');
            ttmlContext.layout.appendChild(anonymousRegion);
            ttmlContext.body.setAttributeNS(ttmlContext.settings.ttmlNamespace, 'region', 'anonymous');
        }
        return head;
    }
    static _processAnonymousSpans(ttmlContext, element) {
        if (TtmlParser._isTagNS(element, 'p', ttmlContext.settings.ttmlNamespace)) {
            const textNodeGroups = [];
            let prevNodeType = 0;
            for (const child of nodeListToArray(element.childNodes)) {
                if (child.nodeType === Node.TEXT_NODE) {
                    if (prevNodeType !== Node.TEXT_NODE) {
                        textNodeGroups.push([]);
                    }
                    textNodeGroups[textNodeGroups.length - 1].push(child);
                }
                prevNodeType = child.nodeType;
            }
            for (const group of textNodeGroups) {
                const anonSpan = ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace, 'span');
                anonSpan.appendChild(group[0].parentNode.replaceChild(anonSpan, group[0]));
                for (let index = 1; index < group.length; index++) {
                    anonSpan.appendChild(group[index]);
                }
            }
        }
        for (const child of nodeListToArray(element.childNodes)) {
            this._processAnonymousSpans(ttmlContext, child);
        }
    }
    static _applyTiming(ttmlContext, element, bound, isParallelContext, timeParser) {
        const beginAttribute = TtmlParser.getAttributeNS(element, 'begin', ttmlContext.settings.ttmlNamespace);
        let startTime = beginAttribute ? timeParser.parse(beginAttribute) : bound.start;
        let endTime = 0;
        let duration = 0;
        let end = 0;
        const durationAttribute = TtmlParser.getAttributeNS(element, 'dur', ttmlContext.settings.ttmlNamespace);
        const endAttribute = TtmlParser.getAttributeNS(element, 'end', ttmlContext.settings.ttmlNamespace);
        if ((!durationAttribute) && (!endAttribute)) {
            if (isParallelContext) {
                if (startTime <= bound.end) {
                    endTime = bound.end;
                }
                else {
                    endTime = 0;
                }
            }
        }
        else if (durationAttribute && endAttribute) {
            duration = timeParser.parse(durationAttribute);
            end = timeParser.parse(endAttribute);
            const minEnd = Math.min(startTime + duration, bound.start + end);
            endTime = Math.min(minEnd, bound.end);
        }
        else if (endAttribute) {
            end = timeParser.parse(endAttribute);
            endTime = Math.min(bound.start + end, bound.end);
        }
        else {
            duration = timeParser.parse(durationAttribute);
            endTime = Math.min(startTime + duration, bound.end);
        }
        if (endTime < startTime) {
            endTime = startTime;
        }
        startTime = Math.floor(startTime);
        endTime = Math.floor(endTime);
        element.setAttribute('data-time-start', startTime.toString());
        element.setAttribute('data-time-end', endTime.toString());
        if ((startTime >= 0) && (ttmlContext.events.filter((event) => { return event.time === startTime; }).length <= 0)) {
            ttmlContext.events.push({ time: startTime, element: element });
        }
        let start = startTime;
        for (const child of nodeListToArray(element.childNodes)) {
            if (child.nodeType === Node.ELEMENT_NODE) {
                if (TtmlParser.getAttributeNS(element, 'timeContainer', ttmlContext.settings.ttmlNamespace) !== 'seq') {
                    this._applyTiming(ttmlContext, child, { start: startTime, end: endTime }, true, timeParser);
                }
                else {
                    this._applyTiming(ttmlContext, child, { start: start, end: endTime }, false, timeParser);
                    start = parseInt(child.getAttribute('data-time-end'), 10);
                }
            }
        }
    }
    static _applyStyling(ttmlContext, head) {
        const styling = TtmlParser._getFirstElementByTagNameNS(head, 'styling', ttmlContext.settings.ttmlNamespace);
        const styles = styling ? nodeListToArray(styling.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'style')) : [];
        for (const element of nodeListToArray(ttmlContext.root.querySelectorAll('*'))) {
            this._applyStyle(ttmlContext, element, styles);
        }
    }
    static _applyStyle(ttmlContext, element, styles) {
        const styleSet = {};
        this._applyStylesheet(ttmlContext.settings, styleSet, element, styles);
        TtmlParser.applyInlineStyles(ttmlContext.settings, styleSet, element);
        let empty = true;
        for (const style in styleSet) {
            if (styleSet.hasOwnProperty(style)) {
                empty = false;
                break;
            }
        }
        if (!empty) {
            element.setAttribute('data-styleSet', ttmlContext.styleSetCache.length.toString());
            ttmlContext.styleSetCache.push(styleSet);
        }
    }
    static _applyStylesheet(settings, styleSet, element, styles) {
        const styleAttribute = TtmlParser.getAttributeNS(element, 'style', settings.ttmlNamespace);
        const ids = styleAttribute ? styleAttribute.split(/\s+/) : [];
        for (const styleId of ids) {
            for (const style of styles) {
                if (TtmlParser.getAttributeNS(style, 'id', xmlNS) === styleId) {
                    this._applyStylesheet(settings, styleSet, style, styles);
                    TtmlParser.applyInlineStyles(settings, styleSet, style);
                }
            }
        }
        if (TtmlParser._isTagNS(element, 'region', settings.ttmlNamespace)) {
            for (const style of nodeListToArray(element.getElementsByTagNameNS(settings.ttmlNamespace, 'style'))) {
                TtmlParser.applyInlineStyles(settings, styleSet, style);
            }
        }
    }
    static _isTagNS(element, tagName, namespace) {
        return ((element.namespaceURI === namespace) && this.getLocalTagName(element) === tagName);
    }
    static _getFirstElementByTagNameNS(context, tagName, namespace) {
        let result;
        if (context) {
            const matches = context.getElementsByTagNameNS(namespace, tagName);
            if (matches && matches.length) {
                result = matches[0];
            }
        }
        return result;
    }
}
TtmlParser.mediaStart = -1;
TtmlParser.mediaEnd = 99999999;
//# sourceMappingURL=ttml-parser.js.map
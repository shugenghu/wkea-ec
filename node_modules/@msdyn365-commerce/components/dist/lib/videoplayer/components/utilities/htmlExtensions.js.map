{"version":3,"file":"htmlExtensions.js","sourceRoot":"./src/","sources":["videoplayer/components/utilities/htmlExtensions.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNullOrWhiteSpace, trim} from './stringExtensions';\n\nexport function getText(element?: HTMLElement | Element): string {\n    return !!element ? element.textContent || '' : '';\n}\n\n/* Add a css class to an element.\n* @param  {HTMLElement} element - The element to add the css class to.\n* @param  {string} cssClass - The css class to add.\n*/\nexport function addClass(element: HTMLElement, cssClass: string): void {\n    if ((!!element) && (!isNullOrWhiteSpace(cssClass)) && (!hasClass(element, cssClass))) {\n        if (element.classList) {\n            element.classList.add(cssClass);\n        } else {\n            element.className = trim(`${element.className} ${cssClass}`);\n        }\n    }\n}\n\n/* Checks for the presence of a css class on an element.\n* @param  {HTMLElement} element - The element to check the css class of.\n* @param  {string} cssClass - The css class to check for.\n* @return True if the element's className has the specified class, otherwise false.\n*/\n// TODO: user classList for supported browsers\nexport function hasClass(element: HTMLElement, cssClass: string): boolean {\n    if ((!element) || isNullOrWhiteSpace(cssClass)) {\n        return false;\n    } else if (element.classList) {\n        return element.classList.contains(cssClass);\n    } else {\n        return (`' ' ${element.className} ' '`).indexOf(`' ' ${trim(cssClass)}  ' '`) > -1;\n    }\n}\n\n/*\n* Convert node list to array.\n* @param  {NodeListOf<T extends Node>} nodeList\n*/\nexport function nodeListToArray<T extends Node>(nodeList: NodeListOf<T> | NodeListOf<Element> |\n    HTMLCollection | NodeList | NamedNodeMap): T[] {\n    if (!nodeList) {\n        return [];\n    }\n\n    const elements: T[] = [];\n\n    // tslint:disable-next-line: prefer-for-of\n    for (let n = 0; n < nodeList.length; n++) {\n        elements.push(<T>nodeList[n]);\n    }\n\n    return elements;\n}\n\n/** Select elements in a context.\n * @param  {string} selector - can be class, id or tag selector.\n * @param  {HTMLElement} [context] - any element to scope the selection. It's optional. If not provided document will be assumed.\n * @returns HTMLElement[]\n */\nexport function selectElements(selector: string, context?: HTMLElement): HTMLElement[] {\n    return selectElementsT<HTMLElement>(selector, context);\n}\n\n/** Select elements in a context.\n * @param  {string} selector - can be class, id or tag selector.\n * @param  {HTMLElement} [context] - any element to scope the selection. It's optional. If not provided document will be assumed.\n * @returns T[]\n */\nexport function selectElementsT<T extends HTMLElement>(selector: string, context?: HTMLElement): T[] {\n    if (isNullOrWhiteSpace(selector) || selector === '#') {\n        return <T[]>[];\n    }\n\n    const currentContext: HTMLElement | Document = context || document;\n\n    // check if the first character is class or id.\n    if (/^[\\#.]?[\\w-]+$/.test(selector)) {\n        // tslint:disable-next-line: switch-default\n        switch (selector[0]) {\n            case '.':\n                if (currentContext.getElementsByClassName) {\n                    return nodeListToArray(currentContext.getElementsByClassName!(selector.slice(1)));\n                } else {\n                    return nodeListToArray(<NodeListOf<T>>currentContext.querySelectorAll(selector));\n                }\n            case '#':\n                const element = currentContext.querySelector(selector);\n                return <T[]>(element ? [element] : []);\n        }\n\n        return nodeListToArray(currentContext.getElementsByTagName(selector));\n    }\n\n    return nodeListToArray(<NodeListOf<T>>currentContext.querySelectorAll(selector));\n}\n\n/* Sets or gets CSS properties\n* @param  {HTMLElement} element\n* @param  {string} property - The CSS property name\n* @param  {any} [value] - The value to set on the CSS property\n* @returns {any} - The value of the CSS property\n*/\n// tslint:disable-next-line: no-any\nexport function css(element: HTMLElement | Node, property: string, value?: any): any {\n    if (!element) {\n        return null;\n    }\n\n    if (!!value || value === '') {\n    // tslint:disable-next-line: no-any\n        (<any>element).style[property] = value;\n    } else {\n    // tslint:disable-next-line: no-any\n        value = (<any>element).style[property];\n\n        if (isNullOrWhiteSpace(value)) {\n        // tslint:disable-next-line: no-any tslint:disable-next-line: prefer-type-cast\n            value = getComputedStyle(element as any);\n            value = value[property];\n        }\n\n        return value;\n    }\n}\n\n/**\n * Remove all inner HTML from a parent element - used to delete child elements\n * @param {HTMLElement} parentElement - the parent element from which all children should be removed\n * @returns void\n */\nexport function removeInnerHtml(parentElement: HTMLElement): void {\n    if (parentElement) {\n    // tslint:disable-next-line: no-inner-html\n        parentElement.innerHTML = '';\n    }\n}\n\n/** Select first element from the selected elements using provided selector.\n * @param {string} selector - element selector.\n * @param {HTMLElement} [context] - an optional context to scope the selection.\n * @returns {HTMLElement} - the first element from the match.\n */\nexport function selectFirstElement(selector: string, context?: HTMLElement): HTMLElement | null {\n    const elementsSelected = selectElementsT<HTMLElement>(selector, context);\n    return (!elementsSelected || !elementsSelected.length) ? null : elementsSelected[0];\n}\n"]}
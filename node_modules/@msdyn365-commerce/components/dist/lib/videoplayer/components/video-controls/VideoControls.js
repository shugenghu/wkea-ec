import { getPayloadObject, getTelemetryAttributes, Slider, UncontrolledTooltip } from '@msdyn365-commerce-modules/utilities';
import * as React from 'react';
import ActionToggle from '../action-toggle/ActionToggle';
import { MenuCategories, VideoPlayerNames } from '../data/player-constants';
import { LocalizationConstants } from '../helper/localization-helper';
import Menu from '../menu/menu';
export const ButtonMenuTypes = {
    ClosedCaption: 'close-caption',
    Options: 'options'
};
const volumeSliderDivOffset = 162;
export default class VideoControls extends React.PureComponent {
    constructor(props) {
        super(props);
        this.selectedMenuItems = [];
        this.volumeButtonDiv = React.createRef();
        this.playButtonRef = React.createRef();
        this.pauseButtonRef = React.createRef();
        this.closedCaptionRef = React.createRef();
        this.optionButtonRef = React.createRef();
        this.fullscreenButtonRef = React.createRef();
        this.exitFullScreenButtonRef = React.createRef();
        this.videoControlDiv = React.createRef();
        this.closedCaptionButtonDiv = React.createRef();
        this.optionButtonDiv = React.createRef();
        this.menuRef = React.createRef();
        this.muteButtonRef = React.createRef();
        this.unMuteButtonRef = React.createRef();
        this.showVolumeControl = (autohide) => () => {
            const offsetPosition = this._getOffsetPosition(this.volumeButtonDiv);
            window && window.clearTimeout(this.volumeAutoHideTimer);
            this.setState({
                showVolumeSlider: true,
                volumeSliderLeftPosition: offsetPosition.offsetLeft,
                volumeSliderTopPosition: offsetPosition.offsetTop - volumeSliderDivOffset + 1
            });
            if (autohide && document.activeElement.parentElement !== this.volumeButtonDiv.current.firstChild) {
                this.volumeAutoHideTimer = window && window.setTimeout(() => {
                    this._hideVolumeControl();
                }, VideoControls.volumeAutoHideTimeout);
            }
        };
        this._onDocumentClick = (e) => {
            const target = e.target;
            if (!(((this.currentMenu === ButtonMenuTypes.ClosedCaption) && (target === this.closedCaptionButtonDiv.current.firstChild || target.parentElement === this.closedCaptionButtonDiv.current.firstChild)) ||
                ((this.currentMenu === ButtonMenuTypes.Options) && (target === this.optionButtonDiv.current.firstChild || target.parentElement === this.optionButtonDiv.current.firstChild)))) {
                this.setState({
                    showMenu: !this.state.showMenu
                });
            }
        };
        this._renderClosedCaptionButton = () => {
            return (React.createElement("div", { className: `${VideoControls.videoControlsClassName}__closedcaption__container`, ref: this.closedCaptionButtonDiv },
                React.createElement("button", { ref: this.closedCaptionRef, "aria-label": this.props.resources.closedCaptionLabel, className: `${VideoControls.videoControlsClassName}__closedcaptionbtn`, onClick: this._onClosedCaptionClick }),
                React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.closedCaptionRef }, this.props.resources.closedCaptionLabel)));
        };
        this._renderOptionButton = () => {
            return (React.createElement("div", { className: `${VideoControls.videoControlsClassName}__moreoptions__container`, ref: this.optionButtonDiv },
                React.createElement("button", { ref: this.optionButtonRef, "aria-label": this.props.resources.optionButtonLabel, className: `${VideoControls.videoControlsClassName}__moreoptionsbtn`, onClick: this._onOptionsButtonClick }),
                React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.optionButtonRef }, this.props.resources.optionButtonLabel)));
        };
        this._renderFullScreenButton = () => {
            this.payLoad.contentAction.etext = this.props.isInFullScreen ? LocalizationConstants.exitFullScreenAriaLabel : LocalizationConstants.fullScreenAriaLabel;
            const attribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
            return (React.createElement("div", { className: `${VideoControls.videoControlsClassName}__fullscreenbtn__container` },
                React.createElement(ActionToggle, { onChange: this.props.toggleFullScreen, toggled: this.props.isInFullScreen, className: `${VideoControls.videoControlsClassName}__fullscreenbtn__wrapper` },
                    React.createElement("button", Object.assign({ ref: this.fullscreenButtonRef, "aria-label": this.props.resources.fullScreenAriaLabel, className: `${VideoControls.videoControlsClassName}__fullscreenbtn` }, attribute)),
                    React.createElement("button", Object.assign({ ref: this.exitFullScreenButtonRef, "aria-label": this.props.resources.exitFullScreenAriaLabel, className: `${VideoControls.videoControlsClassName}__exitfullscreenbtn` }, attribute))),
                React.createElement(UncontrolledTooltip, { className: `${VideoControls.videoControlsClassName}__fullscreenbtn__tooltip`, trigger: 'hover focus', target: this.fullscreenButtonRef },
                    " ",
                    this.props.resources.fullScreenAriaLabel),
                React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.exitFullScreenButtonRef },
                    " ",
                    this.props.resources.exitFullScreenAriaLabel)));
        };
        this._renderVolumeButton = () => {
            this.payLoad.contentAction.etext = this.props.isMuted ? LocalizationConstants.unMuteAriaLabel : LocalizationConstants.muteAriaLabel;
            const attribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
            const volumeButtonProps = {
                className: `${VideoControls.videoControlsClassName}__muteunmutebtn__wrapper`,
                onChange: this.props.onMuteClick,
                toggled: this.props.isMuted,
                onFocus: this.showVolumeControl(),
                onBlur: this._hideVolumeControl,
                onMouseOver: this.showVolumeControl(),
                onMouseOut: this._hideVolumeControl,
            };
            return (React.createElement(ActionToggle, Object.assign({}, volumeButtonProps),
                React.createElement("button", Object.assign({ "aria-label": this.props.resources.muteAriaLabel, ref: this.muteButtonRef, className: `${VideoControls.videoControlsClassName}__mutebtn` }, attribute)),
                React.createElement("button", Object.assign({ "aria-label": this.props.resources.unMuteAriaLabel, ref: this.unMuteButtonRef, className: `${VideoControls.videoControlsClassName}__unmutebtn` }, attribute))));
        };
        this._renderVideoSlider = () => {
            const videoProps = {
                id: 'VideoSlider',
                inForm: false,
                className: `${VideoControls.videoControlsClassName}__slidercontainer`,
                min: this.props.playPosition.startTime,
                max: this.props.playPosition.endTime,
                ariaLabel: this.props.resources.seekBarLabel,
                fillTrackValue: this.props.playPosition.bufferedDuration,
                step: this.props.videoSeekSteps || 1,
                orientation: 'horizontal',
                showProgressBar: true,
                onChange: this.props.onProgressChange,
                showLabels: false,
                showTooltip: true,
                handleTooltipText: this._handleProgressToolTipText(this.props.playPosition.currentTime),
                sliderThumbs: [
                    {
                        id: 'VideoSliderThumb',
                        value: this.props.playPosition.currentTime,
                        ariaValueText: this.props.playPosition.currentTime.toString()
                    }
                ]
            };
            return (React.createElement(Slider, Object.assign({}, videoProps)));
        };
        this._renderVolumeSlider = () => {
            const volumeSliderProps = {
                id: 'VolumeSlider',
                inForm: false,
                className: `${VideoControls.videoControlsClassName}__volumeslider`,
                min: 0,
                max: 100,
                step: this.props.volumeSeekSteps || 5,
                orientation: 'vertical',
                showProgressBar: false,
                onChange: this.props.onVolumeChange,
                onFocus: this.showVolumeControl(),
                onBlur: this._hideVolumeControl,
                showLabels: false,
                showTooltip: true,
                sliderThumbs: [
                    {
                        id: 'VolumeSliderThumb',
                        value: Math.round(this.props.currentVolume),
                        ariaValueText: Math.round(this.props.currentVolume).toString(),
                    }
                ]
            };
            return (React.createElement(Slider, Object.assign({}, volumeSliderProps)));
        };
        this._handleProgressToolTipText = (tooltip) => () => {
            return this._toElapsedTimeString(tooltip);
        };
        this.volumeAutoHideTimer = 0;
        this.focusedMenuItemIndex = 0;
        this.currentMenu = '';
        this._hideVolumeControl = this._hideVolumeControl.bind(this);
        this._onMenuItemClick = this._onMenuItemClick.bind(this);
        this._reevaluateWidth = this._reevaluateWidth.bind(this);
        this._onClosedCaptionClick = this._onClosedCaptionClick.bind(this);
        this._onDocumentClick = this._onDocumentClick.bind(this);
        this._onOptionsButtonClick = this._onOptionsButtonClick.bind(this);
        this._onMenuBlur = this._onMenuBlur.bind(this);
        this._onMenuFocus = this._onMenuFocus.bind(this);
        this._onMouseOver = this._onMouseOver.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onMenuKeyDown = this._onMenuKeyDown.bind(this);
        this._onMenuKeyUp = this._onMenuKeyUp.bind(this);
        this.state = {
            showVolumeSlider: false,
            volumeSliderLeftPosition: 0,
            volumeSliderTopPosition: -160,
            showMenu: false,
            menuLeftPosition: 0,
            currentMenu: this.props.closedCaptionMenu,
            toolTipClass: ''
        };
        this.payLoad = getPayloadObject('click', this.props.telemetryContent, '');
    }
    componentDidUpdate(prevProps) {
        if (!this.props.isControlPanelVisible) {
            this.setState({
                showMenu: false
            });
        }
        if (this.props.currentClosedCaptionLanguage !== prevProps.currentClosedCaptionLanguage
            || this.props.currentClosedCaptionsSetting !== prevProps.currentClosedCaptionsSetting
            || this.props.currentAudioTrack !== prevProps.currentAudioTrack) {
            this._updateSelectedMenu();
        }
    }
    render() {
        const { className, ...props } = this.props;
        const currentTime = this._toElapsedTimeString(props.playPosition.currentTime);
        const endTime = this._toElapsedTimeString(props.playPosition.endTime);
        const volumeDivStyle = {
            top: this.state.volumeSliderTopPosition,
            left: this.state.volumeSliderLeftPosition
        };
        const menuDivStyle = {
            left: this.state.menuLeftPosition
        };
        this.payLoad.contentAction.etext = this.props.playing ? LocalizationConstants.pauseAriaLabel : LocalizationConstants.playAriaLabel;
        const attribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
        return (React.createElement("div", { className: className, ref: this.videoControlDiv, role: 'none', onKeyDown: this.props.handleControlsKeyDownHandler, onBlur: this.props.onBlur, onFocus: this.props.onFocus },
            React.createElement("div", { className: `${VideoControls.videoControlsClassName}__wrapper` },
                React.createElement("div", { className: `${VideoControls.videoControlsClassName}__playpausebtn__container` },
                    React.createElement(ActionToggle, { className: `${VideoControls.videoControlsClassName}__playpausebtn__wrapper`, onChange: this.props.onPlayClick, toggled: this.props.playing },
                        React.createElement("button", Object.assign({ ref: this.playButtonRef, "aria-label": this.props.resources.playAriaLabel, className: `${VideoControls.videoControlsClassName}__playbtn` }, attribute)),
                        React.createElement("button", Object.assign({ ref: this.pauseButtonRef, "aria-label": this.props.resources.pauseAriaLabel, className: `${VideoControls.videoControlsClassName}__pausebtn` }, attribute))),
                    React.createElement(UncontrolledTooltip, { className: this.state.toolTipClass, trigger: 'hover focus', target: this.playButtonRef },
                        " ",
                        this.props.resources.playAriaLabel),
                    React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.pauseButtonRef },
                        " ",
                        this.props.resources.pauseAriaLabel)),
                React.createElement("div", { className: `${VideoControls.videoControlsClassName}__time` },
                    React.createElement("div", { className: `${VideoControls.videoControlsClassName}__time__screenreader`, "aria-hidden": this.props.isMobileDevice, "aria-live": 'polite' }, `${this.props.resources.videoTimeDurationLabel} ${currentTime} / ${endTime}`),
                    React.createElement("div", { className: `${VideoControls.videoControlsClassName}__time__text`, "aria-hidden": 'true' },
                        currentTime,
                        " /",
                        ` `,
                        endTime)),
                React.createElement("div", { className: `${VideoControls.videoControlsClassName}__slider__container` }, this._renderVideoSlider()),
                (this.props.closedCaptionMenu) &&
                    this._renderClosedCaptionButton(),
                (this.props.optionMenu) &&
                    this._renderOptionButton(),
                (this.state.showMenu) &&
                    (React.createElement(Menu, { ref: this.menuRef, className: `${VideoControls.videoControlsClassName}__menu`, playerMenu: this.state.currentMenu, style: menuDivStyle, onDocumentClick: this._onDocumentClick, onMenuItemClick: this._onMenuItemClick, onFocus: this._onMenuFocus, onBlur: this._onMenuBlur, onMouseOver: this._onMouseOver, onMouseOut: this._onMouseOut, onKeyDown: this._onMenuKeyDown, onKeyUp: this._onMenuKeyUp })),
                (!this.props.isMobileDevice) && React.createElement("div", { className: `${VideoControls.videoControlsClassName}__muteunmutebtn__container`, ref: this.volumeButtonDiv }, this._renderVolumeButton()),
                (!this.props.isMobileDevice) && React.createElement("div", { className: `${VideoControls.videoControlsClassName}__volumeslider__container ${this.state.showVolumeSlider ? 'show' : 'hide'}`, onFocus: this.showVolumeControl(), onBlur: this._hideVolumeControl, onMouseOver: this.showVolumeControl(), onMouseOut: this._hideVolumeControl, style: volumeDivStyle, role: 'presentation' }, this._renderVolumeSlider()),
                this._renderFullScreenButton())));
    }
    setFocusOnPlay() {
        this.playButtonRef.current.focus();
    }
    setFocusOnMenuButton() {
        if (this.props.isControlPanelVisible) {
            if (this.currentMenu === ButtonMenuTypes.ClosedCaption) {
                this.closedCaptionRef.current.focus();
            }
            else {
                this.optionButtonRef.current.focus();
            }
        }
    }
    componentDidMount() {
        window && window.addEventListener('resize', this._reevaluateWidth);
        this._reevaluateWidth();
        if (this._isIPhone()) {
            const fullscreen = document.getElementsByClassName(`${VideoControls.videoControlsClassName}__fullscreenbtn__container`);
            fullscreen[0].setAttribute('hidden', 'true');
        }
    }
    componentWillUnmount() {
        window && window.removeEventListener('resize', this._reevaluateWidth);
    }
    _reevaluateWidth() {
        const rowDiv = this.videoControlDiv.current.children[0];
        let controlBarButtonsWidth = 0;
        for (let i = 0; i < rowDiv.children.length; i++) {
            if (rowDiv.children[i].children[0] !== undefined && rowDiv.children[i].children[0].className.includes('action-toggle')) {
                controlBarButtonsWidth += rowDiv.children[i].clientWidth;
            }
        }
        const sliderWidth = controlBarButtonsWidth + 100;
        rowDiv.children[2].setAttribute('style', `${'width: calc(100% - '}${sliderWidth}${'px)'}`);
        if (this.state.showVolumeSlider) {
            this._hideVolumeControl();
        }
        if (!this.props.isMobileDevice) {
            const offsetPosition = this._getOffsetPosition(this.volumeButtonDiv);
            this.setState({
                volumeSliderLeftPosition: offsetPosition.offsetLeft,
                volumeSliderTopPosition: offsetPosition.offsetTop - volumeSliderDivOffset
            });
        }
        if (this.state.showMenu) {
            this.setState({
                showMenu: false
            });
        }
        const videoControlWidth = this.videoControlDiv.current.clientWidth;
        const viewportMax = window && window.innerWidth;
        this._applyTooltipClassOnWidthChange(videoControlWidth, viewportMax);
    }
    _onMenuFocus(e) {
        const button = e.target;
        const hasEvents = button.getAttribute('data-has-events');
        if (hasEvents) {
            this.props.onMenuItemFocus({
                category: button.parentElement.parentElement.parentElement.getAttribute('data-category'),
                id: button.parentElement.id,
                data: button.getAttribute('data-info')
            });
        }
    }
    _onMenuBlur(e) {
        const button = e.target;
        const hasEvents = button.getAttribute('data-has-events');
        if (hasEvents) {
            this.props.onMenuItemBlur();
        }
    }
    _onMouseOver(e) {
        const button = e.target;
        const hasEvents = button.getAttribute('data-has-events');
        if (hasEvents) {
            this.props.onMenuItemFocus({
                category: button.parentElement.parentElement.parentElement.getAttribute('data-category'),
                id: button.parentElement.id,
                data: button.getAttribute('data-info')
            });
        }
    }
    _onMouseOut(e) {
        const button = e.target;
        const hasEvents = button.getAttribute('data-has-events');
        if (hasEvents) {
            this.props.onMenuItemBlur();
        }
    }
    _onMenuKeyDown(e) {
        this._onMenuKeyPressed(e);
    }
    _onMenuKeyUp(event) {
        const e = event;
        const key = e.keyCode;
        if (key === 32) {
            event.preventDefault();
        }
    }
    _onMenuKeyPressed(event) {
        const key = event.keyCode;
        const target = event.target;
        const currentMenuItem = this.state.currentMenu;
        this._resetFocusForCurrentMenu(currentMenuItem);
        switch (key) {
            case 37:
            case 39:
                event.stopPropagation();
                event.preventDefault();
                if (key === 39 && target.getAttribute('data-has-children') === 'true') {
                    this._onMenuItemClick(event);
                }
                if (key === 37 && target.getAttribute('data-isbackbutton') === 'true') {
                    this._onMenuItemClick(event);
                }
                break;
            case 13:
            case 32:
                event.preventDefault();
                this._onMenuItemClick(event);
                break;
            case 38:
            case 40:
                event.stopPropagation();
                event.preventDefault();
                if (key === 38) {
                    this.focusedMenuItemIndex -= 1;
                    if (this.focusedMenuItemIndex < 0) {
                        this.focusedMenuItemIndex = currentMenuItem.items.length - 1;
                    }
                }
                else {
                    this.focusedMenuItemIndex = ((this.focusedMenuItemIndex + 1) % currentMenuItem.items.length);
                }
                currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
                this.setState({
                    currentMenu: currentMenuItem
                }, () => { if (this.menuRef.current) {
                    this.menuRef.current.forceUpdate();
                } });
                break;
            case 33:
            case 36:
                event.stopPropagation();
                event.preventDefault();
                this.focusedMenuItemIndex = 0;
                currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
                this.setState({
                    currentMenu: currentMenuItem
                }, () => { if (this.menuRef.current) {
                    this.menuRef.current.forceUpdate();
                } });
                break;
            case 35:
            case 34:
                event.stopPropagation();
                event.preventDefault();
                this.focusedMenuItemIndex = currentMenuItem.items.length - 1;
                currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
                this.setState({
                    currentMenu: currentMenuItem
                }, () => { if (this.menuRef.current) {
                    this.menuRef.current.forceUpdate();
                } });
                break;
            case 27:
                this.setFocusOnMenuButton();
                this.setState({
                    showMenu: false
                });
                break;
            case 9:
                if (((this.focusedMenuItemIndex < currentMenuItem.items.length - 1 || this.focusedMenuItemIndex === currentMenuItem.items.length - 1 && event.shiftKey) && this.focusedMenuItemIndex >= 0) && !(this.focusedMenuItemIndex === 0 && event.shiftKey)) {
                    this.focusedMenuItemIndex += event.shiftKey ? -1 : 1;
                    currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
                    this.setState({
                        currentMenu: currentMenuItem
                    });
                }
                else {
                    event.stopPropagation();
                    event.preventDefault();
                    this.setState({
                        showMenu: false
                    });
                    if (event.shiftKey) {
                        this.setFocusOnMenuButton();
                    }
                    else {
                        if (this.currentMenu === ButtonMenuTypes.ClosedCaption && this.optionButtonRef.current) {
                            this.optionButtonRef.current.focus();
                        }
                        else {
                            this.props.isMuted ? this.unMuteButtonRef.current.focus() : this.muteButtonRef.current.focus();
                        }
                    }
                }
        }
    }
    _onMenuItemClick(e) {
        const button = e.currentTarget;
        if (button.getAttribute('data-has-children') === 'true') {
            const index = Number(button.getAttribute('data-itemindex'));
            this.selectedMenuItems.push(index);
            const currentMenuItem = this._getSelectedMenuFromList();
            this.focusedMenuItemIndex = 0;
            currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
            this.setState({
                currentMenu: currentMenuItem
            });
        }
        else if (button.getAttribute('data-isbackbutton') === 'true') {
            this.focusedMenuItemIndex = this.selectedMenuItems.pop();
            const currentMenuItem = this._getSelectedMenuFromList();
            currentMenuItem.items[this.focusedMenuItemIndex].hasFocus = true;
            this.setState({
                currentMenu: currentMenuItem
            });
        }
        else {
            const currentMenuItem = this._getSelectedMenuFromList();
            this._resetFocusForCurrentMenu(currentMenuItem);
            const index = Number(button.getAttribute('data-itemindex'));
            this.focusedMenuItemIndex = index;
            const data = this.currentMenu === ButtonMenuTypes.ClosedCaption ? button.getAttribute('data-info') :
                JSON.stringify({ url: button.getAttribute('data-info'), lang: button.getAttribute('lang') });
            this.props.onMenuItemClick({
                category: button.parentElement.parentElement.parentElement.getAttribute('data-category'),
                id: button.parentElement.id,
                data: data
            });
        }
        this._updateSelectedMenu();
    }
    _resetFocusForCurrentMenu(currentMenu) {
        currentMenu.items.forEach(item => item.hasFocus = false);
    }
    _getSelectedMenuFromList() {
        let menuItem = this.currentMenu === ButtonMenuTypes.ClosedCaption ? this.props.closedCaptionMenu : this.props.optionMenu;
        for (let i = 0; i < this.selectedMenuItems.length; i++) {
            menuItem = menuItem.items[this.selectedMenuItems[i]].subMenu;
        }
        return menuItem;
    }
    _updateSelectedMenu() {
        const currentMenuItem = this._getSelectedMenuFromList();
        if (currentMenuItem) {
            switch (currentMenuItem.category) {
                case MenuCategories.ClosedCaption:
                    currentMenuItem.items.forEach((item) => {
                        if (item.data && item.data === this.props.currentClosedCaptionLanguage) {
                            item.selected = true;
                        }
                        else {
                            item.selected = false;
                        }
                    });
                    break;
                case MenuCategories.ClosedCaptionSettings:
                    currentMenuItem.items.forEach((item) => {
                        for (const setting in this.props.currentClosedCaptionsSetting) {
                            const data = `${setting}:${this.props.currentClosedCaptionsSetting[setting]}`;
                            if (item.data && item.data === data) {
                                item.selected = true;
                                break;
                            }
                            else {
                                item.selected = false;
                            }
                        }
                    });
                    break;
                case MenuCategories.AudioTracks:
                    currentMenuItem.items.forEach((item) => {
                        if (item.language && item.language === this.props.currentAudioTrack) {
                            item.selected = true;
                        }
                        else {
                            item.selected = false;
                        }
                    });
            }
            this.setState({
                currentMenu: currentMenuItem
            }, () => { if (this.menuRef.current) {
                this.menuRef.current.forceUpdate();
            } });
        }
    }
    _getOffsetPosition(refDiv) {
        const buttonWidth = refDiv.current.children[0].clientWidth;
        const elementwidth = refDiv.current.offsetWidth;
        const offsetLeft = refDiv.current.offsetLeft + (elementwidth - buttonWidth) / 2;
        const offsetTop = refDiv.current.offsetTop;
        return {
            offsetLeft,
            offsetTop
        };
    }
    _onClosedCaptionClick() {
        this.currentMenu = ButtonMenuTypes.ClosedCaption;
        const offsetLeft = this._getOffsetPosition(this.closedCaptionButtonDiv).offsetLeft;
        this.focusedMenuItemIndex = 0;
        this.selectedMenuItems = [];
        const closedCaptionMenu = this.props.closedCaptionMenu;
        this._resetFocusForCurrentMenu(closedCaptionMenu);
        closedCaptionMenu.items[this.focusedMenuItemIndex].hasFocus = true;
        this.setState({
            showMenu: (this.currentMenu === ButtonMenuTypes.ClosedCaption && !this.state.showMenu),
            menuLeftPosition: offsetLeft - 120,
            currentMenu: closedCaptionMenu,
        });
        this._updateSelectedMenu();
    }
    _onOptionsButtonClick() {
        this.currentMenu = ButtonMenuTypes.Options;
        const offsetLeft = this._getOffsetPosition(this.optionButtonDiv).offsetLeft;
        this.focusedMenuItemIndex = 0;
        this.selectedMenuItems = [];
        const optionMenu = this.props.optionMenu;
        this._resetFocusForCurrentMenu(optionMenu);
        optionMenu.items[this.focusedMenuItemIndex].hasFocus = true;
        this.setState({
            showMenu: (this.currentMenu === ButtonMenuTypes.Options && !this.state.showMenu),
            menuLeftPosition: offsetLeft - 120,
            currentMenu: optionMenu,
        });
        this._updateSelectedMenu();
    }
    _hideVolumeControl() {
        window && window.clearTimeout(this.volumeAutoHideTimer);
        this.setState({
            showVolumeSlider: false
        });
    }
    _toElapsedTimeString(seconds) {
        const negative = seconds < 0;
        if (negative) {
            seconds *= -1;
        }
        const hours = Math.floor(seconds / 3600);
        const remainder = seconds % 3600;
        const minutes = Math.floor(remainder / 60);
        let elapsedTime = '';
        elapsedTime = hours > 0 ? `${hours}:` : '';
        seconds = Math.floor(remainder % 60);
        elapsedTime += `${(minutes < 10 ? '0' : '') + minutes.toString()}`;
        elapsedTime += `:${seconds === 0 ? '00' : (seconds < 10 ? '0' : '') + seconds.toString()}`;
        return negative ? `-${elapsedTime}` : elapsedTime;
    }
    _applyTooltipClassOnWidthChange(videoControlWidth, viewportMax) {
        if (videoControlWidth) {
            this.setState({
                toolTipClass: (videoControlWidth > this.props.viewportMin && videoControlWidth < viewportMax) ? `${VideoControls.videoControlsClassName}__playpausebtn__tooltip` : ''
            });
        }
    }
    _isIPhone() {
        const useragent = window && window.navigator.userAgent;
        return !!useragent.match(/iPhone/i);
    }
}
VideoControls.defaultProps = {
    resources: {
        playAriaLabel: LocalizationConstants.playAriaLabel,
        pauseAriaLabel: LocalizationConstants.pauseAriaLabel,
        closeAriaLabel: LocalizationConstants.closeAriaLabel,
        muteAriaLabel: LocalizationConstants.muteAriaLabel,
        unMuteAriaLabel: LocalizationConstants.unMuteAriaLabel,
        fullScreenAriaLabel: LocalizationConstants.fullScreenAriaLabel,
        exitFullScreenAriaLabel: LocalizationConstants.exitFullScreenAriaLabel,
        pausedAriaLabel: LocalizationConstants.pausedAriaLabel,
        playingAriaLabel: LocalizationConstants.playingAriaLabel,
        seekBarLabel: LocalizationConstants.seekBarLabel,
        videoTimeDurationLabel: LocalizationConstants.videoTimeDurationLabel,
        closedCaptionLabel: LocalizationConstants.closedCaptionLabel
    },
    viewportMin: 200
};
VideoControls.videoControlsClassName = `${VideoPlayerNames.videoplayerContainer}__controls`;
VideoControls.volumeAutoHideTimeout = 2000;
//# sourceMappingURL=VideoControls.js.map
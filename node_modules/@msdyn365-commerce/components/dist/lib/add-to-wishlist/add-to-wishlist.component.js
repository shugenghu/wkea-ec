import classnames from 'classnames';
import React, { useState } from 'react';
import { buildWishlistLine, getCustomer, GetCustomerInput } from '@msdyn365-commerce-modules/retail-actions';
import { Alert, UncontrolledTooltip } from '@msdyn365-commerce-modules/utilities';
import { msdyn365Commerce } from '@msdyn365-commerce/core';
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { addLinesAsync, createCommerceListAsync, createGetByCustomerInput, removeLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CommerceListsDataActions.g';
const onClick = async (_event, props, state) => {
    const { user } = props.context.request;
    let { product } = props.data;
    if (state.waiting) {
        return;
    }
    if (!user.isAuthenticated && user.signInUrl && window) {
        window.location.assign(user.signInUrl);
        return;
    }
    state.setWaiting(true);
    if (!(props.getSelectedProduct === undefined)) {
        product = (await props.getSelectedProduct) || props.data.product;
    }
    await (doesProductExistInWishlist(product, props) ? removeFromWishlist(product, props, state) : addToWishlist(product, props, state));
    state.setWaiting(false);
};
const onDismiss = (state) => {
    state.setContent({ color: 'success', showAlert: false });
};
const AddToWishlistComponentActions = {
    onClick: onClick,
    onDismiss: onDismiss
};
const AddToWishlist = (props) => {
    const [waiting, setWaiting] = useState(false);
    const [canRemove, setCanRemove] = useState(doesProductExistInWishlist(props.data.product, props));
    const [content, setContent] = useState({});
    const state = {
        waiting,
        canRemove,
        content,
        setWaiting,
        setCanRemove,
        setContent
    };
    React.useEffect(() => {
        setCanRemove(doesProductExistInWishlist(props.data.product, props));
    }, [props]);
    const { removeFromWishlistButtonText, addToWishlistButtonText, showStatusMessage, showRemoveButton, showButtonText, className, disabled, showButtonTooltip, tooltipPosition } = props;
    const onClickHandler = (event) => { return AddToWishlistComponentActions.onClick(event, props, state); };
    const onDismissHandler = () => { return AddToWishlistComponentActions.onDismiss(state); };
    const ariaLabel = state.canRemove ? removeFromWishlistButtonText : addToWishlistButtonText;
    const addToWishlistRef = React.createRef();
    const removeFromWishlistRef = React.createRef();
    const showMessage = showStatusMessage !== undefined ? showStatusMessage : true;
    const showButton = showRemoveButton !== undefined ? showRemoveButton : true;
    const showTooltip = showButtonTooltip !== undefined ? showButtonTooltip : true;
    const tooltipPos = showButtonTooltip !== undefined ? tooltipPosition : 'right';
    if (state.canRemove && !showButton) {
        return null;
    }
    return (React.createElement(React.Fragment, null,
        showButtonText ? (React.createElement(React.Fragment, null,
            React.createElement("button", { className: classnames('msc-add-to-wishlist', className, state.waiting ? 'msc-add-to-wishlist__waiting' : '', state.canRemove ? 'msc-add-to-wishlist__removing' : ''), "aria-label": ariaLabel, onClick: onClickHandler, disabled: disabled, ref: addToWishlistRef }, ariaLabel),
            showTooltip && React.createElement(UncontrolledTooltip, { placement: tooltipPos, trigger: 'hover focus', target: addToWishlistRef }, ariaLabel))) : (React.createElement(React.Fragment, null,
            React.createElement("button", { className: classnames('msc-add-to-wishlist', className, state.waiting ? 'msc-add-to-wishlist__waiting' : '', state.canRemove ? 'msc-add-to-wishlist__removing' : ''), "aria-label": ariaLabel, onClick: onClickHandler, disabled: disabled, ref: removeFromWishlistRef }),
            showTooltip && React.createElement(UncontrolledTooltip, { placement: tooltipPos, trigger: 'hover focus', target: addToWishlistRef }, ariaLabel))),
        state.content.showAlert && showMessage ?
            React.createElement("div", { className: 'ms-wishlist-items__product-status' },
                React.createElement(Alert, { color: state.content.color, isOpen: state.content.showAlert, toggle: onDismissHandler }, state.content.wishlistTextMessage)) :
            ''));
};
const doesProductExistInWishlist = (product, props) => {
    const { wishlists } = props.data;
    if (!wishlists || !wishlists[0]) {
        return false;
    }
    const { CommerceListLines } = wishlists[0];
    if (!CommerceListLines || CommerceListLines.length === 0) {
        return false;
    }
    for (const wishlistItem of CommerceListLines) {
        if (wishlistItem.ProductId === product.RecordId) {
            return true;
        }
    }
    return false;
};
const propogateSuccess = (props, result) => {
    const { onSuccess, cartline } = props;
    if (onSuccess) {
        cartline ? onSuccess(result, props.cartline) : onSuccess(result);
    }
};
const propogateError = (props, result) => {
    const { onError } = props;
    if (onError) {
        onError(result);
    }
};
const addToWishlist = async (product, props, state) => {
    const { canAddMasterProduct, context } = props;
    if (product.Dimensions && !canAddMasterProduct) {
        const missingDimensions = product.Dimensions.filter(dimension => !(dimension.DimensionValue && dimension.DimensionValue.Value));
        if (missingDimensions.length > 0) {
            propogateError(props, { status: 'MISSINGDIMENSION', missingDimensions: missingDimensions });
            return AsyncResult.resolve();
        }
    }
    if (context.request.user.isAuthenticated) {
        if (!props.data.wishlists || props.data.wishlists.length === 0) {
            const wishlistName = props.nameOfWishlist;
            const customer = await getCustomerAccount(props);
            if (customer && customer.AccountNumber) {
                const listData = {
                    CustomerId: customer.AccountNumber,
                    Name: wishlistName,
                    CommerceListTypeValue: 1,
                    Id: 0
                };
                try {
                    const commerceList = await createCommerceListAsync({ callerContext: context.actionContext }, listData);
                    return callAddWishlistLine(props, state, commerceList.Id, product.RecordId);
                }
                catch (error) {
                    if (context.telemetry) {
                        context.telemetry.warning(error);
                        context.telemetry.debug('Unable to create a wishlist');
                    }
                    propogateError(props, { status: 'FAILED' });
                }
            }
            else {
                context.telemetry.debug('Customer account number missing');
            }
        }
        else {
            return callAddWishlistLine(props, state, props.data.wishlists[0].Id, product.RecordId);
        }
    }
    return AsyncResult.resolve();
};
const callAddWishlistLine = async (props, state, wishlistId, productId) => {
    const { context } = props;
    try {
        const customer = await getCustomerAccount(props);
        if (customer && customer.AccountNumber) {
            const createdCommerceList = await addLinesAsync({ callerContext: context.actionContext }, wishlistId, [buildWishlistLine(productId, customer.AccountNumber, wishlistId)]);
            context.actionContext.update(createGetByCustomerInput({}, null), [createdCommerceList]);
            if (context.telemetry) {
                context.telemetry.debug(`Added item to the wishlist ${createdCommerceList}`);
            }
            state.setCanRemove(true);
            state.setContent({
                color: 'success',
                showAlert: true, wishlistTextMessage: props.addToWishlistMessage ? props.addToWishlistMessage : 'Added to your wishlist'
            });
            propogateSuccess(props, { status: 'ADDED' });
        }
        else {
            context.telemetry.debug(`Customer Account number missing`);
        }
    }
    catch (error) {
        if (context.telemetry) {
            context.telemetry.warning(error);
            context.telemetry.debug(`Unable to add item to wishlist ${error}`);
        }
        state.setContent({
            color: 'danger',
            showAlert: true, wishlistTextMessage: props.addItemToWishlistError
        });
        propogateError(props, { status: 'FAILED' });
    }
};
const removeFromWishlist = async (product, props, state) => {
    const { context, data, removedFromWishlistMessage, removeItemFromWishlistError } = props;
    const { wishlists } = data;
    const { actionContext, telemetry } = context;
    if (context.request.user.isAuthenticated) {
        if (wishlists && wishlists[0]) {
            const wishlistLine = wishlists[0].CommerceListLines.find(line => line.ProductId === product.RecordId);
            if (wishlistLine) {
                try {
                    const customer = await getCustomerAccount(props);
                    const commerceList = await removeLinesAsync({ callerContext: actionContext }, wishlists[0].Id, [wishlistLine]);
                    if (customer) {
                        context.actionContext.update(createGetByCustomerInput({}, null), [commerceList]);
                    }
                    else {
                        telemetry.debug('Customer Account Number missing');
                    }
                    if (telemetry) {
                        telemetry.debug(`[WishlistButton] ${product.RecordId} removed from Wishlist ${commerceList.Id}`);
                    }
                    state.setCanRemove(false);
                    state.setContent({
                        color: 'success',
                        showAlert: true, wishlistTextMessage: removedFromWishlistMessage ? removedFromWishlistMessage : `Removed item from the wishlist`
                    });
                    propogateSuccess(props, { status: 'REMOVED' });
                }
                catch (error) {
                    if (telemetry) {
                        telemetry.warning(error);
                        telemetry.debug('[WishlistButton] Error removing item from the wishlist');
                    }
                    state.setContent({
                        color: 'danger',
                        wishlistTextMessage: removeItemFromWishlistError
                    });
                    propogateError(props, { status: 'FAILED' });
                }
            }
        }
        else {
            if (telemetry) {
                telemetry.debug('[WishlistButton] Can\'t remove from wishlist since no wishlist exisits OR there is no product data');
            }
        }
    }
    return AsyncResult.resolve();
};
const getCustomerAccount = (props) => {
    const { context } = props;
    const customerInput = new GetCustomerInput(context.actionContext.requestContext.apiSettings);
    return getCustomer(customerInput, context.actionContext);
};
export const AddToWishlistComponent = msdyn365Commerce.createComponent('AddToWishlist', { component: AddToWishlist, ...AddToWishlistComponentActions });
//# sourceMappingURL=add-to-wishlist.component.js.map
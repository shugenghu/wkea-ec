import { format, getPayloadObject, getTelemetryAttributes, mapToCssModules, UncontrolledTooltip } from '@msdyn365-commerce-modules/utilities';
import classNames from 'classnames';
import * as React from 'react';
import CarouselContext from './CarouselContext';
import CarouselItem from './CarouselItem';
export default class Carousel extends React.Component {
    constructor(props) {
        super(props);
        this.directionTextPrev = 'prev';
        this.directionTextNext = 'next';
        this.setInterval = (props = this.props) => {
            this.clearInterval();
            const { interval, autoplay } = props;
            if (interval && !(autoplay === false)) {
                this.cycleInterval = setInterval(() => {
                    props.next();
                }, interval);
            }
        };
        this.clearInterval = () => {
            clearInterval(this.cycleInterval);
        };
        this.hoverStart = (e) => {
            const { pause, mouseEnter } = this.props;
            if (pause === 'hover') {
                this.clearInterval();
            }
            if (mouseEnter) {
                mouseEnter(e);
            }
        };
        this.hoverEnd = (e) => {
            const { pause, mouseLeave } = this.props;
            if (pause === 'hover') {
                this.setInterval();
            }
            if (mouseLeave) {
                mouseLeave(e);
            }
        };
        this.handleKeyPress = (e) => {
            const { keyboard, previous, next } = this.props;
            if (keyboard) {
                if (e.keyCode === 37) {
                    previous();
                }
                else if (e.keyCode === 39) {
                    next();
                }
            }
        };
        this.renderItems = (carouselItems, className) => {
            const { slide, handleOnExiting, handleOnExited, activeIndex } = this.props;
            const slides = carouselItems && carouselItems.length ? (carouselItems.map((slotContent, index) => {
                return (React.createElement(CarouselItem, { key: index, onExiting: handleOnExiting, onExited: handleOnExited }, slotContent));
            })) : ([]);
            return (React.createElement("div", { className: className }, slides.map((item, index) => {
                const isIn = (index === activeIndex);
                return React.cloneElement(item, {
                    in: isIn,
                    slide: slide,
                });
            })));
        };
        this._handleKeyPressPrev = (e) => {
            if (e.keyCode === 13) {
                e.preventDefault();
                this.props.previous();
            }
        };
        this._handleKeyPressNext = (e) => {
            if (e.keyCode === 13) {
                e.preventDefault();
                this.props.next();
            }
        };
        this.props = props;
        this.handleKeyPress = this.handleKeyPress.bind(this);
        this._handleTouchStart = this._handleTouchStart.bind(this);
        this._handleTouchEnd = this._handleTouchEnd.bind(this);
        this.renderItems = this.renderItems.bind(this);
        this.hoverStart = this.hoverStart.bind(this);
        this.scrollThreshold = this.props.touchScrollThreshold !== undefined ? this.props.touchScrollThreshold : 100;
        this.state = {
            direction: 'right',
            indicatorClicked: false
        };
        this._onClickPrev = this._onClickPrev.bind(this);
        this._onClickNext = this._onClickNext.bind(this);
        this._handleKeyPressPrev = this._handleKeyPressPrev.bind(this);
        this._handleKeyPressNext = this._handleKeyPressNext.bind(this);
        this.linkRefPrev = React.createRef();
        this.linkRefNext = React.createRef();
        this.payLoad = getPayloadObject('click', this.props.telemetryContent, '');
    }
    componentDidMount() {
        if (this.props.ride === 'carousel') {
            this.setInterval();
        }
        document.addEventListener('keyup', this.handleKeyPress);
    }
    componentWillReceiveProps(nextProps) {
        this.setInterval(nextProps);
        const { activeIndex } = this.props;
        if (activeIndex !== null) {
            if (activeIndex + 1 === nextProps.activeIndex) {
                this.setState({ direction: 'right' });
            }
            else if (activeIndex - 1 === nextProps.activeIndex) {
                this.setState({ direction: 'left' });
            }
            else if (activeIndex > nextProps.activeIndex) {
                this.setState({ direction: this.state.indicatorClicked ? 'left' : 'right' });
            }
            else if (activeIndex !== nextProps.activeIndex) {
                this.setState({ direction: this.state.indicatorClicked ? 'right' : 'left' });
            }
            this.setState({ indicatorClicked: false });
        }
    }
    componentWillUnmount() {
        this.clearInterval();
        document.removeEventListener('keyup', this.handleKeyPress);
    }
    render() {
        const { cssModule, className, transitionType, dismissEnabled, hideFlipper, showPaginationTooltip, items, hideIndicator } = this.props;
        function carouselClass(transitionTypeValue) {
            switch (transitionTypeValue) {
                case 'slide':
                    return 'slide';
                case 'fade':
                    return 'carousel-fade';
                default:
                    return null;
            }
        }
        const showTooltip = showPaginationTooltip !== undefined ? showPaginationTooltip : true;
        const outerClasses = mapToCssModules(classNames(className, 'msc-carousel', carouselClass(transitionType)), cssModule);
        const innerClasses = mapToCssModules(classNames('msc-carousel__inner'), cssModule);
        const dismiss = dismissEnabled && this._renderDismissCarousel();
        const indicators = !hideIndicator && this._renderIndicators(showTooltip);
        const carouselControls = !hideFlipper && this._renderCarouselControls(showTooltip);
        if (items && items.length) {
            return (React.createElement(CarouselContext.Provider, { value: { direction: this.state.direction } },
                React.createElement("div", { className: outerClasses, onMouseEnter: this.hoverStart, onMouseLeave: this.hoverEnd, onTouchStart: this._handleTouchStart, onTouchEnd: this._handleTouchEnd },
                    items && items.length && this.renderItems(items, innerClasses),
                    items && items.length > 1 && carouselControls,
                    items && items.length > 1 && indicators,
                    dismiss)));
        }
        else {
            return (null);
        }
    }
    _handleTouchStart(evt) {
        if (evt.touches.length === 0) {
            this.scrollStart = undefined;
        }
        else {
            this.scrollStart = evt.touches[0].screenX;
        }
    }
    _handleTouchEnd(evt) {
        if (evt.changedTouches.length > 0 && this.scrollStart !== undefined) {
            const { previous, next } = this.props;
            const newTarget = evt.changedTouches[0].screenX;
            const delta = newTarget - this.scrollStart;
            if (delta > this.scrollThreshold) {
                previous();
            }
            if (delta < -this.scrollThreshold) {
                next();
            }
        }
        this.scrollStart = undefined;
        return;
    }
    _renderIndicators(showTooltip) {
        const { items, activeIndex, cssModule, onIndicatorsClickHandler, indicatorAriaText } = this.props;
        const listClasses = mapToCssModules('msc-carousel__indicators', cssModule);
        const indicators = items && items.length && items.map((item, idx) => {
            const indicatorClasses = mapToCssModules(classNames({ active: activeIndex === idx }), cssModule);
            const label = indicatorAriaText ? format(indicatorAriaText, idx + 1) : '';
            const indicatorId = `indicatorSlide` + `${idx + 1}`;
            this.payLoad.contentAction.etext = (idx + 1).toString();
            const attribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
            return (React.createElement(React.Fragment, null,
                React.createElement("li", Object.assign({ id: indicatorId, "aria-label": label, "aria-setsize": items.length, "aria-posinset": idx + 1, "aria-selected": activeIndex === idx ? true : false, key: `${item.key || item.src}${item.caption}${item.altText}`, role: 'tab', tabIndex: 0, className: indicatorClasses, onClick: (e) => {
                        e.preventDefault();
                        onIndicatorsClickHandler(idx);
                        this.setState({ indicatorClicked: true });
                    } }, attribute)),
                showTooltip && React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: `${indicatorId}` }, label)));
        });
        return (React.createElement("ol", { className: listClasses, role: 'tablist' }, indicators));
    }
    _renderCarouselControls(showTooltip) {
        const { cssModule, directionTextPrev, directionTextNext } = this.props;
        const anchorClassesPrev = mapToCssModules('msc-carousel__control__prev', cssModule);
        const anchorClassesNext = mapToCssModules('msc-carousel__control__next', cssModule);
        const iconClassesPrev = mapToCssModules('msc-carousel__control__prev__icon', cssModule);
        const iconClassesNext = mapToCssModules('msc-carousel__control__next__icon', cssModule);
        const screenReaderClasses = mapToCssModules('screen-reader-only', cssModule);
        const indexNumber = 0;
        this.payLoad.contentAction.etext = this.directionTextPrev;
        const prevAttribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
        this.payLoad.contentAction.etext = this.directionTextNext;
        const nextAttribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
        return (React.createElement(React.Fragment, null,
            React.createElement("a", Object.assign({ className: anchorClassesPrev, role: 'button', tabIndex: indexNumber, onClick: this._onClickPrev, onKeyUp: this._handleKeyPressPrev, ref: this.linkRefPrev }, prevAttribute),
                React.createElement("span", { className: iconClassesPrev, "aria-hidden": 'true' }),
                React.createElement("span", { className: screenReaderClasses }, directionTextPrev || this.directionTextPrev)),
            showTooltip && React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.linkRefPrev }, directionTextPrev),
            React.createElement("a", Object.assign({ className: anchorClassesNext, role: 'button', tabIndex: indexNumber, onClick: this._onClickNext, onKeyUp: this._handleKeyPressNext, ref: this.linkRefNext }, nextAttribute),
                React.createElement("span", { className: iconClassesNext, "aria-hidden": 'true' }),
                React.createElement("span", { className: screenReaderClasses }, directionTextNext || this.directionTextNext)),
            showTooltip && React.createElement(UncontrolledTooltip, { trigger: 'hover focus', target: this.linkRefNext }, directionTextNext)));
    }
    _onClickPrev(e) {
        e.preventDefault();
        this.props.previous();
    }
    _onClickNext(e) {
        e.preventDefault();
        this.props.next();
    }
    _renderDismissCarousel() {
        const { handleDismissCarousel, dismissCarouselAriaText } = this.props;
        return (React.createElement("button", { className: 'msc-carousel__dismiss msi msi-times', "aria-label": dismissCarouselAriaText, onClick: handleDismissCarousel }));
    }
}
Carousel.defaultProps = {
    interval: 5000,
    pause: 'hover',
    keyboard: true,
    slide: true,
    hideIndicator: false
};
//# sourceMappingURL=Carousel.js.map
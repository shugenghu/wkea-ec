{"version":3,"file":"app-cache.js","sourceRoot":"","sources":["../../src/app-cache.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IDictionary, IRequestContext } from '@msdyn365-commerce/core-internal';\nimport { isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { METRIC_APP_CACHE_INSERT, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { isObservable, toJS } from 'mobx';\nimport NodeCache from 'node-cache';\nimport { normalizeCacheKey } from './cache-utils';\nimport { ICache, ICacheItem, ICacheKey, ICacheSource } from './ICache';\nimport { ICacheSettings } from './ICacheSettings';\n\n/**\n * DEFAULT cache time to live value in seconds\n */\nconst defaultTimeoutInMS: number = 5000;\n\n/**\n * DEFAULT cache time to live value in seconds\n */\nconst DEFAULT_CACHE_TTL: number = 600;\n\n/**\n * DEFAULT cache time to refresh value in seconds\n */\nconst DEFAULT_CACHE_TTR: number = 60;\n\n/**\n * Default cache check period(in seconds) to check if ttl of any cache items expired\n */\nconst DEFAULT_CHECK_PERIOD: number = 600;\n\ninterface ICacheItemInternal<T> extends ICacheItem<T> {\n    /**\n     * Timestamp in milliseconds at which the cache key gets expired and will cause appcache\n     * to set shouldRefresh property of the expired item to true - indicating that the data should be refreshed\n     */\n    expireAtInTimeMilliseconds: number;\n\n    /**\n     * Flag to track the loading state internally so that when the cache item is refreshing, it will return the current value for the given cache key\n     */\n    isRefreshing?: boolean;\n    /**\n     * Flag to track the when the item start refreshing.\n     */\n    refreshStartTimeInMS?: number;\n}\n\n/**\n * Server app cache implementation\n */\nexport class AppCache implements ICache {\n    public nodeCache: NodeCache;\n\n    private entityKeys: IDictionary<IDictionary<boolean>>;\n\n    private settings: ICacheSettings = {};\n\n    private refreshTimeout: number = defaultTimeoutInMS;\n\n    private requestContext?: IRequestContext;\n\n    public constructor(settings: ICacheSettings) {\n        this.settings = settings || {};\n        this.nodeCache = new NodeCache({\n            checkperiod: settings.checkPeriodInSeconds || DEFAULT_CHECK_PERIOD,\n            stdTTL: settings.defaultTTLInSeconds || DEFAULT_CACHE_TTL,\n            // TODO - RAVI check if we can utilitze this to support native clone from node-cache\n            useClones: false\n        });\n        this.entityKeys = {};\n    }\n\n    /**\n     * @function        {setRefresh}               - Method to insert an item in the cache\n     * @param requestContext  {requestContext}     - requestContext\n     */\n    public setRequestContext(requestContext: IRequestContext): void {\n        this.requestContext = requestContext;\n        this._setRefresh(this.requestContext);\n    }\n\n    /**\n     * @function        {getCacheEntries}          - Method to get cache entries\n     */\n    public getCacheEntries(): string[] {\n        const cacheEntriesSet: string[] = [];\n        if (this.settings.ttlInSeconds) {\n            Object.keys(this.settings.ttlInSeconds).forEach(key => {\n                cacheEntriesSet.push(key);\n            });\n        }\n        if (this.settings.ttrInSeconds) {\n            Object.keys(this.settings.ttrInSeconds).forEach(key => {\n                cacheEntriesSet.push(key);\n            });\n        }\n        cacheEntriesSet.filter((item, index) => cacheEntriesSet.indexOf(item) === index);\n        return cacheEntriesSet;\n    }\n\n    /**\n     * @function        {put}           - Method to insert an item in the cache\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\n     */\n    public put<T = unknown>(cacheKey: ICacheKey, item: ICacheItem<T>): boolean {\n        this._validateCacheKey(cacheKey);\n        item.s = item.s !== undefined ? item.s : ICacheSource.AppCache;\n\n        // App-cache is unable to store loading AsyncResults correctly\n        // we need to wait for the promise to resolve, and then store the resolved promise\n        if (isAsyncResult(item.item) && item.item.status === 'LOADING') {\n            item.item.then(() => {\n                this.put(cacheKey, item);\n            });\n            return true;\n        }\n        // node-cache returns observable objects as []\n        // therefore, lets save the pure js version of the same\n        if (item && isObservable(item.item)) {\n            const timerId = `app-cache - ${cacheKey.typeName}`;\n            StaticTelemetry.startTimer(timerId);\n            if (!isAsyncResult(item.item)) {\n                item.item = toJS<T>(item.item);\n            }\n            StaticTelemetry.trackMetric(METRIC_APP_CACHE_INSERT, StaticTelemetry.stopTimer(timerId));\n        }\n\n        cacheKey = normalizeCacheKey(cacheKey);\n\n        const ttl = this._getTTL(cacheKey.typeName);\n        const ttr = this._getTTR(cacheKey.typeName);\n        const computedCacheKey = this._computeCacheKey(cacheKey);\n        const expiryTime = new Date();\n        expiryTime.setSeconds(expiryTime.getSeconds() + ttr);\n\n        // update the cache entity without resetting TTL\n        const prevTtl = this.nodeCache.getTtl(computedCacheKey);\n        let cacheItem: ICacheItemInternal<T>;\n        if (prevTtl) {\n            cacheItem = {\n                expireAtInTimeMilliseconds: expiryTime.getTime(),\n                ...item\n            };\n            // reset isRefreshing to false before the refresh entity write to the cache.\n            const newTtl = prevTtl - Date.now();\n            return this.nodeCache.set(computedCacheKey, cacheItem, newTtl / 1000);\n        }\n        cacheItem = {\n            expireAtInTimeMilliseconds: expiryTime.getTime(),\n            ...item\n        };\n\n        this.entityKeys[cacheKey.typeName] = this.entityKeys[cacheKey.typeName] || {};\n        this.entityKeys[cacheKey.typeName][computedCacheKey] = true;\n\n        return this.nodeCache.set(computedCacheKey, cacheItem, ttl);\n    }\n\n    /**\n     * @function        {get<T>}        - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {ICacheItem<T>} - cached value against the given cache key\n     */\n    public get<T = unknown>(cacheKey: ICacheKey): ICacheItem<T> | undefined {\n        this._validateCacheKey(cacheKey);\n        const preparedCacheKey = this._computeCacheKey(cacheKey);\n        const cacheItemInternal = <ICacheItemInternal<T>>this.nodeCache.get(preparedCacheKey);\n\n        if (!cacheItemInternal) {\n            return undefined;\n        }\n\n        if (!cacheItemInternal.expireAtInTimeMilliseconds || cacheItemInternal.shouldRefresh) {\n            return { ...cacheItemInternal };\n        }\n\n        const now = Date.now();\n        if (cacheItemInternal.expireAtInTimeMilliseconds < now) {\n            if (!cacheItemInternal.isRefreshing) {\n                cacheItemInternal.isRefreshing = true;\n                cacheItemInternal.refreshStartTimeInMS = now;\n                return { ...cacheItemInternal, ...{ shouldRefresh: true } };\n            } else if (this._isRefreshExpired(cacheItemInternal, now)) {\n                // If the data's refresh timout then let the next subsequent caller\n                // know that they have to refresh the data\n                cacheItemInternal.refreshStartTimeInMS = now;\n                return { ...cacheItemInternal, ...{ shouldRefresh: true } };\n            }\n        }\n\n        return <ICacheItem<T>>{ ...cacheItemInternal };\n    }\n\n    /**\n     * @function        {getAllItems}   - Method to get all cached items for a given type\n     * @param typeName  {typeName}      - typeName for which all items need to be fetched\n     * @return          {ICacheItem}    - dictionary of cache items of the given typeName\n     */\n    public getAllItems<T = unknown>(typeName: string): IDictionary<ICacheItem<T>> | undefined {\n        if (typeName === '') {\n            throw new Error('typeName cannot be empty');\n        }\n\n        const cacheKeys = this.entityKeys[typeName.toUpperCase()];\n        const currentTimestamp = Date.now();\n        if (cacheKeys) {\n            const cacheItems = this.nodeCache.mget<ICacheItemInternal<T>>(Object.keys(cacheKeys));\n            const response: IDictionary<ICacheItem<T>> = {};\n            Object.keys(cacheItems)\n                .filter(key => !!cacheItems[key])\n                .map(key => {\n                    if (cacheItems[key].expireAtInTimeMilliseconds > currentTimestamp) {\n                        response[key] = {\n                            ...cacheItems[key],\n                            shouldRefresh: true\n                        };\n                    }\n                });\n\n            return response;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @function        {hasCacheSetting}   - tells if there is a cache setting defined for the given entity type\n     * @param typeName  {typeName}          - typeName for which all items need to be fetched\n     * @return          {boolean}           - true if a cache setting ttr/ttl is specified for the given entity\n     */\n    public hasCacheSetting(typeName: string): boolean {\n        if (typeName === '') {\n            throw new Error('typeName cannot be empty');\n        }\n\n        typeName = typeName.toUpperCase();\n\n        if (this.settings) {\n            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {\n                return !!this.settings.ttrInSeconds[typeName];\n            }\n\n            if (this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]) {\n                return !!this.settings.ttlInSeconds[typeName];\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\n     * @return          {ICacheItem}    - cache item that was copied\n     */\n    public copyTo<T = unknown>(cacheKey: ICacheKey, toCache: ICache): ICacheItem<T> | undefined {\n        const cachedItem = this.get<T>(cacheKey);\n        if (cachedItem) {\n            toCache.put(cacheKey, { item: cachedItem.item, s: ICacheSource.AppCache });\n            return cachedItem;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @function        {getValue<T>}   - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {ICacheItem<T>} - cached value against the given cache key\n     */\n    public getValue<T = unknown>(cacheKey: ICacheKey): T | undefined {\n        const cachedItem = <ICacheItem<T>>this.get(cacheKey);\n        return cachedItem ? cachedItem.item : undefined;\n    }\n\n    /**\n     * @function        {del}           - Method to delete an item from the cache\n     * @param cacheKey  {ICacheKey}     - Array of ICacheGetData items whose values need to be deleted from cache\n     * @return          {boolean}       - returns true if the cache key is deleted successfully. Does not throw errors.\n     */\n    public del(cacheKey: ICacheKey): boolean {\n        return this.nodeCache.del(this._computeCacheKey(cacheKey)) === 1;\n    }\n\n    /**\n     * @function    {keys}              - Method to fetch all the keys in the cache\n     * @return      {string[]}          - returns a list of all the keys in the cache\n     */\n    public keys(): string[] {\n        return this.nodeCache.keys();\n    }\n\n    /**\n     * @function    {flushAll}          - Method to flush all data from the cache\n     */\n    public flushAll(): void {\n        this.nodeCache.flushAll();\n    }\n\n    private _computeCacheKey(key: ICacheKey): string {\n        if (!key.typeName) {\n            throw new Error(`Invalid type (${key.typeName}) - Could not create cache key`);\n        }\n\n        return `${key.typeName}-${key.key}`.toUpperCase();\n    }\n\n    private _validateCacheKey(cacheKey: ICacheKey): void {\n        if (!cacheKey) {\n            throw new Error(`Invalid cacheKey: ${cacheKey}`);\n        }\n\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);\n        }\n    }\n\n    private _getTTR(typeName: string): number {\n        if (this.settings) {\n            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {\n                return this.settings.ttrInSeconds[typeName];\n            }\n\n            if (this.settings.defaultTTRInSeconds) {\n                return this.settings.defaultTTRInSeconds;\n            }\n        }\n\n        return DEFAULT_CACHE_TTR;\n    }\n\n    private _getTTL(typeName: string): number {\n        return this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]\n            ? this.settings.ttlInSeconds[typeName]\n            : DEFAULT_CACHE_TTL;\n    }\n\n    private _setRefresh(requestContext: IRequestContext): void {\n        const actionTimout = Number(requestContext.query && requestContext.query.actionTimeout) || undefined;\n        this.refreshTimeout = actionTimout ? actionTimout : defaultTimeoutInMS;\n    }\n\n    private _isRefreshExpired(cacheItemInternal: ICacheItemInternal<unknown>, currentTime: Number): boolean {\n        if (!cacheItemInternal.refreshStartTimeInMS) {\n            return false;\n        }\n        return cacheItemInternal.refreshStartTimeInMS + this.refreshTimeout * 2 < currentTime;\n    }\n}\n"]}
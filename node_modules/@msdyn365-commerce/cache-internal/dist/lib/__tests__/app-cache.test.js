/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import 'jest';
import { observable } from 'mobx';
import { AppCache } from '../app-cache';
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
describe('Validate app cache put', () => {
    // cache settings are normalized to uppercase. Please check platformutils: getCacheSettings() for implementation
    const cache = new AppCache({
        ttlInSeconds: { SHOES: -1 },
        ttrInSeconds: { FASHION: -1, CATEGORY: 2 },
        checkPeriodInSeconds: 600,
        defaultTTRInSeconds: 10
    });
    it('Should insert values in app cache', () => {
        cache.put({ key: '1234567', typeName: 'electronics' }, {
            item: {
                camera: {
                    features: ['Flash', 'Video'],
                    primary: '5.0 megapixels'
                }
            },
            shouldRefresh: true
        });
        const cacheKey = { key: '1234567', typeName: 'electronics' };
        expect(cache.get(cacheKey)).toMatchObject({
            item: {
                camera: {
                    features: ['Flash', 'Video'],
                    primary: '5.0 megapixels'
                }
            },
            shouldRefresh: true
        });
    });
    it('validate put/get/del of string typeName', () => {
        const cacheKey = { key: '99999', typeName: 'string' };
        cache.put(cacheKey, { item: 'string' });
        expect(cache.getValue(cacheKey)).toEqual('string');
        expect(cache.del(cacheKey)).toBeTruthy();
    });
    it('validate put/get/del of number typeName', () => {
        const cacheKey = { key: '99999', typeName: 'number' };
        cache.put(cacheKey, { item: 0 });
        expect(cache.getValue(cacheKey)).toEqual(0);
        expect(cache.del(cacheKey)).toBeTruthy();
    });
    it('validate put/get/del of boolean typeName', () => {
        const cacheKey = { key: '99999', typeName: 'boolean' };
        cache.put(cacheKey, { item: false });
        expect(cache.getValue(cacheKey)).toEqual(false);
        expect(cache.del(cacheKey)).toBeTruthy();
    });
    it('validate put/get/del of null', () => {
        const cacheKey = { key: '99999', typeName: 'null' };
        cache.put(cacheKey, { item: null });
        expect(cache.getValue(cacheKey)).toBeNull();
        expect(cache.del(cacheKey)).toBeTruthy();
    });
    it('validate put/get/del of undefined', () => {
        const cacheKey = { key: '99999', typeName: 'undefined' };
        cache.put(cacheKey, { item: undefined });
        expect(cache.getValue(cacheKey)).toBeUndefined();
        expect(cache.del(cacheKey)).toBeTruthy();
    });
    it('Should return stale data when ttr expires', () => {
        const cacheKey = { key: '1234567', typeName: 'fashion' };
        cache.put(cacheKey, {
            item: {
                camera: {
                    features: ['Summer wear'],
                    primary: 'old navy'
                }
            }
        });
        const cachedItem = cache.get(cacheKey);
        expect(cachedItem && cachedItem.shouldRefresh).toEqual(true);
    });
    it('Should return undefined when ttl expires', () => {
        cache.put({ key: '1234567', typeName: 'shoes' }, { item: 'athletic' });
        const cacheKey = { key: '1234567', typeName: 'shoes' };
        expect(cache.get(cacheKey)).toBeUndefined();
    });
    it('Should return all keys in the cache', () => {
        cache.put({ key: '1234568', typeName: 'electronics' }, {
            item: {
                camera: {
                    features: ['Flash', 'Video'],
                    primary: '8.0 megapixels'
                }
            }
        });
        expect(cache.keys()).toEqual(['ELECTRONICS-1234567', 'FASHION-1234567', 'ELECTRONICS-1234568']);
    });
    it('Should delete value from app cache', () => {
        const cacheKey = { key: '987654321', typeName: 'electronics' };
        cache.put({ key: '987654321', typeName: 'electronics' }, {
            item: {
                camera: {
                    features: ['Flash', 'Video'],
                    primary: '9.0 megapixels'
                }
            }
        });
        expect(cache.del(cacheKey)).toBeTruthy();
        expect(cache.get(cacheKey)).toBeUndefined();
    });
    it('Should flush all values from app cache', () => {
        cache.flushAll();
        expect(cache.get({ key: '1234567', typeName: 'electronics' })).toBeUndefined();
        expect(cache.get({ key: '1234568', typeName: 'electronics' })).toBeUndefined();
    });
    it('should fallback to default ttr if ttr is not specified', () => {
        const cacheKey = { key: '99999', typeName: 'boolean' };
        const expectedExpirtyTime = new Date();
        expectedExpirtyTime.setSeconds(expectedExpirtyTime.getSeconds() + 10);
        cache.put(cacheKey, { item: false });
        const cachedItem = cache.get(cacheKey);
        // @ts-ignore
        expect(expectedExpirtyTime.toUTCString()).toEqual(new Date(cachedItem.expireAtInTimeMilliseconds).toUTCString());
    });
    it('Insert an mobx observable item and retrive the same', () => {
        const cacheKey = { key: '987654321', typeName: 'mobx-object' };
        const cacheItem = observable([
            {
                RecordId: '12345'
            }
        ]);
        cache.put(cacheKey, { item: cacheItem });
        const cachedItem = cache.get(cacheKey);
        expect(cachedItem).not.toBeUndefined();
        expect(cachedItem && cachedItem.item).toEqual([{ RecordId: '12345' }]);
    });
    it('Inserts an AsyncResult and retireves the same', async () => {
        const cacheKey = { key: '1', typeName: 'observable-promise' };
        const cacheItem = new AsyncResult(resolve => {
            resolve('foo');
        });
        cache.put(cacheKey, { item: cacheItem });
        // tslint:disable-next-line
        await cacheItem;
        const cachedItem = cache.getValue(cacheKey);
        expect(cacheItem instanceof AsyncResult).toBe(true);
        expect(cachedItem instanceof AsyncResult).toBe(true);
        expect(cacheItem).toBe(cachedItem);
    });
    it('Can handle observable AsyncResults', async () => {
        const cacheKey = { key: '1', typeName: 'observable-promise' };
        const cacheItem = observable(new AsyncResult(resolve => {
            resolve('foo');
        }));
        cache.put(cacheKey, { item: cacheItem });
        // tslint:disable-next-line
        await cacheItem;
        const cachedItem = cache.getValue(cacheKey);
        expect(cacheItem instanceof AsyncResult).toBe(true);
        expect(cachedItem instanceof AsyncResult).toBe(true);
    });
    // tslint:disable-next-line:mocha-avoid-only
    it('Should return the cache value in case if the item is in refreshing state', async (done) => {
        jest.setTimeout(20000);
        const cacheKey = { key: '12345', typeName: 'Category' };
        cache.put(cacheKey, { item: 'Shirts' });
        expect(cache.get(cacheKey).shouldRefresh).toBeUndefined();
        setTimeout(() => {
            // shouldRefresh to be true if the ttr expired
            expect(cache.get(cacheKey).shouldRefresh).toBeTruthy();
            // subsequent requests should get the item in cache with shouldRefresh: undefined
            const value = cache.get(cacheKey);
            expect(value.item).toEqual('Shirts');
            expect(cache.get(cacheKey).shouldRefresh).toBeUndefined();
        }, 2000);
        setTimeout(() => {
            // shoulRefresh to be true if the item is in isRefreshing state refresh expired.
            expect(cache.get(cacheKey).shouldRefresh).toBeTruthy();
            // shouldRefresh to be undefined in subsequent request.
            expect(cache.get(cacheKey).shouldRefresh).toBeUndefined();
            done();
        }, 15000);
    });
});
//# sourceMappingURL=app-cache.test.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { METRIC_APP_CACHE_INSERT, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { isObservable, toJS } from 'mobx';
import NodeCache from 'node-cache';
import { normalizeCacheKey } from './cache-utils';
import { ICacheSource } from './ICache';
/**
 * DEFAULT cache time to live value in seconds
 */
const defaultTimeoutInMS = 5000;
/**
 * DEFAULT cache time to live value in seconds
 */
const DEFAULT_CACHE_TTL = 600;
/**
 * DEFAULT cache time to refresh value in seconds
 */
const DEFAULT_CACHE_TTR = 60;
/**
 * Default cache check period(in seconds) to check if ttl of any cache items expired
 */
const DEFAULT_CHECK_PERIOD = 600;
/**
 * Server app cache implementation
 */
export class AppCache {
    constructor(settings) {
        this.settings = {};
        this.refreshTimeout = defaultTimeoutInMS;
        this.settings = settings || {};
        this.nodeCache = new NodeCache({
            checkperiod: settings.checkPeriodInSeconds || DEFAULT_CHECK_PERIOD,
            stdTTL: settings.defaultTTLInSeconds || DEFAULT_CACHE_TTL,
            // TODO - RAVI check if we can utilitze this to support native clone from node-cache
            useClones: false
        });
        this.entityKeys = {};
    }
    /**
     * @function        {setRefresh}               - Method to insert an item in the cache
     * @param requestContext  {requestContext}     - requestContext
     */
    setRequestContext(requestContext) {
        this.requestContext = requestContext;
        this._setRefresh(this.requestContext);
    }
    /**
     * @function        {getCacheEntries}          - Method to get cache entries
     */
    getCacheEntries() {
        const cacheEntriesSet = [];
        if (this.settings.ttlInSeconds) {
            Object.keys(this.settings.ttlInSeconds).forEach(key => {
                cacheEntriesSet.push(key);
            });
        }
        if (this.settings.ttrInSeconds) {
            Object.keys(this.settings.ttrInSeconds).forEach(key => {
                cacheEntriesSet.push(key);
            });
        }
        cacheEntriesSet.filter((item, index) => cacheEntriesSet.indexOf(item) === index);
        return cacheEntriesSet;
    }
    /**
     * @function        {put}           - Method to insert an item in the cache
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache
     */
    put(cacheKey, item) {
        this._validateCacheKey(cacheKey);
        item.s = item.s !== undefined ? item.s : ICacheSource.AppCache;
        // App-cache is unable to store loading AsyncResults correctly
        // we need to wait for the promise to resolve, and then store the resolved promise
        if (isAsyncResult(item.item) && item.item.status === 'LOADING') {
            item.item.then(() => {
                this.put(cacheKey, item);
            });
            return true;
        }
        // node-cache returns observable objects as []
        // therefore, lets save the pure js version of the same
        if (item && isObservable(item.item)) {
            const timerId = `app-cache - ${cacheKey.typeName}`;
            StaticTelemetry.startTimer(timerId);
            if (!isAsyncResult(item.item)) {
                item.item = toJS(item.item);
            }
            StaticTelemetry.trackMetric(METRIC_APP_CACHE_INSERT, StaticTelemetry.stopTimer(timerId));
        }
        cacheKey = normalizeCacheKey(cacheKey);
        const ttl = this._getTTL(cacheKey.typeName);
        const ttr = this._getTTR(cacheKey.typeName);
        const computedCacheKey = this._computeCacheKey(cacheKey);
        const expiryTime = new Date();
        expiryTime.setSeconds(expiryTime.getSeconds() + ttr);
        // update the cache entity without resetting TTL
        const prevTtl = this.nodeCache.getTtl(computedCacheKey);
        let cacheItem;
        if (prevTtl) {
            cacheItem = {
                expireAtInTimeMilliseconds: expiryTime.getTime(),
                ...item
            };
            // reset isRefreshing to false before the refresh entity write to the cache.
            const newTtl = prevTtl - Date.now();
            return this.nodeCache.set(computedCacheKey, cacheItem, newTtl / 1000);
        }
        cacheItem = {
            expireAtInTimeMilliseconds: expiryTime.getTime(),
            ...item
        };
        this.entityKeys[cacheKey.typeName] = this.entityKeys[cacheKey.typeName] || {};
        this.entityKeys[cacheKey.typeName][computedCacheKey] = true;
        return this.nodeCache.set(computedCacheKey, cacheItem, ttl);
    }
    /**
     * @function        {get<T>}        - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {ICacheItem<T>} - cached value against the given cache key
     */
    get(cacheKey) {
        this._validateCacheKey(cacheKey);
        const preparedCacheKey = this._computeCacheKey(cacheKey);
        const cacheItemInternal = this.nodeCache.get(preparedCacheKey);
        if (!cacheItemInternal) {
            return undefined;
        }
        if (!cacheItemInternal.expireAtInTimeMilliseconds || cacheItemInternal.shouldRefresh) {
            return { ...cacheItemInternal };
        }
        const now = Date.now();
        if (cacheItemInternal.expireAtInTimeMilliseconds < now) {
            if (!cacheItemInternal.isRefreshing) {
                cacheItemInternal.isRefreshing = true;
                cacheItemInternal.refreshStartTimeInMS = now;
                return { ...cacheItemInternal, ...{ shouldRefresh: true } };
            }
            else if (this._isRefreshExpired(cacheItemInternal, now)) {
                // If the data's refresh timout then let the next subsequent caller
                // know that they have to refresh the data
                cacheItemInternal.refreshStartTimeInMS = now;
                return { ...cacheItemInternal, ...{ shouldRefresh: true } };
            }
        }
        return { ...cacheItemInternal };
    }
    /**
     * @function        {getAllItems}   - Method to get all cached items for a given type
     * @param typeName  {typeName}      - typeName for which all items need to be fetched
     * @return          {ICacheItem}    - dictionary of cache items of the given typeName
     */
    getAllItems(typeName) {
        if (typeName === '') {
            throw new Error('typeName cannot be empty');
        }
        const cacheKeys = this.entityKeys[typeName.toUpperCase()];
        const currentTimestamp = Date.now();
        if (cacheKeys) {
            const cacheItems = this.nodeCache.mget(Object.keys(cacheKeys));
            const response = {};
            Object.keys(cacheItems)
                .filter(key => !!cacheItems[key])
                .map(key => {
                if (cacheItems[key].expireAtInTimeMilliseconds > currentTimestamp) {
                    response[key] = {
                        ...cacheItems[key],
                        shouldRefresh: true
                    };
                }
            });
            return response;
        }
        return undefined;
    }
    /**
     * @function        {hasCacheSetting}   - tells if there is a cache setting defined for the given entity type
     * @param typeName  {typeName}          - typeName for which all items need to be fetched
     * @return          {boolean}           - true if a cache setting ttr/ttl is specified for the given entity
     */
    hasCacheSetting(typeName) {
        if (typeName === '') {
            throw new Error('typeName cannot be empty');
        }
        typeName = typeName.toUpperCase();
        if (this.settings) {
            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {
                return !!this.settings.ttrInSeconds[typeName];
            }
            if (this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]) {
                return !!this.settings.ttlInSeconds[typeName];
            }
        }
        return false;
    }
    /**
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param toCache   {ICache}        - cache object to which the item needs to be copied
     * @return          {ICacheItem}    - cache item that was copied
     */
    copyTo(cacheKey, toCache) {
        const cachedItem = this.get(cacheKey);
        if (cachedItem) {
            toCache.put(cacheKey, { item: cachedItem.item, s: ICacheSource.AppCache });
            return cachedItem;
        }
        return undefined;
    }
    /**
     * @function        {getValue<T>}   - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {ICacheItem<T>} - cached value against the given cache key
     */
    getValue(cacheKey) {
        const cachedItem = this.get(cacheKey);
        return cachedItem ? cachedItem.item : undefined;
    }
    /**
     * @function        {del}           - Method to delete an item from the cache
     * @param cacheKey  {ICacheKey}     - Array of ICacheGetData items whose values need to be deleted from cache
     * @return          {boolean}       - returns true if the cache key is deleted successfully. Does not throw errors.
     */
    del(cacheKey) {
        return this.nodeCache.del(this._computeCacheKey(cacheKey)) === 1;
    }
    /**
     * @function    {keys}              - Method to fetch all the keys in the cache
     * @return      {string[]}          - returns a list of all the keys in the cache
     */
    keys() {
        return this.nodeCache.keys();
    }
    /**
     * @function    {flushAll}          - Method to flush all data from the cache
     */
    flushAll() {
        this.nodeCache.flushAll();
    }
    _computeCacheKey(key) {
        if (!key.typeName) {
            throw new Error(`Invalid type (${key.typeName}) - Could not create cache key`);
        }
        return `${key.typeName}-${key.key}`.toUpperCase();
    }
    _validateCacheKey(cacheKey) {
        if (!cacheKey) {
            throw new Error(`Invalid cacheKey: ${cacheKey}`);
        }
        if (!cacheKey.typeName) {
            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);
        }
    }
    _getTTR(typeName) {
        if (this.settings) {
            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {
                return this.settings.ttrInSeconds[typeName];
            }
            if (this.settings.defaultTTRInSeconds) {
                return this.settings.defaultTTRInSeconds;
            }
        }
        return DEFAULT_CACHE_TTR;
    }
    _getTTL(typeName) {
        return this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]
            ? this.settings.ttlInSeconds[typeName]
            : DEFAULT_CACHE_TTL;
    }
    _setRefresh(requestContext) {
        const actionTimout = Number(requestContext.query && requestContext.query.actionTimeout) || undefined;
        this.refreshTimeout = actionTimout ? actionTimout : defaultTimeoutInMS;
    }
    _isRefreshExpired(cacheItemInternal, currentTime) {
        if (!cacheItemInternal.refreshStartTimeInMS) {
            return false;
        }
        return cacheItemInternal.refreshStartTimeInMS + this.refreshTimeout * 2 < currentTime;
    }
}
//# sourceMappingURL=app-cache.js.map
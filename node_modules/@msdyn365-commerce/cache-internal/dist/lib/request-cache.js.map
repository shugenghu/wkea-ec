{"version":3,"file":"request-cache.js","sourceRoot":"","sources":["../../src/request-cache.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAGH,OAAO,EAAE,aAAa,EAAE,MAAM,iCAAiC,CAAC;AAChE,OAAO,EAAE,UAAU,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,MAAM,CAAC;AACpD,OAAO,EAAE,iBAAiB,EAAE,MAAM,eAAe,CAAC;AAClD,OAAO,EAAiC,YAAY,EAAE,MAAM,UAAU,CAAC;AAEvE;;GAEG;AACH,MAAM,OAAO,YAAY;IAAzB;QACY,kBAAa,GAA6D,EAAE,CAAC;IA2IzF,CAAC;IAzIG;;;;OAIG;IACI,GAAG,CAAc,QAAmB,EAAE,IAAmB;QAC5D,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,iBAAiB,QAAQ,CAAC,QAAQ,aAAa,CAAC,CAAC;SACpE;QAED,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;YACf,MAAM,IAAI,KAAK,CAAC,gBAAgB,QAAQ,CAAC,GAAG,aAAa,CAAC,CAAC;SAC9D;QAED,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,YAAY,CAAC;QACnE,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACtD,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;YAC5C,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;SACrC;QACD,OAAO,WAAW,CAAU,GAAG,EAAE;YAC7B,IAAI,SAAS,GAAiC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;YAEhF,gDAAgD;YAChD,IAAI,SAAS,IAAI,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;gBAC5C,IAAI,SAAS,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;oBACrC,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;iBAC5C;gBACD,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBACzC,gGAAgG;gBAChG,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;aAC5C;iBAAM,IAAI,SAAS,EAAE;gBAClB,GAAG,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACrC;iBAAM;gBACH,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBAC3B,SAAS,GAAG,UAAU,CAAgB,EAAE,GAAG,IAAI,EAAE,EAAE,SAAS,EAAE;wBAC1D,IAAI,EAAE,IAAI;wBACV,IAAI,EAAE,KAAK,QAAQ,MAAM,GAAG,EAAE;qBACjC,CAAC,CAAC;iBACN;qBAAM;oBACH,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;aACjD;YAED,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IACI,GAAG,CAAc,QAAmB;QACvC,IAAI,CAAC,QAAQ,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,qBAAqB,QAAQ,EAAE,CAAC,CAAC;SACpD;QAED,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,0BAA0B,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;SAClE;QAED,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACvC,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAgB,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAClI,CAAC;IAED;;;;OAIG;IACI,WAAW,CAAc,QAAgB;QAC5C,IAAI,CAAC,QAAQ,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC/C;QAED,OAAmC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;IAClF,CAAC;IAED;;;;OAIG;IACI,QAAQ,CAAc,QAAmB;QAC5C,MAAM,UAAU,GAA8B,IAAI,CAAC,GAAG,CAAI,QAAQ,CAAC,CAAC;QACpE,OAAO,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAI,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAC/D,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAc,QAAmB,EAAE,OAAe;QAC3D,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACvC,CAAC;IAED;;;;OAIG;IACI,GAAG,CAAC,QAAmB;QAC1B,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACvC,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACxD,IAAI,SAAS,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtC,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC/B,OAAO,IAAI,CAAC;SACf;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAED;;OAEG;IACI,QAAQ;QACX,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACI,IAAI;QACP,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC3C,CAAC;IAED;;;;OAIG;IACK,MAAM,CAAI,IAAmB;QACjC,OAAO,IAAI,CAAC,IAAI,CAAC;IACrB,CAAC;CACJ","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IDictionary } from '@msdyn365-commerce/core-internal';\nimport { isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { observable, set, transaction } from 'mobx';\nimport { normalizeCacheKey } from './cache-utils';\nimport { ICache, ICacheItem, ICacheKey, ICacheSource } from './ICache';\n\n/**\n * Client cache implementation\n */\nexport class RequestCache implements ICache {\n    private internalCache: { [typeName: string]: IDictionary<ICacheItem<unknown>> } = {};\n\n    /**\n     * @function        {put}           - Method to insert an item in the cache\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\n     */\n    public put<T = unknown>(cacheKey: ICacheKey, item: ICacheItem<T>): boolean {\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid type (${cacheKey.typeName} specified)`);\n        }\n\n        if (!cacheKey.key) {\n            throw new Error(`Invalid key (${cacheKey.key} specified)`);\n        }\n\n        item.s = item.s !== undefined ? item.s : ICacheSource.RequestCache;\n        const { typeName, key } = normalizeCacheKey(cacheKey);\n        if (this.internalCache[typeName] === undefined) {\n            this.internalCache[typeName] = {};\n        }\n        return transaction<boolean>(() => {\n            let cacheItem: ICacheItem<T> = <ICacheItem<T>>this.internalCache[typeName][key];\n\n            // For updating AsyncResults, only update result\n            if (cacheItem && isAsyncResult(cacheItem.item)) {\n                if (cacheItem.item.status !== 'LOADING') {\n                    set(cacheItem.item, 'status', 'LOADING');\n                }\n                set(cacheItem.item, 'result', item.item);\n                // Auto resolve promises whos result is being set, as they are essentially being force-completed\n                set(cacheItem.item, 'status', 'SUCCESS');\n            } else if (cacheItem) {\n                set(cacheItem, 'item', item.item);\n            } else {\n                if (!isAsyncResult(item.item)) {\n                    cacheItem = observable<ICacheItem<T>>({ ...item }, undefined, {\n                        deep: true,\n                        name: `T:${typeName}_K:${key}`\n                    });\n                } else {\n                    cacheItem = item;\n                }\n                this.internalCache[typeName][key] = cacheItem;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * @function        {get}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public get<T = unknown>(cacheKey: ICacheKey): ICacheItem<T> | undefined {\n        if (!cacheKey) {\n            throw new Error(`Invalid cacheKey: ${cacheKey}`);\n        }\n\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);\n        }\n\n        cacheKey = normalizeCacheKey(cacheKey);\n        return this.internalCache[cacheKey.typeName] ? <ICacheItem<T>>this.internalCache[cacheKey.typeName][cacheKey.key] : undefined;\n    }\n\n    /**\n     * @function        {get}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public getAllItems<T = unknown>(typeName: string): IDictionary<ICacheItem<T>> | undefined {\n        if (!typeName) {\n            throw new Error(`typeName cannot be empty`);\n        }\n\n        return <IDictionary<ICacheItem<T>>>this.internalCache[typeName.toUpperCase()];\n    }\n\n    /**\n     * @function        {getValue}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public getValue<T = unknown>(cacheKey: ICacheKey): T | undefined {\n        const cachedItem: ICacheItem<T> | undefined = this.get<T>(cacheKey);\n        return cachedItem ? this._value<T>(cachedItem) : undefined;\n    }\n\n    /**\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\n     * @return          {ICacheItem}    - cache item that was copied\n     */\n    public copyTo<T = unknown>(cacheKey: ICacheKey, toCache: ICache): ICacheItem<T> | undefined {\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * @function    {del}               - Method to delete an item from the cache\n     * @param key   {ICacheKey}       - Array of ICacheGetData items whose values need to be deleted from cache\n     * @return      {number}            - returns true if the cache key is deleted successfully. Does not throw errors.\n     */\n    public del(cacheKey: ICacheKey): boolean {\n        cacheKey = normalizeCacheKey(cacheKey);\n        const cacheType = this.internalCache[cacheKey.typeName];\n        if (cacheType && cacheType[cacheKey.key]) {\n            delete cacheType[cacheKey.key];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @function    {flushAll}          - Method to flush all data from the cache\n     */\n    public flushAll(): void {\n        this.internalCache = {};\n    }\n\n    /**\n     * @function    {keys}              - Method to fetch all the keys in the cache\n     * @return      {string[]}          - returns a list of all the keys in the cache\n     */\n    public keys(): string[] {\n        return Object.keys(this.internalCache);\n    }\n\n    /**\n     * Get the value out of a cache item\n     * This returns the raw value of the item, it will *not* be a MobX observable value\n     * @param item The observable cache item to retireve the value from\n     */\n    private _value<T>(item: ICacheItem<T>): T {\n        return item.item;\n    }\n}\n"]}
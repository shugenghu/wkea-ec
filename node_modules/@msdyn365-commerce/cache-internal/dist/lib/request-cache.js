/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
import { isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { observable, set, transaction } from 'mobx';
import { normalizeCacheKey } from './cache-utils';
import { ICacheSource } from './ICache';
/**
 * Client cache implementation
 */
export class RequestCache {
    constructor() {
        this.internalCache = {};
    }
    /**
     * @function        {put}           - Method to insert an item in the cache
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache
     */
    put(cacheKey, item) {
        if (!cacheKey.typeName) {
            throw new Error(`Invalid type (${cacheKey.typeName} specified)`);
        }
        if (!cacheKey.key) {
            throw new Error(`Invalid key (${cacheKey.key} specified)`);
        }
        item.s = item.s !== undefined ? item.s : ICacheSource.RequestCache;
        const { typeName, key } = normalizeCacheKey(cacheKey);
        if (this.internalCache[typeName] === undefined) {
            this.internalCache[typeName] = {};
        }
        return transaction(() => {
            let cacheItem = this.internalCache[typeName][key];
            // For updating AsyncResults, only update result
            if (cacheItem && isAsyncResult(cacheItem.item)) {
                if (cacheItem.item.status !== 'LOADING') {
                    set(cacheItem.item, 'status', 'LOADING');
                }
                set(cacheItem.item, 'result', item.item);
                // Auto resolve promises whos result is being set, as they are essentially being force-completed
                set(cacheItem.item, 'status', 'SUCCESS');
            }
            else if (cacheItem) {
                set(cacheItem, 'item', item.item);
            }
            else {
                if (!isAsyncResult(item.item)) {
                    cacheItem = observable({ ...item }, undefined, {
                        deep: true,
                        name: `T:${typeName}_K:${key}`
                    });
                }
                else {
                    cacheItem = item;
                }
                this.internalCache[typeName][key] = cacheItem;
            }
            return true;
        });
    }
    /**
     * @function        {get}           - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {IAny}          - cached value against the given cache key
     */
    get(cacheKey) {
        if (!cacheKey) {
            throw new Error(`Invalid cacheKey: ${cacheKey}`);
        }
        if (!cacheKey.typeName) {
            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);
        }
        cacheKey = normalizeCacheKey(cacheKey);
        return this.internalCache[cacheKey.typeName] ? this.internalCache[cacheKey.typeName][cacheKey.key] : undefined;
    }
    /**
     * @function        {get}           - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {IAny}          - cached value against the given cache key
     */
    getAllItems(typeName) {
        if (!typeName) {
            throw new Error(`typeName cannot be empty`);
        }
        return this.internalCache[typeName.toUpperCase()];
    }
    /**
     * @function        {getValue}           - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {IAny}          - cached value against the given cache key
     */
    getValue(cacheKey) {
        const cachedItem = this.get(cacheKey);
        return cachedItem ? this._value(cachedItem) : undefined;
    }
    /**
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param toCache   {ICache}        - cache object to which the item needs to be copied
     * @return          {ICacheItem}    - cache item that was copied
     */
    copyTo(cacheKey, toCache) {
        throw new Error('Not Implemented');
    }
    /**
     * @function    {del}               - Method to delete an item from the cache
     * @param key   {ICacheKey}       - Array of ICacheGetData items whose values need to be deleted from cache
     * @return      {number}            - returns true if the cache key is deleted successfully. Does not throw errors.
     */
    del(cacheKey) {
        cacheKey = normalizeCacheKey(cacheKey);
        const cacheType = this.internalCache[cacheKey.typeName];
        if (cacheType && cacheType[cacheKey.key]) {
            delete cacheType[cacheKey.key];
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @function    {flushAll}          - Method to flush all data from the cache
     */
    flushAll() {
        this.internalCache = {};
    }
    /**
     * @function    {keys}              - Method to fetch all the keys in the cache
     * @return      {string[]}          - returns a list of all the keys in the cache
     */
    keys() {
        return Object.keys(this.internalCache);
    }
    /**
     * Get the value out of a cache item
     * This returns the raw value of the item, it will *not* be a MobX observable value
     * @param item The observable cache item to retireve the value from
     */
    _value(item) {
        return item.item;
    }
}
//# sourceMappingURL=request-cache.js.map
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import { IDictionary, IRequestContext } from '@msdyn365-commerce/core-internal';
import { isAsyncResult } from '@msdyn365-commerce/retail-proxy';
import { METRIC_APP_CACHE_INSERT, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';
import { isObservable, toJS } from 'mobx';
import NodeCache from 'node-cache';
import { normalizeCacheKey } from './cache-utils';
import { ICache, ICacheItem, ICacheKey, ICacheSource } from './ICache';
import { ICacheSettings } from './ICacheSettings';

/**
 * DEFAULT cache time to live value in seconds
 */
const defaultTimeoutInMS: number = 5000;

/**
 * DEFAULT cache time to live value in seconds
 */
const DEFAULT_CACHE_TTL: number = 600;

/**
 * DEFAULT cache time to refresh value in seconds
 */
const DEFAULT_CACHE_TTR: number = 60;

/**
 * Default cache check period(in seconds) to check if ttl of any cache items expired
 */
const DEFAULT_CHECK_PERIOD: number = 600;

interface ICacheItemInternal<T> extends ICacheItem<T> {
    /**
     * Timestamp in milliseconds at which the cache key gets expired and will cause appcache
     * to set shouldRefresh property of the expired item to true - indicating that the data should be refreshed
     */
    expireAtInTimeMilliseconds: number;

    /**
     * Flag to track the loading state internally so that when the cache item is refreshing, it will return the current value for the given cache key
     */
    isRefreshing?: boolean;
    /**
     * Flag to track the when the item start refreshing.
     */
    refreshStartTimeInMS?: number;
}

/**
 * Server app cache implementation
 */
export class AppCache implements ICache {
    public nodeCache: NodeCache;

    private entityKeys: IDictionary<IDictionary<boolean>>;

    private settings: ICacheSettings = {};

    private refreshTimeout: number = defaultTimeoutInMS;

    private requestContext?: IRequestContext;

    public constructor(settings: ICacheSettings) {
        this.settings = settings || {};
        this.nodeCache = new NodeCache({
            checkperiod: settings.checkPeriodInSeconds || DEFAULT_CHECK_PERIOD,
            stdTTL: settings.defaultTTLInSeconds || DEFAULT_CACHE_TTL,
            // TODO - RAVI check if we can utilitze this to support native clone from node-cache
            useClones: false
        });
        this.entityKeys = {};
    }

    /**
     * @function        {setRefresh}               - Method to insert an item in the cache
     * @param requestContext  {requestContext}     - requestContext
     */
    public setRequestContext(requestContext: IRequestContext): void {
        this.requestContext = requestContext;
        this._setRefresh(this.requestContext);
    }

    /**
     * @function        {getCacheEntries}          - Method to get cache entries
     */
    public getCacheEntries(): string[] {
        const cacheEntriesSet: string[] = [];
        if (this.settings.ttlInSeconds) {
            Object.keys(this.settings.ttlInSeconds).forEach(key => {
                cacheEntriesSet.push(key);
            });
        }
        if (this.settings.ttrInSeconds) {
            Object.keys(this.settings.ttrInSeconds).forEach(key => {
                cacheEntriesSet.push(key);
            });
        }
        cacheEntriesSet.filter((item, index) => cacheEntriesSet.indexOf(item) === index);
        return cacheEntriesSet;
    }

    /**
     * @function        {put}           - Method to insert an item in the cache
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache
     */
    public put<T = unknown>(cacheKey: ICacheKey, item: ICacheItem<T>): boolean {
        this._validateCacheKey(cacheKey);
        item.s = item.s !== undefined ? item.s : ICacheSource.AppCache;

        // App-cache is unable to store loading AsyncResults correctly
        // we need to wait for the promise to resolve, and then store the resolved promise
        if (isAsyncResult(item.item) && item.item.status === 'LOADING') {
            item.item.then(() => {
                this.put(cacheKey, item);
            });
            return true;
        }
        // node-cache returns observable objects as []
        // therefore, lets save the pure js version of the same
        if (item && isObservable(item.item)) {
            const timerId = `app-cache - ${cacheKey.typeName}`;
            StaticTelemetry.startTimer(timerId);
            if (!isAsyncResult(item.item)) {
                item.item = toJS<T>(item.item);
            }
            StaticTelemetry.trackMetric(METRIC_APP_CACHE_INSERT, StaticTelemetry.stopTimer(timerId));
        }

        cacheKey = normalizeCacheKey(cacheKey);

        const ttl = this._getTTL(cacheKey.typeName);
        const ttr = this._getTTR(cacheKey.typeName);
        const computedCacheKey = this._computeCacheKey(cacheKey);
        const expiryTime = new Date();
        expiryTime.setSeconds(expiryTime.getSeconds() + ttr);

        // update the cache entity without resetting TTL
        const prevTtl = this.nodeCache.getTtl(computedCacheKey);
        let cacheItem: ICacheItemInternal<T>;
        if (prevTtl) {
            cacheItem = {
                expireAtInTimeMilliseconds: expiryTime.getTime(),
                ...item
            };
            // reset isRefreshing to false before the refresh entity write to the cache.
            const newTtl = prevTtl - Date.now();
            return this.nodeCache.set(computedCacheKey, cacheItem, newTtl / 1000);
        }
        cacheItem = {
            expireAtInTimeMilliseconds: expiryTime.getTime(),
            ...item
        };

        this.entityKeys[cacheKey.typeName] = this.entityKeys[cacheKey.typeName] || {};
        this.entityKeys[cacheKey.typeName][computedCacheKey] = true;

        return this.nodeCache.set(computedCacheKey, cacheItem, ttl);
    }

    /**
     * @function        {get<T>}        - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {ICacheItem<T>} - cached value against the given cache key
     */
    public get<T = unknown>(cacheKey: ICacheKey): ICacheItem<T> | undefined {
        this._validateCacheKey(cacheKey);
        const preparedCacheKey = this._computeCacheKey(cacheKey);
        const cacheItemInternal = <ICacheItemInternal<T>>this.nodeCache.get(preparedCacheKey);

        if (!cacheItemInternal) {
            return undefined;
        }

        if (!cacheItemInternal.expireAtInTimeMilliseconds || cacheItemInternal.shouldRefresh) {
            return { ...cacheItemInternal };
        }

        const now = Date.now();
        if (cacheItemInternal.expireAtInTimeMilliseconds < now) {
            if (!cacheItemInternal.isRefreshing) {
                cacheItemInternal.isRefreshing = true;
                cacheItemInternal.refreshStartTimeInMS = now;
                return { ...cacheItemInternal, ...{ shouldRefresh: true } };
            } else if (this._isRefreshExpired(cacheItemInternal, now)) {
                // If the data's refresh timout then let the next subsequent caller
                // know that they have to refresh the data
                cacheItemInternal.refreshStartTimeInMS = now;
                return { ...cacheItemInternal, ...{ shouldRefresh: true } };
            }
        }

        return <ICacheItem<T>>{ ...cacheItemInternal };
    }

    /**
     * @function        {getAllItems}   - Method to get all cached items for a given type
     * @param typeName  {typeName}      - typeName for which all items need to be fetched
     * @return          {ICacheItem}    - dictionary of cache items of the given typeName
     */
    public getAllItems<T = unknown>(typeName: string): IDictionary<ICacheItem<T>> | undefined {
        if (typeName === '') {
            throw new Error('typeName cannot be empty');
        }

        const cacheKeys = this.entityKeys[typeName.toUpperCase()];
        const currentTimestamp = Date.now();
        if (cacheKeys) {
            const cacheItems = this.nodeCache.mget<ICacheItemInternal<T>>(Object.keys(cacheKeys));
            const response: IDictionary<ICacheItem<T>> = {};
            Object.keys(cacheItems)
                .filter(key => !!cacheItems[key])
                .map(key => {
                    if (cacheItems[key].expireAtInTimeMilliseconds > currentTimestamp) {
                        response[key] = {
                            ...cacheItems[key],
                            shouldRefresh: true
                        };
                    }
                });

            return response;
        }

        return undefined;
    }

    /**
     * @function        {hasCacheSetting}   - tells if there is a cache setting defined for the given entity type
     * @param typeName  {typeName}          - typeName for which all items need to be fetched
     * @return          {boolean}           - true if a cache setting ttr/ttl is specified for the given entity
     */
    public hasCacheSetting(typeName: string): boolean {
        if (typeName === '') {
            throw new Error('typeName cannot be empty');
        }

        typeName = typeName.toUpperCase();

        if (this.settings) {
            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {
                return !!this.settings.ttrInSeconds[typeName];
            }

            if (this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]) {
                return !!this.settings.ttlInSeconds[typeName];
            }
        }

        return false;
    }

    /**
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @param toCache   {ICache}        - cache object to which the item needs to be copied
     * @return          {ICacheItem}    - cache item that was copied
     */
    public copyTo<T = unknown>(cacheKey: ICacheKey, toCache: ICache): ICacheItem<T> | undefined {
        const cachedItem = this.get<T>(cacheKey);
        if (cachedItem) {
            toCache.put(cacheKey, { item: cachedItem.item, s: ICacheSource.AppCache });
            return cachedItem;
        }

        return undefined;
    }

    /**
     * @function        {getValue<T>}   - Method to get the cached item
     * @param cacheKey  {ICacheKey}     - object to build the cache key
     * @return          {ICacheItem<T>} - cached value against the given cache key
     */
    public getValue<T = unknown>(cacheKey: ICacheKey): T | undefined {
        const cachedItem = <ICacheItem<T>>this.get(cacheKey);
        return cachedItem ? cachedItem.item : undefined;
    }

    /**
     * @function        {del}           - Method to delete an item from the cache
     * @param cacheKey  {ICacheKey}     - Array of ICacheGetData items whose values need to be deleted from cache
     * @return          {boolean}       - returns true if the cache key is deleted successfully. Does not throw errors.
     */
    public del(cacheKey: ICacheKey): boolean {
        return this.nodeCache.del(this._computeCacheKey(cacheKey)) === 1;
    }

    /**
     * @function    {keys}              - Method to fetch all the keys in the cache
     * @return      {string[]}          - returns a list of all the keys in the cache
     */
    public keys(): string[] {
        return this.nodeCache.keys();
    }

    /**
     * @function    {flushAll}          - Method to flush all data from the cache
     */
    public flushAll(): void {
        this.nodeCache.flushAll();
    }

    private _computeCacheKey(key: ICacheKey): string {
        if (!key.typeName) {
            throw new Error(`Invalid type (${key.typeName}) - Could not create cache key`);
        }

        return `${key.typeName}-${key.key}`.toUpperCase();
    }

    private _validateCacheKey(cacheKey: ICacheKey): void {
        if (!cacheKey) {
            throw new Error(`Invalid cacheKey: ${cacheKey}`);
        }

        if (!cacheKey.typeName) {
            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);
        }
    }

    private _getTTR(typeName: string): number {
        if (this.settings) {
            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {
                return this.settings.ttrInSeconds[typeName];
            }

            if (this.settings.defaultTTRInSeconds) {
                return this.settings.defaultTTRInSeconds;
            }
        }

        return DEFAULT_CACHE_TTR;
    }

    private _getTTL(typeName: string): number {
        return this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]
            ? this.settings.ttlInSeconds[typeName]
            : DEFAULT_CACHE_TTL;
    }

    private _setRefresh(requestContext: IRequestContext): void {
        const actionTimout = Number(requestContext.query && requestContext.query.actionTimeout) || undefined;
        this.refreshTimeout = actionTimout ? actionTimout : defaultTimeoutInMS;
    }

    private _isRefreshExpired(cacheItemInternal: ICacheItemInternal<unknown>, currentTime: Number): boolean {
        if (!cacheItemInternal.refreshStartTimeInMS) {
            return false;
        }
        return cacheItemInternal.refreshStartTimeInMS + this.refreshTimeout * 2 < currentTime;
    }
}

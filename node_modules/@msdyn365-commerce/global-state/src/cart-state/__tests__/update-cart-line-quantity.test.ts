import 'jest';

import * as core from '@msdyn365-commerce/core';
import * as CartsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import mockRequestContextNoSetting from '../../__mocks__/request-context-nosettings.json';
import mockRequestContextReduced from '../../__mocks__/request-context-reduced-max-quantity.json';
import mockRequestContext from '../../__mocks__/request-context.json';
import updateCartLineQuantityInternal from '../update-cart-line-quantity';

describe('updateCartLineQuantity tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: <core.IRequestContext>(<unknown>mockRequestContext) });
    const actionContextNoSetting = core.buildMockActionContext({ requestContext: <core.IRequestContext>(<unknown>mockRequestContextNoSetting) });
    const actionContextReduced = core.buildMockActionContext({ requestContext: <core.IRequestContext>(<unknown>mockRequestContextReduced) });

    const sampleCart = {
        Id: 'cart1',
        CartLines: [
            {
                LineId: 'cl1',
                ProductId: 1
            },
            {
                LineId: 'cl2',
                ProductId: 3
            },
            {
                LineId: 'cl3',
                ProductId: 5
            },
            {
                LineId: 'cl4',
                ProductId: 7
            }
        ]
    };

    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g');
    });

    beforeEach(() => {
        jest.resetAllMocks();

        // @ts-ignore: Jest Mocking Confuses TS Complier
        CartsDataActions.updateCartLinesAsync = jest.fn().mockImplementation((ctx, id, cartLineIds) => {
            return Promise.resolve({
                Id: 'cart2'
            });
        });
    });

    it('updateCartLineQuantity returns FAILED if cart is undefined', async () => {
        const result = await updateCartLineQuantityInternal(undefined, 'cl1', 5, actionContext);

        expect(result.status).toBe('FAILED');

        expect(CartsDataActions.updateCartLinesAsync).not.toBeCalled();
    });

    it('updateCartLineQuantity returns FAILED if cart doesn\'t contain line', async () => {
        const result = await updateCartLineQuantityInternal(sampleCart, 'cl0', 5, actionContext);

        expect(result.status).toBe('FAILED');

        expect(CartsDataActions.updateCartLinesAsync).not.toBeCalled();
    });

    it('updateCartLineQuantity matches line with avail quantity', async () => {
        const result = await updateCartLineQuantityInternal(sampleCart, 'cl1', 5, actionContext);

        expect(CartsDataActions.updateCartLinesAsync).toHaveBeenCalledWith(
            expect.anything(),
            'cart1',
            expect.arrayContaining([
                expect.objectContaining(
                    {
                        LineId: 'cl1',
                        Quantity: 5,
                        ProductId: 1
                    }
                )
            ]),
            null
        );

        expect(result.status).toBe('SUCCESS');
        expect(result.cart).not.toBeUndefined();
        expect(result.cart!.Id).toEqual('cart2');
    });

    it('updateCartLineQuantity respects MAXQUANTITY', async () => {
        const result = await updateCartLineQuantityInternal(sampleCart, 'cl1', 10, actionContextReduced);

        expect(CartsDataActions.updateCartLinesAsync).toHaveBeenCalledWith(
            expect.anything(),
            'cart1',
            expect.arrayContaining([
                expect.objectContaining(
                    {
                        LineId: 'cl1',
                        Quantity: 5,
                        ProductId: 1
                    }
                )
            ]),
            null
        );

        expect(result.status).toBe('SUCCESS');
        expect(result.cart).not.toBeUndefined();
        expect(result.cart!.Id).toEqual('cart2');
    });

    it('updateCartLineQuantity respects default MAXQUANTITY of 10', async () => {
        const result = await updateCartLineQuantityInternal(sampleCart, 'cl1', 15, actionContextNoSetting);

        expect(CartsDataActions.updateCartLinesAsync).toHaveBeenCalledWith(
            expect.anything(),
            'cart1',
            expect.arrayContaining([
                expect.objectContaining(
                    {
                        LineId: 'cl1',
                        Quantity: 10,
                        ProductId: 1
                    }
                )
            ]),
            null
        );

        expect(result.status).toBe('SUCCESS');
        expect(result.cart).not.toBeUndefined();
        expect(result.cart!.Id).toEqual('cart2');
    });

    it('updateCartLineQuantity returns failure if updateCartLinesAsync throws', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        CartsDataActions.updateCartLinesAsync = jest.fn().mockImplementation(cb => {
            return Promise.reject(new Error('Fail'));
        });

        const result = await updateCartLineQuantityInternal(sampleCart, 'cl1', 5, actionContext);

        expect(result.status).toBe('FAILED');
        expect(result.cart).toBeUndefined();
    });
});
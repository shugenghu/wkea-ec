import 'jest';
import * as core from '@msdyn365-commerce/core';
import mockRequestContextNoChannel from '../../__mocks__/request-context-nochannel.json';
import mockRequestContext from '../../__mocks__/request-context.json';
import addProductsToCart from '../add-product-to-cart';
import addPromoCodeInternal from '../add-promo-code';
import { BaseCartState } from '../base-cart-state';
import clearCartLineDeliveryModeInternal from '../clear-cart-line-delivery-mode';
import getOrCreateActiveCart from '../get-or-create-active-cart';
import refreshCart from '../refresh-cart';
import removeAllPromoCodesInternal from '../remove-all-promo-codes';
import removeCartLinesInternal from '../remove-cart-lines';
import removePromoCodesInternal from '../remove-promo-codes';
import updateCartInternal from '../update-cart';
import updateCartLineDeliverySpecificationsInternal from '../update-cart-line-delivery-specifications';
import updateCartLineQuantityInternal from '../update-cart-line-quantity';
import updateLoyaltyCardIdInternal from '../update-loyalty-card-id';
import updateReceiptEmailInternal from '../update-receipt-email';
import clearCartLinesDeliveryInformation from '../clear-cart-lines-delivery-information';
describe('cartState getters and setters', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('CartState preserves expected default values', async () => {
        const cartState = new BaseCartState(actionContext);
        expect(cartState.cart).toEqual({});
    });
});
describe('initialize tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('Goes into error state if getting cart fails', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return undefined;
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.status).toBe('ERROR');
        expect(getOrCreateActiveCart).toBeCalled();
    });
    it('Calls get or create active cart', async () => {
        const cart = {
            Id: 'mockCart_refreshCart'
        };
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return cart;
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.cart.Id).toBe(cart.Id);
        expect(getOrCreateActiveCart).toBeCalled();
        expect(cartState.status).toBe('READY');
    });
    it('Doesn\'t update  after multiple calls', async () => {
        const cart = {
            Id: 'mockCart_refreshCart'
        };
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return cart;
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        await cartState.initialize();
        expect(cartState.cart.Id).toBe(cart.Id);
        expect(getOrCreateActiveCart).toBeCalledTimes(1);
        expect(cartState.status).toBe('READY');
    });
});
describe('refreshCart tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('Refresh cart returns result of refreshCart', async () => {
        const cart = {
            Id: 'mockCart_refreshCart'
        };
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return cart;
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.refreshCart({});
        expect(cartState.status).toEqual('READY');
        expect(cartState.cart.Id).toBe(cart.Id);
        expect(refreshCart).toBeCalled();
    });
    it('Is still called multiple times', async () => {
        const cart = {
            Id: 'mockCart_refreshCart'
        };
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return cart;
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.refreshCart({});
        await cartState.refreshCart({});
        expect(cartState.status).toEqual('READY');
        expect(cartState.cart.Id).toBe(cart.Id);
        expect(refreshCart).toBeCalledTimes(2);
    });
});
describe('addProductToCart tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../add-product-to-cart');
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return {};
        });
    });
    it('addProductToCart returns failure state if org unit specified but can\'t get channel information', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn();
        const cartState = new BaseCartState(core.buildMockActionContext({ requestContext: mockRequestContextNoChannel }));
        const response = await cartState.addProductToCart({ product, count: 1, location: {} });
        expect(response.status).toBe('FAILED');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).not.toBeCalled();
    });
    it('addProductToCart copies BOPIS information', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.addProductToCart({
            product, count: 1, location: {
                OrgUnitNumber: '1',
                State: 'New York'
            }
        });
        expect(addProductsToCart).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({
            DeliveryMode: actionContext.requestContext.channel.PickupDeliveryModeCode,
            FulfillmentStoreId: '1',
            WarehouseId: '1',
            ShippingAddress: expect.objectContaining({
                State: 'New York'
            })
        }), expect.anything(), undefined, undefined, false);
    });
    it('addProductToCart defaults count to 1', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.addProductToCart({ product });
        expect(addProductsToCart).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({
            Quantity: 1
        }), expect.anything(), undefined, undefined, false);
    });
    it('addProductToCart respects count', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.addProductToCart({ product, count: 5 });
        expect(addProductsToCart).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({
            Quantity: 5
        }), expect.anything(), undefined, undefined, false);
    });
    it('If first addProductsToCarts succeeds, return result and sets cart', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c2' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('SUCCESS');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(1);
        expect(cartState.cart.Id).toBe('c2');
    });
    it('If first addProductsToCarts fails with MAXQUANTITY, return result but don\'t set cart', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: undefined, status: 'FAILED', substatus: 'MAXQUANTITY' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('FAILED');
        expect(response.substatus).toBe('MAXQUANTITY');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(1);
        expect(cartState.cart).toEqual({});
    });
    it('If first addProductsToCarts fails, try once more and don\'t set cart', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        const mockCart = { Id: 'cart1' };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: undefined, status: 'FAILED' };
        });
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return mockCart;
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('FAILED');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(2);
        expect(cartState.cart).toEqual(mockCart);
    });
    it('If first addProductsToCarts fails, and refresh cart fails dont try action a second time', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementation(cb => {
            return { cart: undefined, status: 'FAILED' };
        });
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return undefined;
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('FAILED');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(1);
        expect(cartState.cart).toEqual({});
    });
    it('If first addProductsToCarts fails on first attempt, passes on second', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementationOnce(cb => {
            return { cart: undefined, status: 'FAILED' };
        }).mockImplementationOnce(cb => {
            return { cart: { Id: 'c3' }, status: 'SUCCESS' };
        });
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c2' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('SUCCESS');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(2);
        expect(cartState.cart.Id).toBe('c3');
    });
    it('If first addProductsToCarts fails on first attempt, passes on second but only set cart if cart returned', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementationOnce(cb => {
            return { cart: undefined, status: 'FAILED' };
        }).mockImplementationOnce(cb => {
            return { cart: undefined, status: 'FAILED', substatus: 'MAXQUANTITY' };
        });
        // @ts-ignore
        refreshCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c2' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addProductToCart({ product });
        expect(response.status).toBe('FAILED');
        expect(response.substatus).toBe('MAXQUANTITY');
        expect(cartState.status).toEqual('READY');
        expect(addProductsToCart).toBeCalledTimes(2);
        expect(cartState.cart).toBeDefined();
        expect(cartState.cart.Id).toEqual('c2');
    });
});
describe('removeCartLine tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../remove-cart-lines');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('If first removeCartLine succeeds, return result and sets cart', async () => {
        // @ts-ignore
        removeCartLinesInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.removeCartLines({ cartLineIds: ['1'] });
        expect(response.status).toBe('SUCCESS');
        expect(removeCartLinesInternal).toBeCalledTimes(1);
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('clearCartLinePickupLocation tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../clear-cart-line-delivery-mode');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('If first clearBopisLocationFromCartLine succeeds, return result and sets cart', async () => {
        // @ts-ignore
        clearCartLineDeliveryModeInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.clearCartLinePickupLocation({ cartLineId: 'cl1' });
        expect(response.status).toBe('SUCCESS');
        expect(clearCartLineDeliveryModeInternal).toBeCalledTimes(1);
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('updateCartLinePickupLocation tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    const actionContextNoChannel = core.buildMockActionContext({ requestContext: mockRequestContextNoChannel });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart-line-delivery-specifications');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateCartLinePickupLocation calls updateCartLineDeliverySpecificationsInternal with proper information', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateCartLinePickupLocation({ cartLineId: 'cl1', location: { OrgUnitNumber: 'SEATTLE', City: 'Seattle' } });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledTimes(1);
        expect(updateCartLineDeliverySpecificationsInternal).toHaveBeenCalledWith({}, expect.arrayContaining([
            expect.objectContaining({
                LineId: 'cl1',
                DeliverySpecification: expect.objectContaining({
                    DeliveryModeId: '50',
                    DeliveryPreferenceTypeValue: 2,
                    PickUpStoreId: 'SEATTLE',
                    DeliveryAddress: expect.objectContaining({
                        City: 'Seattle'
                    })
                })
            })
        ]), expect.anything());
    });
    it('updateCartLinePickupLocation returns failure if channel information not present', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContextNoChannel);
        const response = await cartState.updateCartLinePickupLocation({ cartLineId: 'cl1', location: { OrgUnitNumber: 'SEATTLE', City: 'Seattle' } });
        expect(response.status).toBe('FAILED');
    });
    it('If first addProductsToCarts throws skip second and go into error state', async () => {
        const product = {
            RecordId: 1,
            ProductTypeValue: 1,
            BasePrice: 10,
            Price: 10,
            AdjustedPrice: 10
        };
        // @ts-ignore
        addProductsToCart = jest.fn().mockImplementationOnce(cb => {
            return Promise.reject(new Error('Fail'));
        }).mockImplementationOnce(cb => {
            return { cart: { Id: 'c3' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        await expect(cartState.addProductToCart({ product })).rejects.toThrow('Fail');
        expect(addProductsToCart).toBeCalledTimes(1);
        expect(cartState.status).toEqual('ERROR');
    });
});
describe('removeCartLines tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../remove-cart-lines');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('removeCartLines calls removeCartLines with proper information', async () => {
        // @ts-ignore
        removeCartLinesInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.removeCartLines({ cartLineIds: ['cl1', 'cl2'] });
        expect(response.status).toBe('SUCCESS');
        expect(removeCartLinesInternal).toBeCalledTimes(1);
        expect(removeCartLinesInternal).toHaveBeenCalledWith({}, expect.arrayContaining(['cl1', 'cl2']), expect.anything());
    });
});
describe('updateCartLineQuantity tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart-line-quantity');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateCartLineQuantity calls updateCartLineQuantity with proper information', async () => {
        // @ts-ignore
        updateCartLineQuantityInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateCartLineQuantity({ cartLineId: 'cl1', newQuantity: 5 });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartLineQuantityInternal).toBeCalledTimes(1);
        expect(updateCartLineQuantityInternal).toHaveBeenCalledWith({}, 'cl1', 5, expect.anything());
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('updateReceiptEmail tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-receipt-email');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateReceiptEmail calls updateReceiptEmail with proper information', async () => {
        // @ts-ignore
        updateReceiptEmailInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1', ReceiptEmail: 'email' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateReceiptEmail({ newEmail: 'email' });
        expect(response.status).toBe('SUCCESS');
        expect(updateReceiptEmailInternal).toBeCalledTimes(1);
        expect(updateReceiptEmailInternal).toHaveBeenCalledWith({}, 'email', expect.anything());
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('updateAttributeValues tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateAttributeValues calls updateAttributeValues with proper information', async () => {
        // @ts-ignore
        updateCartInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1', AttributeValues: [{ Name: 'attributeValue' }] }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        expect(cartState.attributeValues).toEqual([]);
        const response = await cartState.updateAttributeValues({ newAttributeValues: [{ Name: 'attributeValue' }] });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartInternal).toBeCalledTimes(1);
        expect(updateCartInternal).toHaveBeenCalledWith({}, { Id: undefined, AttributeValues: [{ Name: 'attributeValue' }] }, expect.anything());
        expect(cartState.cart.Id).toBe('c1');
        expect(cartState.cart.AttributeValues).toEqual([{ Name: 'attributeValue' }]);
        expect(cartState.attributeValues).toEqual([{ Name: 'attributeValue' }]);
    });
});
describe('updateExtensionProperties tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateExtensionProperties calls updateExtensionProperties with proper information', async () => {
        // @ts-ignore
        updateCartInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1', ExtensionProperties: [{ Key: 'key', Value: { StringValue: 'extensionProerty' } }] }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        expect(cartState.extensionProperties).toEqual([]);
        const response = await cartState.updateExtensionProperties({ newExtensionProperties: [{ Key: 'key', Value: { StringValue: 'extensionProerty' } }] });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartInternal).toBeCalledTimes(1);
        expect(updateCartInternal).toHaveBeenCalledWith({}, { Id: undefined, ExtensionProperties: [{ Key: 'key', Value: { StringValue: 'extensionProerty' } }] }, expect.anything());
        expect(cartState.cart.Id).toBe('c1');
        expect(cartState.cart.ExtensionProperties).toEqual([{ Key: 'key', Value: { StringValue: 'extensionProerty' } }]);
        expect(cartState.extensionProperties).toEqual([{ Key: 'key', Value: { StringValue: 'extensionProerty' } }]);
    });
});
describe('updateCart tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('updateCart calls updateCart with proper information', async () => {
        // @ts-ignore
        updateCartInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c2', ReceiptEmail: 'email' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateCart({ newCartObject: { Id: 'Id', ReceiptEmail: 'email2' } });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartInternal).toBeCalledTimes(1);
        expect(updateCartInternal).toHaveBeenCalledWith({}, { Id: 'Id', ReceiptEmail: 'email2' }, expect.anything());
        expect(cartState.cart.Id).toBe('c2');
    });
});
describe('addPromoCode tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../add-promo-code');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('addPromoCode calls addPromoCode with proper information', async () => {
        // @ts-ignore
        addPromoCodeInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.addPromoCode({ promoCode: 'SAVE10' });
        expect(response.status).toBe('SUCCESS');
        expect(addPromoCodeInternal).toBeCalledTimes(1);
        expect(addPromoCodeInternal).toHaveBeenCalledWith({}, 'SAVE10', expect.anything());
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('removePromoCode tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../remove-promo-codes');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('removePromoCode calls removePromoCodesInternal with proper information', async () => {
        // @ts-ignore
        removePromoCodesInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.removePromoCodes({ promoCodes: ['SAVE10'] });
        expect(response.status).toBe('SUCCESS');
        expect(removePromoCodesInternal).toBeCalledTimes(1);
        expect(removePromoCodesInternal).toHaveBeenCalledWith({}, ['SAVE10'], expect.anything());
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('removePromoCodes tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../remove-all-promo-codes');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('removeAllPromoCodes calls removeAllPromoCodesInternal with proper information', async () => {
        // @ts-ignore
        removeAllPromoCodesInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.removeAllPromoCodes({});
        expect(response.status).toBe('SUCCESS');
        expect(removeAllPromoCodesInternal).toBeCalledTimes(1);
        expect(removeAllPromoCodesInternal).toHaveBeenCalledWith({}, expect.anything());
        expect(cartState.cart.Id).toBe('c1');
    });
});
describe('isEmpty tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('isEmpty returns true if no cart present', async () => {
        const cartState = new BaseCartState(actionContext);
        expect(cartState.isEmpty).toBe(true);
    });
    it('isEmpty returns true if cart has no cart lines', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: undefined };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.isEmpty).toBe(true);
    });
    it('isEmpty returns true  if cart lines is empty', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.isEmpty).toBe(true);
    });
    it('isEmpty returns false cart lines is not empty', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ cartLineId: 'cl1', Quantity: 3 }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.isEmpty).toBe(false);
    });
});
describe('totalItemsInCart tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('totalItemsInCart returns 0 if no cart present', async () => {
        const cartState = new BaseCartState(actionContext);
        expect(cartState.totalItemsInCart).toBe(0);
    });
    it('totalItemsInCart returns 0 if cart has no cart lines', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: undefined };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.totalItemsInCart).toBe(0);
    });
    it('totalItemsInCart returns 0 if cart lines is empty', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.totalItemsInCart).toBe(0);
    });
    it('totalItemsInCart returns cart line count cart lines is not empty', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ cartLineId: 'cl1', Quantity: 3 }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.totalItemsInCart).toBe(3);
    });
    it('totalItemsInCart totals up all cart lines counts', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ cartLineId: 'cl1', Quantity: 3 }, { cartLineId: 'cl2', Quantity: 2 }, { cartLineId: 'cl3', Quantity: 1 }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.totalItemsInCart).toBe(6);
    });
    it('totalItemsInCart defaults count to 1 if not set', async () => {
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ cartLineId: 'cl1' }, { cartLineId: 'cl2', Quantity: 2 }, { cartLineId: 'cl3', Quantity: 1 }, { cartLineId: 'cl4' }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        expect(cartState.totalItemsInCart).toBe(5);
    });
});
describe('updateCartDeliverySpecification tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-cart-line-delivery-specifications');
        jest.mock('../get-or-create-active-cart');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('bypasses updateCartLineDeliverySpecificationsInternal call if no delivery mode present', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateCartDeliverySpecification({ deliveryModeId: '', shippingAddress: undefined });
        expect(response.status).toBe('FAILED');
        expect(response.substatus).toBe('EMPTYINPUT');
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledTimes(0);
    });
    it('bypasses updateCartLineDeliverySpecificationsInternal call if no cart lines present', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateCartDeliverySpecification({ deliveryModeId: '5', shippingAddress: undefined });
        expect(response.status).toBe('FAILED');
        expect(response.substatus).toBe('NOCONTENT');
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledTimes(0);
    });
    it('calls updateCartLineDeliverySpecificationsInternal with expected information', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1', CartLines: [{ LineId: 'cl1' }, { LineId: 'cl2' }] }, status: 'SUCCESS' };
        });
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ LineId: 'cl1', DeliveryMode: '26' }, { LineId: 'cl2', DeliveryMode: '26' }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        const response = await cartState.updateCartDeliverySpecification({ deliveryModeId: '5', shippingAddress: { City: 'Seattle' } });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledTimes(1);
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledWith(expect.anything(), expect.arrayContaining([
            expect.objectContaining({
                LineId: 'cl1',
                DeliverySpecification: expect.objectContaining({
                    DeliveryModeId: '5',
                    DeliveryPreferenceTypeValue: 1,
                    DeliveryAddress: expect.objectContaining({
                        City: 'Seattle'
                    })
                })
            }),
            expect.objectContaining({
                LineId: 'cl2',
                DeliverySpecification: expect.objectContaining({
                    DeliveryModeId: '5',
                    DeliveryPreferenceTypeValue: 1,
                    DeliveryAddress: expect.objectContaining({
                        City: 'Seattle'
                    })
                })
            })
        ]), expect.anything());
    });
    it('filters out lines marked for BOPIS', async () => {
        // @ts-ignore
        updateCartLineDeliverySpecificationsInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1', CartLines: [{ LineId: 'cl1' }, { LineId: 'cl2', PickupDeliveryModeCode: '50' }] }, status: 'SUCCESS' };
        });
        // @ts-ignore
        getOrCreateActiveCart = jest.fn().mockImplementation(cb => {
            return { Id: 'c1', CartLines: [{ LineId: 'cl1' }, { LineId: 'cl2', PickupDeliveryModeCode: '50' }] };
        });
        const cartState = new BaseCartState(actionContext);
        await cartState.initialize();
        const response = await cartState.updateCartDeliverySpecification({ deliveryModeId: '5', shippingAddress: { City: 'Seattle' } });
        expect(response.status).toBe('SUCCESS');
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledTimes(1);
        expect(updateCartLineDeliverySpecificationsInternal).toBeCalledWith(expect.anything(), expect.arrayContaining([
            expect.objectContaining({
                LineId: 'cl1',
                DeliverySpecification: expect.objectContaining({
                    DeliveryModeId: '5',
                    DeliveryPreferenceTypeValue: 1,
                    DeliveryAddress: expect.objectContaining({
                        City: 'Seattle'
                    })
                })
            })
        ]), expect.anything());
    });
});
describe('updateLoyaltyCardId tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../update-loyalty-card-id');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('bypasses updateLoyaltyCardId call if no loyalty card present', async () => {
        // @ts-ignore
        updateLoyaltyCardIdInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateLoyaltyCardId({ loyaltyCardNumber: undefined });
        expect(response.status).toBe('FAILED');
        expect(response.substatus).toBe('EMPTYINPUT');
        expect(updateLoyaltyCardIdInternal).toBeCalledTimes(0);
    });
    it('calls updateLoyaltyCardId with proper information', async () => {
        // @ts-ignore
        updateLoyaltyCardIdInternal = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.updateLoyaltyCardId({ loyaltyCardNumber: 'CARD1' });
        expect(response.status).toBe('SUCCESS');
        expect(updateLoyaltyCardIdInternal).toBeCalledTimes(1);
        expect(updateLoyaltyCardIdInternal).toHaveBeenCalledWith({}, 'CARD1', expect.anything());
    });
});
describe('clearCartLinesDeliveryInformation tests', () => {
    const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });
    // Setup mocks
    beforeAll(() => {
        core.initializeMockApp();
        jest.mock('../clear-cart-lines-delivery-information');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    it('If clearCartLinesDeliveryInformation succeeds, return result and sets cart', async () => {
        // @ts-ignore
        clearCartLinesDeliveryInformation = jest.fn().mockImplementation(cb => {
            return { cart: { Id: 'c1' }, status: 'SUCCESS' };
        });
        const cartState = new BaseCartState(actionContext);
        const response = await cartState.clearCartLinesDeliveryInformation({});
        expect(response.status).toBe('SUCCESS');
        expect(clearCartLinesDeliveryInformation).toBeCalledTimes(1);
        expect(cartState.cart.Id).toBe('c1');
    });
});
//# sourceMappingURL=base-cart-state.test.js.map
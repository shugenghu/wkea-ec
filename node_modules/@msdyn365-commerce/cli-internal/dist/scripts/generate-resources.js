"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Overview
 *
 * 1. gets list of modules in src/packages
 * 2. Generates a resources folder in src
 * 3. Generates global.json resource file for module resources in src/resources/modules folder
 * 4. Generates global.json resource file for authoring resources in src/resources/authoring folder
 *
 * usage: yarn msdyn365 generate-resources
 */
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const path = require("path");
exports.SRC_FOLDER = path.resolve(process.cwd(), 'src');
const GLOBAL_AUTHORING_RESOURCES_PATH = path.join('resources', 'authoring', 'global.json');
const GLOBAL_MODULES_RESOURCES_PATH = path.join('resources', 'modules', 'global.json');
const CURRENT_DIRECTORY = path.resolve(process.cwd());
/**
 * Method to construct authoring resource property
 * @param resourceProperty module/authoring resource property defined in module definition
 * @return returns authoring resource property
 */
const getResourceProperty = (resourceProperty) => {
    const prop = {};
    if (typeof resourceProperty === 'string') {
        prop.value = resourceProperty;
        prop[`_value.comment`] = '';
    }
    else if (Array.isArray(resourceProperty)) {
        prop.value = resourceProperty;
        prop[`_value.comment`] = '';
    }
    else if (resourceProperty && resourceProperty.value) {
        prop.value = resourceProperty.value;
        if (resourceProperty.comment) {
            prop[`_value.comment`] = resourceProperty.comment;
        }
    }
    return prop;
};
/**
 * parses the slots property in module definition to extract authoring resources friendlyName, description
 * @param slotsDictionary dictionary of slots from the module definition
 * @return returns slots authoring resources dictionary
 */
const parseSlots = (slotsDictionary) => {
    const slotsResources = {};
    slotsDictionary &&
        Object.keys(slotsDictionary).forEach(slotKey => {
            const slot = slotsDictionary[slotKey];
            slotsResources[slotKey] = {};
            if (slot.friendlyName) {
                slotsResources[slotKey].friendlyName = getResourceProperty(slot.friendlyName);
            }
            if (slot.description) {
                slotsResources[slotKey].description = getResourceProperty(slot.description);
            }
        });
    return slotsResources;
};
/**
 * parses the config property in module definition to extract authoring resources friendlyName, description, group and options
 * @param configDictionary config property in module definition
 * @return returns config authoring resources and the options (enums) authoring resources
 */
const parseModuleConfig = (configDictionary) => {
    let configResources = {};
    let options = {};
    configDictionary &&
        Object.keys(configDictionary).forEach(configKey => {
            const config = configDictionary[configKey];
            configResources[configKey] = {};
            if (config.friendlyName) {
                configResources[configKey].friendlyName = getResourceProperty(config.friendlyName);
            }
            if (config.description) {
                configResources[configKey].description = getResourceProperty(config.description);
            }
            if (config.group) {
                configResources[configKey].group = getResourceProperty(config.group);
            }
            if (config.enum) {
                Object.keys(config.enum).forEach((enumKey) => {
                    options[`${enumKey}`] = getResourceProperty(config.enum[enumKey]);
                });
            }
            if (config.properties) {
                // recursively call to parse config properties
                const res = parseModuleConfig(config.properties);
                // Merge the config properties
                configResources = Object.assign(Object.assign({}, configResources), res.config);
                // Merge options from the recursive call
                options = Object.assign(Object.assign({}, (options || {})), (res.options || {}));
            }
        });
    return {
        config: configResources,
        options
    };
};
/**
 * Fetches the list of .definition.json files and parses them to extract
 * authoring resources and modules resources
 * @param packageJsonFilesPathPattern glob pattern to read the definition files
 */
// tslint:disable-next-line: max-func-body-length
const getModuleResources = (isDefinitionExtension, themeName, exportSDKResources) => __awaiter(void 0, void 0, void 0, function* () {
    // Get all definitions and filter out the ones from node modules
    let definitionFilesPaths;
    let moduleType;
    if (isDefinitionExtension && themeName !== '' && themeName !== '____keystone_theme_name____') {
        definitionFilesPaths = yield utilities_internal_1.safeGetAllFilesPath(path.join(CURRENT_DIRECTORY, '**', themeName, '**', '*.definition.ext.json'));
        moduleType = `module definition extensions in ${themeName}`;
    }
    else {
        definitionFilesPaths = yield utilities_internal_1.safeGetAllFilesPath(`./**/*.definition.json`);
        moduleType = 'module Definitions';
    }
    definitionFilesPaths = definitionFilesPaths.filter(item => item.indexOf('node_modules') === -1);
    utilities_internal_1.trace.info(`Found ${definitionFilesPaths.length} ${moduleType} to import`);
    if (!isDefinitionExtension && exportSDKResources) {
        // When this flag is set, export the SDK modules definitions as well.
        const sdkModuleDefinitionFiles = yield utilities_internal_1.safeGetAllFilesPath(`./node_modules/@msdyn365-commerce-modules/core-components/**/*.definition.json`);
        if (sdkModuleDefinitionFiles && sdkModuleDefinitionFiles.length) {
            utilities_internal_1.trace.info(`Found ${sdkModuleDefinitionFiles.length} module defintions to import from SDK`);
            definitionFilesPaths.push(...sdkModuleDefinitionFiles);
        }
    }
    utilities_internal_1.trace.info(definitionFilesPaths);
    const globalAuthoringResources = {};
    const globalDefinitionExtensionAuthoringResources = {};
    let globalModuleResources = {};
    const promises = definitionFilesPaths.map((definitionFilePath) => __awaiter(void 0, void 0, void 0, function* () {
        let moduleDefinitionJSON = (yield utilities_internal_1.safeReadJson(definitionFilePath, utilities_internal_1.trace)) || {};
        const definitionExtensionName = path.basename(definitionFilePath, '.definition.ext.json');
        if (moduleDefinitionJSON) {
            moduleDefinitionJSON = yield utilities_internal_1.resolveRef(moduleDefinitionJSON, definitionFilePath);
        }
        if (!moduleDefinitionJSON) {
            return;
        }
        const moduleAuthoringResources = {};
        const moduleResources = {};
        if (moduleDefinitionJSON.friendlyName) {
            moduleAuthoringResources.friendlyName = getResourceProperty(moduleDefinitionJSON.friendlyName);
        }
        if (moduleDefinitionJSON.description) {
            moduleAuthoringResources.description = getResourceProperty(moduleDefinitionJSON.description);
        }
        if (moduleDefinitionJSON.tags) {
            moduleAuthoringResources.tags = getResourceProperty(moduleDefinitionJSON.tags);
        }
        if (moduleDefinitionJSON.slots) {
            moduleAuthoringResources.slots = parseSlots(moduleDefinitionJSON.slots);
        }
        if (moduleDefinitionJSON.config) {
            const moduleConfigRes = parseModuleConfig(moduleDefinitionJSON.config);
            moduleAuthoringResources.config = moduleConfigRes.config;
            moduleAuthoringResources.options = moduleConfigRes.options;
        }
        if (moduleDefinitionJSON.resources) {
            Object.keys(moduleDefinitionJSON.resources).forEach((resourceKey) => {
                moduleResources[resourceKey] = getResourceProperty(moduleDefinitionJSON.resources[resourceKey]);
            });
        }
        if (moduleDefinitionJSON.dependentSchemas) {
            parseDependentSchemas(moduleDefinitionJSON.dependentSchemas, moduleAuthoringResources);
        }
        if (isDefinitionExtension) {
            globalDefinitionExtensionAuthoringResources[definitionExtensionName] = moduleAuthoringResources;
        }
        else {
            globalAuthoringResources[moduleDefinitionJSON.name] = moduleAuthoringResources;
        }
        globalModuleResources = Object.assign(Object.assign({}, globalModuleResources), (moduleResources || {}));
    }));
    yield Promise.all(promises);
    return {
        authoringResources: globalAuthoringResources,
        moduleResources: globalModuleResources,
        definitionExtensionAuthoringResources: globalDefinitionExtensionAuthoringResources
    };
});
/**
 * Parses the dependentSchemas property in definition extension for contextual property panel
 * @param dependentProperties DependentSchema propeties from definition extension
 * @param moduleAuthoringResources module authoring resources for generating authoring resource strings
 */
const parseDependentSchemas = (dependentProperties, moduleAuthoringResources) => {
    if (dependentProperties) {
        moduleAuthoringResources.dependentSchemas = {};
        // tslint:disable-next-line:no-for-in
        for (const prop in dependentProperties) {
            if (dependentProperties[prop]) {
                moduleAuthoringResources.dependentSchemas[prop] = {};
                if (dependentProperties[prop].oneOf) {
                    const oneOfProperty = dependentProperties[prop].oneOf;
                    if (oneOfProperty) {
                        moduleAuthoringResources.dependentSchemas[prop].oneOf = [];
                        oneOfProperty.forEach(configProperties => {
                            var _a;
                            const moduleConfig = parseModuleConfig(configProperties.properties);
                            const authoringResourceProperties = {
                                properties: moduleConfig.config,
                                options: moduleConfig.options
                            };
                            (_a = moduleAuthoringResources === null || moduleAuthoringResources === void 0 ? void 0 : moduleAuthoringResources.dependentSchemas[prop]) === null || _a === void 0 ? void 0 : _a.oneOf.push(authoringResourceProperties);
                        });
                    }
                }
                if (dependentProperties[prop].properties) {
                    const dependentProperty = dependentProperties[prop].properties;
                    moduleAuthoringResources.dependentSchemas[prop].properties = {};
                    moduleAuthoringResources.dependentSchemas[prop].options = {};
                    if (dependentProperty) {
                        const moduleConfig = parseModuleConfig(dependentProperty);
                        moduleAuthoringResources.dependentSchemas[prop].properties = moduleConfig.config;
                        moduleAuthoringResources.dependentSchemas[prop].options = moduleConfig.options;
                    }
                }
            }
        }
    }
};
/**
 * Parses the global property in style preset definition to extract authoring resouirces friendlyName, description, group
 * @param globalDictionary global propterty in style preset definition
 * @return returns global authoring resources dictionary
 */
const parseStylePresetGlobal = (globalDictionary) => {
    const globalResources = {};
    globalDictionary &&
        Object.keys(globalDictionary).forEach(globalKey => {
            const global = globalDictionary[globalKey];
            globalResources[globalKey] = {};
            if (global.friendlyName) {
                globalResources[globalKey].friendlyName = getResourceProperty(global.friendlyName);
            }
            if (global.description) {
                globalResources[globalKey].description = getResourceProperty(global.description);
            }
            if (global.group) {
                globalResources[globalKey].group = getResourceProperty(global.group);
            }
        });
    return globalResources;
};
/**
 * Parses the module property in style preset definition to extract authoring resouirces friendlyName, description, group
 * @param moduleDictionary module propterty in style preset definition
 * @return returns module authoring resources dictionary
 */
const parseStylePresetModules = (moduleDictionary) => {
    const moduleResources = {};
    moduleDictionary &&
        Object.keys(moduleDictionary).forEach(moduleName => {
            const moduleProperties = moduleDictionary[moduleName];
            moduleResources[moduleName] = {};
            Object.keys(moduleProperties).forEach(propertyKey => {
                const modules = moduleDictionary[moduleName][propertyKey];
                moduleResources[moduleName][propertyKey] = {};
                if (modules.friendlyName) {
                    moduleResources[moduleName][propertyKey].friendlyName = getResourceProperty(modules.friendlyName);
                }
                if (modules.description) {
                    moduleResources[moduleName][propertyKey].description = getResourceProperty(modules.description);
                }
                if (modules.group) {
                    moduleResources[moduleName][propertyKey].group = getResourceProperty(modules.group);
                }
            });
        });
    return moduleResources;
};
/**
 * Fetches the list of .definition.scss.json files and parses them to extract authroing resources
 * @param packageJsonFilesPathPattern glob pattern to read the definition.scss.json files
 */
const getStyleResources = (themePath) => __awaiter(void 0, void 0, void 0, function* () {
    const stylePresetDefinitionFilesPaths = yield utilities_internal_1.safeGetAllFilesPath(path.join(CURRENT_DIRECTORY, '**', `${themePath}.definition.scss.json`));
    let globalAuthoringResources = {};
    const promises = stylePresetDefinitionFilesPaths.map((definitionFilePath) => __awaiter(void 0, void 0, void 0, function* () {
        let stylePresetDefinitionJSON = (yield utilities_internal_1.safeReadJson(definitionFilePath, utilities_internal_1.trace)) || {};
        if (stylePresetDefinitionJSON) {
            stylePresetDefinitionJSON = yield utilities_internal_1.resolveRef(stylePresetDefinitionJSON, definitionFilePath);
        }
        const styleAuthoringResources = {};
        if (stylePresetDefinitionJSON.friendlyName) {
            styleAuthoringResources.friendlyName = getResourceProperty(stylePresetDefinitionJSON.name);
        }
        if (stylePresetDefinitionJSON.description) {
            styleAuthoringResources.description = getResourceProperty(stylePresetDefinitionJSON.description);
        }
        if (stylePresetDefinitionJSON.global) {
            styleAuthoringResources.global = parseStylePresetGlobal(stylePresetDefinitionJSON.global);
        }
        if (stylePresetDefinitionJSON.modules) {
            styleAuthoringResources.modules = parseStylePresetModules(stylePresetDefinitionJSON.modules);
        }
        globalAuthoringResources = styleAuthoringResources;
    }));
    yield Promise.all(promises);
    return globalAuthoringResources;
});
/**
 * Fetches the list of .scss.json files and parses them to extract authroing resources
 * @param packageJsonFilesPathPattern glob pattern to read the .scss.json files
 */
const getPresetResources = (themePath) => __awaiter(void 0, void 0, void 0, function* () {
    const stylePresetInstanceFilePaths = (yield utilities_internal_1.safeGetAllFilesPath(path.join(CURRENT_DIRECTORY, '**', themePath, '**', '*.scss.json'))).filter(p => !p.endsWith('.definition.scss.json'));
    const globalAuthoringResources = {};
    const promises = stylePresetInstanceFilePaths.map((definitionFilePath) => __awaiter(void 0, void 0, void 0, function* () {
        const presetJSON = (yield utilities_internal_1.safeReadJson(definitionFilePath, utilities_internal_1.trace)) || {};
        const presetAuthoringResources = {};
        if (presetJSON.friendlyName) {
            presetAuthoringResources.friendlyName = getResourceProperty(presetJSON.name);
        }
        if (presetJSON.description) {
            presetAuthoringResources.description = getResourceProperty(presetJSON.description);
        }
        globalAuthoringResources[presetJSON.name] = presetAuthoringResources;
    }));
    yield Promise.all(promises);
    return globalAuthoringResources;
});
/**
 * Fetches the list of .definition.json files and parses them to extract theme authroing resources
 * @param packageJsonFilesPathPattern glob pattern to read the definition.json files
 */
const getThemeResources = () => __awaiter(void 0, void 0, void 0, function* () {
    let definitionFilesPaths = yield utilities_internal_1.safeGetAllFilesPath(path.join(CURRENT_DIRECTORY, '**', '*.definition.json'));
    definitionFilesPaths = definitionFilesPaths.filter(item => item.indexOf('lib') === -1);
    const globalAuthoringResources = {};
    const promises = definitionFilesPaths.map((definitionFilePath) => __awaiter(void 0, void 0, void 0, function* () {
        const themeAuthoringResources = {};
        let themeDefinitionJSON = (yield utilities_internal_1.safeReadJson(definitionFilePath, utilities_internal_1.trace)) || {};
        if (themeDefinitionJSON.name !== '____keystone_template_name____') {
            if (themeDefinitionJSON) {
                themeDefinitionJSON = yield utilities_internal_1.resolveRef(themeDefinitionJSON, definitionFilePath);
            }
            if (themeDefinitionJSON.$type === 'themeModule') {
                const themePath = path.basename(definitionFilePath, '.definition.json');
                if (themeDefinitionJSON.friendlyName) {
                    themeAuthoringResources.friendlyName = getResourceProperty(themeDefinitionJSON.friendlyName);
                }
                if (themeDefinitionJSON.description) {
                    themeAuthoringResources.description = getResourceProperty(themeDefinitionJSON.description);
                }
                themeAuthoringResources.styles = {};
                themeAuthoringResources.styles.definition = yield getStyleResources(themePath);
                themeAuthoringResources.styles.presets = yield getPresetResources(themePath);
                const definition = yield getModuleResources(true, themePath);
                themeAuthoringResources.definitionExtensions = definition.definitionExtensionAuthoringResources;
                globalAuthoringResources[themeDefinitionJSON.name] = themeAuthoringResources;
            }
        }
    }));
    yield Promise.all(promises);
    return globalAuthoringResources;
});
/**
 * Fetches the list of .definition.json files and parses them to extract
 * authoring resources and modules resources
 * @param packageJsonFilesPathPattern glob pattern to read the definition files
 */
const getSettings = (exportSDKResources) => __awaiter(void 0, void 0, void 0, function* () {
    utilities_internal_1.trace.info('Get Settings');
    // get the app.settings document in partner app
    let appSettingFilePaths = yield utilities_internal_1.safeGetAllFilesPath(`./**/app.settings.json`);
    appSettingFilePaths = appSettingFilePaths.filter(item => item.indexOf('node_modules') === -1);
    utilities_internal_1.trace.info(`Found ${appSettingFilePaths.length} to import`);
    utilities_internal_1.trace.info(appSettingFilePaths);
    if (exportSDKResources) {
        // when flag is set, export SDK app-settings file as well.
        appSettingFilePaths = yield utilities_internal_1.safeGetAllFilesPath(`./node_modules/@msdyn365-commerce/runtime-internal/**/app.settings.json`);
    }
    let allAppSettingsResources = {};
    const parseResources = (instance) => {
        const appSettingResources = {};
        if (instance.friendlyName) {
            appSettingResources.friendlyName = getResourceProperty(instance.friendlyName);
        }
        if (instance.description) {
            appSettingResources.description = getResourceProperty(instance.description);
        }
        return appSettingResources;
    };
    utilities_internal_1.trace.info('Exporting below AppSetitng files');
    utilities_internal_1.trace.info(appSettingFilePaths);
    const promises = appSettingFilePaths.map((appSettingFilePath) => __awaiter(void 0, void 0, void 0, function* () {
        const appSettingsResources = {};
        const appSettingJSON = (yield utilities_internal_1.safeReadJson(appSettingFilePath, utilities_internal_1.trace)) || {};
        appSettingJSON.config &&
            Object.keys(appSettingJSON.config).forEach(key => {
                allAppSettingsResources[key] = parseResources(appSettingJSON.config[key]);
            });
        appSettingJSON.contentSecurityPolicy &&
            Object.keys(appSettingJSON.contentSecurityPolicy).forEach(key => {
                allAppSettingsResources[key] = parseResources(appSettingJSON.contentSecurityPolicy[key]);
            });
        appSettingJSON.routes &&
            Object.keys(appSettingJSON.routes).forEach(key => {
                allAppSettingsResources[key] = parseResources(appSettingJSON.routes[key]);
            });
        appSettingJSON.themes &&
            Object.keys(appSettingJSON.themes).forEach(key => {
                allAppSettingsResources[key] = parseResources(appSettingJSON.themes[key]);
            });
        allAppSettingsResources = Object.assign(Object.assign({}, allAppSettingsResources), appSettingsResources);
    }));
    yield Promise.all(promises);
    return allAppSettingsResources;
});
// tslint:disable-next-line:no-any
const sortObjectByKeys = (objectToSort) => {
    if (!objectToSort) {
        return {};
    }
    // tslint:disable-next-line:no-any
    const sortedObject = {};
    const sortedKeys = Object.keys(objectToSort).sort();
    sortedKeys.forEach(key => {
        sortedObject[key] = objectToSort[key];
    });
    return sortedObject;
};
/**
 * Generates the authoring and module resource files (global.json) and merges them
 * with existing global.json to preserve overrides/settings defined by customer
 */
function generateResources(outputFolder, exportSDKResources) {
    return __awaiter(this, void 0, void 0, function* () {
        utilities_internal_1.trace.info(`Generate resource to ${outputFolder}`);
        utilities_internal_1.trace.info(`Export Settings ${exportSDKResources}`);
        utilities_internal_1.trace.info(`Working Director ${CURRENT_DIRECTORY}`);
        utilities_internal_1.trace.info('Getting Resources from modules');
        const newModuleResources = yield getModuleResources(false, '', exportSDKResources);
        const newThemeResources = yield getThemeResources();
        const settings = yield getSettings(exportSDKResources);
        const mergedAuthoringResources = {
            settings: settings,
            modules: newModuleResources.authoringResources || {},
            themes: newThemeResources || {}
        };
        const currentAuthoringResources = yield utilities_internal_1.safeReadJson(path.join(outputFolder || exports.SRC_FOLDER, GLOBAL_AUTHORING_RESOURCES_PATH));
        if (currentAuthoringResources && currentAuthoringResources.modules) {
            // Do explicit merge of each properties as '...' does not do recursive merge
            Object.keys(currentAuthoringResources.modules).forEach(moduleName => {
                mergedAuthoringResources.modules[moduleName] = Object.assign(Object.assign({}, (mergedAuthoringResources.modules[moduleName] || {})), (currentAuthoringResources.modules[moduleName] || {}));
            });
        }
        let mergedModulesResources = newModuleResources.moduleResources || {};
        const currentModulesResources = yield utilities_internal_1.safeReadJson(path.join(outputFolder || exports.SRC_FOLDER, GLOBAL_MODULES_RESOURCES_PATH));
        if (currentModulesResources) {
            mergedModulesResources = Object.assign(Object.assign({}, mergedModulesResources), currentModulesResources);
        }
        mergedAuthoringResources.settings = sortObjectByKeys(mergedAuthoringResources.settings);
        mergedAuthoringResources.modules = sortObjectByKeys(mergedAuthoringResources.modules);
        mergedModulesResources = sortObjectByKeys(mergedModulesResources);
        yield utilities_internal_1.safeWriteJson(path.join(outputFolder || exports.SRC_FOLDER, GLOBAL_AUTHORING_RESOURCES_PATH), mergedAuthoringResources, utilities_internal_1.trace, 4);
        yield utilities_internal_1.safeWriteJson(path.join(outputFolder || exports.SRC_FOLDER, GLOBAL_MODULES_RESOURCES_PATH), mergedModulesResources, utilities_internal_1.trace, 4);
    });
}
exports.default = generateResources;

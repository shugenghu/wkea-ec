"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-require-imports
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const cp = require("child_process");
const dotenv = require("dotenv");
const fs = require("fs-extra");
const path = require("path");
const semver = require("semver");
/**
 * List of packages we care about setting alpha resolutions on
 */
const sdkPackages = [
    '@msdyn365-commerce-modules/core-components',
    '@msdyn365-commerce/action-internal',
    '@msdyn365-commerce/bootloader',
    '@msdyn365-commerce/build-scripts-internal',
    '@msdyn365-commerce/cli-internal',
    '@msdyn365-commerce/core-internal',
    '@msdyn365-commerce/definition-generator-internal',
    '@msdyn365-commerce/tslint-rules',
    '@msdyn365-commerce/runtime-internal',
    '@msdyn365-commerce/utilities-internal',
    '@msdyn365-commerce/theming-internal',
    '@msdyn365-commerce/telemetry-internal'
];
const sskPackages = ['@msdyn365-commerce-modules/starter-pack', '@msdyn365-commerce-theme/fabrikam'];
const retailProxyPackages = ['@msdyn365-commerce/retail-proxy'];
/**
 * Gets the latest set of versions for all packages associated with an entity
 * @param entity The entity to fetch all latest versions for. Can either be 'sdk', 'ssk' or 'retail-proxy'
 */
const getLatestVersionsForEntity = (entity) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let latestVersions;
    switch (entity) {
        case 'sdk':
            latestVersions = getLatestVersions(sdkPackages);
            break;
        case 'ssk':
            latestVersions = getLatestVersions(sskPackages);
            const sskVersion = (_a = latestVersions[0]) === null || _a === void 0 ? void 0 : _a.version;
            const pathToPackageJson = path.join(process.cwd(), 'package.json');
            const packageJson = JSON.parse(fs.readFileSync(pathToPackageJson).toString());
            // Verify the current installed retail-proxy can support the latest SSK
            if (sskVersion && packageJson.dependencies && packageJson.dependencies['@msdyn365-commerce/retail-proxy']) {
                const retailProxyVersion = packageJson.dependencies['@msdyn365-commerce/retail-proxy'];
                if (semver.gtr(sskVersion, `~${retailProxyVersion}`)) {
                    utilities_internal_1.trace.warn('Warning: Potentially updating to unsupported SSK version! SSK recommends minor version of current retail-proxy to be greater than or equal to its minor version.');
                    utilities_internal_1.trace.warn(`Warning: Current retail-proxy version is ${splitSemverVersion(retailProxyVersion, 2)} which is less than latest SSK ${splitSemverVersion(sskVersion, 2)}`);
                }
            }
            else {
                utilities_internal_1.trace.warn(`Warning: Missing required dependency '@msdyn365-commerce/retail-proxy' for SSK`);
            }
            break;
        case 'retail-proxy':
            latestVersions = getLatestVersions(retailProxyPackages);
            const envConfig = dotenv.parse(utilities_internal_1.safeReadFileSync(path.resolve(process.cwd(), '.env')));
            // Verify the currently deployed retail-server is compatible with the latest retail-proxy
            if (envConfig.MSDyn365Commerce_BASEURL && latestVersions[0]) {
                const rcsuVersion = yield utilities_internal_1.getRCSUversion(envConfig.MSDyn365Commerce_BASEURL);
                const semverRcsuVersion = constructSemverVersionFromRcsuVersion(rcsuVersion);
                if (semverRcsuVersion && semver.gtr(latestVersions[0].version, `~${semverRcsuVersion}`)) {
                    utilities_internal_1.trace.warn('Warning: Potentially updating to unsupported retail-proxy version!');
                    utilities_internal_1.trace.warn(`Warning: Currenttly deployed retail-server version is ${splitSemverVersion(semverRcsuVersion, 2)} which is less than latest retail-proxy ${splitSemverVersion(latestVersions[0].version, 2)}`);
                }
            }
            break;
        default:
            console.error(`Unsupported entity ${entity}. Please use 'sdk', 'ssk' or 'retail-proxy'.`);
            console.error(`Example: yarn msdyn365 update-versions retail-proxy`);
            process.exit(1);
    }
    return latestVersions;
});
const splitSemverVersion = (version, index) => {
    let semverParts = version.split('.');
    semverParts = semverParts.slice(0, index);
    return semverParts.join('.');
};
/**
 * The RCSU version usually contains extra version information apart from
 * Major.Minor.Patch semver standard so this strips off the last number
 * @param rcsuVersion The rcsu base version
 */
const constructSemverVersionFromRcsuVersion = (rcsuVersion) => {
    const semverParts = rcsuVersion.split('.');
    // Remove the last part
    if (semverParts.length >= 4) {
        return splitSemverVersion(rcsuVersion, 3);
    }
    else if (semverParts.length === 3) {
        return rcsuVersion;
    }
    return undefined;
};
/**
 * Given an array of package names, this returns the latest version for each package
 * @param packages An array of package names
 */
const getLatestVersions = (packages) => {
    return packages
        .map(packageInstance => {
        const execResult = cp.execSync(`yarn info ${packageInstance} --json`, undefined);
        const versionInfo = JSON.parse(execResult).data;
        if (versionInfo && versionInfo.versions && Array.isArray(versionInfo.versions)) {
            const latestVersion = versionInfo.versions[versionInfo.versions.length - 1];
            // tslint:disable-next-line:no-console
            console.info(`found [latest] - ${latestVersion} for package ${packageInstance}`);
            return {
                packageInstance,
                version: latestVersion
            };
        }
        else {
            console.error(`Did not find latest tag for package ${packageInstance}`);
        }
    })
        .filter(Boolean);
};
/**
 * Updates package.json dependencies with the latest dependencies
 * @param {Object} deps
 */
// tslint:disable-next-line:no-any
const setDependencies = (deps, useResolutions) => {
    const pathToPackageJson = path.join(process.cwd(), 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(pathToPackageJson).toString());
    Object.keys(deps).forEach(dep => {
        console.log(dep, deps[dep]);
        if (packageJson.dependencies[dep]) {
            packageJson.dependencies[dep] = `${useResolutions ? deps[dep] : `^${deps[dep]}`}`;
        }
    });
    // If use resolutions is set, set resolutions for each of the packages
    if (useResolutions) {
        packageJson.resolutions = Object.assign(Object.assign({}, packageJson.resolutions), deps);
    }
    fs.writeFileSync(pathToPackageJson, JSON.stringify(packageJson, null, 4));
};
/**
 * Entry point
 */
const main = (entity = 'sdk', useResolutions = true, isDryRun = false) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const versions = yield getLatestVersionsForEntity(entity);
    console.log(`Will use the following package versions:`);
    console.table(versions);
    // If this is a dry run output the information but don't actually update the versions
    if (!isDryRun) {
        const newDependencyVersions = Array.from(versions.values()).reduce((prev, packageData) => (Object.assign(Object.assign({}, prev), { [packageData.packageInstance]: packageData.version })), {});
        setDependencies(newDependencyVersions, useResolutions);
    }
    return ((_b = versions[0]) === null || _b === void 0 ? void 0 : _b.version) || '--';
});
exports.default = main;

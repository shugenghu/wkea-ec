"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const chalk = require("chalk");
const fs = require("fs-extra");
const path = require("path");
const whitelistPackages = ['core-components', 'shared-components'];
const ValidationTypes = { module: 'module', package: 'package' };
const jsonschema_1 = require("jsonschema");
const validation_helpers_1 = require("./validation-helpers");
// Utility Functions
// Get a list of validations to run
function getValidationSuite(validationSuitePath) {
    if (!fs.existsSync(validationSuitePath) || !utilities_internal_1.isDirectory(validationSuitePath)) {
        utilities_internal_1.trace.error(`Validation Suite Path given does not exist: ${validationSuitePath}`);
        return [];
    }
    return fs.readdirSync(validationSuitePath).filter((file) => {
        return path.extname(file) === '.js';
    });
}
const packageValidationSuite = getValidationSuite(path.join(__dirname, '/packageValidation'));
const moduleValidationSuite = getValidationSuite(path.join(__dirname, '/moduleValidation'));
// Runs every validation in validationSuite against valdiationSubject. Returns T/F depending on result
// validationType - package or module. Determines which folder to look for and logs to output
// validationSuite- list of files with validation functions to run
// validationSubjects- Array of [path,name] arrays to run validation against
function runValidation(validationSubject, validationSuite, validationType) {
    return __awaiter(this, void 0, void 0, function* () {
        let overallStatus = validation_helpers_1.generateStatusJson();
        for (const [name, packagePath] of validationSubject) {
            let subjectStatus = validation_helpers_1.generateStatusJson();
            for (const validationToRun of validationSuite) {
                const options = { name: name, path: packagePath };
                // Diabling require warning here because we want to dynamically load each validator as needed
                // tslint:disable-next-line
                const validationResult = require(`./${validationType}Validation/${validationToRun}`)(options);
                subjectStatus = validation_helpers_1.mergeStatusJson(subjectStatus, validationResult);
            }
            if (subjectStatus.success) {
                utilities_internal_1.trace.info(`${chalk.default.cyan(name)}: ${`${validationType} Passed all ${validationType} level validation!`}`);
            }
            else {
                utilities_internal_1.trace.error(`${chalk.default.cyan(name)}: ${`${validationType} Failed ${validationType} level validation.`}`);
            }
            overallStatus = validation_helpers_1.mergeStatusJson(overallStatus, subjectStatus);
        }
        return overallStatus;
    });
}
function validateContentList(contentList, contentType) {
    const contentToValidate = [];
    for (const [contentName, contentPath] of contentList) {
        let pathToContent;
        const lastSlashIndex = contentPath.lastIndexOf('\\');
        if (lastSlashIndex === -1) {
            utilities_internal_1.trace.error(`Unable to check ${contentType} ${contentName} because there is no slash in the path`);
            continue;
        }
        if (contentType === 'module') {
            pathToContent = path.join(contentPath, `${contentName}.tsx`);
        }
        else if (contentType === 'theme') {
            pathToContent = path.join(contentPath, `${contentName}.definition.json`);
        }
        else {
            pathToContent = path.join(contentPath, `${contentName}.connector.json`);
        }
        if (validation_helpers_1.checkFileExists(pathToContent, `Unable to check ${contentType} ${contentName} because the listed path doesn't exist: `)) {
            contentToValidate.push([contentName, contentPath]);
        }
    }
    return contentToValidate;
}
/**
 * Returns an array of modules /themes/connector to validate, with each module/theme/connector information element being an array as follows [name, path]
 * @param packagePath -Path to the package that the modules/themes/connectors are located in
 * @param contentType Type of content to validate and map- module/theme/connector
 */
function getValidationContent(packagePath, contentType) {
    const contentList = [];
    let pathToContent;
    if (contentType === 'module') {
        pathToContent = path.resolve(packagePath, `src/modules`);
    }
    else if (contentType === 'theme') {
        pathToContent = path.resolve(packagePath, `src/themes`);
    }
    else {
        pathToContent = path.resolve(packagePath, `src/connectors`);
    }
    if (fs.existsSync(pathToContent)) {
        utilities_internal_1.getDirectories(pathToContent).forEach((name) => {
            const themePath = path.resolve(pathToContent, name);
            contentList.push([name, themePath]);
        });
    }
    // now let's validate that our package paths are good
    return validateContentList(contentList, contentType);
}
// Function to validate a Package, running package and module validations
function validatePackage(packagePath) {
    return __awaiter(this, void 0, void 0, function* () {
        let status = validation_helpers_1.generateStatusJson();
        utilities_internal_1.trace.info('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
        // Check to make sure that package path exists
        if (!validation_helpers_1.checkFileExists(packagePath, 'Package Path does not exist: ')) {
            return validation_helpers_1.markFailure(status);
        }
        const packageName = path.basename(packagePath);
        // check if it's in the whitelist
        if (whitelistPackages.indexOf(packageName) !== -1) {
            utilities_internal_1.trace.info(`${packageName} is in the whitelist... skipping validation`);
            return status;
        }
        // ok, package exists, now run package validations
        utilities_internal_1.trace.info(`Starting validation for package: ${packageName}`);
        utilities_internal_1.trace.debug(`Path to package: ${packagePath}`);
        const modulesToValidate = getValidationContent(packagePath, 'module');
        const themesToValidate = getValidationContent(packagePath, 'theme');
        const connectorToValidate = getValidationContent(packagePath, 'connector');
        if (connectorToValidate.length > 0) {
            status = validation_helpers_1.mergeStatusJson(status, runConnectorValidation(connectorToValidate, status));
        }
        status = validation_helpers_1.mergeStatusJson(status, yield runValidation([[packageName, packagePath]], packageValidationSuite, ValidationTypes.package));
        // Now get list of modules and run valdations against them:
        if (modulesToValidate.length === 0 && themesToValidate.length === 0 && connectorToValidate.length === 0) {
            return status;
        }
        status = validation_helpers_1.mergeStatusJson(status, yield runValidation(modulesToValidate, moduleValidationSuite, ValidationTypes.module));
        status = validation_helpers_1.mergeStatusJson(status, yield runValidation(themesToValidate, moduleValidationSuite, ValidationTypes.module));
        // return results of validations
        return status;
    });
}
exports.validatePackage = validatePackage;
function runConnectorValidation(connecter, status) {
    const validator = new jsonschema_1.Validator();
    for (const [name, connectorPath] of connecter) {
        const connectorJsonFilePath = path.resolve(connectorPath, `${name}.connector.json`);
        const connectorJson = fs.readJSONSync(connectorJsonFilePath);
        const providerFilePath = path.resolve(connectorPath, `${name}.provider.ts`);
        if (connectorJson.$type === 'experimentationConnector') {
            if (!validation_helpers_1.checkFileExists(providerFilePath, `The package has a connector of type: experimentationConnector for which ${name}.provider.ts file is missing`)) {
                return validation_helpers_1.markFailure(status);
            }
        }
        const validationResult = utilities_internal_1.runSchemaValidationWithNestedError(validator, utilities_internal_1.safeReadJsonSync(connectorJsonFilePath), 
        // tslint:disable-next-line:no-any
        utilities_internal_1.safeReadJsonSync(path.resolve(__dirname, '../..', 'connector-schema.json')));
        if (validationResult.errors.length > 0) {
            utilities_internal_1.trace.error(`Connector file ${name}.connector.json does not match connector schema. Error: ${validationResult.errors}`);
            return validation_helpers_1.markFailure(status);
        }
    }
    return status;
}
// function to validate all packages in a given folder
function validateAllPackages(packageRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        let status = validation_helpers_1.generateStatusJson();
        if (!validation_helpers_1.checkFileExists(packageRoot, 'Package root does not exist: ')) {
            return validation_helpers_1.markFailure(status);
        }
        const packagesToValidate = utilities_internal_1.getDirectories(packageRoot);
        // Run validation against all packages
        for (const p of packagesToValidate) {
            status = validation_helpers_1.mergeStatusJson(status, yield validatePackage(path.join(packageRoot, p)));
        }
        return status;
    });
}
exports.validateAllPackages = validateAllPackages;
module.exports.validateAllPackages = validateAllPackages;
module.exports.validatePackage = validatePackage;

"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @description add module script
 */
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const fs = require("fs-extra");
const klawSync = require("klaw-sync");
const logSymbols = require("log-symbols");
const path = require("path");
// @ts-ignore
const replaceInFile = require("replace-in-file");
const utils_1 = require("./utils");
let didCompleteModuleCodeGeneration = false;
let didRunDefinitionGeneratorSuccessfully = false;
/**
 * Creates a templated module within src/modules/ containing the basic module structure
 *
 * @param projectName The name of the module that will be applied to all the files contained in the module
 */
function addModule(projectName) {
    if (!projectName) {
        utilities_internal_1.trace.error('Please specify the project name\nExample:');
        utilities_internal_1.trace.error('msdyn365 add-module my-msdyn365-module');
        utils_1.printCmdAndExit(printCommandSummary, projectName);
    }
    // check if package.json file exists
    const packageJsonPath = path.resolve(process.cwd(), `package.json`);
    if (!fs.existsSync(packageJsonPath)) {
        utilities_internal_1.trace.error(`Please run this cli in the root folder (where your package.json is)\nExiting`);
        utils_1.printCmdAndExit(printCommandSummary, projectName);
    }
    const kebabCaseName = utils_1.buildKebabCaseName(projectName);
    const pascalCaseName = utils_1.convertToPascalCaseName(kebabCaseName);
    const modulePath = path.resolve(process.cwd(), `src/modules/${kebabCaseName}`);
    // check if starter pack module with same name exists
    const starterPackModulesPath = path.resolve(process.cwd(), `node_modules\\@msdyn365-commerce-modules`, kebabCaseName);
    if (fs.existsSync(starterPackModulesPath)) {
        utilities_internal_1.trace.error(`Starter pack module with name ${kebabCaseName} already exists, use another name\nExiting`);
        utils_1.printCmdAndExit(printCommandSummary, kebabCaseName);
    }
    // check if regular module already exists
    if (fs.existsSync(modulePath)) {
        utilities_internal_1.trace.error(`Module ${kebabCaseName} already exists, delete it or use another name\nExiting`);
        utils_1.printCmdAndExit(printCommandSummary, projectName);
    }
    // Copy over the template files into the modules folder
    utils_1.copyTemplateFilesToDir(modulePath, 'template/____keystone_module_name____');
    // rename directories first to avoid naming conflicts while modifying files
    // copy file names to editable array
    const readOnlyPathNames = klawSync(modulePath, {
        nofile: true
    });
    const editablePathNames = [];
    readOnlyPathNames.forEach((pathName, index) => {
        editablePathNames[index] = pathName.path;
    });
    // Rename directories
    editablePathNames.forEach((pathName, index, pathNames) => {
        if (pathName.indexOf(utils_1.PROJECT_PLACEHOLDER) !== -1) {
            const oldName = pathName;
            const newName = oldName.replace(utils_1.PROJECT_PLACEHOLDER, kebabCaseName);
            try {
                fs.renameSync(oldName, newName);
            }
            catch (error) {
                utilities_internal_1.trace.error(`Error while renaming directory ${oldName}`, error);
                utils_1.printCmdAndExit(printCommandSummary, projectName);
            }
            // Since directory has been renamed, modify the remaining paths
            for (let i = index; i < pathNames.length; i++) {
                if (pathNames[i].indexOf(oldName) !== -1) {
                    pathNames[i] = pathNames[i].replace(oldName, newName);
                }
            }
        }
    });
    // modify files
    const paths = klawSync(modulePath, { nodir: true });
    paths.forEach((pathName) => {
        // replace placeholders within files.
        const options = {
            files: pathName.path,
            from: utils_1.MODULE_REPLACEMENT,
            to: [pascalCaseName, kebabCaseName, projectName]
        };
        try {
            replaceInFile.sync(options);
        }
        catch (error) {
            utilities_internal_1.trace.error(`Error occurred while replacing placeholders within file ${pathName}`, error);
            utils_1.printCmdAndExit(printCommandSummary, projectName);
        }
        // rename files
        if (pathName.path.indexOf(utils_1.PROJECT_PLACEHOLDER) !== -1) {
            try {
                fs.renameSync(pathName.path, pathName.path.replace(utils_1.PROJECT_PLACEHOLDER, kebabCaseName));
            }
            catch (error) {
                utilities_internal_1.trace.error(`Error while renaming file ${pathName}`, error);
                utils_1.printCmdAndExit(printCommandSummary, projectName);
            }
        }
    });
    didRunDefinitionGeneratorSuccessfully = runDefinitionGenerator(kebabCaseName);
    didCompleteModuleCodeGeneration = true;
    printCommandSummary(kebabCaseName);
}
exports.default = addModule;
/**
 * Creates the autogenerated files for a module after pulling down the module
 * from starter pack. Returns true if the definition generator completed successfully
 */
function runDefinitionGenerator(moduleName) {
    utilities_internal_1.trace.info(`Created ${moduleName} ... Now running definition generator`);
    const result = utils_1.spawnSyncWithConsoleOutput(utils_1.DEFINITION_GENERATOR_COMMAND);
    return result.status === 0;
}
/**
 * Prints a summary of what the command did and documents any steps that failed
 */
function printCommandSummary(moduleName) {
    utilities_internal_1.trace.info(`=====================================================================`);
    utilities_internal_1.trace.info(`COMMAND SUMMARY: `);
    utilities_internal_1.trace.info(`\t${didCompleteModuleCodeGeneration ? logSymbols.success : logSymbols.error} Created module ${moduleName}`);
    utilities_internal_1.trace.info(`\t${didRunDefinitionGeneratorSuccessfully ? logSymbols.success : logSymbols.error} Ran definition generator`);
    utilities_internal_1.trace.info(didCompleteModuleCodeGeneration && didRunDefinitionGeneratorSuccessfully
        ? `Command completed successfully!`
        : `Command encountered errors. See above.`);
}

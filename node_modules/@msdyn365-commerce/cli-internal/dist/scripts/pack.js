"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @description package partner app
 */
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const archiver = require("archiver");
const child_process_1 = require("child_process");
const fs = require("fs-extra");
const path = require("path");
const semver = require("semver");
const temp_1 = require("temp");
const utils_1 = require("./utils");
const tmp = temp_1.track();
const PACKAGE_FILE = 'package.json';
const NPMRC_FILE = '.npmrc';
const YARNRC_FILE = '.yarnrc';
const NAMESPACES_WITH_CARROTS = ['@msdyn365-commerce/', '@msdyn365-commerce-modules/core-components'];
let tmpPartnerDir;
const FILES_TO_INCLUDE = ['.env', 'yarn.lock', 'tsconfig.json', 'tslint.json', 'ecosystem.config.js', '.development'];
const DIRS_TO_INCLUDE = ['src', 'public'];
/**
 * Gets the temporary directroy for the current partner build.
 * Creates the directory if it does not exist
 */
const getTempPartnerDir = () => {
    tmpPartnerDir = tmpPartnerDir || tmp.mkdirSync('__tmp_partner__');
    return tmpPartnerDir;
};
/**
 * Builds partner app and exits the 'pack' process on error
 */
const buildPartnerApp = () => {
    let shouldExitWithCode = 0;
    // Remove the yarn lock file so that it may be regenerated
    if (utilities_internal_1.safeFileExistsSync(path.resolve(process.cwd(), 'yarn.lock'))) {
        utilities_internal_1.trace.info('Existing yarn.lock found. Removing to regenerate yarn.lock');
        fs.removeSync(path.resolve(process.cwd(), 'yarn.lock'));
    }
    child_process_1.execSync('yarn --force');
    try {
        const result = utils_1.spawnSyncWithConsoleOutput('yarn build:prod');
        if (result.status && result.status !== 0) {
            shouldExitWithCode = result.status;
            throw result.error;
        }
    }
    catch (err) {
        utilities_internal_1.trace.error(`Error building application.`);
        utilities_internal_1.trace.error(err);
        process.exit(shouldExitWithCode === 0 ? 1 : shouldExitWithCode);
    }
};
/**
 * Returns the current based off of the branch
 */
const resolveGitVersion = (giturl) => {
    if (giturl.includes('Project.Rushmore')) {
        const [repo, branch] = giturl.split('#');
        const urlSegments = giturl.split('_');
        const possibleVersion = urlSegments[urlSegments.length - 1];
        const version = semver.coerce(possibleVersion);
        if (!version) {
            return '*';
        }
        switch ((possibleVersion.match(/X/g) || []).length) {
            case 2:
                return `^${version.version}`;
            case 1:
                return `~${version.version}`;
            default:
                return version.version;
        }
    }
    return giturl;
};
/**
 * Returns the current version defined in the package.json
 * @param packageRootDir Current Working Directory
 * @param fileFromPackageJson Relative path to package.json
 */
const resolveFileVersion = (packageRootDir, fileFromPackageJson) => {
    const filePath = fileFromPackageJson.replace('file:', '');
    const packageJsonPath = path.join(packageRootDir, filePath, PACKAGE_FILE);
    const depPackageJson = utilities_internal_1.safeReadJsonSync(packageJsonPath, utilities_internal_1.trace);
    if (!depPackageJson) {
        utilities_internal_1.trace.error(`Could not find package.json at ${packageJsonPath}`);
        process.exit(1);
        return '';
    }
    else {
        if (NAMESPACES_WITH_CARROTS.find(namespace => depPackageJson.name.startsWith(namespace))) {
            return `^${depPackageJson.version}`;
        }
        return depPackageJson.version;
    }
};
/**
 * Gets the root package.json in the directory
 * @param packageRootDir Current working directory
 */
const getPackageJson = (packageRootDir) => {
    const packageJson = utilities_internal_1.safeReadJsonSync(path.join(packageRootDir, PACKAGE_FILE), utilities_internal_1.trace);
    if (packageJson) {
        return packageJson;
    }
    else {
        utilities_internal_1.trace.error(`Could not find package.json at ${packageRootDir}`);
        process.exit(1);
    }
    return {};
};
/**
 * Generates name for the partner app package in the format: <name>-<version>.zip (standard 'npm pack' format)
 * @param packageRootDir
 */
const getPackageName = (packageRootDir, inputPackageName) => {
    const packageJson = getPackageJson(packageRootDir);
    return inputPackageName ? `${inputPackageName}.zip` : `${packageJson.name.replace('/', '-')}-${packageJson.version}.zip`;
};
/**
 * Creates a temporary directory and writes the resolved package.json. Returns the path to the resovled package.json
 * @param packageRootDir Current working directory
 */
const generatePackageJson = (packageRootDir) => {
    const packageJson = getPackageJson(packageRootDir);
    packageJson.resolutions = generateResolutions(packageJson);
    const deps = Object.keys(packageJson.dependencies);
    if (!packageJson.dependencies) {
        packageJson.dependencies = {};
    }
    packageJson.dependencies['@msdyn365-commerce/bootloader'] = '^1.0.0';
    deps.forEach(dep => {
        const version = packageJson.dependencies[dep];
        if (version.startsWith('file:')) {
            packageJson.dependencies[dep] = resolveFileVersion(packageRootDir, version);
        }
        else if (version.startsWith('git+')) {
            packageJson.dependencies[dep] = resolveGitVersion(version);
        }
    });
    const tmpDir = getTempPartnerDir();
    const tmpPackageJson = path.join(tmpDir, 'package.json');
    fs.writeFileSync(tmpPackageJson, JSON.stringify(packageJson, null, 2), 'utf8');
    return tmpPackageJson;
};
const generateResolutions = (packageJson) => {
    if (!packageJson.resolutions) {
        packageJson.resolutions = {};
    }
    packageJson.resolutions['@msdyn365-commerce/bootloader'] = '^1.0.0';
    packageJson.resolutions['@msdyn365-commerce/core'] = '^1.0.0';
    packageJson.resolutions['@msdyn365-commerce-modules/core-components'] = '^1.0.0';
    return packageJson.resolutions;
};
const generateNpmYarnRcFiles = (packageRootDir) => {
    const tmpDir = getTempPartnerDir();
    const tmpPackageNpmRc = path.join(tmpDir, '.npmrc');
    const tmpPackageYarnRc = path.join(tmpDir, 'yarnrc');
    const partnerNpmrcFile = path.resolve(packageRootDir, '.npmrc');
    const baseNpmrcFile = path.resolve(__dirname, '../.pack-npmrc');
    fs.writeFileSync(tmpPackageNpmRc, mergePartnerNpmrc(partnerNpmrcFile, baseNpmrcFile), 'utf8');
    fs.writeFileSync(tmpPackageYarnRc, utilities_internal_1.safeReadFileSync(path.resolve(__dirname, '../.pack-yarnrc')), 'utf8');
    return { npmrc: tmpPackageNpmRc, yarnrc: tmpPackageYarnRc };
};
const mergePartnerNpmrc = (partnerNpmrcFile, baseNpmrcFile) => {
    const partnerNpmrc = utilities_internal_1.safeReadFileSync(partnerNpmrcFile);
    const baseNpmrc = utilities_internal_1.safeReadFileSync(baseNpmrcFile);
    const baseNpmrcData = [];
    if (baseNpmrc) {
        const lines = baseNpmrc.split(/\r?\n/);
        lines.map(line => {
            baseNpmrcData.push(line);
        });
    }
    const partnerNpmrcData = [];
    if (partnerNpmrc) {
        const lines = baseNpmrc.split(/\r?\n/);
        lines.map(line => {
            if (line.startsWith('@') &&
                !line.startsWith('@msdyn365-commerce-theme:') &&
                !line.startsWith('@msdyn365-commerce-modules:') &&
                !line.startsWith('@msdyn365-commerce:')) {
                partnerNpmrcData.push(line);
            }
        });
    }
    return partnerNpmrcData.concat(baseNpmrcData).join('\r\n');
};
/**
 * Builds partner app and packages the sources after a successful build
 */
function packagePartnerApp(inputPackageName) {
    const packageRootDir = path.resolve(process.cwd());
    const npmYarnRcFiles = generateNpmYarnRcFiles(packageRootDir);
    // TODO: Need to validate to make sure core dependencies are not modified
    // Build the app before packaging the sources
    buildPartnerApp();
    try {
        const packageName = getPackageName(packageRootDir, inputPackageName);
        const output = fs.createWriteStream(packageName);
        const archive = archiver('zip');
        archive.pipe(output);
        DIRS_TO_INCLUDE.map(dir => archive.directory(path.join(packageRootDir, dir), dir));
        FILES_TO_INCLUDE.map(fileName => archive.file(path.join(packageRootDir, fileName), { name: fileName }));
        const newPackageJson = generatePackageJson(packageRootDir);
        archive.file(newPackageJson, { name: PACKAGE_FILE });
        archive.file(npmYarnRcFiles.npmrc, { name: NPMRC_FILE });
        archive.file(npmYarnRcFiles.yarnrc, { name: YARNRC_FILE });
        archive.finalize();
        utilities_internal_1.trace.info(`Created package at: ${packageName}`);
    }
    catch (err) {
        utilities_internal_1.trace.error(`Error occured while packaging the app.`);
        utilities_internal_1.trace.error(err);
        process.exit(1);
    }
}
exports.default = packagePartnerApp;

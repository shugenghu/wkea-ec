"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @description package partner app
 */
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const archiver = require("archiver");
const axios_1 = require("axios");
const child_process_1 = require("child_process");
const dotenv = require("dotenv");
const fs = require("fs-extra");
const path = require("path");
const semver = require("semver");
const temp_1 = require("temp");
const kill = require("tree-kill");
const utils_1 = require("./utils");
const tmp = temp_1.track();
const PACKAGE_FILE = 'package.json';
const NPMRC_FILE = '.npmrc';
const YARNRC_FILE = '.yarnrc';
const NAMESPACES_WITH_CARROTS = ['@msdyn365-commerce/', '@msdyn365-commerce-modules/core-components'];
let tmpPartnerDir;
const FILES_TO_INCLUDE = ['.env', 'yarn.lock', 'tsconfig.json', 'tslint.json', 'ecosystem.config.js', '.development', 'version.json'];
const DIRS_TO_INCLUDE = ['src', 'public'];
/**
 * Gets the temporary directroy for the current partner build.
 * Creates the directory if it does not exist
 */
const getTempPartnerDir = () => {
    tmpPartnerDir = tmpPartnerDir || tmp.mkdirSync('__tmp_partner__');
    return tmpPartnerDir;
};
/**
 * Runs the validate CLI command on the partner package to validate module definition and files.
 * Failing validation will result in pack command failing
 */
const validatePartnerApp = () => {
    utilities_internal_1.trace.info(`Running package validation...`);
    let validationPassed = true;
    try {
        child_process_1.execSync(`yarn msdyn365 validate ./`);
    }
    catch (err) {
        validationPassed = false;
    }
    if (validationPassed) {
        utilities_internal_1.trace.info(`Package validation passed.`);
    }
    else {
        utilities_internal_1.trace.warn(`Package validation failed...Continuing with the pack process.`);
        utilities_internal_1.trace.warn(`Please run 'yarn msdyn365 validate ./' to find and fix errors in your package.`);
    }
};
/**
 * Builds partner app and exits the 'pack' process on error
 */
const buildPartnerApp = () => {
    let shouldExitWithCode = 0;
    // Remove the yarn lock file so that it may be regenerated
    if (utilities_internal_1.safeFileExistsSync(path.resolve(process.cwd(), 'yarn.lock'))) {
        utilities_internal_1.trace.info('Existing yarn.lock found. Removing to regenerate yarn.lock');
        fs.removeSync(path.resolve(process.cwd(), 'yarn.lock'));
    }
    child_process_1.execSync('yarn --force');
    try {
        const result = utils_1.spawnSyncWithConsoleOutput('yarn build:prod');
        if (result.status && result.status !== 0) {
            shouldExitWithCode = result.status;
            throw result.error;
        }
    }
    catch (err) {
        utilities_internal_1.trace.error(`Error building application.`);
        utilities_internal_1.trace.error(err);
        process.exit(shouldExitWithCode === 0 ? 1 : shouldExitWithCode);
    }
};
const pidIsRunning = (pid) => {
    try {
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        return false;
    }
};
const checkPartnerAppStatus = () => __awaiter(void 0, void 0, void 0, function* () {
    utilities_internal_1.trace.info('Starting server and performing health check');
    const result = child_process_1.spawn('npm run start:prod', { shell: true, stdio: 'inherit', detached: true });
    let isServerHealth = false;
    try {
        isServerHealth = yield healthCheck();
    }
    catch (err) {
        utilities_internal_1.trace.error(`server is not healthy ${err}`);
    }
    kill(result.pid);
    // sometimes main proccess will exit before successfully terminate the child process.
    while (pidIsRunning(result.pid)) {
        utilities_internal_1.trace.info(`Server is running on background with process id - ${result.pid}, terminating the server`);
        yield sleep(2000);
        kill(result.pid);
    }
    if (!isServerHealth) {
        process.exit(1);
    }
});
const sleep = (ms) => {
    // tslint:disable-next-line:no-string-based-set-timeout
    return new Promise(resolve => setTimeout(resolve, ms));
};
const healthCheck = () => __awaiter(void 0, void 0, void 0, function* () {
    const envConfig = dotenv.parse(utilities_internal_1.safeReadFileSync(path.resolve(process.cwd(), '.env')));
    const port = envConfig.PORT || 3000;
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    utilities_internal_1.trace.info(`background server running on port ${port}`);
    let retry = 5;
    let healthCheckSuccess = false;
    while (retry > 0) {
        let res;
        try {
            res = yield axios_1.default.get(`https://localhost:${port}/containerhealth`);
        }
        catch (_a) {
            utilities_internal_1.trace.info('server is not healty');
        }
        if (res && res.status === 200) {
            utilities_internal_1.trace.info('server is healthy');
            healthCheckSuccess = true;
            break;
        }
        else {
            utilities_internal_1.trace.info('retrying...');
            yield sleep(3000);
            retry--;
        }
    }
    return healthCheckSuccess;
});
/**
 * Returns the current based off of the branch
 */
const resolveGitVersion = (giturl) => {
    if (giturl.includes('Project.Rushmore')) {
        const [repo, branch] = giturl.split('#');
        const urlSegments = giturl.split('_');
        const possibleVersion = urlSegments[urlSegments.length - 1];
        const version = semver.coerce(possibleVersion);
        if (!version) {
            return '*';
        }
        switch ((possibleVersion.match(/X/g) || []).length) {
            case 2:
                return `^${version.version}`;
            case 1:
                return `~${version.version}`;
            default:
                return version.version;
        }
    }
    return giturl;
};
/**
 * Returns the current version defined in the package.json
 * @param packageRootDir Current Working Directory
 * @param fileFromPackageJson Relative path to package.json
 */
const resolveFileVersion = (packageRootDir, fileFromPackageJson) => {
    const filePath = fileFromPackageJson.replace('file:', '');
    const packageJsonPath = path.join(packageRootDir, filePath, PACKAGE_FILE);
    const depPackageJson = utilities_internal_1.safeReadJsonSync(packageJsonPath, utilities_internal_1.trace);
    if (!depPackageJson) {
        utilities_internal_1.trace.error(`Could not find package.json at ${packageJsonPath}`);
        process.exit(1);
        return '';
    }
    else {
        if (NAMESPACES_WITH_CARROTS.find(namespace => depPackageJson.name.startsWith(namespace))) {
            return `^${depPackageJson.version}`;
        }
        return depPackageJson.version;
    }
};
/**
 * Gets the root package.json in the directory
 * @param packageRootDir Current working directory
 */
const getPackageJson = (packageRootDir) => {
    const packageJson = utilities_internal_1.safeReadJsonSync(path.join(packageRootDir, PACKAGE_FILE), utilities_internal_1.trace);
    if (packageJson) {
        return packageJson;
    }
    else {
        utilities_internal_1.trace.error(`Could not find package.json at ${packageRootDir}`);
        process.exit(1);
    }
    return {};
};
/**
 * Generates name for the partner app package in the format: <name>-<version>.zip (standard 'npm pack' format)
 * @param packageRootDir
 */
const getPackageName = (packageRootDir, inputPackageName) => {
    const packageJson = getPackageJson(packageRootDir);
    return inputPackageName ? `${inputPackageName}.zip` : `${packageJson.name.replace('/', '-')}-${packageJson.version}.zip`;
};
/**
 * Creates a temporary directory and writes the resolved package.json. Returns the path to the resovled package.json
 * @param packageRootDir Current working directory
 */
const generatePackageJson = (packageRootDir) => {
    const packageJson = getPackageJson(packageRootDir);
    // stamping flag to indicate the package is generated using msdyn365 pack cli
    // this will later be read by deployment pipeline to validate package
    packageJson.generated = true;
    packageJson.resolutions = generateResolutions(packageJson);
    const deps = Object.keys(packageJson.dependencies);
    if (!packageJson.dependencies) {
        packageJson.dependencies = {};
    }
    packageJson.dependencies['@msdyn365-commerce/bootloader'] = '^1.0.0';
    deps.forEach(dep => {
        const version = packageJson.dependencies[dep];
        if (version.startsWith('file:')) {
            packageJson.dependencies[dep] = resolveFileVersion(packageRootDir, version);
        }
        else if (version.startsWith('git+')) {
            packageJson.dependencies[dep] = resolveGitVersion(version);
        }
    });
    const tmpDir = getTempPartnerDir();
    const tmpPackageJson = path.join(tmpDir, 'package.json');
    fs.writeFileSync(tmpPackageJson, JSON.stringify(packageJson, null, 2), 'utf8');
    return tmpPackageJson;
};
const generateResolutions = (packageJson) => {
    if (!packageJson.resolutions) {
        packageJson.resolutions = {};
    }
    packageJson.resolutions['@msdyn365-commerce/bootloader'] = '^1.0.0';
    packageJson.resolutions['@msdyn365-commerce/core'] = '^1.0.0';
    packageJson.resolutions['@msdyn365-commerce-modules/core-components'] = '^1.0.0';
    return packageJson.resolutions;
};
const generateNpmYarnRcFiles = (packageRootDir) => {
    const tmpDir = getTempPartnerDir();
    const tmpPackageNpmRc = path.join(tmpDir, '.npmrc');
    const tmpPackageYarnRc = path.join(tmpDir, 'yarnrc');
    const partnerNpmrcFile = path.resolve(packageRootDir, '.npmrc');
    const baseNpmrcFile = path.resolve(__dirname, '../.pack-npmrc');
    fs.writeFileSync(tmpPackageNpmRc, mergePartnerNpmrc(partnerNpmrcFile, baseNpmrcFile), 'utf8');
    fs.writeFileSync(tmpPackageYarnRc, utilities_internal_1.safeReadFileSync(path.resolve(__dirname, '../.pack-yarnrc')), 'utf8');
    return { npmrc: tmpPackageNpmRc, yarnrc: tmpPackageYarnRc };
};
const mergePartnerNpmrc = (partnerNpmrcFile, baseNpmrcFile) => {
    const partnerNpmrc = utilities_internal_1.safeReadFileSync(partnerNpmrcFile);
    const baseNpmrc = utilities_internal_1.safeReadFileSync(baseNpmrcFile);
    const baseNpmrcData = [];
    if (baseNpmrc) {
        const lines = baseNpmrc.split(/\r?\n/);
        lines.map(line => {
            baseNpmrcData.push(line);
        });
    }
    const partnerNpmrcData = [];
    if (partnerNpmrc) {
        const lines = baseNpmrc.split(/\r?\n/);
        lines.map(line => {
            if (line.startsWith('@') &&
                !line.startsWith('@msdyn365-commerce-theme:') &&
                !line.startsWith('@msdyn365-commerce-modules:') &&
                !line.startsWith('@msdyn365-commerce:')) {
                partnerNpmrcData.push(line);
            }
        });
    }
    return partnerNpmrcData.concat(baseNpmrcData).join('\r\n');
};
/**
 * Builds partner app and packages the sources after a successful build
 */
function packagePartnerApp(inputPackageName, skipHealthCheck = false, useMaxMemoryHeap = false, skipPackageValidation = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (useMaxMemoryHeap) {
            process.env.NODE_OPTIONS = '--max_old_space_size=4096';
        }
        const packageRootDir = path.resolve(process.cwd());
        const npmYarnRcFiles = generateNpmYarnRcFiles(packageRootDir);
        // Validate the partner application and fail pack if the package fails validation
        if (!skipPackageValidation) {
            validatePartnerApp();
        }
        else {
            utilities_internal_1.trace.info('Skipping package validation...');
        }
        // TODO: Need to validate to make sure core dependencies are not modified
        // Build the app before packaging the sources
        buildPartnerApp();
        // check if server successfully start
        if (!skipHealthCheck) {
            yield checkPartnerAppStatus();
        }
        try {
            const packageName = getPackageName(packageRootDir, inputPackageName);
            const output = fs.createWriteStream(packageName);
            const archive = archiver('zip');
            archive.pipe(output);
            DIRS_TO_INCLUDE.map(dir => archive.directory(path.join(packageRootDir, dir), dir));
            FILES_TO_INCLUDE.map(fileName => archive.file(path.join(packageRootDir, fileName), { name: fileName }));
            const newPackageJson = generatePackageJson(packageRootDir);
            archive.file(newPackageJson, { name: PACKAGE_FILE });
            archive.file(npmYarnRcFiles.npmrc, { name: NPMRC_FILE });
            archive.file(npmYarnRcFiles.yarnrc, { name: YARNRC_FILE });
            archive.finalize();
            utilities_internal_1.trace.info(`Created package at: ${packageName}`);
        }
        catch (err) {
            utilities_internal_1.trace.error(`Error occured while packaging the app.`);
            utilities_internal_1.trace.error(err);
            process.exit(1);
        }
    });
}
exports.default = packagePartnerApp;

/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const fs = require("fs-extra");
const klawSync = require("klaw-sync");
const logSymbols = require("log-symbols");
const path = require("path");
// @ts-ignore
const replaceInFile = require("replace-in-file");
const utils_1 = require("./utils");
// Preset Paths
const rootPackagePath = process.cwd();
const starterPackModulesPath = utils_1.getMSDyn365ModuleDir();
const partnerModulesPath = path.resolve(rootPackagePath, 'src/modules');
// Keeps a mapping of module names to their file path
const copyableModulesFileMap = {};
const EXCLUDE_MODULES_FROM_MODIFICATION = new Set(['core-components']);
// Used to print command summary at the end
let didPullDownStarterPackModule = false;
let didRunDefinitionGeneratorSuccessfully = false;
let didSuccessfullyRenameCopiedModule = false;
/**
 * Populates a mapping of all copy-able modules to their file path location
 */
const mapModuleNameToModulePath = () => {
    utilities_internal_1.getDirectories(starterPackModulesPath).forEach((moduleName) => {
        const modulePath = path.resolve(starterPackModulesPath, moduleName);
        if (!EXCLUDE_MODULES_FROM_MODIFICATION.has(moduleName)) {
            if (fs.existsSync(path.resolve(modulePath, 'src/modules'))) {
                utilities_internal_1.getDirectories(path.resolve(modulePath, 'src/modules')).forEach((subModuleName) => {
                    // Check to see if this is a valid module with a module definition file
                    const subModulePath = path.resolve(modulePath, 'src/modules', `${subModuleName}`);
                    if (fs.existsSync(path.resolve(subModulePath, `${subModuleName}.definition.json`))) {
                        copyableModulesFileMap[subModuleName] = subModulePath;
                    }
                });
            }
        }
    });
};
/**
 * Prints a list of store starter kit modules that are capable of being copied
 * to a partner's environment
 */
const printListOfSupportedModules = () => {
    const copyableModules = Object.keys(copyableModulesFileMap);
    copyableModules.length === 0
        ? utilities_internal_1.trace.error('No modules for modification found. Please ensure you have dependencies on starter-pack or other modules to run this command')
        : utilities_internal_1.trace.info(JSON.stringify(copyableModules));
};
/**
 *  Function to filter out copying of test directory
 */
const filterTestDirectory = (src) => {
    if (src.includes(`__tests__`) || src.includes('tests')) {
        return false;
    }
    return true;
};
/**
 * Copies the starter pack module down to the partner environment
 */
const copyStarterPackModuleToPartnerEnv = (moduleName) => {
    try {
        fs.copySync(copyableModulesFileMap[moduleName], path.resolve(partnerModulesPath, moduleName), { filter: filterTestDirectory });
    }
    catch (err) {
        utilities_internal_1.trace.error('Error copying starter pack module source code. Unable to locate src/modules within selected module', err);
        utils_1.printCmdAndExit(printCommandSummary, moduleName);
    }
    utilities_internal_1.trace.info('File copying done!');
    didPullDownStarterPackModule = true;
};
/**
 * Renames the copied starter pack module directories to new module name
 */
const renameCopiedModuleDirectories = (modulesBasePath, oldModuleName, newModuleName) => {
    // Counter to keep track of the depth of renaming directories
    let directoryLevelRenameCounter = 0;
    const editablePathNames = [];
    // rename directories first to avoid naming conflicts while modifying files
    const modulePath = path.join(modulesBasePath, oldModuleName);
    // copy file names to editable array
    const readOnlyPathNames = klawSync(modulePath, {
        nofile: true
    });
    readOnlyPathNames.forEach((pathName, index) => {
        editablePathNames[index] = pathName.path;
    });
    editablePathNames.unshift(modulePath);
    // Rename directories first
    editablePathNames.forEach((pathName) => {
        // Limiting rename to only top level directory
        if (path.basename(pathName).indexOf(oldModuleName) !== -1 && directoryLevelRenameCounter < 1) {
            const oldName = pathName;
            const newName = oldName.replace(oldModuleName, newModuleName);
            try {
                fs.renameSync(oldName, newName);
                directoryLevelRenameCounter++;
            }
            catch (error) {
                utilities_internal_1.trace.error(`Error while renaming directory ${oldName}`, error);
                utils_1.printCmdAndExit(printCommandSummary, oldModuleName);
            }
        }
    });
};
/**
 * Renames the copied starter pack module files to new module name
 */
const renameCopiedModuleFiles = (modulesBasePath, oldModuleName, newModuleName) => {
    const modulePath = path.join(modulesBasePath, newModuleName);
    // Rename files
    const paths = klawSync(modulePath, { nodir: true });
    paths.forEach((pathName) => {
        // Look for files with starter-pack module name
        if (path.basename(pathName.path).indexOf(oldModuleName) !== -1) {
            // Modify module definition name if file name matches *.definition.json
            const filePath = pathName.path;
            if (filePath.includes('.definition.json')) {
                updateContentInDefinitionFile(filePath, oldModuleName, newModuleName);
            }
            else if (filePath.includes('.json')) {
                // tslint:disable-next-line: no-any The structure of mock files is known
                const mockJson = utilities_internal_1.safeReadJsonSync(filePath);
                if (mockJson && mockJson.typeName) {
                    mockJson.typeName = `${mockJson.typeName}`.replace(oldModuleName, newModuleName);
                    fs.writeJSONSync(filePath, mockJson, { spaces: '\t' });
                }
            }
            else if (filePath.includes('.ts')) {
                renamePlaceholdersInTsFiles(oldModuleName, newModuleName, pathName);
            }
            // Rename files
            if (!filePath.includes('actions')) {
                try {
                    fs.renameSync(filePath, `${path.dirname(filePath)}/${path.basename(filePath).replace(oldModuleName, newModuleName)}`);
                }
                catch (error) {
                    utilities_internal_1.trace.error(`Error while renaming file ${pathName.path}`, error);
                    utils_1.printCmdAndExit(printCommandSummary, oldModuleName);
                }
            }
        }
        if (pathName.path.includes('index.ts')) {
            renamePlaceholdersInIndexFile(oldModuleName, newModuleName, pathName);
        }
    });
};
/**
 * Rename placeholders in TS files
 */
const renamePlaceholdersInTsFiles = (oldModuleName, newModuleName, pathName) => {
    // Convert the import statements in the ts(x) files to import the newly renmaed interfaces
    // from the new file paths
    // Regex to match the old file paths for view, autogen props and data files
    const propsImportRegex = new RegExp(`${oldModuleName}\.props\.autogenerated\'/;`, 'g');
    const dataImportRegex = new RegExp(`${oldModuleName}\.data\'/;`, 'g');
    // Regex to match old config, data, props class names
    const oldModulePascalName = utils_1.convertToPascalCaseName(oldModuleName);
    const autoGenConfigClassName = new RegExp(`I${oldModulePascalName}Config`, 'g');
    const autoGenPropsClassName = new RegExp(`I${oldModulePascalName}Props`, 'g');
    const autoGenResourcesClassName = new RegExp(`I${oldModulePascalName}Resources`, 'g');
    const dataClassName = new RegExp(`I${oldModulePascalName}Data`, 'g');
    const viewImportRegex = new RegExp(`\/${oldModuleName}`, 'g');
    const newModulePascalName = utils_1.convertToPascalCaseName(newModuleName);
    // Map each old filepath/classname to its new equivalent
    const options = {
        files: pathName.path,
        from: [
            propsImportRegex,
            dataImportRegex,
            autoGenConfigClassName,
            autoGenPropsClassName,
            dataClassName,
            autoGenResourcesClassName,
            viewImportRegex
        ],
        to: [
            `${newModuleName}.props.autogenerated`,
            `${newModuleName}.data`,
            `I${newModulePascalName}Config`,
            `I${newModulePascalName}Props`,
            `I${newModulePascalName}Data`,
            `I${newModulePascalName}Resources`,
            `/${newModuleName}`
        ]
    };
    replaceInFileFunction(options, oldModuleName, pathName);
};
/**
 *  Rename content in module defintiion file
 */
const updateContentInDefinitionFile = (filePath, oldModuleName, newModuleName) => {
    // tslint:disable-next-line: no-any The structure of definition.json is known
    const defN = utilities_internal_1.safeReadJsonSync(filePath);
    if (defN) {
        defN.name = `${defN.name}`.replace(oldModuleName, newModuleName);
        defN.friendlyName = `${defN.friendlyName} (COPY)`;
        if (defN.module && defN.module.view) {
            defN.module.view = `${defN.module.view}`.replace(oldModuleName, newModuleName);
        }
        fs.writeJSONSync(filePath, defN, { spaces: '\t' });
    }
};
/**
 * Rename imports/exports in module index files
 */
const renamePlaceholdersInIndexFile = (oldModuleName, newModuleName, pathName) => {
    const readIndexFile = fs.readFileSync(pathName.path).toString();
    if (readIndexFile.includes(oldModuleName)) {
        const oldModuleNameRegex = new RegExp(`\/${oldModuleName}`, 'g');
        const oldModulePascalName = utils_1.convertToPascalCaseName(oldModuleName);
        const autoGenConfigClassName = new RegExp(`I${oldModulePascalName}Config`, 'g');
        const autoGenPropsClassName = new RegExp(`I${oldModulePascalName}Props`, 'g');
        const dataClassName = new RegExp(`I${oldModulePascalName}Data`, 'g');
        const autoGenResourcesClassName = new RegExp(`I${oldModulePascalName}Resources`, 'g');
        const newModulePascalName = utils_1.convertToPascalCaseName(newModuleName);
        const options = {
            files: pathName.path,
            from: [oldModuleNameRegex, autoGenConfigClassName, autoGenPropsClassName, dataClassName, autoGenResourcesClassName],
            to: [
                `/${newModuleName}`,
                `I${newModulePascalName}Config`,
                `I${newModulePascalName}Props`,
                `I${newModulePascalName}Data`,
                `I${newModulePascalName}Resources`
            ]
        };
        replaceInFileFunction(options, oldModuleName, pathName);
    }
};
/**
 * Inject a starter pack module into a partners modules library
 * Command Format: keystone modify {starterPackModuleName}
 */
function copyModule(args) {
    mapModuleNameToModulePath();
    // Check for starter pack modules folder
    if (!fs.existsSync(starterPackModulesPath)) {
        utilities_internal_1.trace.debug(`Expected location of starter pack modules: ${starterPackModulesPath}`);
        utilities_internal_1.trace.error('Could not find any MSDyn365 modules. Please ensure you have dependencies on starter-pack or other modules to run this command');
    }
    // If --listmodules is passed in, print the list of modules available for modification and exit
    if (args.listmodules) {
        printListOfSupportedModules();
    }
    else {
        const moduleName = args.starterPackModuleName;
        let newModuleName = args.newModuleName;
        // Fail if newModuleName is not provided
        if (!newModuleName) {
            utilities_internal_1.trace.error(`Missing argument 'newModuleName'. Copy command requires a new unique name to name the copied starter pack module.`);
            utils_1.printCmdAndExit(printCommandSummary, moduleName);
        }
        // If newModuleName wasn't provided we would have already failed and exited this script so this is ok to do for typing purposes
        newModuleName = newModuleName || '';
        newModuleName = utils_1.buildKebabCaseName(newModuleName);
        if (fs.existsSync(copyableModulesFileMap[moduleName])) {
            // Check if partner already has a module with the same name
            if (fs.existsSync(path.resolve(partnerModulesPath, newModuleName))) {
                utilities_internal_1.trace.error(`module ${newModuleName} already exists at ${partnerModulesPath} Please choose another name or rename the existing one`);
                utils_1.printCmdAndExit(printCommandSummary, moduleName);
            }
            else {
                // Do the copying of the module upto the partners modules folder
                copyStarterPackModuleToPartnerEnv(moduleName);
                // Rename the directories to newModuleName
                renameCopiedModuleDirectories(partnerModulesPath, moduleName, newModuleName);
                // Rename the files of the copied module to newModuleName
                renameCopiedModuleFiles(partnerModulesPath, moduleName, newModuleName);
                didSuccessfullyRenameCopiedModule = true;
                didRunDefinitionGeneratorSuccessfully = runDefinitionGenerator(newModuleName);
                printCommandSummary(moduleName);
            }
        }
        else {
            utilities_internal_1.trace.error('The module you requested does not exist in the starter pack');
            printListOfSupportedModules();
            utils_1.printCmdAndExit(printCommandSummary, moduleName);
        }
    }
}
exports.default = copyModule;
/**
 * Common function to run replaceInFile.sync
 */
const replaceInFileFunction = (options, oldModuleName, pathName) => {
    try {
        replaceInFile.sync(options);
    }
    catch (error) {
        utilities_internal_1.trace.error(`Error occurred while replacing placeholders within file ${pathName}`, error);
        utils_1.printCmdAndExit(printCommandSummary, oldModuleName);
    }
};
/**
 * Creates the autogenerated files for a module after pulling down the module
 * from starter pack. Returns true if the definition generator completed successfully
 */
function runDefinitionGenerator(moduleName) {
    utilities_internal_1.trace.info(`Created ${moduleName} ... Now generating types for module definition`);
    const result = utils_1.spawnSyncWithConsoleOutput(utils_1.DEFINITION_GENERATOR_COMMAND);
    return result.status === 0;
}
/**
 * Prints a summary of what the command did and documents any steps that failed
 */
function printCommandSummary(moduleName) {
    utilities_internal_1.trace.info(`=====================================================================`);
    utilities_internal_1.trace.info(`COMMAND SUMMARY: `);
    utilities_internal_1.trace.info(`\t${didPullDownStarterPackModule ? logSymbols.success : logSymbols.error} Pulled down starter-pack module ${moduleName}`);
    utilities_internal_1.trace.info(`\t${didSuccessfullyRenameCopiedModule ? logSymbols.success : logSymbols.error} Renamed starter-pack module ${moduleName}`);
    utilities_internal_1.trace.info(`\t${didRunDefinitionGeneratorSuccessfully ? logSymbols.warning : logSymbols.error} Ran definition generator`);
    utilities_internal_1.trace.warn(`WARNING`);
    utilities_internal_1.trace.warn(`=====================================================================`);
    utilities_internal_1.trace.warn(`The copy command only copies module source code. It does not guarantee successful build of a module as there could be file path and package dependencies missing.`);
    utilities_internal_1.trace.warn(`Please check copied module for any missing dependencies before building and rename interfaces/classes as needed.`);
    utilities_internal_1.trace.warn(`Also please fix the files with import paths to methods which are outside the module scope for build to be successful.`);
    utilities_internal_1.trace.warn(`Delete any modules you do not wish to modify and run "yarn" to install dependencies. Once the dependencies are installed, build and check for any errors/warnings and resolve them accordingly.`);
    utilities_internal_1.trace.info(didPullDownStarterPackModule && didRunDefinitionGeneratorSuccessfully && didRunDefinitionGeneratorSuccessfully
        ? `Command completed successfully with warnings! See warning.`
        : `Command encountered errors. See above.`);
}

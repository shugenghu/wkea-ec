"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utilities_internal_1 = require("@msdyn365-commerce/utilities-internal");
const fs = require("fs-extra");
const jsonschema_1 = require("jsonschema");
const path = require("path");
const validation_helpers_1 = require("../validation-helpers");
/**
 * Validates definition extensions folder for a theme module
 * @param modulePath path to the theme module
 * @param status validation status
 * @param validator Validator
 */
const validateDefinitionExtensions = (modulePath, status, validator) => {
    let isMissingAutogeneratedPropFile = false;
    const definitionExtensionsPath = path.resolve(modulePath, "definition-extensions" /* DEF_EXTENSIONS_FOLDER */);
    if (fs.existsSync(definitionExtensionsPath)) {
        const filesInDir = utilities_internal_1.getFilesInDirSync(definitionExtensionsPath) || [];
        // Do not allow any file extensions other than .definition.ext.json and .ext.props.autogenerated.ts
        filesInDir.forEach(name => {
            if (!name.endsWith(".definition.ext.json" /* DEF_EXTENSION_FILE */) && !name.endsWith(".ext.props.autogenerated.ts" /* DEF_EXT_PROPS */)) {
                utilities_internal_1.trace.error(`Unsupported file extension ${name} found in definition-extensions`);
                validation_helpers_1.markFailure(status);
            }
        });
        const definitionExtensions = filesInDir.filter(name => name.endsWith(".definition.ext.json" /* DEF_EXTENSION_FILE */));
        definitionExtensions.forEach((name) => {
            const moduleName = path.basename(name, ".definition.ext.json" /* DEF_EXTENSION_FILE */);
            // Check for corresponding .ext.props.autogenerated.ts file
            if (filesInDir.indexOf(`${moduleName}${".ext.props.autogenerated.ts" /* DEF_EXT_PROPS */}`) === -1) {
                isMissingAutogeneratedPropFile = true;
            }
            // validate definition.ext.json against definition-schema
            const extValidationResult = validator.validate(utilities_internal_1.safeReadJsonSync(path.resolve(definitionExtensionsPath, name)), 
            // tslint:disable-next-line:no-any
            utilities_internal_1.safeReadJsonSync(path.resolve(__dirname, '../..', 'definition-schema.json')));
            if (extValidationResult.errors.length > 0) {
                utilities_internal_1.trace.error(`Extended Module defintion ${name} does not match definition schema. Error: ${extValidationResult.errors}`);
                validation_helpers_1.markFailure(status);
            }
        });
    }
    return {
        isMissingAutogeneratedPropFile
    };
};
/**
 * Validates theme stylePreset definition file against the style-presets-schema.json file
 * @param themePath path to the theme module
 * @param status validation status
 * @param validator Validator
 */
const validateStylePresetDefinition = (themeName, themePath, status, validator) => {
    const styleDefinitionsFilePath = path.resolve(themePath, "styles" /* STYLES */);
    if (fs.existsSync(styleDefinitionsFilePath)) {
        const filesInDir = utilities_internal_1.getFilesInDirSync(styleDefinitionsFilePath) || [];
        // Do not allow any file extension other than .scss, .definition.scss.json and .scss.json
        filesInDir.forEach(name => {
            if (!name.endsWith(".theme.scss" /* STYLE_SCSS_FILE */) &&
                !name.endsWith(".definition.scss.json" /* STYLE_PRESET_FILE */) &&
                !name.endsWith(".scss.json" /* STYLE_PRESET_INSTANCE_FILE */)) {
                utilities_internal_1.trace.error(`Unsupported file extension ${name} found in styles folder`);
                validation_helpers_1.markFailure(status);
            }
        });
        const defaultStylePreset = filesInDir.filter(name => name.endsWith(".definition.scss.json" /* STYLE_PRESET_FILE */));
        let defaultStylePresetValidationStatus = true;
        defaultStylePreset.forEach((name) => {
            // Extract name of style preset definition file
            const stylePresetFileName = path.basename(name, ".definition.scss.json" /* STYLE_PRESET_FILE */);
            // Extract name property from style preset .definition.scss.json file
            const readJSON = fs.readJSONSync(path.resolve(styleDefinitionsFilePath, name));
            const definitionThemeName = readJSON.name;
            if (stylePresetFileName === themeName) {
                if (definitionThemeName === stylePresetFileName) {
                    // validate the style preset definition file with the definiton-schema
                    const validationResult = validator.validate(utilities_internal_1.safeReadJsonSync(path.resolve(styleDefinitionsFilePath, `${themeName}.definition.scss.json`)), 
                    // tslint:disable-next-line:no-any
                    utilities_internal_1.safeReadJsonSync(path.resolve(__dirname, '../..', 'style-presets-schema.json')));
                    if (validationResult.errors.length > 0) {
                        defaultStylePresetValidationStatus = false;
                        utilities_internal_1.trace.error('Style-preset definition file does not match the style-preset-schema');
                        utilities_internal_1.trace.error(`Error: ${validationResult.errors}`);
                        validation_helpers_1.markFailure(status);
                    }
                }
                else {
                    utilities_internal_1.trace.error('The name property in the definition style preset file should match the .definition.scss.json file name');
                    validation_helpers_1.markFailure(status);
                }
            }
            else {
                utilities_internal_1.trace.error(`Definition style preset file name does not match: ${themeName}.definition.scss.json`);
                validation_helpers_1.markFailure(status);
            }
        });
        const instanceStylePreset = filesInDir.filter(name => name.endsWith(".scss.json" /* STYLE_PRESET_INSTANCE_FILE */) && !name.endsWith(".definition.scss.json" /* STYLE_PRESET_FILE */));
        if (instanceStylePreset.length > 0 && defaultStylePresetValidationStatus) {
            validateStylePresetInstance(status, validator, styleDefinitionsFilePath, defaultStylePreset, instanceStylePreset);
        }
    }
};
/** Validates theme stylePreset instance files against the default style preset theme definition file
 * @param themePath path to the theme module
 * @param status validation status
 * @param validator Validator
 * @param styleDefinitionsFilePath path to the styles folder of the theme module
 * @param stylePresetDefault default style preset definition file of the theme module
 * @param stylePresetInstanceFiles style preset instance files of the theme module
 */
const validateStylePresetInstance = (status, validator, styleDefinitionsFilePath, stylePresetDefinitionFile, stylePresetInstanceFiles) => {
    let defaultStylePreset;
    let extractedPropertiesFromDefaultStylePreset = {};
    const stylePresetSchema = fs.readJSONSync(path.resolve(__dirname, '../..', 'style-presets-schema.json'));
    for (let i = 0; i < stylePresetDefinitionFile.length; i++) {
        const themeName = path.basename(stylePresetDefinitionFile[i], ".definition.scss.json" /* STYLE_PRESET_FILE */);
        defaultStylePreset = fs.readJSONSync(path.resolve(styleDefinitionsFilePath, `${themeName}.definition.scss.json`));
    }
    // Extracting global style preset properties from default style preset, setting them in temp stylePresetSchema
    extractedPropertiesFromDefaultStylePreset = defaultStylePreset.global;
    stylePresetSchema.definitions.global.patternProperties = undefined;
    stylePresetSchema.definitions.global.properties = extractedPropertiesFromDefaultStylePreset;
    // Extracting modules style preset properties from default style preset and setting them in temp stylePresetSchema
    extractedPropertiesFromDefaultStylePreset = defaultStylePreset.modules;
    stylePresetSchema.definitions.modules.patternProperties = undefined;
    stylePresetSchema.definitions.modules.properties = extractedPropertiesFromDefaultStylePreset;
    const modulePropsList = stylePresetSchema.definitions.modules.properties;
    const stylePresetModules = Object.keys(modulePropsList);
    // Altering the schema of modules in stylePreset to validate all the properties of a given module
    if (stylePresetModules.length > 0) {
        for (let i = 0; i < stylePresetModules.length; i++) {
            const presetModule = stylePresetModules[i];
            const moduleProperties = stylePresetSchema.definitions.modules.properties[presetModule];
            stylePresetSchema.definitions.modules.properties[presetModule] = {
                type: 'object',
                additionalProperties: false,
                properties: moduleProperties
            };
        }
    }
    // Setting additional properties in stylePresetSchema for global and modules as false to satisfy validation requirement
    stylePresetSchema.definitions.global.additionalProperties = false;
    stylePresetSchema.definitions.modules.additionalProperties = false;
    for (let i = 0; i < stylePresetInstanceFiles.length; i++) {
        const readJSON = fs.readJSONSync(path.resolve(styleDefinitionsFilePath, stylePresetInstanceFiles[i]));
        const stylePresetInstanceFileName = path.basename(stylePresetInstanceFiles[i], ".scss.json" /* STYLE_PRESET_INSTANCE_FILE */);
        if (readJSON.name === stylePresetInstanceFileName) {
            const validationResult = validator.validate(utilities_internal_1.safeReadJsonSync(path.resolve(styleDefinitionsFilePath, `${readJSON.name}.scss.json`)), stylePresetSchema);
            if (validationResult.errors.length > 0) {
                utilities_internal_1.trace.error(`Style preset instance file ${readJSON.name} does not match the style-preset-definition file for the current theme.`);
                utilities_internal_1.trace.error(`Error: ${validationResult.errors}`);
                validation_helpers_1.markFailure(status);
            }
        }
        else {
            utilities_internal_1.trace.error(`The name property in ${stylePresetInstanceFiles[i]} should match the .scss.json file name.`);
            validation_helpers_1.markFailure(status);
        }
    }
};
/**
 * This validation checks for the existance of file extension files and
 * validates that the data.ts file (if it exists) matches the view name.
 * Lastly, it validates the module defintion follows the appropriate JSON schema.
 * For example, it checks for the existance of this file:
 * modulePath/moduleName.data.ts
 * @param options A module registration object that contains the name and path of the module
 */
// tslint:disable-next-line:no-any
module.exports = (options) => {
    const modulePath = options.path;
    const moduleName = options.name;
    const status = validation_helpers_1.generateStatusJson();
    const requiredExtensionList = ['.tsx', '.definition.json'];
    requiredExtensionList.forEach((extensionToCheck) => {
        const filePathToCheck = path.join(modulePath, `${moduleName}${extensionToCheck}`);
        if (!validation_helpers_1.checkFileExists(filePathToCheck, 'Expected the following file to exist: ')) {
            validation_helpers_1.markFailure(status);
        }
    });
    // Validate that the view file name matches the name given in the module definition
    // disable no-any because we know the schema of the module definition json
    // tslint:disable-next-line: no-unnecessary-type-assertion no-any
    const moduleDefinitionFile = utilities_internal_1.safeReadJsonSync(path.resolve(modulePath, `${moduleName}.definition.json`));
    const moduleDefinitionName = moduleDefinitionFile.name;
    // Read all the filenames in the modules directory and validate
    // that the view name matches the name given in the definition file
    // and print a warning if autogenerated prop file is missing
    let isMissingAutogeneratedPropFile = true;
    let isMissingViewFile = true;
    utilities_internal_1.getFilesInDirSync(modulePath).forEach((name) => {
        if (name.indexOf('.props.autogenerated.ts') !== -1) {
            isMissingAutogeneratedPropFile = false;
        }
        if (name.indexOf('.tsx') !== -1 && name.indexOf(moduleDefinitionName) !== -1) {
            isMissingViewFile = false;
        }
    });
    const validator = new jsonschema_1.Validator();
    // If this is a theme module perform an extra set of validations
    // tslint:disable-next-line: no-string-literal we know this property is required on definition files
    if (moduleDefinitionFile['$type'] === 'themeModule') {
        isMissingAutogeneratedPropFile = false;
        if (moduleDefinitionFile.name !== moduleName) {
            utilities_internal_1.trace.error('Theme name in definition file must match directory name.');
            validation_helpers_1.markFailure(status);
        }
        if (!validation_helpers_1.checkFileExists(path.resolve(modulePath, `styles/${moduleName}.theme.scss`), 'Expected the following file to exist')) {
            utilities_internal_1.trace.error('Theme package is missing a theme sass file or is incorretly name');
            validation_helpers_1.markFailure(status);
        }
        if (!validation_helpers_1.checkFileExists(path.resolve(modulePath, `${moduleName}.theme.settings.json`), 'Expected the following file to exist')) {
            utilities_internal_1.trace.error('Theme package is missing a theme settings file or incorrectly named');
            validation_helpers_1.markFailure(status);
        }
        isMissingAutogeneratedPropFile = validateDefinitionExtensions(modulePath, status, validator).isMissingAutogeneratedPropFile;
    }
    if (isMissingViewFile) {
        utilities_internal_1.trace.error(`Module name in module defintion file does not match the .tsx view name for ${moduleName}.`);
        utilities_internal_1.trace.error(`Check to see if the view file is missing or if the name does not match`);
        validation_helpers_1.markFailure(status);
    }
    // Print warning if autogenerated files are missing but continue with the validation
    if (isMissingAutogeneratedPropFile) {
        utilities_internal_1.trace.warn(`Missing autogenerated prop files files for ${moduleName}. Run 'yarn gendef -d ./'  to generate this file.`);
    }
    const validationResult = validator.validate(moduleDefinitionFile, 
    // tslint:disable-next-line:no-any
    utilities_internal_1.safeReadJsonSync(path.resolve(__dirname, '../..', 'definition-schema.json')));
    if (validationResult.errors.length > 0) {
        utilities_internal_1.trace.error(`Module defintion ${moduleDefinitionFile} does not match definition schema. Error: ${validationResult.errors}`);
        validation_helpers_1.markFailure(status);
    }
    validateStylePresetDefinition(moduleName, modulePath, status, validator);
    return status;
};

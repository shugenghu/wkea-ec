"use strict";
/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const utils_1 = require("../scripts/utils");
const testing_mocks_1 = require("./__mocks__/testing-mocks");
describe('test buildKebabCaseName', () => {
    it('properly builds kebab case names', () => {
        expect(utils_1.buildKebabCaseName('sample project name')).toMatchSnapshot();
    });
    it('does not modify an existing kebab case name', () => {
        expect(utils_1.buildKebabCaseName('sample-project-name')).toMatchSnapshot();
    });
});
describe('test convertToPascalCaseName', () => {
    it('properly converts kebab case name to pascal case name', () => {
        expect(utils_1.convertToPascalCaseName('sample-project')).toMatchSnapshot();
    });
    it('properly converts kebab case name to pascal case name w/ mutiple dashes', () => {
        expect(utils_1.convertToPascalCaseName('sample-project-name')).toMatchSnapshot();
    });
    it('does not modify existing PascalCaseName', () => {
        expect(utils_1.convertToPascalCaseName('SampleProjectName')).toMatchSnapshot();
    });
});
describe('test convertPascalCaseNameToCamelCase', () => {
    it('properly converts PascalCaseName to camelCase', () => {
        expect(utils_1.convertPascalCaseNameToCamelCase('SampleProject')).toMatchSnapshot();
    });
    it('does not modify existing camelCaseName', () => {
        expect(utils_1.convertPascalCaseNameToCamelCase('sampleProjectName')).toMatchSnapshot();
    });
});
describe('test parsePayload', () => {
    it('properly parses valid JSON string', () => {
        const testObj = utils_1.parsePayload(testing_mocks_1.testJson);
        expect(testObj.menu.id).toBe('file');
        expect(testObj.menu.value).toBe('File');
    });
    it('throws error for invalid JSON string', () => {
        console.log(`Intentionally logging error as part of test. Ignore error below.`);
        expect(utils_1.parsePayload(testing_mocks_1.testBadJson)).toBeNull();
    });
});
describe('test readFile', () => {
    it('correctly reads a file into a string', () => {
        // Create a test file
        const testFilePath = path.resolve(process.cwd(), `test.txt`);
        try {
            fs.writeFileSync(testFilePath, 'Test Content');
        }
        catch (error) {
            console.log('Unable to create test file during read file test. Aborting.', error);
        }
        expect(utils_1.readFile(testFilePath)).toBe('Test Content');
        // Remove test file
        try {
            fs.unlinkSync(testFilePath);
        }
        catch (error) {
            console.log('Unable to delete test file during read file test. Aborting', error);
        }
    });
    it('correctly reads a file with newlines into a string', () => {
        // Create a test file
        const testFilePath = path.resolve(process.cwd(), `test.txt`);
        try {
            fs.writeFileSync(testFilePath, 'Test Content\n More Test Content {}');
        }
        catch (error) {
            console.log('Unable to create test file during read file test. Aborting.', error);
        }
        expect(utils_1.readFile(testFilePath)).toBe('Test Content\n More Test Content {}');
        // Remove test file
        try {
            fs.unlinkSync(testFilePath);
        }
        catch (error) {
            console.log('Unable to delete test file during read file test. Aborting', error);
        }
    });
    it('returnes undefined for non existent file path', () => {
        // Create a test file
        const testFilePath = path.resolve(process.cwd(), `test.txt`);
        expect(utils_1.readFile(testFilePath)).toBeUndefined();
    });
});

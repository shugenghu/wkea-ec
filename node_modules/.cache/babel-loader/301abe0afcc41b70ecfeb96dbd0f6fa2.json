{"ast":null,"code":"import\"core-js/modules/web.dom-collections.for-each.js\";import\"core-js/modules/web.dom-collections.iterator.js\";import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{isAsyncResult}from'@msdyn365-commerce/retail-proxy';import{METRIC_APP_CACHE_INSERT,StaticTelemetry}from'@msdyn365-commerce/telemetry-internal';import{isObservable,toJS}from'mobx';import NodeCache from'node-cache';import{normalizeCacheKey}from'./cache-utils';import{ICacheSource}from'./ICache';/**\r\n * DEFAULT cache time to live value in seconds\r\n */const defaultTimeoutInMS=5000;/**\r\n * DEFAULT cache time to live value in seconds\r\n */const DEFAULT_CACHE_TTL=600;/**\r\n * DEFAULT cache time to refresh value in seconds\r\n */const DEFAULT_CACHE_TTR=60;/**\r\n * Default cache check period(in seconds) to check if ttl of any cache items expired\r\n */const DEFAULT_CHECK_PERIOD=600;/**\r\n * Server app cache implementation\r\n */export class AppCache{constructor(settings){this.settings={};this.disableRefresh=false;this.refreshTimeout=defaultTimeoutInMS;this.settings=settings||{};this.nodeCache=new NodeCache({checkperiod:settings.checkPeriodInSeconds||DEFAULT_CHECK_PERIOD,stdTTL:settings.defaultTTLInSeconds||DEFAULT_CACHE_TTL,// TODO - RAVI check if we can utilitze this to support native clone from node-cache\nuseClones:false});this.entityKeys={};}/**\r\n     * @function        {setRefresh}               - Method to insert an item in the cache\r\n     * @param requestContext  {requestContext}     - requestContext\r\n     */setRequestContext(requestContext){this.requestContext=requestContext;this._setRefresh(this.requestContext);}/**\r\n     * @function        {getCacheEntries}          - Method to get cache entries\r\n     */getCacheEntries(){const cacheEntriesSet=[];if(this.settings.ttlInSeconds){Object.keys(this.settings.ttlInSeconds).forEach(key=>{cacheEntriesSet.push(key);});}if(this.settings.ttrInSeconds){Object.keys(this.settings.ttrInSeconds).forEach(key=>{cacheEntriesSet.push(key);});}cacheEntriesSet.filter((item,index)=>cacheEntriesSet.indexOf(item)===index);return cacheEntriesSet;}/**\r\n     * @function        {put}           - Method to insert an item in the cache\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\r\n     */put(cacheKey,item){this._validateCacheKey(cacheKey);item.s=item.s!==undefined?item.s:ICacheSource.AppCache;// App-cache is unable to store loading AsyncResults correctly\n// we need to wait for the promise to resolve, and then store the resolved promise\nif(isAsyncResult(item.item)&&item.item.status==='LOADING'){item.item.then(()=>{this.put(cacheKey,item);});return true;}// node-cache returns observable objects as []\n// therefore, lets save the pure js version of the same\nif(item&&isObservable(item.item)){const timerId=\"app-cache - \".concat(cacheKey.typeName);StaticTelemetry.startTimer(timerId);if(!isAsyncResult(item.item)){item.item=toJS(item.item);}StaticTelemetry.trackMetric(METRIC_APP_CACHE_INSERT,StaticTelemetry.stopTimer(timerId));}cacheKey=normalizeCacheKey(cacheKey);const ttl=this._getTTL(cacheKey.typeName);const ttr=this._getTTR(cacheKey.typeName);const computedCacheKey=this._computeCacheKey(cacheKey);const expiryTime=new Date();expiryTime.setSeconds(expiryTime.getSeconds()+ttr);// update the cache entity without resetting TTL\nconst prevTtl=this.nodeCache.getTtl(computedCacheKey);let cacheItem;if(prevTtl){cacheItem=_objectSpread({expireAtInTimeMilliseconds:expiryTime.getTime()},item);// reset isRefreshing to false before the refresh entity write to the cache.\nconst newTtl=prevTtl-Date.now();return this.nodeCache.set(computedCacheKey,cacheItem,newTtl/1000);}cacheItem=_objectSpread({expireAtInTimeMilliseconds:expiryTime.getTime()},item);this.entityKeys[cacheKey.typeName]=this.entityKeys[cacheKey.typeName]||{};this.entityKeys[cacheKey.typeName][computedCacheKey]=true;return this.nodeCache.set(computedCacheKey,cacheItem,ttl);}/**\r\n     * @function        {get<T>}        - Method to get the cached item\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @return          {ICacheItem<T>} - cached value against the given cache key\r\n     */get(cacheKey){this._validateCacheKey(cacheKey);const preparedCacheKey=this._computeCacheKey(cacheKey);const cacheItemInternal=this.nodeCache.get(preparedCacheKey);if(!cacheItemInternal){return undefined;}if(!cacheItemInternal.expireAtInTimeMilliseconds||cacheItemInternal.shouldRefresh){return _objectSpread({},cacheItemInternal);}const now=Date.now();if(cacheItemInternal.expireAtInTimeMilliseconds<now){if(!cacheItemInternal.isRefreshing){cacheItemInternal.isRefreshing=true;cacheItemInternal.refreshStartTimeInMS=now;return _objectSpread(_objectSpread({},cacheItemInternal),{shouldRefresh:true});}else if(this._isRefreshExpired(cacheItemInternal,now)){// If the data's refresh timout then let the next subsequent caller\n// know that they have to refresh the data\ncacheItemInternal.refreshStartTimeInMS=now;return _objectSpread(_objectSpread({},cacheItemInternal),{shouldRefresh:true});}}return _objectSpread({},cacheItemInternal);}/**\r\n     * @function        {getAllItems}   - Method to get all cached items for a given type\r\n     * @param typeName  {typeName}      - typeName for which all items need to be fetched\r\n     * @return          {ICacheItem}    - dictionary of cache items of the given typeName\r\n     */getAllItems(typeName){if(typeName===''){throw new Error('typeName cannot be empty');}const cacheKeys=this.entityKeys[typeName.toUpperCase()];const currentTimestamp=Date.now();if(cacheKeys){const cacheItems=this.nodeCache.mget(Object.keys(cacheKeys));const response={};Object.keys(cacheItems).filter(key=>!!cacheItems[key]).map(key=>{if(cacheItems[key].expireAtInTimeMilliseconds>currentTimestamp){response[key]=_objectSpread(_objectSpread({},cacheItems[key]),{},{shouldRefresh:true});}});return response;}return undefined;}/**\r\n     * @function        {hasCacheSetting}   - tells if there is a cache setting defined for the given entity type\r\n     * @param typeName  {typeName}          - typeName for which all items need to be fetched\r\n     * @return          {boolean}           - true if a cache setting ttr/ttl is specified for the given entity\r\n     */hasCacheSetting(typeName){if(typeName===''){throw new Error('typeName cannot be empty');}typeName=typeName.toUpperCase();if(this.settings){if(this.settings.ttrInSeconds&&this.settings.ttrInSeconds[typeName]){return!!this.settings.ttrInSeconds[typeName];}if(this.settings.ttlInSeconds&&this.settings.ttlInSeconds[typeName]){return!!this.settings.ttlInSeconds[typeName];}}return false;}/**\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\r\n     * @return          {ICacheItem}    - cache item that was copied\r\n     */copyTo(cacheKey,toCache){const cachedItem=this.get(cacheKey);// if the disableRefresh is set to true, we follow the previous logic that treating shouldRefresh item to be undefined.\nif(cachedItem&&cachedItem.shouldRefresh&&this.disableRefresh){return undefined;}if(cachedItem){toCache.put(cacheKey,{item:cachedItem.item,s:ICacheSource.AppCache});return cachedItem;}return undefined;}/**\r\n     * @function        {getValue<T>}   - Method to get the cached item\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @return          {ICacheItem<T>} - cached value against the given cache key\r\n     */getValue(cacheKey){const cachedItem=this.get(cacheKey);return cachedItem?cachedItem.item:undefined;}/**\r\n     * @function        {del}           - Method to delete an item from the cache\r\n     * @param cacheKey  {ICacheKey}     - Array of ICacheGetData items whose values need to be deleted from cache\r\n     * @return          {boolean}       - returns true if the cache key is deleted successfully. Does not throw errors.\r\n     */del(cacheKey){return this.nodeCache.del(this._computeCacheKey(cacheKey))===1;}/**\r\n     * @function    {keys}              - Method to fetch all the keys in the cache\r\n     * @return      {string[]}          - returns a list of all the keys in the cache\r\n     */keys(){return this.nodeCache.keys();}/**\r\n     * @function    {flushAll}          - Method to flush all data from the cache\r\n     */flushAll(){this.nodeCache.flushAll();}_computeCacheKey(key){if(!key.typeName){throw new Error(\"Invalid type (\".concat(key.typeName,\") - Could not create cache key\"));}return\"\".concat(key.typeName,\"-\").concat(key.key).toUpperCase();}_validateCacheKey(cacheKey){if(!cacheKey){throw new Error(\"Invalid cacheKey: \".concat(cacheKey));}if(!cacheKey.typeName){throw new Error(\"Invalid cacheKey type: \".concat(cacheKey.typeName));}}_getTTR(typeName){if(this.settings){if(this.settings.ttrInSeconds&&this.settings.ttrInSeconds[typeName]){return this.settings.ttrInSeconds[typeName];}if(this.settings.defaultTTRInSeconds){return this.settings.defaultTTRInSeconds;}}return DEFAULT_CACHE_TTR;}_getTTL(typeName){return this.settings.ttlInSeconds&&this.settings.ttlInSeconds[typeName]?this.settings.ttlInSeconds[typeName]:DEFAULT_CACHE_TTL;}_setRefresh(requestContext){const actionTimout=Number(requestContext.query&&requestContext.query.actionTimeout)||undefined;this.disableRefresh=requestContext.features&&requestContext.features.disable_appcache_refresh||false;this.refreshTimeout=actionTimout?actionTimout:defaultTimeoutInMS;}_isRefreshExpired(cacheItemInternal,currentTime){if(!cacheItemInternal.refreshStartTimeInMS){return false;}return cacheItemInternal.refreshStartTimeInMS+this.refreshTimeout*2<currentTime;}}","map":{"version":3,"sources":["../../src/app-cache.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IDictionary, IRequestContext } from '@msdyn365-commerce/core-internal';\nimport { isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { METRIC_APP_CACHE_INSERT, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { isObservable, toJS } from 'mobx';\nimport NodeCache from 'node-cache';\nimport { normalizeCacheKey } from './cache-utils';\nimport { ICache, ICacheItem, ICacheKey, ICacheSource } from './ICache';\nimport { ICacheSettings } from './ICacheSettings';\n\n/**\n * DEFAULT cache time to live value in seconds\n */\nconst defaultTimeoutInMS: number = 5000;\n\n/**\n * DEFAULT cache time to live value in seconds\n */\nconst DEFAULT_CACHE_TTL: number = 600;\n\n/**\n * DEFAULT cache time to refresh value in seconds\n */\nconst DEFAULT_CACHE_TTR: number = 60;\n\n/**\n * Default cache check period(in seconds) to check if ttl of any cache items expired\n */\nconst DEFAULT_CHECK_PERIOD: number = 600;\n\ninterface ICacheItemInternal<T> extends ICacheItem<T> {\n    /**\n     * Timestamp in milliseconds at which the cache key gets expired and will cause appcache\n     * to set shouldRefresh property of the expired item to true - indicating that the data should be refreshed\n     */\n    expireAtInTimeMilliseconds: number;\n\n    /**\n     * Flag to track the loading state internally so that when the cache item is refreshing, it will return the current value for the given cache key\n     */\n    isRefreshing?: boolean;\n    /**\n     * Flag to track the when the item start refreshing.\n     */\n    refreshStartTimeInMS?: number;\n}\n\n/**\n * Server app cache implementation\n */\nexport class AppCache implements ICache {\n    public nodeCache: NodeCache;\n\n    private entityKeys: IDictionary<IDictionary<boolean>>;\n\n    private settings: ICacheSettings = {};\n\n    private disableRefresh: boolean = false;\n\n    private refreshTimeout: number = defaultTimeoutInMS;\n\n    private requestContext?: IRequestContext;\n\n    public constructor(settings: ICacheSettings) {\n        this.settings = settings || {};\n        this.nodeCache = new NodeCache({\n            checkperiod: settings.checkPeriodInSeconds || DEFAULT_CHECK_PERIOD,\n            stdTTL: settings.defaultTTLInSeconds || DEFAULT_CACHE_TTL,\n            // TODO - RAVI check if we can utilitze this to support native clone from node-cache\n            useClones: false\n        });\n        this.entityKeys = {};\n    }\n\n    /**\n     * @function        {setRefresh}               - Method to insert an item in the cache\n     * @param requestContext  {requestContext}     - requestContext\n     */\n    public setRequestContext(requestContext: IRequestContext): void {\n        this.requestContext = requestContext;\n        this._setRefresh(this.requestContext);\n    }\n\n    /**\n     * @function        {getCacheEntries}          - Method to get cache entries\n     */\n    public getCacheEntries(): string[] {\n        const cacheEntriesSet: string[] = [];\n        if (this.settings.ttlInSeconds) {\n            Object.keys(this.settings.ttlInSeconds).forEach(key => {\n                cacheEntriesSet.push(key);\n            });\n        }\n        if (this.settings.ttrInSeconds) {\n            Object.keys(this.settings.ttrInSeconds).forEach(key => {\n                cacheEntriesSet.push(key);\n            });\n        }\n        cacheEntriesSet.filter((item, index) => cacheEntriesSet.indexOf(item) === index);\n        return cacheEntriesSet;\n    }\n\n    /**\n     * @function        {put}           - Method to insert an item in the cache\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\n     */\n    public put<T = unknown>(cacheKey: ICacheKey, item: ICacheItem<T>): boolean {\n        this._validateCacheKey(cacheKey);\n        item.s = item.s !== undefined ? item.s : ICacheSource.AppCache;\n\n        // App-cache is unable to store loading AsyncResults correctly\n        // we need to wait for the promise to resolve, and then store the resolved promise\n        if (isAsyncResult(item.item) && item.item.status === 'LOADING') {\n            item.item.then(() => {\n                this.put(cacheKey, item);\n            });\n            return true;\n        }\n        // node-cache returns observable objects as []\n        // therefore, lets save the pure js version of the same\n        if (item && isObservable(item.item)) {\n            const timerId = `app-cache - ${cacheKey.typeName}`;\n            StaticTelemetry.startTimer(timerId);\n            if (!isAsyncResult(item.item)) {\n                item.item = toJS<T>(item.item);\n            }\n            StaticTelemetry.trackMetric(METRIC_APP_CACHE_INSERT, StaticTelemetry.stopTimer(timerId));\n        }\n\n        cacheKey = normalizeCacheKey(cacheKey);\n\n        const ttl = this._getTTL(cacheKey.typeName);\n        const ttr = this._getTTR(cacheKey.typeName);\n        const computedCacheKey = this._computeCacheKey(cacheKey);\n        const expiryTime = new Date();\n        expiryTime.setSeconds(expiryTime.getSeconds() + ttr);\n\n        // update the cache entity without resetting TTL\n        const prevTtl = this.nodeCache.getTtl(computedCacheKey);\n        let cacheItem: ICacheItemInternal<T>;\n        if (prevTtl) {\n            cacheItem = {\n                expireAtInTimeMilliseconds: expiryTime.getTime(),\n                ...item\n            };\n            // reset isRefreshing to false before the refresh entity write to the cache.\n            const newTtl = prevTtl - Date.now();\n            return this.nodeCache.set(computedCacheKey, cacheItem, newTtl / 1000);\n        }\n        cacheItem = {\n            expireAtInTimeMilliseconds: expiryTime.getTime(),\n            ...item\n        };\n\n        this.entityKeys[cacheKey.typeName] = this.entityKeys[cacheKey.typeName] || {};\n        this.entityKeys[cacheKey.typeName][computedCacheKey] = true;\n\n        return this.nodeCache.set(computedCacheKey, cacheItem, ttl);\n    }\n\n    /**\n     * @function        {get<T>}        - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {ICacheItem<T>} - cached value against the given cache key\n     */\n    public get<T = unknown>(cacheKey: ICacheKey): ICacheItem<T> | undefined {\n        this._validateCacheKey(cacheKey);\n        const preparedCacheKey = this._computeCacheKey(cacheKey);\n        const cacheItemInternal = <ICacheItemInternal<T>>this.nodeCache.get(preparedCacheKey);\n\n        if (!cacheItemInternal) {\n            return undefined;\n        }\n\n        if (!cacheItemInternal.expireAtInTimeMilliseconds || cacheItemInternal.shouldRefresh) {\n            return { ...cacheItemInternal };\n        }\n\n        const now = Date.now();\n        if (cacheItemInternal.expireAtInTimeMilliseconds < now) {\n            if (!cacheItemInternal.isRefreshing) {\n                cacheItemInternal.isRefreshing = true;\n                cacheItemInternal.refreshStartTimeInMS = now;\n                return { ...cacheItemInternal, ...{ shouldRefresh: true } };\n            } else if (this._isRefreshExpired(cacheItemInternal, now)) {\n                // If the data's refresh timout then let the next subsequent caller\n                // know that they have to refresh the data\n                cacheItemInternal.refreshStartTimeInMS = now;\n                return { ...cacheItemInternal, ...{ shouldRefresh: true } };\n            }\n        }\n\n        return <ICacheItem<T>>{ ...cacheItemInternal };\n    }\n\n    /**\n     * @function        {getAllItems}   - Method to get all cached items for a given type\n     * @param typeName  {typeName}      - typeName for which all items need to be fetched\n     * @return          {ICacheItem}    - dictionary of cache items of the given typeName\n     */\n    public getAllItems<T = unknown>(typeName: string): IDictionary<ICacheItem<T>> | undefined {\n        if (typeName === '') {\n            throw new Error('typeName cannot be empty');\n        }\n\n        const cacheKeys = this.entityKeys[typeName.toUpperCase()];\n        const currentTimestamp = Date.now();\n        if (cacheKeys) {\n            const cacheItems = this.nodeCache.mget<ICacheItemInternal<T>>(Object.keys(cacheKeys));\n            const response: IDictionary<ICacheItem<T>> = {};\n            Object.keys(cacheItems)\n                .filter(key => !!cacheItems[key])\n                .map(key => {\n                    if (cacheItems[key].expireAtInTimeMilliseconds > currentTimestamp) {\n                        response[key] = {\n                            ...cacheItems[key],\n                            shouldRefresh: true\n                        };\n                    }\n                });\n\n            return response;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @function        {hasCacheSetting}   - tells if there is a cache setting defined for the given entity type\n     * @param typeName  {typeName}          - typeName for which all items need to be fetched\n     * @return          {boolean}           - true if a cache setting ttr/ttl is specified for the given entity\n     */\n    public hasCacheSetting(typeName: string): boolean {\n        if (typeName === '') {\n            throw new Error('typeName cannot be empty');\n        }\n\n        typeName = typeName.toUpperCase();\n\n        if (this.settings) {\n            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {\n                return !!this.settings.ttrInSeconds[typeName];\n            }\n\n            if (this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]) {\n                return !!this.settings.ttlInSeconds[typeName];\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\n     * @return          {ICacheItem}    - cache item that was copied\n     */\n    public copyTo<T = unknown>(cacheKey: ICacheKey, toCache: ICache): ICacheItem<T> | undefined {\n        const cachedItem = this.get<T>(cacheKey);\n        // if the disableRefresh is set to true, we follow the previous logic that treating shouldRefresh item to be undefined.\n        if (cachedItem && cachedItem.shouldRefresh && this.disableRefresh) {\n            return undefined;\n        }\n        if (cachedItem) {\n            toCache.put(cacheKey, { item: cachedItem.item, s: ICacheSource.AppCache });\n            return cachedItem;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @function        {getValue<T>}   - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {ICacheItem<T>} - cached value against the given cache key\n     */\n    public getValue<T = unknown>(cacheKey: ICacheKey): T | undefined {\n        const cachedItem = <ICacheItem<T>>this.get(cacheKey);\n        return cachedItem ? cachedItem.item : undefined;\n    }\n\n    /**\n     * @function        {del}           - Method to delete an item from the cache\n     * @param cacheKey  {ICacheKey}     - Array of ICacheGetData items whose values need to be deleted from cache\n     * @return          {boolean}       - returns true if the cache key is deleted successfully. Does not throw errors.\n     */\n    public del(cacheKey: ICacheKey): boolean {\n        return this.nodeCache.del(this._computeCacheKey(cacheKey)) === 1;\n    }\n\n    /**\n     * @function    {keys}              - Method to fetch all the keys in the cache\n     * @return      {string[]}          - returns a list of all the keys in the cache\n     */\n    public keys(): string[] {\n        return this.nodeCache.keys();\n    }\n\n    /**\n     * @function    {flushAll}          - Method to flush all data from the cache\n     */\n    public flushAll(): void {\n        this.nodeCache.flushAll();\n    }\n\n    private _computeCacheKey(key: ICacheKey): string {\n        if (!key.typeName) {\n            throw new Error(`Invalid type (${key.typeName}) - Could not create cache key`);\n        }\n\n        return `${key.typeName}-${key.key}`.toUpperCase();\n    }\n\n    private _validateCacheKey(cacheKey: ICacheKey): void {\n        if (!cacheKey) {\n            throw new Error(`Invalid cacheKey: ${cacheKey}`);\n        }\n\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);\n        }\n    }\n\n    private _getTTR(typeName: string): number {\n        if (this.settings) {\n            if (this.settings.ttrInSeconds && this.settings.ttrInSeconds[typeName]) {\n                return this.settings.ttrInSeconds[typeName];\n            }\n\n            if (this.settings.defaultTTRInSeconds) {\n                return this.settings.defaultTTRInSeconds;\n            }\n        }\n\n        return DEFAULT_CACHE_TTR;\n    }\n\n    private _getTTL(typeName: string): number {\n        return this.settings.ttlInSeconds && this.settings.ttlInSeconds[typeName]\n            ? this.settings.ttlInSeconds[typeName]\n            : DEFAULT_CACHE_TTL;\n    }\n\n    private _setRefresh(requestContext: IRequestContext): void {\n        const actionTimout = Number(requestContext.query && requestContext.query.actionTimeout) || undefined;\n        this.disableRefresh = (requestContext.features && requestContext.features.disable_appcache_refresh) || false;\n        this.refreshTimeout = actionTimout ? actionTimout : defaultTimeoutInMS;\n    }\n\n    private _isRefreshExpired(cacheItemInternal: ICacheItemInternal<unknown>, currentTime: Number): boolean {\n        if (!cacheItemInternal.refreshStartTimeInMS) {\n            return false;\n        }\n        return cacheItemInternal.refreshStartTimeInMS + this.refreshTimeout * 2 < currentTime;\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
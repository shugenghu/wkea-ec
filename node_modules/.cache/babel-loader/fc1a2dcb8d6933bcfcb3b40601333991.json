{"ast":null,"code":"import\"core-js/modules/es.promise.js\";import\"core-js/modules/web.dom-collections.for-each.js\";import\"core-js/modules/web.dom-collections.iterator.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */ // tslint:disable: no-any\nimport{ICacheSource,RequestCache}from'@msdyn365-commerce/cache-internal';import{msdyn365Commerce}from'@msdyn365-commerce/core-internal';import{AsyncResult,DataServiceRequest,isAsyncResult}from'@msdyn365-commerce/retail-proxy';import{GenericConsoleLogger,LogLevel,StaticTelemetry,Telemetry}from'@msdyn365-commerce/telemetry-internal';import uuidv1 from'uuid/v1';import ActionExecutor from'./action-executor';import{ActionRegistrar}from'./action-registrar';import{shouldWriteToAppCache}from'./action-runtime-utils';import{addLocaleInformation,readCacheEntries,saveCacheEntries}from'./cache/retail-cache-helper';import EventHelper from'./event-emitter';/**\r\n * This class contains the primary logic which controls the execution flow of the action runtime\r\n *\r\n */ /*@internal*/export class ActionContext{/**\r\n     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7\r\n     * @param expectedActionCount: This value specifies the expected number of actions to be queued before\r\n     *                             we kick off execution in the current tier\r\n     */constructor(args){this.executionParams=[];this.appCache=null;this.cacheKeyMap=[];/**\r\n         * Whether the current context as executed\r\n         */this.hasRun=false;/**\r\n         * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count\r\n         */this.currentActionsInQueue=0;/**\r\n         * Object to track the next tier number.\r\n         */this.nextTierCounter={next:0};/**\r\n         * When true will span a new independent action context when an action is executed resetting depth limits\r\n         * Otherwise will invoke the action in the current context.\r\n         */this.spawnChildOnExecute=false;/**\r\n         * Helper method to log trace using telemetry\r\n         * @param message message to log to console\r\n         */this.trace=message=>{this.telemetry.log(LogLevel.Debug,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[this.currentExecutionTier,this.threadId,message]});};/**\r\n         * Helper method to log error using telemetry\r\n         * @param message message to log to console\r\n         */this.error=message=>{this.telemetry.log(LogLevel.Error,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[this.currentExecutionTier,this.threadId,message]});};/**\r\n         * Helper method to log debug using telemetry\r\n         * @param message message to log to console\r\n         */this.debug=message=>{this.telemetry.log(LogLevel.Debug,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[this.currentExecutionTier,this.threadId,message]});};/**\r\n         * Returns true if current tier has exceeded max depth\r\n         */this.isMaxDepthExceeded=()=>{const maxDepth=this.requestContext&&this.requestContext.app&&this.requestContext.app.maxDepth||ActionContext.maxDepth;return this.nextTierCounter.next>maxDepth;};/**\r\n         * Retrieves item from request cache and fallsback to app cache if not found\r\n         */this.getItemFromCache=cacheKey=>{let cachedItem=this.requestCache.get(cacheKey);if(cachedItem){return cachedItem.item;}if(process.env.CURRENT_ENVIRONMENT==='node'&&this.appCache){cachedItem=this.appCache.get(cacheKey);}return cachedItem?cachedItem.item:undefined;};/**\r\n         * Signals the end of current tier so actions can return the response\r\n         */this._endCurrentTier=()=>{this.hasRun=true;EventHelper.emit(\"\".concat(this.eventId,\":completed\"),this.currentExecutionTier);};const{id,requestContext,requestCache,appCache,currentExecutionTier,expectedActionCount,spawnChildOnExecute,telemetry}=args;this.threadId=id;this.eventId=uuidv1();this.currentExecutionTier=currentExecutionTier||0;if(this.currentExecutionTier===0){this.nextTierCounter={next:0};}this.expectedActionsInCurrentTier=expectedActionCount||0;this.requestCache=requestCache;this.requestContext=requestContext||{};this.spawnChildOnExecute=Boolean(spawnChildOnExecute);// If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object\nif(telemetry){this.telemetry=telemetry;}else{// register default console logger\nconst moduleTelemetry=new Telemetry();const isDebug=requestContext.params&&requestContext.params.isDebug;// register tracelogger only in development environment or debug is true.\n(process.env.NODE_ENV==='development'||isDebug)&&moduleTelemetry.registerTraceLogger({traceLogger:GenericConsoleLogger,options:{isDebug:isDebug}});this.telemetry=moduleTelemetry;}/**\r\n         * @deprecated\r\n         * Trace is an alias for telemetry.log(LogLevel.Trace, message)\r\n         * Use the telemetry object directly.\r\n         */this.trace=message=>{this.telemetry.log(LogLevel.Debug,message);};// enable app cache only if the disable_app_cache feature switch is false\nif(requestContext.features&&!!!requestContext.features.disable_app_cache){this.appCache=appCache;}}/**\r\n     * Chains an action method to the current context for execution\r\n     * @param action - action method\r\n     * @param inputs - action input\r\n     */ // tslint:disable-next-line:max-func-body-length\nchainAction(_action,inputs,actionOption){const action=ActionRegistrar.unwrapAction(_action);addLocaleInformation(inputs,this.requestContext.locale);if(!action||!inputs){// Decrement the expected actions on this tier since this action was incorrectly configured\nthis.expectedActionsInCurrentTier--;if(this.currentActionsInQueue<this.expectedActionsInCurrentTier){return Promise.resolve(null);}if(!this.hasRun){return this.runAllActionsInQueue().then(()=>null);}return Promise.resolve(null);}if(this.isMaxDepthExceeded()){this.debug('Max depth exceeded - not running further.');return Promise.resolve(null);}if(this.hasRun){// If the parent action decides to queue another action after the current tier completes execution\n// then set the hasRun to false, so the action can fire right away\nthis.hasRun=false;this.executionParams.length=0;this.currentActionsInQueue=0;}this.currentActionsInQueue++;const isBatched=action.prototype.isBatched;const inputsArray=isBatched?inputs:[inputs];let current=this.executionParams.find(a=>a.action===action);if(current&&isBatched){current.addInputs(inputsArray);}else{const inputIdentifier=\"\".concat(inputsArray[0].getCacheObjectType(),\"||\").concat(inputsArray[0].getCacheKey());if(!this.cacheKeyMap.find(key=>key===inputIdentifier)){current=new ActionExecutor(action,inputsArray,this.telemetry,actionOption);this.executionParams.push(current);this.cacheKeyMap.push(inputIdentifier);}}// @ts-ignore\n// tslint:disable-next-line: max-func-body-length\nconst asyncResult=new AsyncResult(async(resolve,reject)=>{if(this.currentActionsInQueue<this.expectedActionsInCurrentTier){// Hold the thread until the entire tier is populated\nawait new Promise(innerResolve=>{const onEventIdCompletion=tierNum=>{if(tierNum===this.currentExecutionTier){innerResolve();}};EventHelper.on(\"\".concat(this.eventId,\":completed\"),onEventIdCompletion);});EventHelper.removeAllListeners(\"\".concat(this.eventId,\":completed\"));}if(!this.hasRun){await this.runAllActionsInQueue();}const outputs=inputsArray.map(i=>{if(i instanceof DataServiceRequest){try{// @ts-ignore\nconst entry=readCacheEntries(i,this.requestCache,this.appCache,false,StaticTelemetry);return entry.entry;}catch(e){this.debug(\"Error execution action type '[\".concat(i&&i.getCacheObjectType(),\"' and cache key '[{\").concat(i&&i.getCacheKey(),\"}]', returning null\"));return null;}}else{const cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};const cacheItem=this.requestCache.get(cacheKey);const cacheValue=!!cacheItem?this.requestCache.getValue(cacheKey):null;if(cacheItem&&!!cacheItem.error){throw cacheValue;}else{if(cacheItem&&!msdyn365Commerce.isBrowser){switch(cacheItem.s){case ICacheSource.AppCache:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey(),'AppCache']});break;}case ICacheSource.RequestCache:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey(),'RequestCache']});break;}default:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey,'Undefined']});}}}return cacheValue;}}});this.cacheKeyMap.splice(0,this.cacheKeyMap.length);// Batched observable actions need to be merged into a single AsyncResult\nif(isBatched&&action.prototype.isObservable){resolve(Promise.all(outputs).then(results=>{// Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped\nreturn results.map(result=>{return result&&result._type==='AsyncResult'?result.result:result;});}));}else{// We need to pass along the metadata explicitly to the outer AsyncResult\nif(isAsyncResult(outputs[0])&&!isBatched){outputs[0].then(()=>{asyncResult.metadata=outputs[0].metadata;});}resolve(isBatched?outputs:outputs.length&&outputs[0]||null);}});return asyncResult;}/**\r\n     * Helper method to update cache\r\n     * @param input The input\r\n     * @param data The data\r\n     */update(inputs,data){if(inputs&&data){// If an array of actionInputs has been passed, an equal amount of data items must be present\nconst dataArray=Array.isArray(inputs)?data:[data];const inputArray=Array.isArray(inputs)?inputs:[inputs];if(inputArray.length!==dataArray.length){throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');}addLocaleInformation(inputArray,this.requestContext.locale);inputArray.map((i,idx)=>{if(i instanceof DataServiceRequest){try{// @ts-ignore\nsaveCacheEntries(i,dataArray[idx],this.requestCache,this.appCache,shouldWriteToAppCache(i,this.appCache));}catch(e){this.debug(\"Error in updating cache with input '[\".concat(i.getCacheObjectType(),\"]' - '[\").concat(i.getCacheKey(),\"]', returning null\"));this.error(e);}}else{// When updating OPs, only result can be updated, passed OPs will also be unwrapped.\nif(isAsyncResult(dataArray[idx])){dataArray[idx]=dataArray[idx].result;}const cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};this.requestCache.put(cacheKey,{item:dataArray[idx]});if(this.appCache&&shouldWriteToAppCache(i,this.appCache)){this.appCache.put(cacheKey,{item:dataArray[idx]});}}});if(Array.isArray(inputs)){return inputs.map(input=>{return this.requestCache.getValue({typeName:input.getCacheObjectType(),key:input.getCacheKey()});});}else{return this.requestCache.getValue({typeName:inputs.getCacheObjectType(),key:inputs.getCacheKey()});}}// For scenarios where data/input was bad, we just return original data\nreturn data;}/**\r\n     * Helper method to data cache from cache\r\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\r\n     * @param cacheObjectType entity type that was cached\r\n     * @param cacheKey cache key against which the object is cached\r\n     * @throws if cacheObjecttype is null or empty\r\n     */get(cacheObjectType,cacheKey){if(!cacheObjectType){throw new Error('Cannot have null or empty cacheObjectType');}if(!cacheKey){throw new Error('Cannot have null or empty cacheKey');}const preparedCacheKey={typeName:cacheObjectType,key:cacheKey};let cachedItem=this.requestCache.get(preparedCacheKey);if(process.env.CURRENT_ENVIRONMENT==='node'&&!cachedItem&&this.appCache){cachedItem=this.appCache.get(preparedCacheKey);}if(!cachedItem){return null;}if(typeof cachedItem.item!=='object'||cachedItem.item.$ref!==true){return cachedItem.item;}return Array.isArray(cachedItem.item.key)?cachedItem.item.key.map(key=>this.getItemFromCache({typeName:cacheObjectType,key})).filter(Boolean):null;}/**\r\n     * Helper method to data cache from cache\r\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\r\n     * @param input The input\r\n     * @param data The data\r\n     * @throws if cacheObjecttype is null or empty\r\n     */getAll(cacheObjectType){if(!cacheObjectType){throw new Error('Cannot have null or empty cacheObjectType');}let cachedEntries=this.requestCache.getAllItems(cacheObjectType);if(!cachedEntries){if(process.env.CURRENT_ENVIRONMENT==='node'&&this.appCache){cachedEntries=this.appCache&&this.appCache.getAllItems(cacheObjectType);}if(!cachedEntries){return null;}}return Object.keys(cachedEntries).filter(key=>typeof cachedEntries[key].item!=='object'||cachedEntries[key].item.$ref!==true).map(key=>cachedEntries[key].item);}/**\r\n     * Executes all the actions in the current context in parallel\r\n     */ // tslint:disable max-func-body-length\nasync runAllActionsInQueue(){const{threadId,requestContext,requestCache,appCache,nextTierCounter,executionParams}=this;if(!executionParams.length){this.trace('No actions to execute - not running further.');return;}// Increment the tier each pass through run all actions\nif(this.isMaxDepthExceeded()){this.trace('Max depth exceeded - not running further.');return;}// When kicking off the next tier,\n// set the max number of chain actions the can be expected from child actions\n// equal to the number of actions that are executing in current tier\nconst expectedNumberOfChildThreads=executionParams.length;let nextTierStartingDepth;if(this.spawnChildOnExecute){nextTierStartingDepth=nextTierCounter.next+1;}else{nextTierStartingDepth=++nextTierCounter.next;}const nextTier=new ActionContext({id:threadId,requestContext:requestContext,requestCache:requestCache,appCache:appCache,currentExecutionTier:nextTierStartingDepth,expectedActionCount:expectedNumberOfChildThreads,telemetry:this.telemetry});const refreshContext=new ActionContext({id:'Refresh Context',requestContext:requestContext,requestCache:new RequestCache(),telemetry:this.telemetry,appCache:appCache,spawnChildOnExecute:true});const refreshconfigslocal=new Set();nextTier.nextTierCounter={next:nextTierStartingDepth};// DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions\nconst promises=executionParams.map(param=>{// TODO: should we read from input about the cacheability?\nreturn param.execute(nextTier,requestCache,appCache,this.requestContext.query&&!!this.requestContext.query.cachebypass,[]).then(refreshActions=>{// refresh the data actions which need to be refreshed.\nif(refreshActions.length){refreshconfigslocal.add({paramExecutor:param,actionInputs:refreshActions,refreshContext:refreshContext});}// If the current chain action completes execution\n// decrement the max number of threads that we expect\n// from the next tier\nnextTier.expectedActionsInCurrentTier--;if(!nextTier.hasRun){// First check if the next tier has any actions\n// then check if the number of thread match expected\nif(nextTier.currentActionsInQueue>0&&nextTier.currentActionsInQueue===nextTier.expectedActionsInCurrentTier){return nextTier.runAllActionsInQueue();}}});});// Wait until all the actions in current tier are run to completion\nreturn Promise.all(promises).then(()=>{if(refreshconfigslocal.size>0&&requestContext.features&&!!!requestContext.features.disable_appcache_refresh){refreshconfigslocal.forEach(rf=>{const refreshRequestCache=new RequestCache();rf.paramExecutor.execute(rf.refreshContext,refreshRequestCache,this.appCache,this.requestContext.query&&!!this.requestContext.query.cachebypass,rf.actionInputs).then(()=>StaticTelemetry.log(LogLevel.Information,\"BackgroundRefresh - Executed refresh with action input \".concat(rf.actionInputs[0].getCacheObjectType(),\"-\").concat(rf.actionInputs[0].getCacheKey()))).catch(error=>{StaticTelemetry.log(LogLevel.Warning,\"BackgroundRefresh - Error execution refresh with action input \".concat(rf.actionInputs[0].getCacheObjectType(),\"-\").concat(rf.actionInputs[0].getCacheKey()));});});}this._endCurrentTier();}).catch(error=>{this._endCurrentTier();throw error;});}}ActionContext.maxDepth=200;","map":{"version":3,"sources":["../../src/action-context.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable: no-any\nimport { ICache, ICacheItem, ICacheKey, ICacheSource, RequestCache } from '@msdyn365-commerce/cache-internal';\nimport { IAction, IActionContext, IActionInput, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { GenericConsoleLogger, ITelemetry, LogLevel, StaticTelemetry, Telemetry } from '@msdyn365-commerce/telemetry-internal';\nimport uuidv1 from 'uuid/v1';\nimport ActionExecutor from './action-executor';\nimport { ActionRegistrar } from './action-registrar';\nimport { shouldWriteToAppCache } from './action-runtime-utils';\nimport { addLocaleInformation, readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\n/**\n * This interface is used in ActionContext only, for saving information needed to refresh data actions.\n *\n */\ninterface IRefreshConfigs {\n    refreshContext: IActionContext;\n    actionInputs: IActionInput[];\n    paramExecutor: ActionExecutor;\n}\n/**\n * This class contains the primary logic which controls the execution flow of the action runtime\n *\n */\n/*@internal*/\nexport class ActionContext implements IActionContext {\n    public static maxDepth: number = 200;\n\n    public readonly executionParams: ActionExecutor[] = [];\n    public readonly requestContext: any;\n\n    /**\n     * Telemetry object to log information\n     */\n    public telemetry: ITelemetry;\n\n    private readonly requestCache: ICache;\n    private readonly appCache: ICache | null = null;\n    private readonly cacheKeyMap: string[] = [];\n\n    /**\n     * Action context creates a new instance for every tier of execution,\n     * This number specifies the depth/current tier in the execution flow\n     */\n    private readonly currentExecutionTier: number;\n\n    /**\n     * Thread ID\n     */\n    private readonly threadId: string;\n\n    /**\n     * Event ID\n     * Unique ID for each action context, automatically generated\n     */\n    private readonly eventId: string;\n\n    /**\n     * Whether the current context as executed\n     */\n    private hasRun: boolean = false;\n\n    /**\n     * When this number is > 0, the current context will wait for all the actions to\n     * be queued before kicking off execution.\n     * This number is decremented for every action that is successful in current tier.\n     */\n    private expectedActionsInCurrentTier: number;\n\n    /**\n     * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count\n     */\n    private currentActionsInQueue: number = 0;\n\n    /**\n     * Object to track the next tier number.\n     */\n    private nextTierCounter: { next: number } = { next: 0 };\n\n    /**\n     * When true will span a new independent action context when an action is executed resetting depth limits\n     * Otherwise will invoke the action in the current context.\n     */\n    private spawnChildOnExecute: boolean = false;\n\n    /**\n     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7\n     * @param expectedActionCount: This value specifies the expected number of actions to be queued before\n     *                             we kick off execution in the current tier\n     */\n    constructor(args: {\n        id: string;\n        requestContext: any;\n        requestCache: ICache;\n        appCache: ICache | null;\n        currentExecutionTier?: number;\n        expectedActionCount?: number;\n        spawnChildOnExecute?: boolean;\n        telemetry?: ITelemetry;\n    }) {\n        const {\n            id,\n            requestContext,\n            requestCache,\n            appCache,\n            currentExecutionTier,\n            expectedActionCount,\n            spawnChildOnExecute,\n            telemetry\n        } = args;\n        this.threadId = id;\n        this.eventId = uuidv1();\n\n        this.currentExecutionTier = currentExecutionTier || 0;\n        if (this.currentExecutionTier === 0) {\n            this.nextTierCounter = { next: 0 };\n        }\n\n        this.expectedActionsInCurrentTier = expectedActionCount || 0;\n        this.requestCache = requestCache;\n        this.requestContext = requestContext || {};\n        this.spawnChildOnExecute = Boolean(spawnChildOnExecute);\n\n        // If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object\n        if (telemetry) {\n            this.telemetry = telemetry;\n        } else {\n            // register default console logger\n            const moduleTelemetry = new Telemetry();\n            const isDebug = requestContext.params && requestContext.params.isDebug;\n\n            // register tracelogger only in development environment or debug is true.\n            (process.env.NODE_ENV === 'development' || isDebug) &&\n                moduleTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: isDebug } });\n\n            this.telemetry = moduleTelemetry;\n        }\n\n        /**\n         * @deprecated\n         * Trace is an alias for telemetry.log(LogLevel.Trace, message)\n         * Use the telemetry object directly.\n         */\n        this.trace = (message: string) => {\n            this.telemetry.log(LogLevel.Debug, message);\n        };\n\n        // enable app cache only if the disable_app_cache feature switch is false\n        if (requestContext.features && !!!requestContext.features.disable_app_cache) {\n            this.appCache = appCache;\n        }\n    }\n\n    /**\n     * Chains an action method to the current context for execution\n     * @param action - action method\n     * @param inputs - action input\n     */\n    // tslint:disable-next-line:max-func-body-length\n    public chainAction<T>(_action: IAction<T>, inputs: IActionInput | IActionInput[], actionOption?:IDataActionOptions): Promise<T | (T | null)[] | null> {\n        const action = ActionRegistrar.unwrapAction(_action);\n        addLocaleInformation(inputs, this.requestContext.locale);\n        if (!action || !inputs) {\n            // Decrement the expected actions on this tier since this action was incorrectly configured\n            this.expectedActionsInCurrentTier--;\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                return Promise.resolve(null);\n            }\n\n            if (!this.hasRun) {\n                return this.runAllActionsInQueue().then(() => null);\n            }\n\n            return Promise.resolve(null);\n        }\n\n        if (this.isMaxDepthExceeded()) {\n            this.debug('Max depth exceeded - not running further.');\n            return Promise.resolve(null);\n        }\n\n        if (this.hasRun) {\n            // If the parent action decides to queue another action after the current tier completes execution\n            // then set the hasRun to false, so the action can fire right away\n            this.hasRun = false;\n            this.executionParams.length = 0;\n            this.currentActionsInQueue = 0;\n        }\n\n        this.currentActionsInQueue++;\n        const isBatched = action.prototype.isBatched;\n        const inputsArray = <IActionInput[]>(isBatched ? inputs : [inputs]);\n\n        let current = this.executionParams.find(a => a.action === action);\n        if (current && isBatched) {\n            current.addInputs(inputsArray);\n        } else {\n            const inputIdentifier = `${inputsArray[0].getCacheObjectType()}||${inputsArray[0].getCacheKey()}`;\n            if (!this.cacheKeyMap.find(key => key === inputIdentifier)) {\n                current = new ActionExecutor(action, inputsArray, this.telemetry, actionOption);\n                this.executionParams.push(current);\n                this.cacheKeyMap.push(inputIdentifier);\n            }\n        }\n\n        // @ts-ignore\n        // tslint:disable-next-line: max-func-body-length\n        const asyncResult = new AsyncResult<T | T[]>(async (resolve, reject) => {\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                // Hold the thread until the entire tier is populated\n                await new Promise((innerResolve: Function) => {\n                    const onEventIdCompletion = (tierNum: number) => {\n                        if (tierNum === this.currentExecutionTier) {\n                            innerResolve();\n                        }\n                    };\n                    EventHelper.on<[number]>(`${this.eventId}:completed`, onEventIdCompletion);\n                });\n                EventHelper.removeAllListeners(`${this.eventId}:completed`);\n            }\n\n            if (!this.hasRun) {\n                await this.runAllActionsInQueue();\n            }\n\n            const outputs = inputsArray.map(i => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        const entry = readCacheEntries(i, this.requestCache, this.appCache, false, StaticTelemetry);\n                        return entry.entry;\n                    } catch (e) {\n                        this.debug(\n                            `Error execution action type '[${i && i.getCacheObjectType()}' and cache key '[{${i &&\n                                i.getCacheKey()}}]', returning null`\n                        );\n                        return null;\n                    }\n                } else {\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    const cacheItem = this.requestCache.get<ICacheItem<T>>(cacheKey);\n                    const cacheValue = !!cacheItem ? this.requestCache.getValue<T>(cacheKey) : null;\n\n                    if (cacheItem && !!cacheItem.error) {\n                        throw cacheValue;\n                    } else {\n                        if (cacheItem && !msdyn365Commerce.isBrowser) {\n                            switch (cacheItem.s!) {\n                                case ICacheSource.AppCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'AppCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                case ICacheSource.RequestCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'RequestCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                default: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey, 'Undefined']\n                                        }\n                                    );\n                                }\n                            }\n                        }\n                        return cacheValue;\n                    }\n                }\n            });\n\n            this.cacheKeyMap.splice(0, this.cacheKeyMap.length);\n\n            // Batched observable actions need to be merged into a single AsyncResult\n            if (isBatched && action.prototype.isObservable) {\n                resolve(\n                    Promise.all(outputs).then(results => {\n                        // Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped\n                        return results.map(result => {\n                            return result && result._type === 'AsyncResult' ? result.result : result;\n                        });\n                    })\n                );\n            } else {\n                // We need to pass along the metadata explicitly to the outer AsyncResult\n                if (isAsyncResult(outputs[0]) && !isBatched) {\n                    outputs[0].then(() => {\n                        asyncResult.metadata = outputs[0].metadata;\n                    });\n                }\n\n                resolve(isBatched ? outputs : (outputs.length && outputs[0]) || null);\n            }\n        });\n\n        return asyncResult;\n    }\n\n    /**\n     * Helper method to update cache\n     * @param input The input\n     * @param data The data\n     */\n    public update<T>(inputs: IActionInput | IActionInput[], data: T): T {\n        if (inputs && data) {\n            // If an array of actionInputs has been passed, an equal amount of data items must be present\n            const dataArray = <unknown[]>(Array.isArray(inputs) ? data : [data]);\n            const inputArray = Array.isArray(inputs) ? inputs : [inputs];\n            if (inputArray.length !== dataArray.length) {\n                throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');\n            }\n            addLocaleInformation(inputArray, this.requestContext.locale);\n            inputArray.map((i, idx) => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        saveCacheEntries(i, dataArray[idx], this.requestCache, this.appCache, shouldWriteToAppCache(i, this.appCache));\n                    } catch (e) {\n                        this.debug(\n                            `Error in updating cache with input '[${i.getCacheObjectType()}]' - '[${i.getCacheKey()}]', returning null`\n                        );\n                        this.error(e);\n                    }\n                } else {\n                    // When updating OPs, only result can be updated, passed OPs will also be unwrapped.\n                    if (isAsyncResult(<object>dataArray[idx])) {\n                        dataArray[idx] = (<AsyncResult<unknown>>dataArray[idx]).result;\n                    }\n\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    this.requestCache.put(cacheKey, { item: dataArray[idx] });\n                    if (this.appCache && shouldWriteToAppCache(i, this.appCache)) {\n                        this.appCache.put(cacheKey, { item: dataArray[idx] });\n                    }\n                }\n            });\n\n            if (Array.isArray(inputs)) {\n                return <T>(<unknown>inputs.map(input => {\n                    return this.requestCache.getValue({ typeName: input.getCacheObjectType(), key: input.getCacheKey() });\n                }));\n            } else {\n                return <T>this.requestCache.getValue({ typeName: inputs.getCacheObjectType(), key: inputs.getCacheKey() });\n            }\n        }\n\n        // For scenarios where data/input was bad, we just return original data\n        return data;\n    }\n\n    /**\n     * Helper method to log trace using telemetry\n     * @param message message to log to console\n     */\n    public trace = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log error using telemetry\n     * @param message message to log to console\n     */\n    public error = (message: string): void => {\n        this.telemetry.log(LogLevel.Error, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log debug using telemetry\n     * @param message message to log to console\n     */\n    public debug = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param cacheObjectType entity type that was cached\n     * @param cacheKey cache key against which the object is cached\n     * @throws if cacheObjecttype is null or empty\n     */\n    public get<T>(cacheObjectType: string, cacheKey: string): T | T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        if (!cacheKey) {\n            throw new Error('Cannot have null or empty cacheKey');\n        }\n\n        const preparedCacheKey = { typeName: cacheObjectType, key: cacheKey };\n        let cachedItem = this.requestCache.get<any>(preparedCacheKey);\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && !cachedItem && this.appCache) {\n            cachedItem = this.appCache.get<any>(preparedCacheKey);\n        }\n\n        if (!cachedItem) {\n            return null;\n        }\n\n        if (typeof cachedItem.item !== 'object' || cachedItem.item.$ref !== true) {\n            return cachedItem.item;\n        }\n\n        return Array.isArray(cachedItem.item.key) ? <T[]>(<string[]>cachedItem.item.key)\n                  .map(key => this.getItemFromCache<T>({ typeName: cacheObjectType, key }))\n                  .filter(Boolean) : null;\n    }\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param input The input\n     * @param data The data\n     * @throws if cacheObjecttype is null or empty\n     */\n    public getAll<T>(cacheObjectType: string): T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        let cachedEntries = this.requestCache.getAllItems<any>(cacheObjectType);\n        if (!cachedEntries) {\n            if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n                cachedEntries = this.appCache && this.appCache.getAllItems<any>(cacheObjectType);\n            }\n\n            if (!cachedEntries) {\n                return null;\n            }\n        }\n\n        return <T[]>Object.keys(cachedEntries)\n            .filter(key => typeof cachedEntries![key].item !== 'object' || cachedEntries![key].item.$ref !== true)\n            .map(key => cachedEntries![key].item);\n    }\n\n    /**\n     * Executes all the actions in the current context in parallel\n     */\n    // tslint:disable max-func-body-length\n    public async runAllActionsInQueue(): Promise<void> {\n        const { threadId, requestContext, requestCache, appCache, nextTierCounter, executionParams } = this;\n        if (!executionParams.length) {\n            this.trace('No actions to execute - not running further.');\n            return;\n        }\n        // Increment the tier each pass through run all actions\n        if (this.isMaxDepthExceeded()) {\n            this.trace('Max depth exceeded - not running further.');\n            return;\n        }\n\n        // When kicking off the next tier,\n        // set the max number of chain actions the can be expected from child actions\n        // equal to the number of actions that are executing in current tier\n        const expectedNumberOfChildThreads = executionParams.length;\n\n        let nextTierStartingDepth;\n        if (this.spawnChildOnExecute) {\n            nextTierStartingDepth = nextTierCounter.next + 1;\n        } else {\n            nextTierStartingDepth = ++nextTierCounter.next;\n        }\n\n        const nextTier = new ActionContext({\n            id: threadId,\n            requestContext: requestContext,\n            requestCache: requestCache,\n            appCache: appCache,\n            currentExecutionTier: nextTierStartingDepth,\n            expectedActionCount: expectedNumberOfChildThreads,\n            telemetry: this.telemetry\n        });\n\n        const refreshContext = new ActionContext({\n            id: 'Refresh Context',\n            requestContext: requestContext,\n            requestCache: new RequestCache(),\n            telemetry: this.telemetry,\n            appCache: appCache,\n            spawnChildOnExecute: true\n        });\n        const refreshconfigslocal: Set<IRefreshConfigs> = new Set();\n\n        nextTier.nextTierCounter = { next: nextTierStartingDepth };\n        // DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions\n        const promises: Promise<any>[] = executionParams.map(param => {\n            // TODO: should we read from input about the cacheability?\n            return param\n                .execute(nextTier, requestCache, appCache, this.requestContext.query && !!this.requestContext.query.cachebypass, [])\n                .then(refreshActions => {\n                    // refresh the data actions which need to be refreshed.\n                    if (refreshActions.length) {\n                        refreshconfigslocal.add({\n                            paramExecutor: param,\n                            actionInputs: refreshActions,\n                            refreshContext: refreshContext\n                        });\n                    }\n\n                    // If the current chain action completes execution\n                    // decrement the max number of threads that we expect\n                    // from the next tier\n                    nextTier.expectedActionsInCurrentTier--;\n\n                    if (!nextTier.hasRun) {\n                        // First check if the next tier has any actions\n                        // then check if the number of thread match expected\n                        if (\n                            nextTier.currentActionsInQueue > 0 &&\n                            nextTier.currentActionsInQueue === nextTier.expectedActionsInCurrentTier\n                        ) {\n                            return nextTier.runAllActionsInQueue();\n                        }\n                    }\n                });\n        });\n\n        // Wait until all the actions in current tier are run to completion\n        return Promise.all(promises)\n            .then(() => {\n                if (refreshconfigslocal.size > 0 && requestContext.features && !!!requestContext.features.disable_appcache_refresh) {\n                    refreshconfigslocal.forEach(rf => {\n                        const refreshRequestCache = new RequestCache();\n                        rf.paramExecutor\n                            .execute(\n                                rf.refreshContext,\n                                refreshRequestCache,\n                                this.appCache,\n                                this.requestContext.query && !!this.requestContext.query.cachebypass,\n                                rf.actionInputs\n                            )\n                            .then(() =>\n                                StaticTelemetry.log(\n                                    LogLevel.Information,\n                                    `BackgroundRefresh - Executed refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                )\n                            )\n                            .catch(error => {\n                                StaticTelemetry.log(\n                                    LogLevel.Warning,\n                                    `BackgroundRefresh - Error execution refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                );\n                            });\n                    });\n                }\n                this._endCurrentTier();\n            })\n            .catch(error => {\n                this._endCurrentTier();\n                throw error;\n            });\n    }\n\n    /**\n     * Returns true if current tier has exceeded max depth\n     */\n    private isMaxDepthExceeded = (): boolean => {\n        const maxDepth = (this.requestContext && this.requestContext.app && this.requestContext.app.maxDepth) || ActionContext.maxDepth;\n        return this.nextTierCounter.next > maxDepth;\n    };\n\n    /**\n     * Retrieves item from request cache and fallsback to app cache if not found\n     */\n    private getItemFromCache = <T>(cacheKey: ICacheKey): T | undefined => {\n        let cachedItem = this.requestCache.get<T>(cacheKey);\n\n        if (cachedItem) {\n            return cachedItem.item;\n        }\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n            cachedItem = this.appCache.get<T>(cacheKey);\n        }\n\n        return cachedItem ? cachedItem.item : undefined;\n    };\n\n    /**\n     * Signals the end of current tier so actions can return the response\n     */\n    private _endCurrentTier = (): void => {\n        this.hasRun = true;\n        EventHelper.emit(`${this.eventId}:completed`, this.currentExecutionTier);\n    };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
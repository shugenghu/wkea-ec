{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{ActionRegistrar}from'./action-registrar';/**\r\n * Wraps a data action with the associated action wrap.\r\n * @param options\r\n * @param actionWrap\r\n */export const wrapDataAction=(options,actionWrap)=>{if(!options){throw new Error('wrapDataAction called with invalid options. Options should have atleast action defined');}if(!options.action){throw new Error(\"Received invalid actions when attempting to parse options. Input name: \".concat(options.input?options.input.name:'undefined'));}let inputFunc=options.input;let id=options.id;let isBatched=options.isBatched;options.action.prototype={id,isBatched,isAction:true};actionWrap.prototype={id,isAction:false,_action:options.action,set RegistrationId(registrationId){options.action.prototype.RegistrationId=registrationId;},get RegistrationId(){return options.action.prototype.RegistrationId||'';},set inputFunc(func){// @ts-ignore\ninputFunc=func;},get inputFunc(){return inputFunc;},get isBatched(){return isBatched;},set isBatched(_isBatched){isBatched=_isBatched;},get Action(){return options.action;},set Action(newAction){// There are no getter/setters on the action function prototype so this behaves as expected.\ninputFunc=newAction.prototype.input||inputFunc;id=newAction.prototype.id||id;isBatched=newAction.prototype.isBatched||isBatched;newAction.prototype=_objectSpread(_objectSpread({},newAction.prototype),options.action.prototype);options.action=newAction;},setProperty:(propertyName,value)=>{options.action.prototype[propertyName]=value;actionWrap.prototype[propertyName]=options.action.prototype[propertyName];}};if(actionWrap.prototype.id){ActionRegistrar.registerAction(actionWrap.prototype.id,actionWrap);}return actionWrap;};","map":{"version":3,"sources":["../../src/wrap-data-action.ts"],"names":[],"mappings":"m2BAAA;;;AAGG,GAGH,OAAS,eAAT,KAAgC,oBAAhC,CAaA;;;;AAIG,GACH,MAAO,MAAM,CAAA,cAAc,CAAG,CAAO,OAAP,CAAyC,UAAzC,GAA6F,CACvH,GAAI,CAAC,OAAL,CAAc,CACV,KAAM,IAAI,CAAA,KAAJ,CAAU,wFAAV,CAAN,CACH,CAED,GAAI,CAAC,OAAO,CAAC,MAAb,CAAqB,CACjB,KAAM,IAAI,CAAA,KAAJ,kFACwE,OAAO,CAAC,KAAR,CAAgB,OAAO,CAAC,KAAR,CAAc,IAA9B,CAAqC,WAD7G,EAAN,CAGH,CAED,GAAI,CAAA,SAAS,CAAG,OAAO,CAAC,KAAxB,CACA,GAAI,CAAA,EAAE,CAAG,OAAO,CAAC,EAAjB,CACA,GAAI,CAAA,SAAS,CAAG,OAAO,CAAC,SAAxB,CACA,OAAO,CAAC,MAAR,CAAe,SAAf,CAA2B,CACvB,EADuB,CAEvB,SAFuB,CAGvB,QAAQ,CAAE,IAHa,CAA3B,CAMA,UAAU,CAAC,SAAX,CAAuB,CACnB,EADmB,CAEnB,QAAQ,CAAE,KAFS,CAGnB,OAAO,CAAE,OAAO,CAAC,MAHE,CAInB,GAAI,CAAA,cAAJ,CAAmB,cAAnB,CAAyC,CACrC,OAAO,CAAC,MAAR,CAAe,SAAf,CAAyB,cAAzB,CAA0C,cAA1C,CACH,CANkB,CAOnB,GAAI,CAAA,cAAJ,EAAkB,CACd,MAAO,CAAA,OAAO,CAAC,MAAR,CAAe,SAAf,CAAyB,cAAzB,EAA2C,EAAlD,CACH,CATkB,CAUnB,GAAI,CAAA,SAAJ,CAAc,IAAd,CAA4B,CACxB;AACA,SAAS,CAAG,IAAZ,CACH,CAbkB,CAcnB,GAAI,CAAA,SAAJ,EAAa,CACT,MAAO,CAAA,SAAP,CACH,CAhBkB,CAiBnB,GAAI,CAAA,SAAJ,EAAa,CACT,MAAO,CAAA,SAAP,CACH,CAnBkB,CAoBnB,GAAI,CAAA,SAAJ,CAAc,UAAd,CAAiC,CAC7B,SAAS,CAAG,UAAZ,CACH,CAtBkB,CAuBnB,GAAI,CAAA,MAAJ,EAAU,CACN,MAAO,CAAA,OAAO,CAAC,MAAf,CACH,CAzBkB,CA0BnB,GAAI,CAAA,MAAJ,CAAW,SAAX,CAAmC,CAC/B;AACA,SAAS,CAAG,SAAS,CAAC,SAAV,CAAoB,KAApB,EAA6B,SAAzC,CACA,EAAE,CAAG,SAAS,CAAC,SAAV,CAAoB,EAApB,EAA0B,EAA/B,CACA,SAAS,CAAG,SAAS,CAAC,SAAV,CAAoB,SAApB,EAAiC,SAA7C,CACA,SAAS,CAAC,SAAV,gCAA2B,SAAS,CAAC,SAArC,EAAmD,OAAO,CAAC,MAAR,CAAe,SAAlE,EACA,OAAO,CAAC,MAAR,CAAiB,SAAjB,CACH,CAjCkB,CAkCnB,WAAW,CAAE,CAAC,YAAD,CAAuB,KAAvB,GAAyC,CAClD,OAAO,CAAC,MAAR,CAAe,SAAf,CAAyB,YAAzB,EAAyC,KAAzC,CACA,UAAU,CAAC,SAAX,CAAqB,YAArB,EAAqC,OAAO,CAAC,MAAR,CAAe,SAAf,CAAyB,YAAzB,CAArC,CACH,CArCkB,CAAvB,CAuCA,GAAI,UAAU,CAAC,SAAX,CAAqB,EAAzB,CAA6B,CACzB,eAAe,CAAC,cAAhB,CAA+B,UAAU,CAAC,SAAX,CAAqB,EAApD,CAAwD,UAAxD,EACH,CAED,MAAO,CAAA,UAAP,CACH,CAhEM","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IAction, IActionInput, IObservableAction } from '@msdyn365-commerce/core-internal';\nimport { ActionRegistrar } from './action-registrar';\n\n// tslint:disable:prefer-method-signature no-any\n\nexport type dataActionOptions<TOut> = {\n    action: IAction<TOut>;\n    isBatched?: boolean;\n    id?: string;\n    input?: (...args: any[]) => IActionInput | IActionInput[];\n};\n\ntype IActionWrap<TOut> = IAction<TOut> | IObservableAction<TOut>;\n\n/**\n * Wraps a data action with the associated action wrap.\n * @param options\n * @param actionWrap\n */\nexport const wrapDataAction = <TOut>(options: dataActionOptions<TOut>, actionWrap: IActionWrap<TOut>): IActionWrap<TOut> => {\n    if (!options) {\n        throw new Error('wrapDataAction called with invalid options. Options should have atleast action defined');\n    }\n\n    if (!options.action) {\n        throw new Error(\n            `Received invalid actions when attempting to parse options. Input name: ${options.input ? options.input.name : 'undefined'}`\n        );\n    }\n\n    let inputFunc = options.input!;\n    let id = options.id;\n    let isBatched = options.isBatched!;\n    options.action.prototype = {\n        id,\n        isBatched,\n        isAction: true\n    };\n\n    actionWrap.prototype = {\n        id,\n        isAction: false,\n        _action: options.action,\n        set RegistrationId(registrationId: string) {\n            options.action.prototype.RegistrationId = registrationId;\n        },\n        get RegistrationId(): string {\n            return options.action.prototype.RegistrationId || '';\n        },\n        set inputFunc(func: Function) {\n            // @ts-ignore\n            inputFunc = func;\n        },\n        get inputFunc(): Function {\n            return inputFunc;\n        },\n        get isBatched(): boolean {\n            return isBatched;\n        },\n        set isBatched(_isBatched: boolean) {\n            isBatched = _isBatched;\n        },\n        get Action(): IAction<TOut> {\n            return options.action;\n        },\n        set Action(newAction: IAction<TOut>) {\n            // There are no getter/setters on the action function prototype so this behaves as expected.\n            inputFunc = newAction.prototype.input || inputFunc;\n            id = newAction.prototype.id || id;\n            isBatched = newAction.prototype.isBatched || isBatched;\n            newAction.prototype = { ...newAction.prototype, ...options.action.prototype };\n            options.action = newAction;\n        },\n        setProperty: (propertyName: string, value: unknown) => {\n            options.action.prototype[propertyName] = value;\n            actionWrap.prototype[propertyName] = options.action.prototype[propertyName];\n        }\n    };\n    if (actionWrap.prototype.id) {\n        ActionRegistrar.registerAction(actionWrap.prototype.id, actionWrap);\n    }\n\n    return actionWrap;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
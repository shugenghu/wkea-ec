{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */ /**\r\n * Cache with TTL and polling to remove items from it, default implementaiton is to only poll on server\r\n */export var TTLCache=/*#__PURE__*/function(){function TTLCache(options){var _this=this;_classCallCheck(this,TTLCache);this.removalThresholdInMs=options&&options.removalThresholdInMs||300000;this.intervalForRemovalInMs=options&&options.intervalForRemovalInMs||120000;this._cache=new Map();if(process.env.CURRENT_ENVIRONMENT==='node'){// interval trigger to clear the map -- only on server\nsetInterval(function(){return _this._cleanCache();},this.intervalForRemovalInMs);}}/**\r\n     * Gets a value from cache\r\n     *\r\n     * @param {string} key the key\r\n     * @returns {(TValue | undefined)} the value, if it exists\r\n     */_createClass(TTLCache,[{key:\"get\",value:function get(key){var value=this._cache.get(key);if(value){return value[0];}}/**\r\n     * Set a value\r\n     *\r\n     * @param {string} key the key\r\n     * @param {TValue} value the value\r\n     */},{key:\"set\",value:function set(key,value,onRemoveCallback){var now=Date.now();this._cache.set(key,[value,now,onRemoveCallback]);}},{key:\"clear\",value:function clear(){this._cache.clear();}// cleans up the map implementation\n},{key:\"_cleanCache\",value:function _cleanCache(){var now=Date.now();var keys=this._cache.keys();var _iterator=_createForOfIteratorHelper(keys),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var key=_step.value;var value=this._cache.get(key);if(value&&value.length>1&&now-value[1]>this.removalThresholdInMs){this._cache[\"delete\"](key);if(typeof value[2]==='function'){value[2](key);}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}}]);return TTLCache;}();","map":{"version":3,"sources":["../../../../src/_server/inteceptors/ttl-cache.ts"],"names":[],"mappings":"s/CAAA;;;AAGG,G,CAQH;;AAEG,GACH,UAAa,CAAA,QAAb,yBAUI,kBAAY,OAAZ,CAAsC,+CAClC,KAAK,oBAAL,CAA6B,OAAO,EAAI,OAAO,CAAC,oBAApB,EAA6C,MAAzE,CACA,KAAK,sBAAL,CAA+B,OAAO,EAAI,OAAO,CAAC,sBAApB,EAA+C,MAA7E,CACA,KAAK,MAAL,CAAc,GAAI,CAAA,GAAJ,EAAd,CAEA,GAAI,OAAO,CAAC,GAAR,CAAY,mBAAZ,GAAoC,MAAxC,CAAgD,CAC5C;AACA,WAAW,CAAC,iBAAM,CAAA,KAAI,CAAC,WAAL,EAAN,EAAD,CAA2B,KAAK,sBAAhC,CAAX,CACH,CACJ,CAED;;;;;AAKG,OA1BP,qDA2Be,GA3Bf,CA2B0B,CAClB,GAAM,CAAA,KAAK,CAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAd,CACA,GAAI,KAAJ,CAAW,CACP,MAAO,CAAA,KAAK,CAAC,CAAD,CAAZ,CACH,CACJ,CAED;;;;;AAKG,OAvCP,gCAwCe,GAxCf,CAwC4B,KAxC5B,CAwC2C,gBAxC3C,CAwC+E,CACvE,GAAM,CAAA,GAAG,CAAG,IAAI,CAAC,GAAL,EAAZ,CACA,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAqB,CAAC,KAAD,CAAQ,GAAR,CAAa,gBAAb,CAArB,EACH,CA3CL,qCA6CgB,CACR,KAAK,MAAL,CAAY,KAAZ,GACH,CAED;AAjDJ,iDAkDuB,CACf,GAAM,CAAA,GAAG,CAAG,IAAI,CAAC,GAAL,EAAZ,CACA,GAAM,CAAA,IAAI,CAAG,KAAK,MAAL,CAAY,IAAZ,EAAb,CAFe,yCAGG,IAHH,YAGf,+CAAwB,IAAb,CAAA,GAAa,aACpB,GAAM,CAAA,KAAK,CAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAd,CACA,GAAI,KAAK,EAAI,KAAK,CAAC,MAAN,CAAe,CAAxB,EAA6B,GAAG,CAAG,KAAK,CAAC,CAAD,CAAX,CAAiB,KAAK,oBAAvD,CAA6E,CACzE,KAAK,MAAL,WAAmB,GAAnB,EACA,GAAI,MAAO,CAAA,KAAK,CAAC,CAAD,CAAZ,GAAoB,UAAxB,CAAoC,CAChC,KAAK,CAAC,CAAD,CAAL,CAAS,GAAT,EACH,CACJ,CACJ,CAXc,qDAYlB,CA9DL","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nexport interface ITTLCacheOptions {\n    removalThresholdInMs?: number;\n    intervalForRemovalInMs?: number;\n}\n\nexport type TOnRemoveCallback = (removedKey: string) => void;\n/**\n * Cache with TTL and polling to remove items from it, default implementaiton is to only poll on server\n */\nexport class TTLCache<TValue> {\n    // threshold for removal, 5mins\n    public readonly removalThresholdInMs: number;\n\n    // frequency of cleaning, 2mins -- this is the period it'll look for keys older than removalThresholdInMs\n    public readonly intervalForRemovalInMs: number;\n\n    // internal cache\n    private _cache: Map<string, [TValue, number, TOnRemoveCallback?]>;\n\n    constructor(options?: ITTLCacheOptions) {\n        this.removalThresholdInMs = (options && options.removalThresholdInMs) || 300000;\n        this.intervalForRemovalInMs = (options && options.intervalForRemovalInMs) || 120000;\n        this._cache = new Map<string, [TValue, number, TOnRemoveCallback?]>();\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node') {\n            // interval trigger to clear the map -- only on server\n            setInterval(() => this._cleanCache(), this.intervalForRemovalInMs);\n        }\n    }\n\n    /**\n     * Gets a value from cache\n     *\n     * @param {string} key the key\n     * @returns {(TValue | undefined)} the value, if it exists\n     */\n    public get(key: string): TValue | undefined {\n        const value = this._cache.get(key);\n        if (value) {\n            return value[0];\n        }\n    }\n\n    /**\n     * Set a value\n     *\n     * @param {string} key the key\n     * @param {TValue} value the value\n     */\n    public set(key: string, value: TValue, onRemoveCallback?: TOnRemoveCallback): void {\n        const now = Date.now();\n        this._cache.set(key, [value, now, onRemoveCallback]);\n    }\n\n    public clear(): void {\n        this._cache.clear();\n    }\n\n    // cleans up the map implementation\n    private _cleanCache(): void {\n        const now = Date.now();\n        const keys = this._cache.keys();\n        for (const key of keys) {\n            const value = this._cache.get(key);\n            if (value && value.length > 1 && now - value[1] > this.removalThresholdInMs) {\n                this._cache.delete(key);\n                if (typeof value[2] === 'function') {\n                    value[2](key);\n                }\n            }\n        }\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _asyncToGenerator from\"@babel/runtime/helpers/esm/asyncToGenerator\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{createObservableDataAction}from'@msdyn365-commerce/action-internal';import{readAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';import{getProductRatingsAsync,searchByCriteriaAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';import{getElementsAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';import*as semver from'semver';import{CATEGORY_PAGE_NAME,PDP_PAGE_NAME,PICKS_FOR_YOU_LIST}from'../../consts';import{getProductImageUrls,orderProductSearchResults}from'../../utils/product-list-utils';import getSimpleProducts,{ProductInput}from'../get-simple-products';var actionInputError=function actionInputError(missingType){throw new Error(\"Input \".concat(missingType,\" is missing and required to run GetProductsByRecommendationId action\"));};var MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS='9.16.8';/**\r\n * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context\r\n * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.\r\n *\r\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\r\n * @param input The ProductListInput provided to the action\r\n * @param context The current action context\r\n */var getCategoryIdForReco=function getCategoryIdForReco(recommendationCriteria,input,context){var categoryIds=[];if(input.listMetadata.includePageContext||!input.listMetadata.categoryIds||input.listMetadata.categoryIds.length===0){var urlTokens=context.requestContext.urlTokens;if(urlTokens&&urlTokens.pageType&&urlTokens.pageType.toLowerCase()===CATEGORY_PAGE_NAME){if(urlTokens.recordId){categoryIds=[+urlTokens.recordId];}}}else{// Use category from a specific context if provided\nif(input.listMetadata.categoryIds&&input.listMetadata.categoryIds.length>0){categoryIds=input.listMetadata.categoryIds;}}recommendationCriteria.CategoryIds=categoryIds;};/**\r\n * Fetches the current active cart to be used when cart context\r\n * is selected for a reco list\r\n *\r\n * @param ctx The current action context\r\n */var getCart=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx){var cart,cookies,cartCookie,cartCookieParts,readCart;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(ctx.requestContext&&ctx.requestContext.cookies)){_context.next=10;break;}cookies=ctx.requestContext&&ctx.requestContext.cookies;cartCookie=cookies.getCartCookie();cartCookieParts=cartCookie.split(':');if(!(cartCookieParts&&cartCookieParts.length===2)){_context.next=10;break;}if(!(ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"t\"/* Auth */||!ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"p\"/* Anon */)){_context.next=10;break;}_context.next=8;return readAsync({callerContext:ctx},cartCookieParts[1]);case 8:readCart=_context.sent;if(readCart&&readCart.Id){cart=readCart;}case 10:return _context.abrupt(\"return\",cart);case 11:case\"end\":return _context.stop();}}},_callee);}));return function getCart(_x){return _ref.apply(this,arguments);};}();/**\r\n * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will\r\n * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.\r\n * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.\r\n *\r\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\r\n * @param input The ProductListInput provided to the action\r\n * @param context The current action context\r\n */var getProductIdForReco=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(recommendationCriteria,input,context){var productIds,cart,validCartLines,cartProductIds,urlTokens;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:productIds=[];// If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call\nif(!input.listMetadata.includeCart){_context2.next=8;break;}_context2.next=4;return getCart(context);case 4:cart=_context2.sent;if(cart&&cart.CartLines){validCartLines=cart.CartLines.filter(function(element){return element.ProductId!==undefined;});cartProductIds=validCartLines.map(function(product){return product.ProductId;});context.telemetry.debug(\"Products in cart: \".concat(cartProductIds));// If the cart isn't empty, assign the products in the cart to the productIds for seeding\nif(cartProductIds&&cartProductIds.length>0){// @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]\n// however, we filter on undefined product ids first before mapping on product ids so each element must be defined\nproductIds=cartProductIds;}}_context2.next=9;break;case 8:if(input.listMetadata.includePageContext||!input.listMetadata.productIds||input.listMetadata.productIds.length===0){urlTokens=context.requestContext.urlTokens;if(urlTokens&&urlTokens.recordId&&urlTokens.pageType&&urlTokens.pageType.toLowerCase()===PDP_PAGE_NAME){productIds=[+urlTokens.recordId];}}else{// Use the product from specfic context\nif(input.listMetadata.productIds&&input.listMetadata.productIds.length>0){productIds=[input.listMetadata.productIds[0]];}}case 9:recommendationCriteria.ProductIds=productIds;case 10:case\"end\":return _context2.stop();}}},_callee2);}));return function getProductIdForReco(_x2,_x3,_x4){return _ref2.apply(this,arguments);};}();// tslint:disable-next-line: max-func-body-length\nexport var getProductsByRecommendationList=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(input,context){var customerAccountNumber,recommendationCriteria,proxyContext,reccomendationListId;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:// If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products\ncustomerAccountNumber=context.requestContext&&context.requestContext.user&&context.requestContext.user.customerAccountNumber;if(!(input.listMetadata.recommendationListId===PICKS_FOR_YOU_LIST&&!customerAccountNumber)){_context4.next=3;break;}return _context4.abrupt(\"return\",[]);case 3:recommendationCriteria={};proxyContext={callerContext:context,queryResultSettings:{Paging:{Top:input.listMetadata.pageSize||10}}};recommendationCriteria.CatalogId=input.catalogId;if(input.listMetadata.recommendationListId){reccomendationListId=input.listMetadata.recommendationListId;}else{actionInputError(\"recommendationListId (from listmetadata)\");}getCategoryIdForReco(recommendationCriteria,input,context);_context4.next=10;return getProductIdForReco(recommendationCriteria,input,context);case 10:if((input.listMetadata.personalization||reccomendationListId===PICKS_FOR_YOU_LIST)&&customerAccountNumber){recommendationCriteria.CustomerAccountNumber=customerAccountNumber;proxyContext.bypassCache='get';}context.telemetry.debug(\"Recommendation Criteria: \".concat(JSON.stringify(recommendationCriteria)));return _context4.abrupt(\"return\",getElementsAsync(proxyContext,reccomendationListId,recommendationCriteria).then(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(recommendedElements){var productInputs,productTypeId,i,element,itemIds,productSearchCriteria,productSearchResults,productRatingsPromise;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!recommendedElements){_context3.next=27;break;}productInputs=[];productTypeId=[];// Grab all the elements that are products and store the product ids\nfor(i=0;i<recommendedElements.length;i++){element=recommendedElements[i];// Element type value of 1 indicates product type\nif(element.ElementId&&element.ElementTypeValue===1){productInputs[i]=new ProductInput(+element.ElementId,context.requestContext.apiSettings);productTypeId[i]=element.ElementId;}}context.telemetry.debug(\"Running recommendation action for list \".concat(input.listMetadata.recommendationListId));context.telemetry.debug(\"Number of products returned: \".concat(productTypeId.length));context.telemetry.debug('Product ids returned',productTypeId);if(!productInputs.length){_context3.next=27;break;}if(!semver.gte(semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion)||'',MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS)){_context3.next=25;break;}itemIds=productInputs.map(function(value){return value.productId;});productSearchCriteria={Ids:itemIds,Context:{ChannelId:+context.requestContext.apiSettings.channelId,CatalogId:+context.requestContext.apiSettings.catalogId}};_context3.prev=11;_context3.next=14;return searchByCriteriaAsync({callerContext:context},productSearchCriteria);case 14:productSearchResults=_context3.sent;// If the ProductSearchResult API finds the products then populate the product image urls and return\n// otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons\ncontext.telemetry.debug('Product search results returned',JSON.stringify(productSearchResults));if(!(productSearchResults.length>0)){_context3.next=20;break;}getProductImageUrls(productSearchResults,context.requestContext.apiSettings);productSearchResults=orderProductSearchResults(itemIds,productSearchResults);return _context3.abrupt(\"return\",productSearchResults);case 20:_context3.next=25;break;case 22:_context3.prev=22;_context3.t0=_context3[\"catch\"](11);// In case of an error fall back to legacy flow\ncontext.telemetry.error(\"Error while getting productSearchResult: \".concat(_context3.t0));case 25:// Get Product Ratings Block (If needed)\nproductRatingsPromise=getProductRatingsAsync({callerContext:context},productInputs.map(function(productInput){return productInput.productId;}));return _context3.abrupt(\"return\",getSimpleProducts(productInputs,context).then(function(products){getProductImageUrls(products,context.requestContext.apiSettings);products=orderProductSearchResults(productInputs.map(function(value){return value.productId;}),products);return productRatingsPromise.then(function(productRatings){productRatings.forEach(function(productRating){var unratedProduct=products.find(function(mappedProduct){return mappedProduct.RecordId===productRating.ProductId;});if(unratedProduct){unratedProduct.TotalRatings=productRating.TotalRatings;unratedProduct.AverageRating=productRating.AverageRating;}});return products;});}));case 27:return _context3.abrupt(\"return\",[]);case 28:case\"end\":return _context3.stop();}}},_callee3,null,[[11,22]]);}));return function(_x7){return _ref4.apply(this,arguments);};}())[\"catch\"](function(error){context.telemetry.error(\"Error running productByRecommendation action: \".concat(error));throw new Error(error);}));case 13:case\"end\":return _context4.stop();}}},_callee4);}));return function getProductsByRecommendationList(_x5,_x6){return _ref3.apply(this,arguments);};}();export var getProductsByRecommendationListAction=createObservableDataAction({action:getProductsByRecommendationList,id:'@msdyn365-commerce/products-by-recommendation'});","map":{"version":3,"sources":["../../../../src/hydrators/product-list-actions/products-by-recommendation.action.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { createObservableDataAction } from '@msdyn365-commerce/action-internal';\nimport { IAction, IActionContext } from '@msdyn365-commerce/core-internal';\nimport { readAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';\nimport { getProductRatingsAsync, searchByCriteriaAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';\nimport { getElementsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';\nimport {\n    Cart,\n    ProductSearchCriteria,\n    ProductSearchResult,\n    RecommendationCriteria,\n    RecommendedElement\n} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';\nimport { IContext } from '@msdyn365-commerce/retail-proxy/dist/Interfaces';\nimport * as semver from 'semver';\nimport { CATEGORY_PAGE_NAME, PDP_PAGE_NAME, PICKS_FOR_YOU_LIST } from '../../consts';\nimport { getProductImageUrls, orderProductSearchResults } from '../../utils/product-list-utils';\nimport getSimpleProducts, { ProductInput } from '../get-simple-products';\nimport { ProductListInput } from '../hydrator-action-inputs';\n\nconst actionInputError = (missingType: string) => {\n    throw new Error(`Input ${missingType} is missing and required to run GetProductsByRecommendationId action`);\n};\n\nconst enum CartTokenPrefix {\n    Auth = 't',\n    Anon = 'p'\n}\n\nconst MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS = '9.16.8';\n\n/**\n * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context\n * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getCategoryIdForReco = (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let categoryIds: number[] = [];\n\n    if (input.listMetadata.includePageContext || !input.listMetadata.categoryIds || input.listMetadata.categoryIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.pageType && urlTokens.pageType.toLowerCase() === CATEGORY_PAGE_NAME) {\n            if (urlTokens.recordId) {\n                categoryIds = [+urlTokens.recordId];\n            }\n        }\n    } else {\n        // Use category from a specific context if provided\n        if (input.listMetadata.categoryIds && input.listMetadata.categoryIds.length > 0) {\n            categoryIds = input.listMetadata.categoryIds;\n        }\n    }\n\n    recommendationCriteria.CategoryIds = categoryIds;\n};\n\n/**\n * Fetches the current active cart to be used when cart context\n * is selected for a reco list\n *\n * @param ctx The current action context\n */\nconst getCart = async (ctx: IActionContext): Promise<Cart | undefined> => {\n    let cart;\n    if (ctx.requestContext && ctx.requestContext.cookies) {\n        const cookies = ctx.requestContext && ctx.requestContext.cookies;\n        const cartCookie = cookies.getCartCookie();\n        const cartCookieParts = cartCookie.split(':');\n        if (cartCookieParts && cartCookieParts.length === 2) {\n            if (\n                (ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Auth) ||\n                (!ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Anon)\n            ) {\n                const readCart = await readAsync({ callerContext: ctx }, cartCookieParts[1]);\n                if (readCart && readCart.Id) {\n                    cart = readCart;\n                }\n            }\n        }\n    }\n    return cart;\n};\n\n/**\n * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will\n * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.\n * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getProductIdForReco = async (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let productIds: number[] = [];\n    // If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call\n    if (input.listMetadata.includeCart) {\n        const cart = await getCart(context);\n        if (cart && cart.CartLines) {\n            const validCartLines = cart.CartLines.filter(element => element.ProductId !== undefined);\n            const cartProductIds = validCartLines.map(product => product.ProductId);\n            context.telemetry.debug(`Products in cart: ${cartProductIds}`);\n            // If the cart isn't empty, assign the products in the cart to the productIds for seeding\n            if (cartProductIds && cartProductIds.length > 0) {\n                // @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]\n                // however, we filter on undefined product ids first before mapping on product ids so each element must be defined\n                productIds = cartProductIds;\n            }\n        }\n    } else if (input.listMetadata.includePageContext || !input.listMetadata.productIds || input.listMetadata.productIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.recordId && urlTokens.pageType && urlTokens.pageType.toLowerCase() === PDP_PAGE_NAME) {\n            productIds = [+urlTokens.recordId];\n        }\n    } else {\n        // Use the product from specfic context\n        if (input.listMetadata.productIds && input.listMetadata.productIds.length > 0) {\n            productIds = [input.listMetadata.productIds[0]];\n        }\n    }\n\n    recommendationCriteria.ProductIds = productIds;\n};\n\n// tslint:disable-next-line: max-func-body-length\nexport const getProductsByRecommendationList = async (input: ProductListInput, context: IActionContext): Promise<ProductSearchResult[]> => {\n    // If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products\n    const customerAccountNumber =\n        context.requestContext && context.requestContext.user && context.requestContext.user.customerAccountNumber;\n    if (input.listMetadata.recommendationListId === PICKS_FOR_YOU_LIST && !customerAccountNumber) {\n        return [];\n    }\n\n    const recommendationCriteria: RecommendationCriteria = {};\n    const proxyContext: IContext = { callerContext: context, queryResultSettings: { Paging: { Top: input.listMetadata.pageSize || 10 } } };\n    recommendationCriteria.CatalogId = input.catalogId;\n\n    let reccomendationListId;\n    if (input.listMetadata.recommendationListId) {\n        reccomendationListId = input.listMetadata.recommendationListId;\n    } else {\n        actionInputError(`recommendationListId (from listmetadata)`);\n    }\n\n    getCategoryIdForReco(recommendationCriteria, input, context);\n    await getProductIdForReco(recommendationCriteria, input, context);\n\n    if ((input.listMetadata.personalization || reccomendationListId === PICKS_FOR_YOU_LIST) && customerAccountNumber) {\n        recommendationCriteria.CustomerAccountNumber = customerAccountNumber;\n        proxyContext.bypassCache = 'get';\n    }\n\n    context.telemetry.debug(`Recommendation Criteria: ${JSON.stringify(recommendationCriteria)}`);\n\n    return getElementsAsync(proxyContext, reccomendationListId, recommendationCriteria)\n        .then(async (recommendedElements: RecommendedElement[]) => {\n            if (recommendedElements) {\n                const productInputs: ProductInput[] = [];\n                const productTypeId: string[] = [];\n                // Grab all the elements that are products and store the product ids\n                for (let i = 0; i < recommendedElements.length; i++) {\n                    const element = recommendedElements[i];\n                    // Element type value of 1 indicates product type\n                    if (element.ElementId && element.ElementTypeValue === 1) {\n                        productInputs[i] = new ProductInput(+element.ElementId, context.requestContext.apiSettings);\n                        productTypeId[i] = element.ElementId;\n                    }\n                }\n                context.telemetry.debug(`Running recommendation action for list ${input.listMetadata.recommendationListId}`);\n                context.telemetry.debug(`Number of products returned: ${productTypeId.length}`);\n                context.telemetry.debug('Product ids returned', productTypeId);\n\n                if (productInputs.length) {\n                    // Check to see if retail proxy version is greater than min version required for new API\n                    if (\n                        semver.gte(\n                            semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion) || '',\n                            MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS\n                        )\n                    ) {\n                        const itemIds: number[] = productInputs.map(value => value.productId);\n                        const productSearchCriteria: ProductSearchCriteria = {\n                            Ids: itemIds,\n                            Context: {\n                                ChannelId: +context.requestContext.apiSettings.channelId,\n                                CatalogId: +context.requestContext.apiSettings.catalogId\n                            }\n                        };\n                        try {\n                            let productSearchResults = await searchByCriteriaAsync({ callerContext: context }, productSearchCriteria);\n                            // If the ProductSearchResult API finds the products then populate the product image urls and return\n                            // otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons\n                            context.telemetry.debug('Product search results returned', JSON.stringify(productSearchResults));\n                            if (productSearchResults.length > 0) {\n                                getProductImageUrls(productSearchResults, context.requestContext.apiSettings);\n                                productSearchResults = orderProductSearchResults(itemIds, productSearchResults);\n                                return productSearchResults;\n                            }\n                        } catch (e) {\n                            // In case of an error fall back to legacy flow\n                            context.telemetry.error(`Error while getting productSearchResult: ${e}`);\n                        }\n                    }\n\n                    // Get Product Ratings Block (If needed)\n                    const productRatingsPromise = getProductRatingsAsync(\n                        { callerContext: context },\n                        productInputs.map(productInput => productInput.productId)\n                    );\n\n                    return getSimpleProducts(productInputs, context).then((products: ProductSearchResult[]) => {\n                        getProductImageUrls(products, context.requestContext.apiSettings);\n                        products = orderProductSearchResults(\n                            productInputs.map(value => value.productId),\n                            products\n                        );\n                        return productRatingsPromise.then(productRatings => {\n                            productRatings.forEach(productRating => {\n                                const unratedProduct: ProductSearchResult = <ProductSearchResult>(\n                                    products.find(mappedProduct => mappedProduct.RecordId === productRating.ProductId)\n                                );\n                                if (unratedProduct) {\n                                    unratedProduct.TotalRatings = productRating.TotalRatings;\n                                    unratedProduct.AverageRating = productRating.AverageRating;\n                                }\n                            });\n\n                            return products;\n                        });\n                    });\n                }\n            }\n            return [];\n        })\n        .catch(error => {\n            context.telemetry.error(`Error running productByRecommendation action: ${error}`);\n            throw new Error(error);\n        });\n};\n\nexport const getProductsByRecommendationListAction = createObservableDataAction({\n    action: <IAction<ProductSearchResult[]>>getProductsByRecommendationList,\n    id: '@msdyn365-commerce/products-by-recommendation'\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
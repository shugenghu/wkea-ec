{"ast":null,"code":"import\"core-js/modules/web.dom-collections.for-each.js\";import\"core-js/modules/web.dom-collections.iterator.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{EMPTY,format}from'../extensions/StringExtensions';import{DebuggingConsoleSink}from'./ConsoleEventWriter';import{attachLoggingSink,RetailLogger}from'./RetailLogger';/**\r\n * The tracer class allows information to be logged on the device for Information, Warning or Error\r\n * The same method call can be used for each type\r\n * Example:\r\n *         Commerce.Proxy.Tracer.Information(\"Message {0} {1}\", [\"Arg1\", \"Arg2\"]);     // With parameters to be formatted\r\n *         Commerce.Proxy.Tracer.Information(\"Message\");                               // Without parameters\r\n *\r\n * Example of different tracer logs\r\n *   Dynamics-Information: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\r\n *   Dynamics-Warning: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\r\n *   Dynamics-Error: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\r\n */export class Tracer{static init(){attachLoggingSink(new DebuggingConsoleSink());return true;}/**\r\n     * Traces an informational message in the specified format.\r\n     */static Information(informationformat){if(Tracer.TracingOn){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}RetailLogger.genericInfo(Tracer.GetMessage.apply(null,[Tracer.TracerDynamicsError,informationformat,...args]));}}/**\r\n     * Traces a warning message in the specified format.\r\n     */static Warning(warningFormat){if(Tracer.TracingOn){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}RetailLogger.genericWarning(Tracer.GetMessage.apply(null,[Tracer.TracerDynamicsError,warningFormat,...args]));}}/**\r\n     * Traces an error message in the specified format.\r\n     */static Error(errorFormat){if(Tracer.TracingOn){for(var _len3=arguments.length,args=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){args[_key3-1]=arguments[_key3];}RetailLogger.genericError(Tracer.GetMessage.apply(null,[Tracer.TracerDynamicsError,errorFormat,...args]));}}/**\r\n     * Traces an error message in the specified format.\r\n     */static Errors(errors,formatString){for(var _len4=arguments.length,args=new Array(_len4>2?_len4-2:0),_key4=2;_key4<_len4;_key4++){args[_key4-2]=arguments[_key4];}if(Tracer.TracingOn&&errors!==null&&errors.length>0){let errorMessage='';let errorCode='';let errorString='';errors.forEach(error=>{errorMessage=error.ErrorMessage||EMPTY;errorCode=error.ErrorCode||EMPTY;errorString=JSON.stringify(error);Tracer.Error(formatString+' '+format(' \\n ErrorMessage: {0}; \\n ErrorCode: {1}; \\n ErrorObject: \\'{2}\\'',errorMessage,errorCode,errorString),args);});}}static StartCounter(uniqueFunctionName){let counter;if(Tracer.Counters[uniqueFunctionName]===undefined){counter=new PerformanceCounters();counter.Name=uniqueFunctionName;}else{counter=Tracer.Counters[uniqueFunctionName];}counter.Count+=1;Tracer.Counters[uniqueFunctionName]=counter;const now=new Date().getTime();Tracer.Timers.push(now);}static EndCounter(uniqueFunctionName){const now=new Date().getTime();const startTime=Tracer.Timers.pop();const counter=Tracer.Counters[uniqueFunctionName];counter.TotalTime+=now-startTime;}static DumpCounters(){for(const item in Tracer.Counters){if(Tracer.Counters.hasOwnProperty(item)){Tracer.Information('Method = {0} Number of calls = {1} TotalTime = {2}mS Avg = {3}mS',Tracer.Counters[item].Name,Tracer.Counters[item].Count,Tracer.Counters[item].TotalTime,Tracer.Counters[item].TotalTime/Tracer.Counters[item].Count);}}}static GetMessage(type,formatString){for(var _len5=arguments.length,args=new Array(_len5>2?_len5-2:0),_key5=2;_key5<_len5;_key5++){args[_key5-2]=arguments[_key5];}const now=''+new Date().getTime()+'mS';if(Tracer.TracingOn){if(!args){return Tracer.TracerDynamics+type+'\\t'+formatString+'\\t'+now;}else{return Tracer.TracerDynamics+type+'\\t'+format.apply(null,[formatString,Array.prototype.slice.call(args)])+'\\t'+now;}}}}Tracer.TracerDynamics='Dynamics-';Tracer.TracerDynamicsError='Error: ';Tracer.TracingOn=true;Tracer.Counters=new Array();Tracer.Timers=new Array();Tracer._initialized=Tracer.init();class PerformanceCounters{constructor(){this.Count=0;this.TotalTime=0;}}","map":{"version":3,"sources":["../../src/logging/Tracer.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { ProxyError } from '../exceptions';\nimport { EMPTY, format } from '../extensions/StringExtensions';\nimport { DebuggingConsoleSink } from './ConsoleEventWriter';\nimport { attachLoggingSink, RetailLogger } from './RetailLogger';\n\n/**\n * The tracer class allows information to be logged on the device for Information, Warning or Error\n * The same method call can be used for each type\n * Example:\n *         Commerce.Proxy.Tracer.Information(\"Message {0} {1}\", [\"Arg1\", \"Arg2\"]);     // With parameters to be formatted\n *         Commerce.Proxy.Tracer.Information(\"Message\");                               // Without parameters\n *\n * Example of different tracer logs\n *   Dynamics-Information: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\n *   Dynamics-Warning: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\n *   Dynamics-Error: <<Formatted message>> <<number of milliseconds since 1970/01/01>>\n */\n\nexport class Tracer {\n    private static TracerDynamics: string = 'Dynamics-';\n    private static TracerDynamicsError: string = 'Error: ';\n\n    private static TracingOn: boolean = true;\n\n    private static Counters: any[] = new Array();\n    private static Timers: any[] = new Array();\n\n    public static init(): boolean {\n        attachLoggingSink(new DebuggingConsoleSink());\n        return true;\n    }\n\n    public static _initialized: boolean = Tracer.init();\n\n    /**\n     * Traces an informational message in the specified format.\n     */\n    public static Information(informationformat: string, ...args: any[]): void {\n        if (Tracer.TracingOn) {\n            RetailLogger.genericInfo(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, informationformat, ...args]));\n        }\n    }\n\n    /**\n     * Traces a warning message in the specified format.\n     */\n    public static Warning(warningFormat: string, ...args: any[]): void {\n        if (Tracer.TracingOn) {\n            RetailLogger.genericWarning(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, warningFormat, ...args]));\n        }\n    }\n\n    /**\n     * Traces an error message in the specified format.\n     */\n    public static Error(errorFormat: string, ...args: any[]): void {\n        if (Tracer.TracingOn) {\n            RetailLogger.genericError(Tracer.GetMessage.apply(null, [Tracer.TracerDynamicsError, errorFormat, ...args]));\n        }\n    }\n\n    /**\n     * Traces an error message in the specified format.\n     */\n    public static Errors(errors: ProxyError[], formatString: string, ...args: any[]): void {\n        if (Tracer.TracingOn && errors !== null && errors.length > 0) {\n            let errorMessage: string = '';\n            let errorCode: string = '';\n            let errorString: string = '';\n\n            errors.forEach(error => {\n                errorMessage = error.ErrorMessage || EMPTY;\n                errorCode = error.ErrorCode || EMPTY;\n                errorString = JSON.stringify(error);\n                Tracer.Error(\n                    formatString +\n                        ' ' +\n                        format(' \\n ErrorMessage: {0}; \\n ErrorCode: {1}; \\n ErrorObject: \\'{2}\\'', errorMessage, errorCode, errorString),\n                    args\n                );\n            });\n        }\n    }\n\n    public static StartCounter(uniqueFunctionName: string): void {\n        let counter;\n        if (Tracer.Counters[uniqueFunctionName] === undefined) {\n            counter = new PerformanceCounters();\n            counter.Name = uniqueFunctionName;\n        } else {\n            counter = Tracer.Counters[uniqueFunctionName];\n        }\n        counter.Count += 1;\n        Tracer.Counters[uniqueFunctionName] = counter;\n        const now = new Date().getTime();\n        Tracer.Timers.push(now);\n    }\n\n    public static EndCounter(uniqueFunctionName: string): void {\n        const now = new Date().getTime();\n        const startTime = Tracer.Timers.pop();\n        const counter = Tracer.Counters[uniqueFunctionName];\n        counter.TotalTime += now - startTime;\n    }\n\n    public static DumpCounters() {\n        for (const item in Tracer.Counters) {\n            if (Tracer.Counters.hasOwnProperty(item)) {\n                Tracer.Information(\n                    'Method = {0} Number of calls = {1} TotalTime = {2}mS Avg = {3}mS',\n                    Tracer.Counters[item].Name,\n                    Tracer.Counters[item].Count,\n                    Tracer.Counters[item].TotalTime,\n                    Tracer.Counters[item].TotalTime / Tracer.Counters[item].Count\n                );\n            }\n        }\n    }\n\n    private static GetMessage(type: string, formatString: string, ...args: any[]) {\n        const now = '' + new Date().getTime() + 'mS';\n        if (Tracer.TracingOn) {\n            if (!args) {\n                return Tracer.TracerDynamics + type + '\\t' + formatString + '\\t' + now;\n            } else {\n                return (\n                    Tracer.TracerDynamics + type + '\\t' + format.apply(null, [formatString, Array.prototype.slice.call(args)]) + '\\t' + now\n                );\n            }\n        }\n    }\n}\n\nclass PerformanceCounters {\n    public Name: string;\n    public Count: number = 0;\n    public TotalTime: number = 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
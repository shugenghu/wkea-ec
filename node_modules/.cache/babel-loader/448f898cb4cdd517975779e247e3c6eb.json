{"ast":null,"code":"/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import axios from'axios';import{jsonHandler}from'./handler';const normalHeaders={accept:'Accept','content-type':'Content-Type','odata-version':'OData-Version','odata-maxversion':'OData-MaxVersion'};const isAbsoluteUrl=url=>{/// <summary>Checks whether the specified URL is an absolute URL.</summary>\n/// <param name=\"url\" type=\"String\">URL to check.</param>\n/// <returns type=\"Boolean\">true if the url is an absolute URL; false otherwise.</returns>\nreturn url.indexOf('http://')===0||url.indexOf('https://')===0||url.indexOf('file://')===0;};const normalizeHeaders=headers=>{/// <summary>Normalizes headers so they can be found with consistent casing.</summary>\n/// <param name=\"headers\" type=\"Object\">Dictionary of name/value pairs.</param>\nfor(const name in headers){if(headers.hasOwnProperty(name)){const lowerName=name.toLowerCase();const normalName=normalHeaders[lowerName];if(normalName&&name!==normalName){const val=headers[name];delete headers[name];headers[normalName]=val;}}}};const defaultHttpClient={callbackParameterName:'$callback',formatQueryString:'$format=json',enableJsonpCallback:false,request(request,success,error){/// <summary>Performs a network request.</summary>\n/// <param name=\"request\" type=\"Object\">Request description.</request>\n/// <param name=\"success\" type=\"Function\">Success callback with the response object.</param>\n/// <param name=\"error\" type=\"Function\">Error callback with an error object.</param>\n/// <returns type=\"Object\">Object with an 'abort' method for the operation.</returns>\nconst result={abort:null,handleTimeout:null};const cancelToken=axios.CancelToken.source();let done=false;result.abort=()=>{if(done){return;}done=true;cancelToken.cancel('Request aborted');error({message:'Request aborted'});};request.handleTimeout=()=>{if(!done){done=true;cancelToken.cancel('Request aborted');error({message:'Request timed out'});}};const url=request.requestUri;const enableJsonpCallback=request.enableJsonpCallback||false;if(!enableJsonpCallback||!isAbsoluteUrl(url)){let authenticationCreds;if(request.user){authenticationCreds={username:request.user,password:request.password||''};}// console.log('\\r\\nDataServiceRequest - \\r\\n\\n', request);\naxios.request({method:request.method||'get',url,data:request.body,auth:authenticationCreds,headers:request.headers||{},timeout:request.timeoutMS||10000,cancelToken:cancelToken.token}).then(axiosResponse=>{const response={requestUri:url,statusCode:axiosResponse.status,statusText:axiosResponse.statusText,headers:axiosResponse.headers,body:axiosResponse.data};done=true;success(response);}).catch(axiosError=>{const response={requestUri:url,statusCode:axiosError.response?parseInt(axiosError.response.status,10):0,statusText:axiosError.name,body:axiosError.message,data:axiosError.response?axiosError.response.data:{},headers:axiosError.response?axiosError.response.headers:{}};error({message:'HTTP request failed',request,response});});}else{error({message:'Only requests to non-absolute urls are supported at this time without JSONP callback'});}return result;}};const prepareRequest=(request,handler,context)=>{/// <summary>Prepares a request object so that it can be sent through the network.</summary>\n/// <param name=\"request\">Object that represents the request to be sent.</param>\n/// <param name=\"handler\">Handler for data serialization</param>\n/// <param name=\"context\">Context used for preparing the request</param>\n// Default to GET if no method has been specified.\nif(!request.method){request.method='GET';}if(!request.headers){request.headers={};}else{normalizeHeaders(request.headers);}if(request.headers.Accept===undefined){request.headers.Accept=handler.accept;}if(request.data&&request.body===undefined){handler.write(request,context);}if(!request.headers['OData-MaxVersion']){request.headers['OData-MaxVersion']=handler.maxDataServiceVersion||'4.0';}};const invokeRequest=(request,success,error,handler,httpClient,context)=>{/// <summary>Sends a request containing OData payload to a server.</summary>\n/// <param name=\"request\">Object that represents the request to be sent..</param>\n/// <param name=\"success\">Callback for a successful read operation.</param>\n/// <param name=\"error\">Callback for handling errors.</param>\n/// <param name=\"handler\">Handler for data serialization.</param>\n/// <param name=\"httpClient\">HTTP client layer.</param>\n/// <param name=\"context\">Context used for processing the request</param>\nreturn httpClient.request(request,response=>{try{if(response.headers){normalizeHeaders(response.headers);}if(response.data===undefined&&response.statusCode!==204){if(!handler.read(response,context)){throw{message:'Handler could not parse response.'};}}}catch(err){if(err.request===undefined){err.request=request;}if(err.response===undefined){err.response=response;}error(err);return;}success(response.data,response);},error);};export const ODataHttpRequest=(request,success,error)=>{/// <summary>Sends a request containing OData payload to a server.</summary>\n/// <param name=\"request\" type=\"Object\">Object that represents the request to be sent.</param>\n/// <param name=\"success\" type=\"Function\" optional=\"true\">Callback for a successful read operation.</param>\n/// <param name=\"error\" type=\"Function\" optional=\"true\">Callback for handling errors.</param>\n/// <param name=\"handler\" type=\"Object\" optional=\"true\">Handler for data serialization.</param>\n/// <param name=\"httpClient\" type=\"Object\" optional=\"true\">HTTP client layer.</param>\n/// <param name=\"metadata\" type=\"Object\" optional=\"true\">Conceptual metadata for this request.</param>\nsuccess=success||(data=>process.env.NODE_ENV!=='production'&&console.log(JSON.stringify(data)));error=error||(err=>{throw err;});// Augment the request with additional defaults.\nrequest.recognizeDates=request.recognizeDates||false;request.useJsonLight=request.useJsonLight||false;request.inferJsonLightFeedAsObject=request.inferJsonLightFeedAsObject||false;request.callbackParameterName=request.callbackParameterName||defaultHttpClient.callbackParameterName;request.formatQueryString=request.formatQueryString||defaultHttpClient.formatQueryString;request.enableJsonpCallback=request.enableJsonpCallback||defaultHttpClient.enableJsonpCallback;// Create the base context for read/write operations, also specifying complete settings.\nconst context={recognizeDates:request.recognizeDates,callbackParameterName:request.callbackParameterName,formatQueryString:request.formatQueryString,enableJsonpCallback:request.enableJsonpCallback,useJsonLight:request.useJsonLight,inferJsonLightFeedAsObject:request.inferJsonLightFeedAsObject};try{prepareRequest(request,jsonHandler,context);return invokeRequest(request,success,error,jsonHandler,defaultHttpClient,context);}catch(err){error(err);}};","map":{"version":3,"sources":["../../src/externals/DataJS.New.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport axios from 'axios';\nimport { jsonHandler } from './handler';\n\n/**\n * OData request interface.\n */\nexport interface IODataRequest {\n    /**\n     * OData endpoint URI\n     */\n    requestUri: string;\n\n    /**\n     * HTTP method (GET, POST, PUT, DELETE)\n     */\n    method: string;\n\n    /**\n     * Payload of the request (in intermediate format)\n     */\n    data: any;\n\n    /**\n     * Object that contains HTTP headers as name value pairs\n     */\n    headers?: Object;\n\n    /**\n     * (Optional) Username to send for BASIC authentication\n     */\n    user?: string;\n\n    /**\n     * (Optional) Password to send for BASIC authentication\n     */\n    password?: string;\n\n    /**\n     * (Optional) Whether or not to use cross domain cookies.\n     */\n    useCrossDomainCookies?: boolean;\n}\n\nconst normalHeaders = {\n    accept: 'Accept',\n    'content-type': 'Content-Type',\n    'odata-version': 'OData-Version',\n    'odata-maxversion': 'OData-MaxVersion'\n};\n\nconst isAbsoluteUrl = url => {\n    /// <summary>Checks whether the specified URL is an absolute URL.</summary>\n    /// <param name=\"url\" type=\"String\">URL to check.</param>\n    /// <returns type=\"Boolean\">true if the url is an absolute URL; false otherwise.</returns>\n\n    return url.indexOf('http://') === 0 || url.indexOf('https://') === 0 || url.indexOf('file://') === 0;\n};\n\nconst normalizeHeaders = headers => {\n    /// <summary>Normalizes headers so they can be found with consistent casing.</summary>\n    /// <param name=\"headers\" type=\"Object\">Dictionary of name/value pairs.</param>\n\n    for (const name in headers) {\n        if (headers.hasOwnProperty(name)) {\n            const lowerName = name.toLowerCase();\n            const normalName = normalHeaders[lowerName];\n            if (normalName && name !== normalName) {\n                const val = headers[name];\n                delete headers[name];\n                headers[normalName] = val;\n            }\n        }\n    }\n};\n\nconst defaultHttpClient = {\n    callbackParameterName: '$callback',\n    formatQueryString: '$format=json',\n    enableJsonpCallback: false,\n\n    request(request, success, error) {\n        /// <summary>Performs a network request.</summary>\n        /// <param name=\"request\" type=\"Object\">Request description.</request>\n        /// <param name=\"success\" type=\"Function\">Success callback with the response object.</param>\n        /// <param name=\"error\" type=\"Function\">Error callback with an error object.</param>\n        /// <returns type=\"Object\">Object with an 'abort' method for the operation.</returns>\n        const result = { abort: null, handleTimeout: null };\n\n        const cancelToken = axios.CancelToken.source();\n\n        let done = false;\n        result.abort = () => {\n            if (done) {\n                return;\n            }\n            done = true;\n            cancelToken.cancel('Request aborted');\n            error({ message: 'Request aborted' });\n        };\n\n        request.handleTimeout = () => {\n            if (!done) {\n                done = true;\n                cancelToken.cancel('Request aborted');\n                error({ message: 'Request timed out' });\n            }\n        };\n\n        const url = request.requestUri;\n        const enableJsonpCallback = request.enableJsonpCallback || false;\n        if (!enableJsonpCallback || !isAbsoluteUrl(url)) {\n            let authenticationCreds;\n            if (request.user) {\n                authenticationCreds = {\n                    username: request.user,\n                    password: request.password || ''\n                };\n            }\n            // console.log('\\r\\nDataServiceRequest - \\r\\n\\n', request);\n            axios\n                .request({\n                    method: request.method || 'get',\n                    url,\n                    data: request.body,\n                    auth: authenticationCreds,\n                    headers: request.headers || {},\n                    timeout: request.timeoutMS || 10000,\n                    cancelToken: cancelToken.token\n                })\n                .then(axiosResponse => {\n                    const response = {\n                        requestUri: url,\n                        statusCode: axiosResponse.status,\n                        statusText: axiosResponse.statusText,\n                        headers: axiosResponse.headers,\n                        body: axiosResponse.data\n                    };\n                    done = true;\n                    success(response);\n                })\n                .catch(axiosError => {\n                    const response = {\n                        requestUri: url,\n                        statusCode: axiosError.response ? parseInt(axiosError.response.status, 10) : 0,\n                        statusText: axiosError.name,\n                        body: axiosError.message,\n                        data: axiosError.response ? axiosError.response.data : {},\n                        headers: axiosError.response ? axiosError.response.headers : {}\n                    };\n                    error({ message: 'HTTP request failed', request, response });\n                });\n        } else {\n            error({\n                message: 'Only requests to non-absolute urls are supported at this time without JSONP callback'\n            });\n        }\n        return result;\n    }\n};\n\nconst prepareRequest = (request, handler, context) => {\n    /// <summary>Prepares a request object so that it can be sent through the network.</summary>\n    /// <param name=\"request\">Object that represents the request to be sent.</param>\n    /// <param name=\"handler\">Handler for data serialization</param>\n    /// <param name=\"context\">Context used for preparing the request</param>\n\n    // Default to GET if no method has been specified.\n    if (!request.method) {\n        request.method = 'GET';\n    }\n\n    if (!request.headers) {\n        request.headers = {};\n    } else {\n        normalizeHeaders(request.headers);\n    }\n\n    if (request.headers.Accept === undefined) {\n        request.headers.Accept = handler.accept;\n    }\n\n    if (request.data && request.body === undefined) {\n        handler.write(request, context);\n    }\n\n    if (!request.headers['OData-MaxVersion']) {\n        request.headers['OData-MaxVersion'] = handler.maxDataServiceVersion || '4.0';\n    }\n};\n\nconst invokeRequest = (request, success, error, handler, httpClient, context) => {\n    /// <summary>Sends a request containing OData payload to a server.</summary>\n    /// <param name=\"request\">Object that represents the request to be sent..</param>\n    /// <param name=\"success\">Callback for a successful read operation.</param>\n    /// <param name=\"error\">Callback for handling errors.</param>\n    /// <param name=\"handler\">Handler for data serialization.</param>\n    /// <param name=\"httpClient\">HTTP client layer.</param>\n    /// <param name=\"context\">Context used for processing the request</param>\n\n    return httpClient.request(\n        request,\n        response => {\n            try {\n                if (response.headers) {\n                    normalizeHeaders(response.headers);\n                }\n\n                if (response.data === undefined && response.statusCode !== 204) {\n                    if (!handler.read(response, context)) {\n                        throw { message: 'Handler could not parse response.' };\n                    }\n                }\n            } catch (err) {\n                if (err.request === undefined) {\n                    err.request = request;\n                }\n                if (err.response === undefined) {\n                    err.response = response;\n                }\n                error(err);\n                return;\n            }\n\n            success(response.data, response);\n        },\n        error\n    );\n};\n\nexport const ODataHttpRequest = (request, success, error) => {\n    /// <summary>Sends a request containing OData payload to a server.</summary>\n    /// <param name=\"request\" type=\"Object\">Object that represents the request to be sent.</param>\n    /// <param name=\"success\" type=\"Function\" optional=\"true\">Callback for a successful read operation.</param>\n    /// <param name=\"error\" type=\"Function\" optional=\"true\">Callback for handling errors.</param>\n    /// <param name=\"handler\" type=\"Object\" optional=\"true\">Handler for data serialization.</param>\n    /// <param name=\"httpClient\" type=\"Object\" optional=\"true\">HTTP client layer.</param>\n    /// <param name=\"metadata\" type=\"Object\" optional=\"true\">Conceptual metadata for this request.</param>\n\n    success = success || (data => process.env.NODE_ENV !== 'production' && console.log(JSON.stringify(data)));\n    error =\n        error ||\n        (err => {\n            throw err;\n        });\n\n    // Augment the request with additional defaults.\n    request.recognizeDates = request.recognizeDates || false;\n    request.useJsonLight = request.useJsonLight || false;\n    request.inferJsonLightFeedAsObject = request.inferJsonLightFeedAsObject || false;\n    request.callbackParameterName = request.callbackParameterName || defaultHttpClient.callbackParameterName;\n    request.formatQueryString = request.formatQueryString || defaultHttpClient.formatQueryString;\n    request.enableJsonpCallback = request.enableJsonpCallback || defaultHttpClient.enableJsonpCallback;\n\n    // Create the base context for read/write operations, also specifying complete settings.\n    const context = {\n        recognizeDates: request.recognizeDates,\n        callbackParameterName: request.callbackParameterName,\n        formatQueryString: request.formatQueryString,\n        enableJsonpCallback: request.enableJsonpCallback,\n        useJsonLight: request.useJsonLight,\n        inferJsonLightFeedAsObject: request.inferJsonLightFeedAsObject\n    };\n\n    try {\n        prepareRequest(request, jsonHandler, context);\n        return invokeRequest(request, success, error, jsonHandler, defaultHttpClient, context);\n    } catch (err) {\n        error(err);\n    }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
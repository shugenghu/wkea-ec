{"ast":null,"code":"import\"core-js/modules/es.symbol.description.js\";import\"core-js/modules/es.regexp.to-string.js\";import\"core-js/modules/web.dom-collections.iterator.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{__decorate,__metadata}from\"tslib\";// NOTE: no-any is disabled intentionally, as promises require valid use of the any type\n// tslint:disable:no-any\nimport{observable}from'mobx';export const isAsyncResult=item=>{return item&&item.toString&&typeof item.toString==='function'&&item.toString()===\"[object AsyncResult]\";};/**\r\n * Utility Methods For AsyncResult\r\n */const isThenable=obj=>obj&&typeof obj==='object'&&typeof obj.then==='function';/**\r\n * AsyncResult Class\r\n * Promise-style class which allows for observation of the status of the promise\r\n * and it's result during and after is execution.\r\n */export class AsyncResult{/**\r\n     * Class constructor, which starts running the passed executor\r\n     * @param executor Passed function to be executed, resulting in resolution/rejection\r\n     */constructor(executor){this.status='LOADING';this.metadata={};// @ts-ignore\nthis._type='AsyncResult';this._handlers=[];this._attachHandler=handler=>{this._handlers.push(handler);this._executeHandlers();};this._executeHandlers=()=>{if(this.status==='LOADING'){return;}for(const handler of this._handlers){if(this.status==='FAILED'){handler.onFail(this.error);}else{handler.onSuccess(this.result);}}this._handlers=[];};this._resolve=value=>{return this._updateStatus(value,'SUCCESS');};this._reject=reason=>{return this._updateStatus(reason,'FAILED',true);};try{executor(this._resolve,this._reject);}catch(e){this._reject(e);}}static resolve(value){return new AsyncResult(resolve=>{return resolve(value);});}static reject(reason){return new AsyncResult((resolve,reject)=>{return reject(reason);});}/**\r\n     * Method that allows for an executor to be passed to the promise after inital execution,\r\n     * essentially \"rerunning\" the promise.\r\n     * @param executor Passed function to be executed, resulting in resolution/rejection\r\n     */run(executor){this.status='LOADING';this.error=undefined;try{executor(this._resolve,this._reject);}catch(e){this._reject(e);}}/**\r\n     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult\r\n     * @param onSuccess Callback to be run on successful completion of executor\r\n     * @param onFail Callback to be run when executor cannot be successfully completed\r\n     */then(_onSuccess,_onFail){const asyncResult=new AsyncResult((resolve,reject)=>{return this._attachHandler({onSuccess:result=>{if(!_onSuccess){// @ts-ignore: Type overlap issue\nreturn resolve(result);}try{return resolve(_onSuccess(result));}catch(e){return reject(e);}},onFail:reason=>{if(!_onFail){return reject(reason);}try{return resolve(_onFail(reason));}catch(e){return reject(e);}}});});// Always pass the metadata on a then\nasyncResult.metadata=this.metadata;return asyncResult;}/**\r\n     * Hook to allow callback on the unsuccessful run of an executor\r\n     * @param onFail Callback to run when executor fails\r\n     */catch(onFail){const defaultThen=value=>value;return this.then(defaultThen,onFail);}/**\r\n     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor\r\n     * @param callback Callback to be run after original AsyncResult is completed\r\n     */finally(onfinally){return new AsyncResult((resolve,reject)=>{let value;let failed=false;return this.then(result=>{value=result;return onfinally();},reason=>{failed=true;value=reason;return onfinally();}).then(()=>{if(failed){return reject(value);}return resolve(value);});});}toString(){return\"[object AsyncResult]\";}get[Symbol.toStringTag](){return'[object AsyncResult]';}_updateStatus(result,newStatus){let isError=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// Wrap in setTimeout to ensure fully synchronous handlers\n// are still returned AFTER initial class construction\nsetTimeout(()=>{if(this.status!=='LOADING'){return null;}if(isThenable(result)){return result.then(this._resolve,this._reject);}if(isError){this.error=result;}else{this.result=result;}this.status=newStatus;return this._executeHandlers();},0);}}__decorate([observable,__metadata(\"design:type\",Object)],AsyncResult.prototype,\"result\",void 0);__decorate([observable,__metadata(\"design:type\",String)],AsyncResult.prototype,\"status\",void 0);__decorate([observable,__metadata(\"design:type\",Error)],AsyncResult.prototype,\"error\",void 0);__decorate([observable,__metadata(\"design:type\",Object)],AsyncResult.prototype,\"metadata\",void 0);","map":{"version":3,"sources":["../src/async-result.ts"],"names":[],"mappings":"wJAAA;;;AAGG,G,yCAEH;AACA;AACA,OAAS,UAAT,KAA2B,MAA3B,CAKA,MAAO,MAAM,CAAA,aAAa,CAAI,IAAD,EAA+D,CACxF,MAAO,CAAA,IAAI,EAAI,IAAI,CAAC,QAAb,EAAyB,MAAO,CAAA,IAAI,CAAC,QAAZ,GAAyB,UAAlD,EAAgE,IAAI,CAAC,QAAL,2BAAvE,CACH,CAFM,CAIP;;AAEG,GACH,KAAM,CAAA,UAAU,CAAI,GAAD,EAAc,GAAG,EAAI,MAAO,CAAA,GAAP,GAAe,QAAtB,EAAkC,MAAO,CAAA,GAAG,CAAC,IAAX,GAAoB,UAAvF,CAgBA;;;;AAIG,GACH,MAAM,MAAO,CAAA,WAAW,CA0BpB;;;AAGG,OACH,WAAA,CAAY,QAAZ,CAAmE,CA3BhD,KAAA,MAAA,CAA4B,SAA5B,CAIA,KAAA,QAAA,CAA2B,EAA3B,CAEnB;AACQ,KAAA,KAAA,CAAgB,aAAhB,CAEA,KAAA,SAAA,CAAqC,EAArC,CAkIA,KAAA,cAAA,CAAkB,OAAD,EAA8B,CACnD,KAAK,SAAL,CAAe,IAAf,CAAoB,OAApB,EAEA,KAAK,gBAAL,GACH,CAJO,CAMA,KAAA,gBAAA,CAAmB,IAAK,CAC5B,GAAI,KAAK,MAAL,GAAgB,SAApB,CAA+B,CAC3B,OACH,CAED,IAAK,KAAM,CAAA,OAAX,GAAsB,MAAK,SAA3B,CAAsC,CAClC,GAAI,KAAK,MAAL,GAAgB,QAApB,CAA8B,CAC1B,OAAO,CAAC,MAAR,CAAe,KAAK,KAApB,EACH,CAFD,IAEO,CACH,OAAO,CAAC,SAAR,CAAkB,KAAK,MAAvB,EACH,CACJ,CAED,KAAK,SAAL,CAAiB,EAAjB,CACH,CAdO,CAgBA,KAAA,QAAA,CAAY,KAAD,EAA+B,CAC9C,MAAO,MAAK,aAAL,CAAmB,KAAnB,CAA0B,SAA1B,CAAP,CACH,CAFO,CAIA,KAAA,OAAA,CAAW,MAAD,EAAgB,CAC9B,MAAO,MAAK,aAAL,CAAmB,MAAnB,CAA2B,QAA3B,CAAqC,IAArC,CAAP,CACH,CAFO,CAzIJ,GAAI,CACA,QAAQ,CAAC,KAAK,QAAN,CAAgB,KAAK,OAArB,CAAR,CACH,CAAC,MAAO,CAAP,CAAU,CACR,KAAK,OAAL,CAAa,CAAb,EACH,CACJ,CAtBM,MAAO,CAAA,OAAP,CAAwB,KAAxB,CAAkD,CACrD,MAAO,IAAI,CAAA,WAAJ,CAAmB,OAAO,EAAG,CAChC,MAAO,CAAA,OAAO,CAAC,KAAD,CAAd,CACH,CAFM,CAAP,CAGH,CAEM,MAAO,CAAA,MAAP,CAAiB,MAAjB,CAA6B,CAChC,MAAO,IAAI,CAAA,WAAJ,CAAmB,CAAC,OAAD,CAAU,MAAV,GAAoB,CAC1C,MAAO,CAAA,MAAM,CAAC,MAAD,CAAb,CACH,CAFM,CAAP,CAGH,CAcD;;;;AAIG,OACI,GAAG,CAAC,QAAD,CAAwD,CAC9D,KAAK,MAAL,CAAc,SAAd,CACA,KAAK,KAAL,CAAa,SAAb,CACA,GAAI,CACA,QAAQ,CAAC,KAAK,QAAN,CAAgB,KAAK,OAArB,CAAR,CACH,CAAC,MAAO,CAAP,CAAU,CACR,KAAK,OAAL,CAAa,CAAb,EACH,CACJ,CAED;;;;AAIG,OACI,IAAI,CACP,UADO,CAEP,OAFO,CAEwE,CAE/E,KAAM,CAAA,WAAW,CAAG,GAAI,CAAA,WAAJ,CAAqC,CAAC,OAAD,CAAU,MAAV,GAAoB,CACzE,MAAO,MAAK,cAAL,CAAoB,CACvB,SAAS,CAAE,MAAM,EAAG,CAChB,GAAI,CAAC,UAAL,CAAgB,CACZ;AACA,MAAO,CAAA,OAAO,CAAC,MAAD,CAAd,CACH,CAED,GAAI,CACA,MAAO,CAAA,OAAO,CAAC,UAAS,CAAC,MAAD,CAAV,CAAd,CACH,CAAC,MAAO,CAAP,CAAU,CACR,MAAO,CAAA,MAAM,CAAC,CAAD,CAAb,CACH,CACJ,CAZsB,CAavB,MAAM,CAAE,MAAM,EAAG,CACb,GAAI,CAAC,OAAL,CAAa,CACT,MAAO,CAAA,MAAM,CAAC,MAAD,CAAb,CACH,CAED,GAAI,CACA,MAAO,CAAA,OAAO,CAAC,OAAM,CAAC,MAAD,CAAP,CAAd,CACH,CAAC,MAAO,CAAP,CAAU,CACR,MAAO,CAAA,MAAM,CAAC,CAAD,CAAb,CACH,CACJ,CAvBsB,CAApB,CAAP,CAyBH,CA1BmB,CAApB,CA4BA;AACA,WAAW,CAAC,QAAZ,CAAuB,KAAK,QAA5B,CAEA,MAAO,CAAA,WAAP,CACH,CAED;;;AAGG,OACI,KAAK,CAAkB,MAAlB,CAA+F,CACvG,KAAM,CAAA,WAAW,CAAI,KAAD,EAAgB,KAApC,CACA,MAAO,MAAK,IAAL,CAAU,WAAV,CAAuB,MAAvB,CAAP,CACH,CAED;;;AAGG,OACI,OAAO,CAAC,SAAD,CAA4C,CACtD,MAAO,IAAI,CAAA,WAAJ,CAAgB,CAAC,OAAD,CAAU,MAAV,GAAoB,CACvC,GAAI,CAAA,KAAJ,CACA,GAAI,CAAA,MAAM,CAAY,KAAtB,CAEA,MAAO,MAAK,IAAL,CACH,MAAM,EAAG,CACL,KAAK,CAAG,MAAR,CACA,MAAO,CAAA,SAAS,EAAhB,CACH,CAJE,CAKH,MAAM,EAAG,CACL,MAAM,CAAG,IAAT,CACA,KAAK,CAAG,MAAR,CACA,MAAO,CAAA,SAAS,EAAhB,CACH,CATE,EAUL,IAVK,CAUA,IAAK,CACR,GAAI,MAAJ,CAAY,CACR,MAAO,CAAA,MAAM,CAAC,KAAD,CAAb,CACH,CAED,MAAO,CAAA,OAAO,CAAC,KAAD,CAAd,CACH,CAhBM,CAAP,CAiBH,CArBM,CAAP,CAsBH,CAEM,QAAQ,EAAA,CACX,6BACH,CAED,IAAK,MAAM,CAAC,WAAZ,GAAwB,CACpB,MAAO,sBAAP,CACH,CAgCO,aAAa,CAAC,MAAD,CAAkB,SAAlB,CAAwE,IAAxB,CAAA,OAAwB,2DAAL,KAAK,CACzF;AACA;AACA,UAAU,CAAC,IAAK,CACZ,GAAI,KAAK,MAAL,GAAgB,SAApB,CAA+B,CAC3B,MAAO,KAAP,CACH,CAED,GAAI,UAAU,CAAC,MAAD,CAAd,CAAwB,CACpB,MAAQ,CAAA,MAAyB,CAAC,IAA1B,CAA+B,KAAK,QAApC,CAA8C,KAAK,OAAnD,CAAR,CACH,CAED,GAAI,OAAJ,CAAa,CACT,KAAK,KAAL,CAAa,MAAb,CACH,CAFD,IAEO,CACH,KAAK,MAAL,CAAc,MAAd,CACH,CAED,KAAK,MAAL,CAAc,SAAd,CAEA,MAAO,MAAK,gBAAL,EAAP,CACH,CAlBS,CAkBP,CAlBO,CAAV,CAmBH,CAlMmB,CACR,UAAA,CAAA,CAAX,UAAW,C,gCAAA,CAAA,C,qBAAA,C,QAAA,C,IAAkB,EAAlB,CAAA,CAEA,UAAA,CAAA,CAAX,UAAW,C,gCAAA,CAAA,C,qBAAA,C,QAAA,C,IAA6C,EAA7C,CAAA,CAEA,UAAA,CAAA,CAAX,UAAW,C,yBAAe,K,CAAf,CAAA,C,qBAAA,C,OAAA,C,IAAqB,EAArB,CAAA,CAEA,UAAA,CAAA,CAAX,UAAW,C,gCAAA,CAAA,C,qBAAA,C,UAAA,C,IAAqC,EAArC,CAAA","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// NOTE: no-any is disabled intentionally, as promises require valid use of the any type\n// tslint:disable:no-any\nimport { observable } from 'mobx';\nimport { IODataMetadata } from './interfaces/IODataMetadata';\n\nexport type AsyncResultStatus = 'LOADING' | 'SUCCESS' | 'FAILED';\n\nexport const isAsyncResult = (item: { toString(): string }): item is AsyncResult<unknown> => {\n    return item && item.toString && typeof item.toString === 'function' && item.toString() === `[object AsyncResult]`;\n};\n\n/**\n * Utility Methods For AsyncResult\n */\nconst isThenable = (obj: any) => obj && typeof obj === 'object' && typeof obj.then === 'function';\n\n/**\n * TYPES & INTERFACES\n */\ninterface IHandler<TIn, TOut> {\n    onSuccess: HandlerOnSuccess<TIn, TOut>;\n    onFail: HandlerOnFail<TOut>;\n}\n\ntype HandlerOnSuccess<TIn, TOut> = (value: TIn) => TOut | PromiseLike<TOut>;\ntype HandlerOnFail<TOut = never> = (reason: any) => TOut | PromiseLike<TOut>;\n\ntype Resolve<T> = (value?: T | PromiseLike<T>) => void;\ntype Reject = (value?: any) => void;\n\n/**\n * AsyncResult Class\n * Promise-style class which allows for observation of the status of the promise\n * and it's result during and after is execution.\n */\nexport class AsyncResult<T> implements Promise<T> {\n    @observable public result?: T;\n\n    @observable public status: AsyncResultStatus = 'LOADING';\n\n    @observable public error?: Error;\n\n    @observable public metadata: IODataMetadata = {};\n\n    // @ts-ignore\n    private _type: string = 'AsyncResult';\n\n    private _handlers: Array<IHandler<T, any>> = [];\n\n    public static resolve<U = any>(value?: U | PromiseLike<U>): AsyncResult<U> {\n        return new AsyncResult<U>(resolve => {\n            return resolve(value);\n        });\n    }\n\n    public static reject<U>(reason?: any): AsyncResult<U> {\n        return new AsyncResult<U>((resolve, reject) => {\n            return reject(reason);\n        });\n    }\n\n    /**\n     * Class constructor, which starts running the passed executor\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    constructor(executor: (resolve: Resolve<T>, reject: Reject) => void) {\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method that allows for an executor to be passed to the promise after inital execution,\n     * essentially \"rerunning\" the promise.\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    public run(executor: (resolve: Resolve<T>, reject: Reject) => void): void {\n        this.status = 'LOADING';\n        this.error = undefined;\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult\n     * @param onSuccess Callback to be run on successful completion of executor\n     * @param onFail Callback to be run when executor cannot be successfully completed\n     */\n    public then<TResult1 = T, TResult2 = never>(\n        onSuccess?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onFail?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n    ): AsyncResult<TResult1 | TResult2> {\n        const asyncResult = new AsyncResult<TResult1 | TResult2>((resolve, reject) => {\n            return this._attachHandler({\n                onSuccess: result => {\n                    if (!onSuccess) {\n                        // @ts-ignore: Type overlap issue\n                        return resolve(result);\n                    }\n\n                    try {\n                        return resolve(onSuccess(result));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                },\n                onFail: reason => {\n                    if (!onFail) {\n                        return reject(reason);\n                    }\n\n                    try {\n                        return resolve(onFail(reason));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                }\n            });\n        });\n\n        // Always pass the metadata on a then\n        asyncResult.metadata = this.metadata;\n\n        return asyncResult;\n    }\n\n    /**\n     * Hook to allow callback on the unsuccessful run of an executor\n     * @param onFail Callback to run when executor fails\n     */\n    public catch<TResult = never>(onFail?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): AsyncResult<T | TResult> {\n        const defaultThen = (value: any) => value;\n        return this.then(defaultThen, onFail);\n    }\n\n    /**\n     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor\n     * @param callback Callback to be run after original AsyncResult is completed\n     */\n    public finally(onfinally?: (() => void) | undefined | null): AsyncResult<T> {\n        return new AsyncResult((resolve, reject) => {\n            let value: T | any;\n            let failed: Boolean = false;\n\n            return this.then(\n                result => {\n                    value = result;\n                    return onfinally();\n                },\n                reason => {\n                    failed = true;\n                    value = reason;\n                    return onfinally();\n                }\n            ).then(() => {\n                if (failed) {\n                    return reject(value);\n                }\n\n                return resolve(value);\n            });\n        });\n    }\n\n    public toString(): string {\n        return `[object AsyncResult]`;\n    }\n\n    get [Symbol.toStringTag](): string {\n        return '[object AsyncResult]';\n    }\n\n    private _attachHandler = (handler: IHandler<T, any>) => {\n        this._handlers.push(handler);\n\n        this._executeHandlers();\n    }\n\n    private _executeHandlers = () => {\n        if (this.status === 'LOADING') {\n            return;\n        }\n\n        for (const handler of this._handlers) {\n            if (this.status === 'FAILED') {\n                handler.onFail(this.error);\n            } else {\n                handler.onSuccess(this.result as T);\n            }\n        }\n\n        this._handlers = [];\n    }\n\n    private _resolve = (value?: T | PromiseLike<T>) => {\n        return this._updateStatus(value, 'SUCCESS');\n    }\n\n    private _reject = (reason: any) => {\n        return this._updateStatus(reason, 'FAILED', true);\n    }\n\n    private _updateStatus(result: T | any, newStatus: AsyncResultStatus, isError: Boolean = false): void {\n        // Wrap in setTimeout to ensure fully synchronous handlers\n        // are still returned AFTER initial class construction\n        setTimeout(() => {\n            if (this.status !== 'LOADING') {\n                return null;\n            }\n\n            if (isThenable(result)) {\n                return (result as PromiseLike<T>).then(this._resolve, this._reject);\n            }\n\n            if (isError) {\n                this.error = result;\n            } else {\n                this.result = result;\n            }\n\n            this.status = newStatus;\n\n            return this._executeHandlers();\n        }, 0);\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
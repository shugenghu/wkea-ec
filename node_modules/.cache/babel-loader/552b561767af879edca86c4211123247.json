{"ast":null,"code":"import _typeof from\"@babel/runtime/helpers/esm/typeof\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _asyncToGenerator from\"@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */ // tslint:disable: no-any\nimport{ICacheSource,RequestCache}from'@msdyn365-commerce/cache-internal';import{msdyn365Commerce}from'@msdyn365-commerce/core-internal';import{AsyncResult,DataServiceRequest,isAsyncResult}from'@msdyn365-commerce/retail-proxy';import{GenericConsoleLogger,LogLevel,StaticTelemetry,Telemetry}from'@msdyn365-commerce/telemetry-internal';import uuidv1 from'uuid/v1';import ActionExecutor from'./action-executor';import{ActionRegistrar}from'./action-registrar';import{shouldWriteToAppCache}from'./action-runtime-utils';import{addLocaleInformation,readCacheEntries,saveCacheEntries}from'./cache/retail-cache-helper';import EventHelper from'./event-emitter';/**\r\n * This class contains the primary logic which controls the execution flow of the action runtime\r\n *\r\n */ /*@internal*/export var ActionContext=/*#__PURE__*/function(){/**\r\n     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7\r\n     * @param expectedActionCount: This value specifies the expected number of actions to be queued before\r\n     *                             we kick off execution in the current tier\r\n     */function ActionContext(args){var _this=this;_classCallCheck(this,ActionContext);this.executionParams=[];this.appCache=null;this.cacheKeyMap=[];/**\r\n         * Whether the current context as executed\r\n         */this.hasRun=false;/**\r\n         * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count\r\n         */this.currentActionsInQueue=0;/**\r\n         * Object to track the next tier number.\r\n         */this.nextTierCounter={next:0};/**\r\n         * When true will span a new independent action context when an action is executed resetting depth limits\r\n         * Otherwise will invoke the action in the current context.\r\n         */this.spawnChildOnExecute=false;/**\r\n         * Helper method to log trace using telemetry\r\n         * @param message message to log to console\r\n         */this.trace=function(message){_this.telemetry.log(LogLevel.Debug,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[_this.currentExecutionTier,_this.threadId,message]});};/**\r\n         * Helper method to log error using telemetry\r\n         * @param message message to log to console\r\n         */this.error=function(message){_this.telemetry.log(LogLevel.Error,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[_this.currentExecutionTier,_this.threadId,message]});};/**\r\n         * Helper method to log debug using telemetry\r\n         * @param message message to log to console\r\n         */this.debug=function(message){_this.telemetry.log(LogLevel.Debug,'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}',{values:[_this.currentExecutionTier,_this.threadId,message]});};/**\r\n         * Returns true if current tier has exceeded max depth\r\n         */this.isMaxDepthExceeded=function(){var maxDepth=_this.requestContext&&_this.requestContext.app&&_this.requestContext.app.maxDepth||ActionContext.maxDepth;return _this.nextTierCounter.next>maxDepth;};/**\r\n         * Retrieves item from request cache and fallsback to app cache if not found\r\n         */this.getItemFromCache=function(cacheKey){var cachedItem=_this.requestCache.get(cacheKey);if(cachedItem){return cachedItem.item;}if(process.env.CURRENT_ENVIRONMENT==='node'&&_this.appCache){cachedItem=_this.appCache.get(cacheKey);}return cachedItem?cachedItem.item:undefined;};/**\r\n         * Signals the end of current tier so actions can return the response\r\n         */this._endCurrentTier=function(){_this.hasRun=true;EventHelper.emit(\"\".concat(_this.eventId,\":completed\"),_this.currentExecutionTier);};var id=args.id,requestContext=args.requestContext,requestCache=args.requestCache,appCache=args.appCache,currentExecutionTier=args.currentExecutionTier,expectedActionCount=args.expectedActionCount,spawnChildOnExecute=args.spawnChildOnExecute,telemetry=args.telemetry;this.threadId=id;this.eventId=uuidv1();this.currentExecutionTier=currentExecutionTier||0;if(this.currentExecutionTier===0){this.nextTierCounter={next:0};}this.expectedActionsInCurrentTier=expectedActionCount||0;this.requestCache=requestCache;this.requestContext=requestContext||{};this.spawnChildOnExecute=Boolean(spawnChildOnExecute);// If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object\nif(telemetry){this.telemetry=telemetry;}else{// register default console logger\nvar moduleTelemetry=new Telemetry();var isDebug=requestContext.params&&requestContext.params.isDebug;// register tracelogger only in development environment or debug is true.\n(process.env.NODE_ENV==='development'||isDebug)&&moduleTelemetry.registerTraceLogger({traceLogger:GenericConsoleLogger,options:{isDebug:isDebug}});this.telemetry=moduleTelemetry;}/**\r\n         * @deprecated\r\n         * Trace is an alias for telemetry.log(LogLevel.Trace, message)\r\n         * Use the telemetry object directly.\r\n         */this.trace=function(message){_this.telemetry.log(LogLevel.Debug,message);};// enable app cache only if the disable_app_cache feature switch is false\nif(requestContext.features&&!!!requestContext.features.disable_app_cache){this.appCache=appCache;}}/**\r\n     * Chains an action method to the current context for execution\r\n     * @param action - action method\r\n     * @param inputs - action input\r\n     */ // tslint:disable-next-line:max-func-body-length\n_createClass(ActionContext,[{key:\"chainAction\",value:function chainAction(_action,inputs,actionOption){var _this2=this;var action=ActionRegistrar.unwrapAction(_action);addLocaleInformation(inputs,this.requestContext.locale);if(!action||!inputs){// Decrement the expected actions on this tier since this action was incorrectly configured\nthis.expectedActionsInCurrentTier--;if(this.currentActionsInQueue<this.expectedActionsInCurrentTier){return Promise.resolve(null);}if(!this.hasRun){return this.runAllActionsInQueue().then(function(){return null;});}return Promise.resolve(null);}if(this.isMaxDepthExceeded()){this.debug('Max depth exceeded - not running further.');return Promise.resolve(null);}if(this.hasRun){// If the parent action decides to queue another action after the current tier completes execution\n// then set the hasRun to false, so the action can fire right away\nthis.hasRun=false;this.executionParams.length=0;this.currentActionsInQueue=0;}this.currentActionsInQueue++;var isBatched=action.prototype.isBatched;var inputsArray=isBatched?inputs:[inputs];var current=this.executionParams.find(function(a){return a.action===action;});if(current&&isBatched){current.addInputs(inputsArray);}else{var inputIdentifier=\"\".concat(inputsArray[0].getCacheObjectType(),\"||\").concat(inputsArray[0].getCacheKey());if(!this.cacheKeyMap.find(function(key){return key===inputIdentifier;})){current=new ActionExecutor(action,inputsArray,this.telemetry,actionOption);this.executionParams.push(current);this.cacheKeyMap.push(inputIdentifier);}}// @ts-ignore\n// tslint:disable-next-line: max-func-body-length\nvar asyncResult=new AsyncResult(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve,reject){var outputs;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(_this2.currentActionsInQueue<_this2.expectedActionsInCurrentTier)){_context.next=4;break;}_context.next=3;return new Promise(function(innerResolve){var onEventIdCompletion=function onEventIdCompletion(tierNum){if(tierNum===_this2.currentExecutionTier){innerResolve();}};EventHelper.on(\"\".concat(_this2.eventId,\":completed\"),onEventIdCompletion);});case 3:EventHelper.removeAllListeners(\"\".concat(_this2.eventId,\":completed\"));case 4:if(_this2.hasRun){_context.next=7;break;}_context.next=7;return _this2.runAllActionsInQueue();case 7:outputs=inputsArray.map(function(i){if(i instanceof DataServiceRequest){try{// @ts-ignore\nvar entry=readCacheEntries(i,_this2.requestCache,_this2.appCache,false,StaticTelemetry);return entry.entry;}catch(e){_this2.debug(\"Error execution action type '[\".concat(i&&i.getCacheObjectType(),\"' and cache key '[{\").concat(i&&i.getCacheKey(),\"}]', returning null\"));return null;}}else{var cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};var cacheItem=_this2.requestCache.get(cacheKey);var cacheValue=!!cacheItem?_this2.requestCache.getValue(cacheKey):null;if(cacheItem&&!!cacheItem.error){throw cacheValue;}else{if(cacheItem&&!msdyn365Commerce.isBrowser){switch(cacheItem.s){case ICacheSource.AppCache:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey(),'AppCache']});break;}case ICacheSource.RequestCache:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey(),'RequestCache']});break;}default:{StaticTelemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{// @ts-ignore\nvalues:[i.getCacheObjectType()||'none',i.getCacheKey,'Undefined']});}}}return cacheValue;}}});_this2.cacheKeyMap.splice(0,_this2.cacheKeyMap.length);// Batched observable actions need to be merged into a single AsyncResult\nif(isBatched&&action.prototype.isObservable){resolve(Promise.all(outputs).then(function(results){// Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped\nreturn results.map(function(result){return result&&result._type==='AsyncResult'?result.result:result;});}));}else{// We need to pass along the metadata explicitly to the outer AsyncResult\nif(isAsyncResult(outputs[0])&&!isBatched){outputs[0].then(function(){asyncResult.metadata=outputs[0].metadata;});}resolve(isBatched?outputs:outputs.length&&outputs[0]||null);}case 10:case\"end\":return _context.stop();}}},_callee);}));return function(_x,_x2){return _ref.apply(this,arguments);};}());return asyncResult;}/**\r\n     * Helper method to update cache\r\n     * @param input The input\r\n     * @param data The data\r\n     */},{key:\"update\",value:function update(inputs,data){var _this3=this;if(inputs&&data){// If an array of actionInputs has been passed, an equal amount of data items must be present\nvar dataArray=Array.isArray(inputs)?data:[data];var inputArray=Array.isArray(inputs)?inputs:[inputs];if(inputArray.length!==dataArray.length){throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');}addLocaleInformation(inputArray,this.requestContext.locale);inputArray.map(function(i,idx){if(i instanceof DataServiceRequest){try{// @ts-ignore\nsaveCacheEntries(i,dataArray[idx],_this3.requestCache,_this3.appCache,shouldWriteToAppCache(i,_this3.appCache));}catch(e){_this3.debug(\"Error in updating cache with input '[\".concat(i.getCacheObjectType(),\"]' - '[\").concat(i.getCacheKey(),\"]', returning null\"));_this3.error(e);}}else{// When updating OPs, only result can be updated, passed OPs will also be unwrapped.\nif(isAsyncResult(dataArray[idx])){dataArray[idx]=dataArray[idx].result;}var cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};_this3.requestCache.put(cacheKey,{item:dataArray[idx]});if(_this3.appCache&&shouldWriteToAppCache(i,_this3.appCache)){_this3.appCache.put(cacheKey,{item:dataArray[idx]});}}});if(Array.isArray(inputs)){return inputs.map(function(input){return _this3.requestCache.getValue({typeName:input.getCacheObjectType(),key:input.getCacheKey()});});}else{return this.requestCache.getValue({typeName:inputs.getCacheObjectType(),key:inputs.getCacheKey()});}}// For scenarios where data/input was bad, we just return original data\nreturn data;}/**\r\n     * Helper method to data cache from cache\r\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\r\n     * @param cacheObjectType entity type that was cached\r\n     * @param cacheKey cache key against which the object is cached\r\n     * @throws if cacheObjecttype is null or empty\r\n     */},{key:\"get\",value:function get(cacheObjectType,cacheKey){var _this4=this;if(!cacheObjectType){throw new Error('Cannot have null or empty cacheObjectType');}if(!cacheKey){throw new Error('Cannot have null or empty cacheKey');}var preparedCacheKey={typeName:cacheObjectType,key:cacheKey};var cachedItem=this.requestCache.get(preparedCacheKey);if(process.env.CURRENT_ENVIRONMENT==='node'&&!cachedItem&&this.appCache){cachedItem=this.appCache.get(preparedCacheKey);}if(!cachedItem){return null;}if(_typeof(cachedItem.item)!=='object'||cachedItem.item.$ref!==true){return cachedItem.item;}return Array.isArray(cachedItem.item.key)?cachedItem.item.key.map(function(key){return _this4.getItemFromCache({typeName:cacheObjectType,key:key});}).filter(Boolean):null;}/**\r\n     * Helper method to data cache from cache\r\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\r\n     * @param input The input\r\n     * @param data The data\r\n     * @throws if cacheObjecttype is null or empty\r\n     */},{key:\"getAll\",value:function getAll(cacheObjectType){if(!cacheObjectType){throw new Error('Cannot have null or empty cacheObjectType');}var cachedEntries=this.requestCache.getAllItems(cacheObjectType);if(!cachedEntries){if(process.env.CURRENT_ENVIRONMENT==='node'&&this.appCache){cachedEntries=this.appCache&&this.appCache.getAllItems(cacheObjectType);}if(!cachedEntries){return null;}}return Object.keys(cachedEntries).filter(function(key){return _typeof(cachedEntries[key].item)!=='object'||cachedEntries[key].item.$ref!==true;}).map(function(key){return cachedEntries[key].item;});}/**\r\n     * Executes all the actions in the current context in parallel\r\n     */ // tslint:disable max-func-body-length\n},{key:\"runAllActionsInQueue\",value:function(){var _runAllActionsInQueue=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var _this5=this;var threadId,requestContext,requestCache,appCache,nextTierCounter,executionParams,expectedNumberOfChildThreads,nextTierStartingDepth,nextTier,refreshContext,refreshconfigslocal,promises;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:threadId=this.threadId,requestContext=this.requestContext,requestCache=this.requestCache,appCache=this.appCache,nextTierCounter=this.nextTierCounter,executionParams=this.executionParams;if(executionParams.length){_context2.next=4;break;}this.trace('No actions to execute - not running further.');return _context2.abrupt(\"return\");case 4:if(!this.isMaxDepthExceeded()){_context2.next=7;break;}this.trace('Max depth exceeded - not running further.');return _context2.abrupt(\"return\");case 7:// When kicking off the next tier,\n// set the max number of chain actions the can be expected from child actions\n// equal to the number of actions that are executing in current tier\nexpectedNumberOfChildThreads=executionParams.length;if(this.spawnChildOnExecute){nextTierStartingDepth=nextTierCounter.next+1;}else{nextTierStartingDepth=++nextTierCounter.next;}nextTier=new ActionContext({id:threadId,requestContext:requestContext,requestCache:requestCache,appCache:appCache,currentExecutionTier:nextTierStartingDepth,expectedActionCount:expectedNumberOfChildThreads,telemetry:this.telemetry});refreshContext=new ActionContext({id:'Refresh Context',requestContext:requestContext,requestCache:new RequestCache(),telemetry:this.telemetry,appCache:appCache,spawnChildOnExecute:true});refreshconfigslocal=new Set();nextTier.nextTierCounter={next:nextTierStartingDepth};// DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions\npromises=executionParams.map(function(param){// TODO: should we read from input about the cacheability?\nreturn param.execute(nextTier,requestCache,appCache,_this5.requestContext.query&&!!_this5.requestContext.query.cachebypass,[]).then(function(refreshActions){// refresh the data actions which need to be refreshed.\nif(refreshActions.length){refreshconfigslocal.add({paramExecutor:param,actionInputs:refreshActions,refreshContext:refreshContext});}// If the current chain action completes execution\n// decrement the max number of threads that we expect\n// from the next tier\nnextTier.expectedActionsInCurrentTier--;if(!nextTier.hasRun){// First check if the next tier has any actions\n// then check if the number of thread match expected\nif(nextTier.currentActionsInQueue>0&&nextTier.currentActionsInQueue===nextTier.expectedActionsInCurrentTier){return nextTier.runAllActionsInQueue();}}});});// Wait until all the actions in current tier are run to completion\nreturn _context2.abrupt(\"return\",Promise.all(promises).then(function(){if(refreshconfigslocal.size>0&&requestContext.features&&!!!requestContext.features.disable_appcache_refresh){refreshconfigslocal.forEach(function(rf){var refreshRequestCache=new RequestCache();rf.paramExecutor.execute(rf.refreshContext,refreshRequestCache,_this5.appCache,_this5.requestContext.query&&!!_this5.requestContext.query.cachebypass,rf.actionInputs).then(function(){return StaticTelemetry.log(LogLevel.Information,\"BackgroundRefresh - Executed refresh with action input \".concat(rf.actionInputs[0].getCacheObjectType(),\"-\").concat(rf.actionInputs[0].getCacheKey()));})[\"catch\"](function(error){StaticTelemetry.log(LogLevel.Warning,\"BackgroundRefresh - Error execution refresh with action input \".concat(rf.actionInputs[0].getCacheObjectType(),\"-\").concat(rf.actionInputs[0].getCacheKey()));});});}_this5._endCurrentTier();})[\"catch\"](function(error){_this5._endCurrentTier();throw error;}));case 15:case\"end\":return _context2.stop();}}},_callee2,this);}));function runAllActionsInQueue(){return _runAllActionsInQueue.apply(this,arguments);}return runAllActionsInQueue;}()}]);return ActionContext;}();ActionContext.maxDepth=200;","map":{"version":3,"sources":["../../src/action-context.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable: no-any\nimport { ICache, ICacheItem, ICacheKey, ICacheSource, RequestCache } from '@msdyn365-commerce/cache-internal';\nimport { IAction, IActionContext, IActionInput, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { GenericConsoleLogger, ITelemetry, LogLevel, StaticTelemetry, Telemetry } from '@msdyn365-commerce/telemetry-internal';\nimport uuidv1 from 'uuid/v1';\nimport ActionExecutor from './action-executor';\nimport { ActionRegistrar } from './action-registrar';\nimport { shouldWriteToAppCache } from './action-runtime-utils';\nimport { addLocaleInformation, readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\n/**\n * This interface is used in ActionContext only, for saving information needed to refresh data actions.\n *\n */\ninterface IRefreshConfigs {\n    refreshContext: IActionContext;\n    actionInputs: IActionInput[];\n    paramExecutor: ActionExecutor;\n}\n/**\n * This class contains the primary logic which controls the execution flow of the action runtime\n *\n */\n/*@internal*/\nexport class ActionContext implements IActionContext {\n    public static maxDepth: number = 200;\n\n    public readonly executionParams: ActionExecutor[] = [];\n    public readonly requestContext: any;\n\n    /**\n     * Telemetry object to log information\n     */\n    public telemetry: ITelemetry;\n\n    private readonly requestCache: ICache;\n    private readonly appCache: ICache | null = null;\n    private readonly cacheKeyMap: string[] = [];\n\n    /**\n     * Action context creates a new instance for every tier of execution,\n     * This number specifies the depth/current tier in the execution flow\n     */\n    private readonly currentExecutionTier: number;\n\n    /**\n     * Thread ID\n     */\n    private readonly threadId: string;\n\n    /**\n     * Event ID\n     * Unique ID for each action context, automatically generated\n     */\n    private readonly eventId: string;\n\n    /**\n     * Whether the current context as executed\n     */\n    private hasRun: boolean = false;\n\n    /**\n     * When this number is > 0, the current context will wait for all the actions to\n     * be queued before kicking off execution.\n     * This number is decremented for every action that is successful in current tier.\n     */\n    private expectedActionsInCurrentTier: number;\n\n    /**\n     * variable tracking the current number of actions that are in queue, context will wait for this to match the expected count\n     */\n    private currentActionsInQueue: number = 0;\n\n    /**\n     * Object to track the next tier number.\n     */\n    private nextTierCounter: { next: number } = { next: 0 };\n\n    /**\n     * When true will span a new independent action context when an action is executed resetting depth limits\n     * Otherwise will invoke the action in the current context.\n     */\n    private spawnChildOnExecute: boolean = false;\n\n    /**\n     * @param currentExecutionTier: Current execution tier in the data fetch pipeline, max is currently 7\n     * @param expectedActionCount: This value specifies the expected number of actions to be queued before\n     *                             we kick off execution in the current tier\n     */\n    constructor(args: {\n        id: string;\n        requestContext: any;\n        requestCache: ICache;\n        appCache: ICache | null;\n        currentExecutionTier?: number;\n        expectedActionCount?: number;\n        spawnChildOnExecute?: boolean;\n        telemetry?: ITelemetry;\n    }) {\n        const {\n            id,\n            requestContext,\n            requestCache,\n            appCache,\n            currentExecutionTier,\n            expectedActionCount,\n            spawnChildOnExecute,\n            telemetry\n        } = args;\n        this.threadId = id;\n        this.eventId = uuidv1();\n\n        this.currentExecutionTier = currentExecutionTier || 0;\n        if (this.currentExecutionTier === 0) {\n            this.nextTierCounter = { next: 0 };\n        }\n\n        this.expectedActionsInCurrentTier = expectedActionCount || 0;\n        this.requestCache = requestCache;\n        this.requestContext = requestContext || {};\n        this.spawnChildOnExecute = Boolean(spawnChildOnExecute);\n\n        // If a telemetry object has been passed in use that telemetry object, otherwise create a new Telemetry object\n        if (telemetry) {\n            this.telemetry = telemetry;\n        } else {\n            // register default console logger\n            const moduleTelemetry = new Telemetry();\n            const isDebug = requestContext.params && requestContext.params.isDebug;\n\n            // register tracelogger only in development environment or debug is true.\n            (process.env.NODE_ENV === 'development' || isDebug) &&\n                moduleTelemetry.registerTraceLogger({ traceLogger: GenericConsoleLogger, options: { isDebug: isDebug } });\n\n            this.telemetry = moduleTelemetry;\n        }\n\n        /**\n         * @deprecated\n         * Trace is an alias for telemetry.log(LogLevel.Trace, message)\n         * Use the telemetry object directly.\n         */\n        this.trace = (message: string) => {\n            this.telemetry.log(LogLevel.Debug, message);\n        };\n\n        // enable app cache only if the disable_app_cache feature switch is false\n        if (requestContext.features && !!!requestContext.features.disable_app_cache) {\n            this.appCache = appCache;\n        }\n    }\n\n    /**\n     * Chains an action method to the current context for execution\n     * @param action - action method\n     * @param inputs - action input\n     */\n    // tslint:disable-next-line:max-func-body-length\n    public chainAction<T>(_action: IAction<T>, inputs: IActionInput | IActionInput[], actionOption?:IDataActionOptions): Promise<T | (T | null)[] | null> {\n        const action = ActionRegistrar.unwrapAction(_action);\n        addLocaleInformation(inputs, this.requestContext.locale);\n        if (!action || !inputs) {\n            // Decrement the expected actions on this tier since this action was incorrectly configured\n            this.expectedActionsInCurrentTier--;\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                return Promise.resolve(null);\n            }\n\n            if (!this.hasRun) {\n                return this.runAllActionsInQueue().then(() => null);\n            }\n\n            return Promise.resolve(null);\n        }\n\n        if (this.isMaxDepthExceeded()) {\n            this.debug('Max depth exceeded - not running further.');\n            return Promise.resolve(null);\n        }\n\n        if (this.hasRun) {\n            // If the parent action decides to queue another action after the current tier completes execution\n            // then set the hasRun to false, so the action can fire right away\n            this.hasRun = false;\n            this.executionParams.length = 0;\n            this.currentActionsInQueue = 0;\n        }\n\n        this.currentActionsInQueue++;\n        const isBatched = action.prototype.isBatched;\n        const inputsArray = <IActionInput[]>(isBatched ? inputs : [inputs]);\n\n        let current = this.executionParams.find(a => a.action === action);\n        if (current && isBatched) {\n            current.addInputs(inputsArray);\n        } else {\n            const inputIdentifier = `${inputsArray[0].getCacheObjectType()}||${inputsArray[0].getCacheKey()}`;\n            if (!this.cacheKeyMap.find(key => key === inputIdentifier)) {\n                current = new ActionExecutor(action, inputsArray, this.telemetry, actionOption);\n                this.executionParams.push(current);\n                this.cacheKeyMap.push(inputIdentifier);\n            }\n        }\n\n        // @ts-ignore\n        // tslint:disable-next-line: max-func-body-length\n        const asyncResult = new AsyncResult<T | T[]>(async (resolve, reject) => {\n            if (this.currentActionsInQueue < this.expectedActionsInCurrentTier) {\n                // Hold the thread until the entire tier is populated\n                await new Promise((innerResolve: Function) => {\n                    const onEventIdCompletion = (tierNum: number) => {\n                        if (tierNum === this.currentExecutionTier) {\n                            innerResolve();\n                        }\n                    };\n                    EventHelper.on<[number]>(`${this.eventId}:completed`, onEventIdCompletion);\n                });\n                EventHelper.removeAllListeners(`${this.eventId}:completed`);\n            }\n\n            if (!this.hasRun) {\n                await this.runAllActionsInQueue();\n            }\n\n            const outputs = inputsArray.map(i => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        const entry = readCacheEntries(i, this.requestCache, this.appCache, false, StaticTelemetry);\n                        return entry.entry;\n                    } catch (e) {\n                        this.debug(\n                            `Error execution action type '[${i && i.getCacheObjectType()}' and cache key '[{${i &&\n                                i.getCacheKey()}}]', returning null`\n                        );\n                        return null;\n                    }\n                } else {\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    const cacheItem = this.requestCache.get<ICacheItem<T>>(cacheKey);\n                    const cacheValue = !!cacheItem ? this.requestCache.getValue<T>(cacheKey) : null;\n\n                    if (cacheItem && !!cacheItem.error) {\n                        throw cacheValue;\n                    } else {\n                        if (cacheItem && !msdyn365Commerce.isBrowser) {\n                            switch (cacheItem.s!) {\n                                case ICacheSource.AppCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'AppCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                case ICacheSource.RequestCache: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey(), 'RequestCache']\n                                        }\n                                    );\n                                    break;\n                                }\n                                default: {\n                                    StaticTelemetry.log(\n                                        LogLevel.Information,\n                                        'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',\n                                        {\n                                            // @ts-ignore\n                                            values: [i.getCacheObjectType() || 'none', i.getCacheKey, 'Undefined']\n                                        }\n                                    );\n                                }\n                            }\n                        }\n                        return cacheValue;\n                    }\n                }\n            });\n\n            this.cacheKeyMap.splice(0, this.cacheKeyMap.length);\n\n            // Batched observable actions need to be merged into a single AsyncResult\n            if (isBatched && action.prototype.isObservable) {\n                resolve(\n                    Promise.all(outputs).then(results => {\n                        // Because AsyncResult sometimes get mangled by MobX, we need to ensure mangled ones are still unwrapped\n                        return results.map(result => {\n                            return result && result._type === 'AsyncResult' ? result.result : result;\n                        });\n                    })\n                );\n            } else {\n                // We need to pass along the metadata explicitly to the outer AsyncResult\n                if (isAsyncResult(outputs[0]) && !isBatched) {\n                    outputs[0].then(() => {\n                        asyncResult.metadata = outputs[0].metadata;\n                    });\n                }\n\n                resolve(isBatched ? outputs : (outputs.length && outputs[0]) || null);\n            }\n        });\n\n        return asyncResult;\n    }\n\n    /**\n     * Helper method to update cache\n     * @param input The input\n     * @param data The data\n     */\n    public update<T>(inputs: IActionInput | IActionInput[], data: T): T {\n        if (inputs && data) {\n            // If an array of actionInputs has been passed, an equal amount of data items must be present\n            const dataArray = <unknown[]>(Array.isArray(inputs) ? data : [data]);\n            const inputArray = Array.isArray(inputs) ? inputs : [inputs];\n            if (inputArray.length !== dataArray.length) {\n                throw new Error('Array of action inputs was passed to actionContext Update, and did not match length of input data array.');\n            }\n            addLocaleInformation(inputArray, this.requestContext.locale);\n            inputArray.map((i, idx) => {\n                if (i instanceof DataServiceRequest) {\n                    try {\n                        // @ts-ignore\n                        saveCacheEntries(i, dataArray[idx], this.requestCache, this.appCache, shouldWriteToAppCache(i, this.appCache));\n                    } catch (e) {\n                        this.debug(\n                            `Error in updating cache with input '[${i.getCacheObjectType()}]' - '[${i.getCacheKey()}]', returning null`\n                        );\n                        this.error(e);\n                    }\n                } else {\n                    // When updating OPs, only result can be updated, passed OPs will also be unwrapped.\n                    if (isAsyncResult(<object>dataArray[idx])) {\n                        dataArray[idx] = (<AsyncResult<unknown>>dataArray[idx]).result;\n                    }\n\n                    const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n                    this.requestCache.put(cacheKey, { item: dataArray[idx] });\n                    if (this.appCache && shouldWriteToAppCache(i, this.appCache)) {\n                        this.appCache.put(cacheKey, { item: dataArray[idx] });\n                    }\n                }\n            });\n\n            if (Array.isArray(inputs)) {\n                return <T>(<unknown>inputs.map(input => {\n                    return this.requestCache.getValue({ typeName: input.getCacheObjectType(), key: input.getCacheKey() });\n                }));\n            } else {\n                return <T>this.requestCache.getValue({ typeName: inputs.getCacheObjectType(), key: inputs.getCacheKey() });\n            }\n        }\n\n        // For scenarios where data/input was bad, we just return original data\n        return data;\n    }\n\n    /**\n     * Helper method to log trace using telemetry\n     * @param message message to log to console\n     */\n    public trace = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log error using telemetry\n     * @param message message to log to console\n     */\n    public error = (message: string): void => {\n        this.telemetry.log(LogLevel.Error, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to log debug using telemetry\n     * @param message message to log to console\n     */\n    public debug = (message: string): void => {\n        this.telemetry.log(LogLevel.Debug, 'Depth: {currentExecutionTier}\\tID: {threadId}\\tMessage: {message}', {\n            values: [this.currentExecutionTier, this.threadId, message]\n        });\n    };\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param cacheObjectType entity type that was cached\n     * @param cacheKey cache key against which the object is cached\n     * @throws if cacheObjecttype is null or empty\n     */\n    public get<T>(cacheObjectType: string, cacheKey: string): T | T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        if (!cacheKey) {\n            throw new Error('Cannot have null or empty cacheKey');\n        }\n\n        const preparedCacheKey = { typeName: cacheObjectType, key: cacheKey };\n        let cachedItem = this.requestCache.get<any>(preparedCacheKey);\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && !cachedItem && this.appCache) {\n            cachedItem = this.appCache.get<any>(preparedCacheKey);\n        }\n\n        if (!cachedItem) {\n            return null;\n        }\n\n        if (typeof cachedItem.item !== 'object' || cachedItem.item.$ref !== true) {\n            return cachedItem.item;\n        }\n\n        return Array.isArray(cachedItem.item.key) ? <T[]>(<string[]>cachedItem.item.key)\n                  .map(key => this.getItemFromCache<T>({ typeName: cacheObjectType, key }))\n                  .filter(Boolean) : null;\n    }\n\n    /**\n     * Helper method to data cache from cache\n     * if cachekey is null or empty, it returns all entries of cacheObjectType\n     * @param input The input\n     * @param data The data\n     * @throws if cacheObjecttype is null or empty\n     */\n    public getAll<T>(cacheObjectType: string): T[] | null {\n        if (!cacheObjectType) {\n            throw new Error('Cannot have null or empty cacheObjectType');\n        }\n\n        let cachedEntries = this.requestCache.getAllItems<any>(cacheObjectType);\n        if (!cachedEntries) {\n            if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n                cachedEntries = this.appCache && this.appCache.getAllItems<any>(cacheObjectType);\n            }\n\n            if (!cachedEntries) {\n                return null;\n            }\n        }\n\n        return <T[]>Object.keys(cachedEntries)\n            .filter(key => typeof cachedEntries![key].item !== 'object' || cachedEntries![key].item.$ref !== true)\n            .map(key => cachedEntries![key].item);\n    }\n\n    /**\n     * Executes all the actions in the current context in parallel\n     */\n    // tslint:disable max-func-body-length\n    public async runAllActionsInQueue(): Promise<void> {\n        const { threadId, requestContext, requestCache, appCache, nextTierCounter, executionParams } = this;\n        if (!executionParams.length) {\n            this.trace('No actions to execute - not running further.');\n            return;\n        }\n        // Increment the tier each pass through run all actions\n        if (this.isMaxDepthExceeded()) {\n            this.trace('Max depth exceeded - not running further.');\n            return;\n        }\n\n        // When kicking off the next tier,\n        // set the max number of chain actions the can be expected from child actions\n        // equal to the number of actions that are executing in current tier\n        const expectedNumberOfChildThreads = executionParams.length;\n\n        let nextTierStartingDepth;\n        if (this.spawnChildOnExecute) {\n            nextTierStartingDepth = nextTierCounter.next + 1;\n        } else {\n            nextTierStartingDepth = ++nextTierCounter.next;\n        }\n\n        const nextTier = new ActionContext({\n            id: threadId,\n            requestContext: requestContext,\n            requestCache: requestCache,\n            appCache: appCache,\n            currentExecutionTier: nextTierStartingDepth,\n            expectedActionCount: expectedNumberOfChildThreads,\n            telemetry: this.telemetry\n        });\n\n        const refreshContext = new ActionContext({\n            id: 'Refresh Context',\n            requestContext: requestContext,\n            requestCache: new RequestCache(),\n            telemetry: this.telemetry,\n            appCache: appCache,\n            spawnChildOnExecute: true\n        });\n        const refreshconfigslocal: Set<IRefreshConfigs> = new Set();\n\n        nextTier.nextTierCounter = { next: nextTierStartingDepth };\n        // DO NOT Trace using current action context, use only secondaryContext to remain consistent with actions\n        const promises: Promise<any>[] = executionParams.map(param => {\n            // TODO: should we read from input about the cacheability?\n            return param\n                .execute(nextTier, requestCache, appCache, this.requestContext.query && !!this.requestContext.query.cachebypass, [])\n                .then(refreshActions => {\n                    // refresh the data actions which need to be refreshed.\n                    if (refreshActions.length) {\n                        refreshconfigslocal.add({\n                            paramExecutor: param,\n                            actionInputs: refreshActions,\n                            refreshContext: refreshContext\n                        });\n                    }\n\n                    // If the current chain action completes execution\n                    // decrement the max number of threads that we expect\n                    // from the next tier\n                    nextTier.expectedActionsInCurrentTier--;\n\n                    if (!nextTier.hasRun) {\n                        // First check if the next tier has any actions\n                        // then check if the number of thread match expected\n                        if (\n                            nextTier.currentActionsInQueue > 0 &&\n                            nextTier.currentActionsInQueue === nextTier.expectedActionsInCurrentTier\n                        ) {\n                            return nextTier.runAllActionsInQueue();\n                        }\n                    }\n                });\n        });\n\n        // Wait until all the actions in current tier are run to completion\n        return Promise.all(promises)\n            .then(() => {\n                if (refreshconfigslocal.size > 0 && requestContext.features && !!!requestContext.features.disable_appcache_refresh) {\n                    refreshconfigslocal.forEach(rf => {\n                        const refreshRequestCache = new RequestCache();\n                        rf.paramExecutor\n                            .execute(\n                                rf.refreshContext,\n                                refreshRequestCache,\n                                this.appCache,\n                                this.requestContext.query && !!this.requestContext.query.cachebypass,\n                                rf.actionInputs\n                            )\n                            .then(() =>\n                                StaticTelemetry.log(\n                                    LogLevel.Information,\n                                    `BackgroundRefresh - Executed refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                )\n                            )\n                            .catch(error => {\n                                StaticTelemetry.log(\n                                    LogLevel.Warning,\n                                    `BackgroundRefresh - Error execution refresh with action input ${rf.actionInputs[0].getCacheObjectType()}-${rf.actionInputs[0].getCacheKey()}`\n                                );\n                            });\n                    });\n                }\n                this._endCurrentTier();\n            })\n            .catch(error => {\n                this._endCurrentTier();\n                throw error;\n            });\n    }\n\n    /**\n     * Returns true if current tier has exceeded max depth\n     */\n    private isMaxDepthExceeded = (): boolean => {\n        const maxDepth = (this.requestContext && this.requestContext.app && this.requestContext.app.maxDepth) || ActionContext.maxDepth;\n        return this.nextTierCounter.next > maxDepth;\n    };\n\n    /**\n     * Retrieves item from request cache and fallsback to app cache if not found\n     */\n    private getItemFromCache = <T>(cacheKey: ICacheKey): T | undefined => {\n        let cachedItem = this.requestCache.get<T>(cacheKey);\n\n        if (cachedItem) {\n            return cachedItem.item;\n        }\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node' && this.appCache) {\n            cachedItem = this.appCache.get<T>(cacheKey);\n        }\n\n        return cachedItem ? cachedItem.item : undefined;\n    };\n\n    /**\n     * Signals the end of current tier so actions can return the response\n     */\n    private _endCurrentTier = (): void => {\n        this.hasRun = true;\n        EventHelper.emit(`${this.eventId}:completed`, this.currentExecutionTier);\n    };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import\"core-js/modules/es.regexp.to-string.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */const EDM='Edm.';const EDM_BOOLEAN=EDM+'Boolean';const EDM_BYTE=EDM+'Byte';const EDM_DATETIME=EDM+'DateTime';const EDM_DATETIMEOFFSET=EDM+'DateTimeOffset';const EDM_DECIMAL=EDM+'Decimal';const EDM_DOUBLE=EDM+'Double';const EDM_INT16=EDM+'Int16';const EDM_INT32=EDM+'Int32';const EDM_INT64=EDM+'Int64';const EDM_SBYTE=EDM+'SByte';const EDM_SINGLE=EDM+'Single';const EDM_TIME=EDM+'Time';const parseBool=propertyValue=>{/// <summary>Parses a string into a boolean value.</summary>\n/// <param name=\"propertyValue\">Value to parse.</param>\n/// <returns type=\"Boolean\">true if the property value is 'true'; false otherwise.</returns>\nif(typeof propertyValue==='boolean'){return propertyValue;}return typeof propertyValue==='string'&&propertyValue.toLowerCase()==='true';};const formatNumberWidth=(value,width,append)=>{/// <summary>Formats the specified value to the given width.</summary>\n/// <param name=\"value\" type=\"Number\">Number to format (non-negative).</param>\n/// <param name=\"width\" type=\"Number\">Minimum width for number.</param>\n/// <param name=\"append\" type=\"Boolean\">Flag indicating if the value is padded at the beginning (false) or at the end (true).</param>\n/// <returns type=\"String\">Text representation.</returns>\nlet result=value.toString(10);while(result.length<width){if(append){result+='0';}else{result='0'+result;}}return result;};const parseTimezone=timezone=>{/// <summary>Parses a timezone description in (+|-)nn:nn format.</summary>\n/// <param name=\"timezone\" type=\"String\">Timezone offset.</param>\n/// <returns type=\"Object\">\n/// An object with a (d)irection property of 1 for + and -1 for -,\n/// offset (h)ours and offset (m)inutes.\n/// </returns>\nlet direction=timezone.substring(0,1);direction=direction==='+'?1:-1;const offsetHours=parseInt(timezone.substring(1),10);const offsetMinutes=parseInt(timezone.substring(timezone.indexOf(':')+1),10);return{d:direction,h:offsetHours,m:offsetMinutes};};// The captured indices for this expression are:\n// 0       - complete input\n// 1       - direction\n// 2,3,4   - years, months, days\n// 5,6,7,8 - hours, minutes, seconds, miliseconds\nconst parseTimeRE=/^([+-])?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d+))?S)?)?/;// The captured indices for this expression are:\n// 0     - complete input\n// 1,2,3 - year with optional minus sign, month, day\n// 4,5,6 - hours, minutes, seconds\n// 7     - optional milliseconds\n// 8     - everything else (presumably offset information)\nconst parseDateTimeRE=/^(-?\\d{4,})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(.*)$/;const getCanonicalTimezone=timezone=>{/// <summary>Gets the canonical timezone representation.</summary>\n/// <param name=\"timezone\" type=\"String\">Timezone representation.</param>\n/// <returns type=\"String\">An 'Z' string if the timezone is absent or 0; the timezone otherwise.</returns>\nreturn!timezone||timezone==='Z'||timezone==='+00:00'||timezone==='-00:00'?'Z':timezone;};const parseDuration=duration=>{/// <summary>Parses a string in xsd:duration format.</summary>\n/// <param name=\"duration\" type=\"String\">Duration value.</param>\n/// <remarks>\n/// This method will throw an exception if the input string has a year or a month component.\n/// </remarks>\n/// <returns type=\"Object\">Object representing the time</returns>\nconst parts=parseTimeRE.exec(duration);if(parts===null){throw{message:'Invalid duration value.'};}const years=parts[2]||'0';const months=parts[3]||'0';const days=parseInt(parts[4],10)||0;const hours=parseInt(parts[5],10)||0;const minutes=parseInt(parts[6],10)||0;const seconds=parseFloat(parts[7])||0;if(years!=='0'||months!=='0'){throw{message:'Unsupported duration value.'};}let ms=parts[8];let ns=0;if(!ms){ms=0;}else{if(ms.length>7){throw{message:'Cannot parse duration value to given precision.'};}ns=formatNumberWidth(ms.substring(3),4,true);ms=formatNumberWidth(ms.substring(0,3),3,true);ms=parseInt(ms,10);ns=parseInt(ns,10);}ms+=seconds*1000+minutes*60000+hours*3600000+days*86400000;if(parts[1]==='-'){ms=-ms;}const result={ms,__edmType:'Edm.Time'};if(ns){result.ns=ns;}return result;};const parseDateTimeOffset=(value,withOffset,nullOnError)=>{/// <summary>Parses a string into a DateTime value.</summary>\n/// <param name=\"value\" type=\"String\">Value to parse.</param>\n/// <param name=\"withOffset\" type=\"Boolean\">Whether offset is expected.</param>\n/// <returns type=\"Date\">The parsed value.</returns>\n// We cannot parse this in cases of failure to match or if offset information is specified.\nconst parts=parseDateTimeRE.exec(value);const offset=parts?getCanonicalTimezone(parts[8]):null;if(!parts||!withOffset&&offset!=='Z'){if(nullOnError){return null;}throw{message:'Invalid date/time value'};}// Pre-parse years, account for year '0' being invalid in dateTime.\nlet year=parseInt(parts[1],10);if(year<=0){year++;}// Pre-parse optional milliseconds, fill in default. Fail if value is too precise.\nlet ms=parts[7];let ns=0;if(!ms){ms=0;}else{if(ms.length>7){if(nullOnError){return null;}throw{message:'Cannot parse date/time value to given precision.'};}ns=formatNumberWidth(ms.substring(3),4,true);ms=formatNumberWidth(ms.substring(0,3),3,true);ms=parseInt(ms,10);ns=parseInt(ns,10);}// Pre-parse other time components and offset them if necessary.\nlet hours=parseInt(parts[4],10);let minutes=parseInt(parts[5],10);const seconds=parseInt(parts[6],10);if(offset!=='Z'){// The offset is reversed to get back the UTC date, which is\n// what the API will eventually have.\nconst timezone=parseTimezone(offset);const direction=-timezone.d;hours+=timezone.h*direction;minutes+=timezone.m*direction;}// Set the date and time separately with setFullYear, so years 0-99 aren't biased like in Date.UTC.\nconst result=new Date();result.setUTCFullYear(year,// Year.\nparseInt(parts[2],10)-1,// Month (zero-based for Date.UTC and setFullYear).\nparseInt(parts[3],10)// Date.\n);result.setUTCHours(hours,minutes,seconds,ms);if(isNaN(result.valueOf())){if(nullOnError){return null;}throw{message:'Invalid date/time value'};}if(withOffset){result.__edmType='Edm.DateTimeOffset';result.__offset=offset;}if(ns){result.__ns=ns;}return result;};export const jsonLightReadStringPropertyValue=(value,propertyType,recognizeDates)=>{/// <summary>Convertes the value of a string property in a JSON light object to its library representation.</summary>\n/// <param name=\"value\" type=\"String\">String value to convert.</param>\n/// <param name=\"propertyType\" type=\"String\">Type name of the property.</param>\n/// <param name=\"recognizeDates\" type=\"Boolean\" optional=\"true\">Flag indicating whether datetime literal strings should be converted to JavaScript Date objects.</param>\n/// <returns>String property value in its library representation.</returns>\nswitch(propertyType){case EDM_BOOLEAN:return parseBool(value);case EDM_BYTE:case EDM_INT16:case EDM_INT32:case EDM_INT64:case EDM_SBYTE:return parseInt(value,10);case EDM_DOUBLE:case EDM_SINGLE:case EDM_DECIMAL:return parseFloat(value);case EDM_TIME:return parseDuration(value);case EDM_DATETIME:const dateStr=value||'';const time=dateStr.substring(dateStr.indexOf('T')+1);const timezoneOffsetIndex=time.indexOf('-');timezoneOffsetIndex===-1?time.indexOf('+'):timezoneOffsetIndex;if(timezoneOffsetIndex!==-1){return parseDateTimeOffset(value,true,/* nullOnError */false);}else{return parseDateTimeOffset(value,false,/* nullOnError */false);}case EDM_DATETIMEOFFSET:return parseDateTimeOffset(value,true,/* nullOnError */false);}if(recognizeDates){return parseDateTimeOffset(value,false,/* nullOnError */true)||parseDateTimeOffset(value,true,/* nullOnError */true)||value;}return value;};","map":{"version":3,"sources":["../../src/externals/helper.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nconst EDM = 'Edm.';\nconst EDM_BOOLEAN = EDM + 'Boolean';\nconst EDM_BYTE = EDM + 'Byte';\nconst EDM_DATETIME = EDM + 'DateTime';\nconst EDM_DATETIMEOFFSET = EDM + 'DateTimeOffset';\nconst EDM_DECIMAL = EDM + 'Decimal';\nconst EDM_DOUBLE = EDM + 'Double';\nconst EDM_INT16 = EDM + 'Int16';\nconst EDM_INT32 = EDM + 'Int32';\nconst EDM_INT64 = EDM + 'Int64';\nconst EDM_SBYTE = EDM + 'SByte';\nconst EDM_SINGLE = EDM + 'Single';\nconst EDM_TIME = EDM + 'Time';\n\nconst parseBool = propertyValue => {\n    /// <summary>Parses a string into a boolean value.</summary>\n    /// <param name=\"propertyValue\">Value to parse.</param>\n    /// <returns type=\"Boolean\">true if the property value is 'true'; false otherwise.</returns>\n\n    if (typeof propertyValue === 'boolean') {\n        return propertyValue;\n    }\n\n    return typeof propertyValue === 'string' && propertyValue.toLowerCase() === 'true';\n};\n\nconst formatNumberWidth = (value, width, append) => {\n    /// <summary>Formats the specified value to the given width.</summary>\n    /// <param name=\"value\" type=\"Number\">Number to format (non-negative).</param>\n    /// <param name=\"width\" type=\"Number\">Minimum width for number.</param>\n    /// <param name=\"append\" type=\"Boolean\">Flag indicating if the value is padded at the beginning (false) or at the end (true).</param>\n    /// <returns type=\"String\">Text representation.</returns>\n    let result = value.toString(10);\n    while (result.length < width) {\n        if (append) {\n            result += '0';\n        } else {\n            result = '0' + result;\n        }\n    }\n\n    return result;\n};\n\nconst parseTimezone = timezone => {\n    /// <summary>Parses a timezone description in (+|-)nn:nn format.</summary>\n    /// <param name=\"timezone\" type=\"String\">Timezone offset.</param>\n    /// <returns type=\"Object\">\n    /// An object with a (d)irection property of 1 for + and -1 for -,\n    /// offset (h)ours and offset (m)inutes.\n    /// </returns>\n\n    let direction = timezone.substring(0, 1);\n    direction = direction === '+' ? 1 : -1;\n\n    const offsetHours = parseInt(timezone.substring(1), 10);\n    const offsetMinutes = parseInt(timezone.substring(timezone.indexOf(':') + 1), 10);\n    return { d: direction, h: offsetHours, m: offsetMinutes };\n};\n\n// The captured indices for this expression are:\n// 0       - complete input\n// 1       - direction\n// 2,3,4   - years, months, days\n// 5,6,7,8 - hours, minutes, seconds, miliseconds\nconst parseTimeRE = /^([+-])?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d+))?S)?)?/;\n\n// The captured indices for this expression are:\n// 0     - complete input\n// 1,2,3 - year with optional minus sign, month, day\n// 4,5,6 - hours, minutes, seconds\n// 7     - optional milliseconds\n// 8     - everything else (presumably offset information)\nconst parseDateTimeRE = /^(-?\\d{4,})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(.*)$/;\n\nconst getCanonicalTimezone = timezone => {\n    /// <summary>Gets the canonical timezone representation.</summary>\n    /// <param name=\"timezone\" type=\"String\">Timezone representation.</param>\n    /// <returns type=\"String\">An 'Z' string if the timezone is absent or 0; the timezone otherwise.</returns>\n\n    return !timezone || timezone === 'Z' || timezone === '+00:00' || timezone === '-00:00' ? 'Z' : timezone;\n};\n\nconst parseDuration = duration => {\n    /// <summary>Parses a string in xsd:duration format.</summary>\n    /// <param name=\"duration\" type=\"String\">Duration value.</param>\n    /// <remarks>\n    /// This method will throw an exception if the input string has a year or a month component.\n    /// </remarks>\n    /// <returns type=\"Object\">Object representing the time</returns>\n\n    const parts = parseTimeRE.exec(duration);\n\n    if (parts === null) {\n        throw { message: 'Invalid duration value.' };\n    }\n\n    const years = parts[2] || '0';\n    const months = parts[3] || '0';\n    const days = parseInt(parts[4], 10) || 0;\n    const hours = parseInt(parts[5], 10) || 0;\n    const minutes = parseInt(parts[6], 10) || 0;\n    const seconds = parseFloat(parts[7]) || 0;\n\n    if (years !== '0' || months !== '0') {\n        throw { message: 'Unsupported duration value.' };\n    }\n\n    let ms: any = parts[8];\n    let ns: any = 0;\n    if (!ms) {\n        ms = 0;\n    } else {\n        if (ms.length > 7) {\n            throw { message: 'Cannot parse duration value to given precision.' };\n        }\n\n        ns = formatNumberWidth(ms.substring(3), 4, true);\n        ms = formatNumberWidth(ms.substring(0, 3), 3, true);\n\n        ms = parseInt(ms, 10);\n        ns = parseInt(ns, 10);\n    }\n\n    ms += seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;\n\n    if (parts[1] === '-') {\n        ms = -ms;\n    }\n\n    const result: any = { ms, __edmType: 'Edm.Time' };\n\n    if (ns) {\n        result.ns = ns;\n    }\n    return result;\n};\n\nconst parseDateTimeOffset = (value, withOffset, nullOnError) => {\n    /// <summary>Parses a string into a DateTime value.</summary>\n    /// <param name=\"value\" type=\"String\">Value to parse.</param>\n    /// <param name=\"withOffset\" type=\"Boolean\">Whether offset is expected.</param>\n    /// <returns type=\"Date\">The parsed value.</returns>\n\n    // We cannot parse this in cases of failure to match or if offset information is specified.\n    const parts = parseDateTimeRE.exec(value);\n    const offset = parts ? getCanonicalTimezone(parts[8]) : null;\n\n    if (!parts || (!withOffset && offset !== 'Z')) {\n        if (nullOnError) {\n            return null;\n        }\n        throw { message: 'Invalid date/time value' };\n    }\n\n    // Pre-parse years, account for year '0' being invalid in dateTime.\n    let year = parseInt(parts[1], 10);\n    if (year <= 0) {\n        year++;\n    }\n\n    // Pre-parse optional milliseconds, fill in default. Fail if value is too precise.\n    let ms: any = parts[7];\n    let ns: any = 0;\n    if (!ms) {\n        ms = 0;\n    } else {\n        if (ms.length > 7) {\n            if (nullOnError) {\n                return null;\n            }\n            throw { message: 'Cannot parse date/time value to given precision.' };\n        }\n\n        ns = formatNumberWidth(ms.substring(3), 4, true);\n        ms = formatNumberWidth(ms.substring(0, 3), 3, true);\n\n        ms = parseInt(ms, 10);\n        ns = parseInt(ns, 10);\n    }\n\n    // Pre-parse other time components and offset them if necessary.\n    let hours = parseInt(parts[4], 10);\n    let minutes = parseInt(parts[5], 10);\n    const seconds = parseInt(parts[6], 10);\n    if (offset !== 'Z') {\n        // The offset is reversed to get back the UTC date, which is\n        // what the API will eventually have.\n        const timezone = parseTimezone(offset);\n        const direction = -timezone.d;\n        hours += timezone.h * direction;\n        minutes += timezone.m * direction;\n    }\n\n    // Set the date and time separately with setFullYear, so years 0-99 aren't biased like in Date.UTC.\n    const result: any = new Date();\n    result.setUTCFullYear(\n        year, // Year.\n        parseInt(parts[2], 10) - 1, // Month (zero-based for Date.UTC and setFullYear).\n        parseInt(parts[3], 10) // Date.\n    );\n    result.setUTCHours(hours, minutes, seconds, ms);\n\n    if (isNaN(result.valueOf())) {\n        if (nullOnError) {\n            return null;\n        }\n        throw { message: 'Invalid date/time value' };\n    }\n\n    if (withOffset) {\n        result.__edmType = 'Edm.DateTimeOffset';\n        result.__offset = offset;\n    }\n\n    if (ns) {\n        result.__ns = ns;\n    }\n\n    return result;\n};\n\nexport const jsonLightReadStringPropertyValue = (value, propertyType, recognizeDates) => {\n    /// <summary>Convertes the value of a string property in a JSON light object to its library representation.</summary>\n    /// <param name=\"value\" type=\"String\">String value to convert.</param>\n    /// <param name=\"propertyType\" type=\"String\">Type name of the property.</param>\n    /// <param name=\"recognizeDates\" type=\"Boolean\" optional=\"true\">Flag indicating whether datetime literal strings should be converted to JavaScript Date objects.</param>\n    /// <returns>String property value in its library representation.</returns>\n\n    switch (propertyType) {\n        case EDM_BOOLEAN:\n            return parseBool(value);\n        case EDM_BYTE:\n        case EDM_INT16:\n        case EDM_INT32:\n        case EDM_INT64:\n        case EDM_SBYTE:\n            return parseInt(value, 10);\n        case EDM_DOUBLE:\n        case EDM_SINGLE:\n        case EDM_DECIMAL:\n            return parseFloat(value);\n        case EDM_TIME:\n            return parseDuration(value);\n        case EDM_DATETIME:\n            const dateStr = value || '';\n            const time = dateStr.substring(dateStr.indexOf('T') + 1);\n            const timezoneOffsetIndex = time.indexOf('-');\n            timezoneOffsetIndex === -1 ? time.indexOf('+') : timezoneOffsetIndex;\n\n            if (timezoneOffsetIndex !== -1) {\n                return parseDateTimeOffset(value, true, /* nullOnError */ false);\n            } else {\n                return parseDateTimeOffset(value, false, /* nullOnError */ false);\n            }\n        case EDM_DATETIMEOFFSET:\n            return parseDateTimeOffset(value, true, /* nullOnError */ false);\n    }\n\n    if (recognizeDates) {\n        return (\n            parseDateTimeOffset(value, false, /* nullOnError */ true) || parseDateTimeOffset(value, true, /* nullOnError */ true) || value\n        );\n    }\n    return value;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
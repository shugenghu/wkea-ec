{"ast":null,"code":"import\"core-js/modules/es.regexp.constructor.js\";import\"core-js/modules/es.regexp.to-string.js\";import\"core-js/modules/es.string.replace.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */ // TODO - refactor to incorporate inbuilt JS extension method\n// TODO - integrate Trace.error\nexport const EMPTY='';export function convertToString(obj){let accumulator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];let depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(!obj){return null;}if(typeof obj==='string'){return obj;}if(typeof obj!=='object'){return obj.toString();}for(const prop in obj){if(obj.hasOwnProperty(prop)){const value=obj[prop];const stringifyValue=convertToString(value,accumulator,depth+1);if(stringifyValue){if(accumulator.length>0&&depth===0){accumulator.push('&');}accumulator.push(prop);accumulator.push(typeof value==='object'?'.':':');accumulator.push(stringifyValue);}}}if(depth===0){return accumulator.join(EMPTY);}}/**\r\n * Verifies whether the object array has elements.\r\n *\r\n * @param {any[]} array The array.\r\n * @return {boolean} True if the object has elements, false otherwise.\r\n */export function hasElements(array){return!!array&&array.length>0;}/**\r\n * Verifies whether the string is empty or whitespace, but not null.\r\n *\r\n * @param {string} object The object.\r\n * @return {boolean} True if the object is empty or whitespace, false otherwise.\r\n */export function isObjectNotEmptyOrNull(value){return value&&typeof value==='object'&&Object.keys(value).length>0;}/**\r\n * Verifies whether the string is empty, but not null.\r\n *\r\n * @param {string} object The object.\r\n * @return {boolean} True if the object is empty, false otherwise.\r\n */export function isEmpty(object){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.isEmpty() has received input parameter not of type string.\");\n}return object!=null&&object.length===0;}/**\r\n * Verifies whether the string is empty or whitespace, but not null.\r\n *\r\n * @param {string} object The object.\r\n * @return {boolean} True if the object is empty or whitespace, false otherwise.\r\n */export function isEmptyOrWhitespace(object){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.isEmptyOrWhitespace() has received input parameter not of type string.\");\n}if(object){// Make sure object is of type string\nobject=object.toString();return typeof object.trim==='function'&&(object.trim()||'').length===0;}return false;}/**\r\n * Verifies whether the string is null or whitespace.\r\n *\r\n * @param {string} object The object.\r\n * @return {boolean} True if the object is null or whitespace, false otherwise.\r\n */export function isNullOrWhitespace(object){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.isNullOrWhitespace() has received input parameter not of type string.\");\n}let returnValue=true;try{returnValue=!object;if(!returnValue){// Make sure object is of type string\nobject=object.toString();returnValue=object.trim().length===0;}}catch(err){// Commerce.Proxy.Tracer.Error(\"StringExtensions.isNullOrWhitespace() caught exception = {0}\", err.message);\n}return returnValue;}/**\r\n * Pad left with padString until the required length is reached.\r\n */export function padLeft(object,padString,length){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.padLeft() has received input parameter not of type string.\");\n}if(!padString||!object){return object;}while(object.length<length){object=padString+object;}return object;}/**\r\n * Pad right with padString until the required length is reached.\r\n */export function padRight(object,padString,length){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.padRight() has received input parameter not of type string.\");\n}if(!padString||!object){return object;}while(object.length<length){object+=padString;}return object;}/**\r\n * Basic C# like string format function.\r\n */export function format(object){if(object&&typeof object!=='string'){// Tracer.Error(\"StringExtensions.isEmptyOrWhitespace has received input parameter not of type string.\");\n}if(isNullOrWhitespace(object)){return object;}for(var _len=arguments.length,params=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){params[_key-1]=arguments[_key];}if(params==null){throw new Error('StringExtensions::format Invalid parameter (params) cannot be null.');}for(let index=0;index<params.length;index++){if(params[index]==null){throw new Error('StringExtensions::format Invalid parameter (at index '+index+') cannot be null or undefined.');}// escape '$' to avoid '$0' issue, '$$$$' means '$$' escaped\nconst param=params[index].toString().replace(/\\$/gi,'$$$$');const regexp=new RegExp('\\\\{'+index+'\\\\}','gi');object=object.replace(regexp,param);}return object;}/**\r\n * Returns an ordinal to indicate the ordering of the strings\r\n * -1: This object is less than comparison object\r\n * 0: This object is equal to the comparison object\r\n * 1: This object is greater than the comparison object\r\n */export function compare(object,comparisonObject,ignoreCase){if(!object&&!comparisonObject){return 0;}else if(!object){return-1;}else if(!comparisonObject){return 1;}const val1=ignoreCase?object.toLowerCase():object;const val2=ignoreCase?comparisonObject.toLowerCase():comparisonObject;return val1<val2?-1:val1>val2?1:0;}/**\r\n * Replaces new line character with <br /> for display.\r\n */export function replaceNewLineWithBr(text){if(text){return replaceAll(text,'\\n','<br />');}return text;}/**\r\n * Replaces all instances of @txtToReplace\r\n */export function replaceAll(txt,txtToReplace,valueToReplaceWith){return txt.replace(new RegExp(txtToReplace,'g'),valueToReplaceWith);}/**\r\n * Escapes single quote to be send as part of URLs.\r\n */export function escapeSingleQuote(text){return text.replace(/(')/g,'\\'$1');}/**\r\n * Removes the trailing slashes from the URI.\r\n *\r\n * @param {string} uri The URI to clean.\r\n * @return {string} The uri without trailing slashes.\r\n */export function CleanUri(uri){if(isNullOrWhitespace(uri)){return EMPTY;}// the cutoff index for the string\nlet cutoffIndex=uri.length-1;while(cutoffIndex>=0&&(uri[cutoffIndex]==='/'||uri[cutoffIndex]==='\\\\')){--cutoffIndex;}// if it ever becomes negative, cutoffIndex + 1 = 0\nreturn uri.substr(0,cutoffIndex+1);}/**\r\n * Determines whether the end of string matches a specified string.\r\n *\r\n * @param {string} str: The string to search in.\r\n * @param {string} suffix: The string to compare to the substring at the end of str.\r\n * @param {boolean} caseSensitive: Determines if the comparison case sensitive (false, by default)\r\n * @return {boolean} true if suffix matches the end of str; otherwise, false.\r\n */export function endsWith(str,suffix){let caseSensitive=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!str||!suffix){return false;}if(suffix.length>str.length){return false;}const originalString=caseSensitive?str:str.toLowerCase();const subString=caseSensitive?suffix:suffix.toLowerCase();return originalString.indexOf(subString,originalString.length-subString.length)!==-1;}","map":{"version":3,"sources":["../../src/extensions/StringExtensions.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// TODO - refactor to incorporate inbuilt JS extension method\n// TODO - integrate Trace.error\n\nexport const EMPTY = '';\n\nexport function convertToString(obj: any, accumulator: string[] = [], depth: number = 0): string {\n    if (!obj) {\n        return null;\n    }\n\n    if (typeof obj === 'string') {\n        return obj;\n    }\n\n    if (typeof obj !== 'object') {\n        return obj.toString();\n    }\n\n    for (const prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            const value = obj[prop];\n            const stringifyValue = convertToString(value, accumulator, depth + 1);\n            if (stringifyValue) {\n                if (accumulator.length > 0 && depth === 0) {\n                    accumulator.push('&');\n                }\n                accumulator.push(prop);\n                accumulator.push(typeof value === 'object' ? '.' : ':');\n                accumulator.push(stringifyValue);\n            }\n        }\n    }\n\n    if (depth === 0) {\n        return accumulator.join(EMPTY);\n    }\n}\n\n/**\n * Verifies whether the object array has elements.\n *\n * @param {any[]} array The array.\n * @return {boolean} True if the object has elements, false otherwise.\n */\nexport function hasElements(array?: any[]): boolean {\n    return !!array && array.length > 0;\n}\n\n/**\n * Verifies whether the string is empty or whitespace, but not null.\n *\n * @param {string} object The object.\n * @return {boolean} True if the object is empty or whitespace, false otherwise.\n */\nexport function isObjectNotEmptyOrNull(value: object): boolean {\n    return value && typeof value === 'object' && Object.keys(value).length > 0;\n}\n\n/**\n * Verifies whether the string is empty, but not null.\n *\n * @param {string} object The object.\n * @return {boolean} True if the object is empty, false otherwise.\n */\nexport function isEmpty(object: string): boolean {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.isEmpty() has received input parameter not of type string.\");\n    }\n    return object != null && object.length === 0;\n}\n\n/**\n * Verifies whether the string is empty or whitespace, but not null.\n *\n * @param {string} object The object.\n * @return {boolean} True if the object is empty or whitespace, false otherwise.\n */\nexport function isEmptyOrWhitespace(object: string): boolean {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.isEmptyOrWhitespace() has received input parameter not of type string.\");\n    }\n    if (object) {\n        // Make sure object is of type string\n        object = object.toString();\n\n        return typeof object.trim === 'function' && (object.trim() || '').length === 0;\n    }\n    return false;\n}\n\n/**\n * Verifies whether the string is null or whitespace.\n *\n * @param {string} object The object.\n * @return {boolean} True if the object is null or whitespace, false otherwise.\n */\nexport function isNullOrWhitespace(object: string): boolean {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.isNullOrWhitespace() has received input parameter not of type string.\");\n    }\n    let returnValue = true;\n    try {\n        returnValue = !object;\n        if (!returnValue) {\n            // Make sure object is of type string\n            object = object.toString();\n            returnValue = object.trim().length === 0;\n        }\n    } catch (err) {\n        // Commerce.Proxy.Tracer.Error(\"StringExtensions.isNullOrWhitespace() caught exception = {0}\", err.message);\n    }\n\n    return returnValue;\n}\n\n/**\n * Pad left with padString until the required length is reached.\n */\nexport function padLeft(object: string, padString: string, length: number): string {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.padLeft() has received input parameter not of type string.\");\n    }\n\n    if (!padString || !object) {\n        return object;\n    }\n\n    while (object.length < length) {\n        object = padString + object;\n    }\n    return object;\n}\n\n/**\n * Pad right with padString until the required length is reached.\n */\nexport function padRight(object: string, padString: string, length: number): string {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.padRight() has received input parameter not of type string.\");\n    }\n\n    if (!padString || !object) {\n        return object;\n    }\n\n    while (object.length < length) {\n        object += padString;\n    }\n    return object;\n}\n\n/**\n * Basic C# like string format function.\n */\nexport function format(object: string, ...params: any[]): string {\n    if (object && typeof object !== 'string') {\n        // Tracer.Error(\"StringExtensions.isEmptyOrWhitespace has received input parameter not of type string.\");\n    }\n\n    if (isNullOrWhitespace(object)) {\n        return object;\n    }\n\n    if (params == null) {\n        throw new Error('StringExtensions::format Invalid parameter (params) cannot be null.');\n    }\n\n    for (let index = 0; index < params.length; index++) {\n        if (params[index] == null) {\n            throw new Error('StringExtensions::format Invalid parameter (at index ' + index + ') cannot be null or undefined.');\n        }\n\n        // escape '$' to avoid '$0' issue, '$$$$' means '$$' escaped\n        const param = params[index].toString().replace(/\\$/gi, '$$$$');\n        const regexp = new RegExp('\\\\{' + index + '\\\\}', 'gi');\n        object = object.replace(regexp, param);\n    }\n\n    return object;\n}\n\n/**\n * Returns an ordinal to indicate the ordering of the strings\n * -1: This object is less than comparison object\n * 0: This object is equal to the comparison object\n * 1: This object is greater than the comparison object\n */\nexport function compare(object: string, comparisonObject: string, ignoreCase?: boolean): number {\n    if (!object && !comparisonObject) {\n        return 0;\n    } else if (!object) {\n        return -1;\n    } else if (!comparisonObject) {\n        return 1;\n    }\n\n    const val1: string = ignoreCase ? object.toLowerCase() : object;\n    const val2: string = ignoreCase ? comparisonObject.toLowerCase() : comparisonObject;\n\n    return val1 < val2 ? -1 : val1 > val2 ? 1 : 0;\n}\n\n/**\n * Replaces new line character with <br /> for display.\n */\nexport function replaceNewLineWithBr(text: string) {\n    if (text) {\n        return replaceAll(text, '\\n', '<br />');\n    }\n\n    return text;\n}\n\n/**\n * Replaces all instances of @txtToReplace\n */\nexport function replaceAll(txt, txtToReplace, valueToReplaceWith) {\n    return txt.replace(new RegExp(txtToReplace, 'g'), valueToReplaceWith);\n}\n\n/**\n * Escapes single quote to be send as part of URLs.\n */\nexport function escapeSingleQuote(text: string) {\n    return text.replace(/(')/g, '\\'$1');\n}\n\n/**\n * Removes the trailing slashes from the URI.\n *\n * @param {string} uri The URI to clean.\n * @return {string} The uri without trailing slashes.\n */\nexport function CleanUri(uri: string): string {\n    if (isNullOrWhitespace(uri)) {\n        return EMPTY;\n    }\n\n    // the cutoff index for the string\n    let cutoffIndex = uri.length - 1;\n\n    while (cutoffIndex >= 0 && (uri[cutoffIndex] === '/' || uri[cutoffIndex] === '\\\\')) {\n        --cutoffIndex;\n    }\n\n    // if it ever becomes negative, cutoffIndex + 1 = 0\n    return uri.substr(0, cutoffIndex + 1);\n}\n\n/**\n * Determines whether the end of string matches a specified string.\n *\n * @param {string} str: The string to search in.\n * @param {string} suffix: The string to compare to the substring at the end of str.\n * @param {boolean} caseSensitive: Determines if the comparison case sensitive (false, by default)\n * @return {boolean} true if suffix matches the end of str; otherwise, false.\n */\nexport function endsWith(str: string, suffix: string, caseSensitive: boolean = false): boolean {\n    if (!str || !suffix) {\n        return false;\n    }\n    if (suffix.length > str.length) {\n        return false;\n    }\n\n    const originalString: string = caseSensitive ? str : str.toLowerCase();\n    const subString: string = caseSensitive ? suffix : suffix.toLowerCase();\n    return originalString.indexOf(subString, originalString.length - subString.length) !== -1;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
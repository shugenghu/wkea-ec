{"ast":null,"code":"import\"core-js/modules/es.promise.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{fixChunkName,getDefaultOrResult}from'./internal/dynamic-import-extensions-helpers';/**\r\n * Method tries to load the module synchronously if it is available or will return undefined\r\n * if module cannot be loaded synchronously.\r\n *\r\n * @param webpackResolvePath The path where webpack will try to load the module from\r\n */const requireModuleSync=webpackResolvePath=>{let result;try{result=__webpack_require__(webpackResolvePath);/**\r\n         * The above is analagous to the following but more succinct.\r\n         *\r\n         * let requiredModule = __webpack_require__(loadedModWebpackyName);\r\n         * if (requiredModule) {\r\n         *    result = requiredModule;\r\n         * }\r\n         *\r\n         */}catch(e){// intentionally blank, module was not able to be loaded synchronously\n}return result;};export const dynamicImport=args=>{if(!args){throw new Error(\"args cannot be null or undefined\");}let result;const univeralImport=args.universalImport();const actualResolvedPath=univeralImport.resolve();let loadedMod;// try to load module synchronously\nloadedMod=requireModuleSync(actualResolvedPath);const loadedSync=!!loadedMod;if(!loadedSync){loadedMod=univeralImport.load();}// This is how to check if object is a promise per spec http://www.ecma-international.org/ecma-262/6.0/#sec-promise.resolve\nconst isPromise=Promise.resolve(loadedMod)===loadedMod;result={isPromise,isSuccess:loadedMod!==undefined,result:loadedMod,// TODO: handle promise case in promise resolve for custom module async loading\ndefaultExport:!isPromise?getDefaultOrResult(loadedMod):null,chunkName:fixChunkName(univeralImport),__isDynamicResult:true};return result;};","map":{"version":3,"sources":["../../../src/utilities/dynamic-import-extensions.ts"],"names":[],"mappings":"sCAAA;;;AAGG,GAIH,OAAS,YAAT,CAAuB,kBAAvB,KAA4D,8CAA5D,CAKA;;;;;AAKG,GACH,KAAM,CAAA,iBAAiB,CAAI,kBAAD,EAA+B,CACrD,GAAI,CAAA,MAAJ,CACA,GAAI,CACA,MAAM,CAAG,mBAAmB,CAAC,kBAAD,CAA5B,CACA;;;;;;;;AAQG,WACN,CAAC,MAAO,CAAP,CAAU,CACR;AACH,CAED,MAAO,CAAA,MAAP,CACH,CAlBD,CAoBA,MAAO,MAAM,CAAA,aAAa,CAAI,IAAD,EAAiD,CAC1E,GAAI,CAAC,IAAL,CAAW,CACP,KAAM,IAAI,CAAA,KAAJ,oCAAN,CACH,CAED,GAAI,CAAA,MAAJ,CACA,KAAM,CAAA,cAAc,CAAG,IAAI,CAAC,eAAL,EAAvB,CACA,KAAM,CAAA,kBAAkB,CAAG,cAAc,CAAC,OAAf,EAA3B,CACA,GAAI,CAAA,SAAJ,CACA;AACA,SAAS,CAAG,iBAAiB,CAAC,kBAAD,CAA7B,CACA,KAAM,CAAA,UAAU,CAAG,CAAC,CAAC,SAArB,CAEA,GAAI,CAAC,UAAL,CAAiB,CACb,SAAS,CAAG,cAAc,CAAC,IAAf,EAAZ,CACH,CAED;AACA,KAAM,CAAA,SAAS,CAAG,OAAO,CAAC,OAAR,CAAuC,SAAvC,IAAsD,SAAxE,CACA,MAAM,CAAG,CACL,SADK,CAEL,SAAS,CAAE,SAAS,GAAK,SAFpB,CAGL,MAAM,CAAE,SAHH,CAIL;AACA,aAAa,CAAE,CAAC,SAAD,CAAa,kBAAkB,CAAwB,SAAxB,CAA/B,CAAoE,IAL9E,CAML,SAAS,CAAE,YAAY,CAAC,cAAD,CANlB,CAOL,iBAAiB,CAAE,IAPd,CAAT,CAUA,MAAO,CAAA,MAAP,CACH,CA9BM","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable no-single-line-block-comment no-reserved-keywords\nimport { IDynamicImportArgs, IDynamicLoadResult } from '../interfaces';\nimport { fixChunkName, getDefaultOrResult, IESModule } from './internal/dynamic-import-extensions-helpers';\n\n// global webpack defined require function\ndeclare var __webpack_require__: (webpackRequireName: string) => {};\n\n/**\n * Method tries to load the module synchronously if it is available or will return undefined\n * if module cannot be loaded synchronously.\n *\n * @param webpackResolvePath The path where webpack will try to load the module from\n */\nconst requireModuleSync = (webpackResolvePath: string) => {\n    let result: {} | undefined;\n    try {\n        result = __webpack_require__(webpackResolvePath);\n        /**\n         * The above is analagous to the following but more succinct.\n         *\n         * let requiredModule = __webpack_require__(loadedModWebpackyName);\n         * if (requiredModule) {\n         *    result = requiredModule;\n         * }\n         *\n         */\n    } catch (e) {\n        // intentionally blank, module was not able to be loaded synchronously\n    }\n\n    return result;\n};\n\nexport const dynamicImport = (args: IDynamicImportArgs): IDynamicLoadResult => {\n    if (!args) {\n        throw new Error(`args cannot be null or undefined`);\n    }\n\n    let result: IDynamicLoadResult;\n    const univeralImport = args.universalImport();\n    const actualResolvedPath = univeralImport.resolve();\n    let loadedMod: {} | Promise<{}> | undefined;\n    // try to load module synchronously\n    loadedMod = requireModuleSync(actualResolvedPath);\n    const loadedSync = !!loadedMod;\n\n    if (!loadedSync) {\n        loadedMod = univeralImport.load();\n    }\n\n    // This is how to check if object is a promise per spec http://www.ecma-international.org/ecma-262/6.0/#sec-promise.resolve\n    const isPromise = Promise.resolve(<IESModule | undefined>loadedMod) === loadedMod;\n    result = {\n        isPromise,\n        isSuccess: loadedMod !== undefined,\n        result: loadedMod,\n        // TODO: handle promise case in promise resolve for custom module async loading\n        defaultExport: !isPromise ? getDefaultOrResult(<IESModule | undefined>loadedMod) : null,\n        chunkName: fixChunkName(univeralImport),\n        __isDynamicResult: true\n    };\n\n    return result;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
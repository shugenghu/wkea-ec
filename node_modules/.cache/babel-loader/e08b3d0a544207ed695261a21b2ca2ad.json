{"ast":null,"code":"import\"core-js/modules/es.regexp.to-string.js\";import\"core-js/modules/es.string.ends-with.js\";import\"core-js/modules/web.dom-collections.for-each.js\";import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{ICacheSource}from'@msdyn365-commerce/cache-internal';import{msdyn365Commerce}from'@msdyn365-commerce/core-internal';import{AsyncResult,DataServiceRequest,isAsyncResult}from'@msdyn365-commerce/retail-proxy';import{LogLevel}from'@msdyn365-commerce/telemetry-internal';const GET_FROM_RETURNIDENTIFIER='___GET__FROM__RETURNIDENTIIER___';export const addLocaleInformation=(inputs,locale)=>{const isArray=Array.isArray(inputs);if(isArray){// @ts-ignore\n(inputs||[]).forEach(input=>{if(input instanceof DataServiceRequest&&!input.getCacheKey().endsWith(\"-\".concat(locale))){// @ts-ignore\nconst tmp=input._cacheKeyFromInput;// @ts-ignore\ninput._cacheKeyFromInput=\"\".concat(tmp,\"-\").concat(locale);}});}else{if(inputs instanceof DataServiceRequest&&!inputs.getCacheKey().endsWith(\"-\".concat(locale))){// @ts-ignore\nconst tmp=inputs._cacheKeyFromInput;// @ts-ignore\ninputs._cacheKeyFromInput=\"\".concat(tmp,\"-\").concat(locale);}}};// tslint:disable\nconst _resolveCacheEntryReference=(dataServiceRequest,item,requestCache,appCache,shouldReadFromAppCache,isWrappingPromise)=>{const cacheValueAsArray=item['key'].map(key=>{// @ts-ignore\nconst value=requestCache.get({typeName:dataServiceRequest._cacheObjectType,key});if(!value&&shouldReadFromAppCache&&appCache){// @ts-ignore\nappCache.copyTo({typeName:dataServiceRequest._cacheObjectType,key},requestCache);}if(!value||!value.item){return undefined;}// @ts-ignore\nif(isAsyncResult(value.item)){return value.item.result;}return value.item;}).filter(data=>data!==undefined&&data!==null);if(item['key'].length>cacheValueAsArray.length){return;}// If we are returning a Promise that represents a future collection, we need to unwrap it\n// @ts-ignore\nconst isReturnTypeACollection=dataServiceRequest._query.isReturnTypeACollection;return cacheValueAsArray&&cacheValueAsArray.length>0?isReturnTypeACollection&&!isWrappingPromise?cacheValueAsArray:cacheValueAsArray[0]:undefined;};const logTelemetrySource=(cacheValue,dataServiceRequest,cacheKey,telemetry)=>{if(!telemetry){return;}if(!msdyn365Commerce.isBrowser){switch(cacheValue.s){case ICacheSource.AppCache:{telemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{values:[// @ts-ignore\ndataServiceRequest._cacheObjectType||'none',cacheKey,'AppCache']});break;}case ICacheSource.RequestCache:{telemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{values:[// @ts-ignore\ndataServiceRequest._cacheObjectType||'none',cacheKey,'RequestCache']});break;}default:{telemetry.log(LogLevel.Information,'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}',{values:[// @ts-ignore\ndataServiceRequest._cacheObjectType||'none',cacheKey,'Default']});break;}}}};const readCacheEntriesBasedOnCacheKeyFromReturnType=(dataServiceRequest,requestCache,appCache,shouldReadFromAppCache,telemetry)=>{// @ts-ignore\nif(dataServiceRequest._cacheKeyFromReturnType.length===0){return{entry:null,shouldRefresh:false};}let shouldRefreshAll=true;// @ts-ignore\nconst cacheEntries=dataServiceRequest._cacheKeyFromReturnType// @ts-ignore\n.map(entry=>{// @ts-ignore\nconst key=\"\".concat(dataServiceRequest._cacheKeyIdentifierFromReturnType,\"-\").concat(entry);// @ts-ignore\nlet cacheValue=requestCache.get({typeName:dataServiceRequest._cacheObjectType,key});if(!cacheValue&&shouldReadFromAppCache&&appCache){// @ts-ignore\ncacheValue=appCache.copyTo({typeName:dataServiceRequest._cacheObjectType,key},requestCache);}if(!cacheValue||!cacheValue.item){return null;}// according to the logic, will treat the entries to shouldRefresh when all entries have shouldRefresh.\nif(!cacheValue.shouldRefresh){shouldRefreshAll=false;}logTelemetrySource(cacheValue,dataServiceRequest,key,telemetry);return cacheValue.item;}).filter(Boolean);// @ts-ignore\nconst isReturnTypeACollection=dataServiceRequest._query.isReturnTypeACollection;const cacheEntriesReturn=cacheEntries&&cacheEntries.length>0?isReturnTypeACollection?cacheEntries:cacheEntries[0]:null;return{entry:cacheEntriesReturn,shouldRefresh:shouldRefreshAll};};export const readCacheEntries=function readCacheEntries(dataServiceRequest,requestCache,appCache){let shouldReadFromAppCache=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let telemetry=arguments.length>4?arguments[4]:undefined;if(!requestCache||// @ts-ignore\n!dataServiceRequest.getCacheKey()&&dataServiceRequest._cacheKeyFromReturnType.length===0||// @ts-ignore\n!dataServiceRequest._cacheObjectType){return{entry:null,shouldRefresh:false};}if(// @ts-ignore\ndataServiceRequest._cacheKeyFromInput===GET_FROM_RETURNIDENTIFIER||// @ts-ignore\ndataServiceRequest._cacheKeyIdentifierFromReturnType&&dataServiceRequest._cacheKeyFromReturnType.length!==0){const entries=readCacheEntriesBasedOnCacheKeyFromReturnType(dataServiceRequest,requestCache,appCache,shouldReadFromAppCache,telemetry);if(entries&&entries.entry){return entries;}}// @ts-ignore\nconst cacheKey={typeName:dataServiceRequest._cacheObjectType,key:dataServiceRequest._cacheKeyFromInput};let cachedValueBasedOnInput=requestCache.get(cacheKey);if(cachedValueBasedOnInput){cachedValueBasedOnInput=_objectSpread({},cachedValueBasedOnInput);}else if(shouldReadFromAppCache&&appCache){cachedValueBasedOnInput=appCache.copyTo(cacheKey,requestCache);}if(!cachedValueBasedOnInput){return readCacheEntriesBasedOnCacheKeyFromReturnType(dataServiceRequest,requestCache,appCache,shouldReadFromAppCache,telemetry);}// @ts-ignore\nlogTelemetrySource(cachedValueBasedOnInput,dataServiceRequest,dataServiceRequest._cacheKeyFromInput,telemetry);if(cachedValueBasedOnInput.item instanceof AsyncResult){if(cachedValueBasedOnInput.item.status!=='LOADING'){cachedValueBasedOnInput.item=cachedValueBasedOnInput.item.result||cachedValueBasedOnInput.item.error;}else{const asyncResult=cachedValueBasedOnInput.item.then(result=>{if(typeof result!=='object'||result['$ref']!==true){return result;}return _resolveCacheEntryReference(dataServiceRequest,result,requestCache,appCache,shouldReadFromAppCache);});return{entry:asyncResult,shouldRefresh:cachedValueBasedOnInput.shouldRefresh};}}if(typeof cachedValueBasedOnInput.item!=='object'||// @ts-ignore\ncachedValueBasedOnInput.item&&cachedValueBasedOnInput.item['$ref']!==true){return{entry:cachedValueBasedOnInput.item,shouldRefresh:cachedValueBasedOnInput.shouldRefresh};}const resolvedRef=_resolveCacheEntryReference(dataServiceRequest,cachedValueBasedOnInput.item,requestCache,appCache,shouldReadFromAppCache,// @ts-ignore\nisAsyncResult(cachedValueBasedOnInput.item));return{entry:resolvedRef,shouldRefresh:cachedValueBasedOnInput.shouldRefresh};};const _saveEntityToCache=(dataServiceRequest,data,requestCache,appCache,isCacheTypeApplication)=>{// @ts-ignore\nif(!data||!dataServiceRequest._cacheKeyFromInput&&!dataServiceRequest._cacheKeyIdentifierFromReturnType){return;}const cacheEntries={};const results=data;// using Object.prototype instead of Array.isArray because results can be Observable Array which cann't be detected with Array.isArray\n// @ts-ignore\nif(!dataServiceRequest._query.isReturnTypeACollection||Object.prototype.toString.call(results)!=='[object Array]'){// @ts-ignore\nif(dataServiceRequest._cacheKeyIdentifierFromReturnType){// @ts-ignore\nconst key=\"\".concat(dataServiceRequest._cacheKeyIdentifierFromReturnType,\"-\").concat(// @ts-ignore\nresults[dataServiceRequest._cacheKeyIdentifierFromReturnType]);// @ts-ignore\ncacheEntries[key]=results;// @ts-ignore\nif(dataServiceRequest._cacheKeyFromInput){let existingCacheItem=requestCache.get({// @ts-ignore\ntypeName:dataServiceRequest._cacheObjectType,// @ts-ignore\nkey:dataServiceRequest._cacheKeyFromInput});if(existingCacheItem){existingCacheItem=_objectSpread({},existingCacheItem);}if(existingCacheItem&&existingCacheItem.item&&(!(existingCacheItem.item instanceof AsyncResult)||existingCacheItem.item.status==='SUCCESS')&&(// @ts-ignore\ntypeof existingCacheItem.item!=='object'||existingCacheItem&&existingCacheItem.item['$ref']!==true)){// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]=results;}else{// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]={$ref:true,// @ts-ignore\ntype:dataServiceRequest._cacheObjectType,// @ts-ignore\nidentifier:dataServiceRequest._cacheKeyIdentifierFromReturnType,key:[key],// @ts-ignore\ncount:dataServiceRequest._totalCount};}}}else{// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]=results;}// @ts-ignore\n}else if(!dataServiceRequest._cacheKeyIdentifierFromReturnType){// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]=results;}else{const cacheValue=results// @ts-ignore\n.map(result=>{// @ts-ignore\nconst identifierValue=result[dataServiceRequest._cacheKeyIdentifierFromReturnType];if(identifierValue){// @ts-ignore\nconst key=\"\".concat(dataServiceRequest._cacheKeyIdentifierFromReturnType,\"-\").concat(identifierValue);// @ts-ignore\ncacheEntries[key]=result;return key;}}).filter(Boolean);let existingCacheItem=requestCache.get({// @ts-ignore\ntypeName:dataServiceRequest._cacheObjectType,// @ts-ignore\nkey:dataServiceRequest._cacheKeyFromInput});if(existingCacheItem){existingCacheItem=_objectSpread({},existingCacheItem);}if(existingCacheItem&&existingCacheItem.item&&(!(existingCacheItem.item instanceof AsyncResult)||existingCacheItem.item.status==='SUCCESS')&&(// @ts-ignore\ntypeof existingCacheItem.item!=='object'||existingCacheItem&&existingCacheItem.item['$ref']!==true)){// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]=results;}else{// @ts-ignore\ncacheEntries[dataServiceRequest._cacheKeyFromInput]={$ref:true,// @ts-ignore\ntype:existingCacheItem._cacheObjectType,// @ts-ignore\nidentifier:existingCacheItem._cacheKeyIdentifierFromReturnType,// @ts-ignore\nisCollection:existingCacheItem._query.isReturnTypeACollection,key:cacheValue,// @ts-ignore\ncount:existingCacheItem._totalCount};}}if(cacheEntries){Object.keys(cacheEntries).map(entryKey=>{// @ts-ignore\nrequestCache.put({typeName:dataServiceRequest._cacheObjectType,key:entryKey},{item:cacheEntries[entryKey]});if(appCache&&isCacheTypeApplication){// @ts-ignore\nappCache.put({typeName:dataServiceRequest._cacheObjectType,key:entryKey},{item:cacheEntries[entryKey]});}});}return cacheEntries;};export const saveCacheEntries=(dataServiceRequest,data,requestCache,appCache,isCacheTypeApplication)=>{// if return Entity is collection\n//        if entity type has identifier/primary key\n//              1. cache array of primay key value of returned entity collection on input cache key\n//              2. cache individual entity on primary key\n//        else\n//              1. cache output on input cache key\n//\n// else  if entity type has identifier/primary key\n//           2. cache output entity on primary key\nif(!data||// @ts-ignore\n!dataServiceRequest._cacheKeyFromInput&&!dataServiceRequest._cacheKeyIdentifierFromReturnType||// @ts-ignore\n!dataServiceRequest._cacheObjectType){return;}if(data instanceof AsyncResult){// For a loading Promise, cache based on input cachekey, and then cache output again once complete\nif(data.status==='LOADING'){data.then(result=>{// @ts-ignore\nif(dataServiceRequest._totalCount!==undefined){// @ts-ignore\ndata.metadata.count=dataServiceRequest._totalCount;}_saveEntityToCache(dataServiceRequest,result,requestCache,appCache,isCacheTypeApplication);return result;});// @ts-ignore\nrequestCache.put({typeName:dataServiceRequest._cacheObjectType,key:dataServiceRequest._cacheKeyFromInput},{item:data});if(appCache&&isCacheTypeApplication){// @ts-ignore\nappCache.put({typeName:dataServiceRequest._cacheObjectType,key:dataServiceRequest._cacheKeyFromInput},{item:data});}// For a completed promise, save the action results to the cache\n}else{// @ts-ignore\nif(dataServiceRequest._totalCount!==undefined){// @ts-ignore\ndata.metadata.count=dataServiceRequest._totalCount;}_saveEntityToCache(dataServiceRequest,data.result,requestCache,appCache,isCacheTypeApplication);return data.result;}}else{return _saveEntityToCache(dataServiceRequest,data,requestCache,appCache,isCacheTypeApplication);}};","map":{"version":3,"sources":["../../../src/cache/retail-cache-helper.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\nimport { ICache, ICacheItem, ICacheSource } from '@msdyn365-commerce/cache-internal';\nimport { IActionInput, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { ITelemetry, LogLevel } from '@msdyn365-commerce/telemetry-internal';\n\nconst GET_FROM_RETURNIDENTIFIER: string = '___GET__FROM__RETURNIDENTIIER___';\n\nexport const addLocaleInformation = (inputs: IActionInput | IActionInput[], locale: string): void => {\n    const isArray = Array.isArray(inputs);\n    if (isArray) {\n        // @ts-ignore\n        (inputs || []).forEach(input => {\n            if (input instanceof DataServiceRequest && !input.getCacheKey().endsWith(`-${locale}`)) {\n                // @ts-ignore\n                const tmp = input._cacheKeyFromInput;\n                // @ts-ignore\n                input._cacheKeyFromInput = `${tmp}-${locale}`;\n            }\n        });\n    } else {\n        if (inputs instanceof DataServiceRequest && !inputs.getCacheKey().endsWith(`-${locale}`)) {\n            // @ts-ignore\n            const tmp = inputs._cacheKeyFromInput;\n            // @ts-ignore\n            inputs._cacheKeyFromInput = `${tmp}-${locale}`;\n        }\n    }\n};\n// tslint:disable\nconst _resolveCacheEntryReference = (\n    dataServiceRequest: DataServiceRequest,\n    item: any,\n    requestCache: ICache,\n    appCache: ICache,\n    shouldReadFromAppCache?: boolean,\n    isWrappingPromise?: boolean\n) => {\n    const cacheValueAsArray = (item['key'] as string[])\n        .map(key => {\n            // @ts-ignore\n            const value = requestCache.get({ typeName: dataServiceRequest._cacheObjectType, key });\n\n            if (!value && shouldReadFromAppCache && appCache) {\n                // @ts-ignore\n                appCache.copyTo({ typeName: dataServiceRequest._cacheObjectType, key }, requestCache);\n            }\n\n            if (!value || !value.item) {\n                return undefined;\n            }\n            // @ts-ignore\n            if (isAsyncResult(value.item)) {\n                return value.item.result;\n            }\n\n            return value.item;\n        })\n        .filter(data => data !== undefined && data !== null);\n\n    if ((item['key'] as string[]).length > cacheValueAsArray.length) {\n        return;\n    }\n\n    // If we are returning a Promise that represents a future collection, we need to unwrap it\n    // @ts-ignore\n    const isReturnTypeACollection = dataServiceRequest._query.isReturnTypeACollection;\n    return cacheValueAsArray && cacheValueAsArray.length > 0\n        ? isReturnTypeACollection && !isWrappingPromise\n            ? cacheValueAsArray\n            : cacheValueAsArray[0]\n        : undefined;\n};\n\nconst logTelemetrySource = (\n    cacheValue: ICacheItem<any>,\n    dataServiceRequest: DataServiceRequest,\n    cacheKey: string,\n    telemetry?: ITelemetry\n) => {\n    if (!telemetry) {\n        return;\n    }\n    if (!msdyn365Commerce.isBrowser) {\n        switch (cacheValue.s!) {\n            case ICacheSource.AppCache: {\n                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {\n                    values: [\n                        // @ts-ignore\n                        dataServiceRequest._cacheObjectType || 'none',\n                        cacheKey,\n                        'AppCache'\n                    ]\n                });\n                break;\n            }\n            case ICacheSource.RequestCache: {\n                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {\n                    values: [\n                        // @ts-ignore\n                        dataServiceRequest._cacheObjectType || 'none',\n                        cacheKey,\n                        'RequestCache'\n                    ]\n                });\n                break;\n            }\n            default: {\n                telemetry.log(LogLevel.Information, 'dataAction with {actiontype}, {cacheKey}.  source {cacheSource}', {\n                    values: [\n                        // @ts-ignore\n                        dataServiceRequest._cacheObjectType || 'none',\n                        cacheKey,\n                        'Default'\n                    ]\n                });\n                break;\n            }\n        }\n    }\n};\n\nconst readCacheEntriesBasedOnCacheKeyFromReturnType = (\n    dataServiceRequest: DataServiceRequest,\n    requestCache: ICache,\n    appCache: ICache,\n    shouldReadFromAppCache: boolean,\n    telemetry?: ITelemetry\n): any => {\n    // @ts-ignore\n    if (dataServiceRequest._cacheKeyFromReturnType.length === 0) {\n        return { entry: null, shouldRefresh: false };\n    }\n    let shouldRefreshAll = true;\n    // @ts-ignore\n    const cacheEntries = dataServiceRequest._cacheKeyFromReturnType\n        // @ts-ignore\n        .map(entry => {\n            // @ts-ignore\n            const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${entry}`;\n            // @ts-ignore\n            let cacheValue = requestCache.get({ typeName: dataServiceRequest._cacheObjectType, key });\n\n            if (!cacheValue && shouldReadFromAppCache && appCache) {\n                // @ts-ignore\n                cacheValue = appCache.copyTo({ typeName: dataServiceRequest._cacheObjectType, key }, requestCache);\n            }\n\n            if (!cacheValue || !cacheValue.item) {\n                return null;\n            }\n            // according to the logic, will treat the entries to shouldRefresh when all entries have shouldRefresh.\n            if (!cacheValue.shouldRefresh) {\n                shouldRefreshAll = false;\n            }\n            logTelemetrySource(cacheValue, dataServiceRequest, key, telemetry);\n\n            return cacheValue.item;\n        })\n        .filter(Boolean);\n    // @ts-ignore\n    const isReturnTypeACollection = dataServiceRequest._query.isReturnTypeACollection;\n    const cacheEntriesReturn = cacheEntries && cacheEntries.length > 0 ? (isReturnTypeACollection ? cacheEntries : cacheEntries[0]) : null;\n    return { entry: cacheEntriesReturn, shouldRefresh: shouldRefreshAll };\n};\n\nexport const readCacheEntries = (\n    dataServiceRequest: DataServiceRequest,\n    requestCache: ICache,\n    appCache: ICache,\n    shouldReadFromAppCache: boolean = false,\n    telemetry?: ITelemetry\n): any => {\n    if (\n        !requestCache ||\n        // @ts-ignore\n        (!dataServiceRequest.getCacheKey() && dataServiceRequest._cacheKeyFromReturnType.length === 0) ||\n        // @ts-ignore\n        !dataServiceRequest._cacheObjectType\n    ) {\n        return { entry: null, shouldRefresh: false };\n    }\n    if (\n        // @ts-ignore\n        dataServiceRequest._cacheKeyFromInput === GET_FROM_RETURNIDENTIFIER ||\n        // @ts-ignore\n        (dataServiceRequest._cacheKeyIdentifierFromReturnType && dataServiceRequest._cacheKeyFromReturnType.length !== 0)\n    ) {\n        const entries = readCacheEntriesBasedOnCacheKeyFromReturnType(\n            dataServiceRequest,\n            requestCache,\n            appCache,\n            shouldReadFromAppCache,\n            telemetry\n        );\n        if (entries && entries.entry) {\n            return entries;\n        }\n    }\n    // @ts-ignore\n    const cacheKey = { typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput };\n    let cachedValueBasedOnInput = requestCache.get(cacheKey);\n    if (cachedValueBasedOnInput) {\n        cachedValueBasedOnInput = { ...cachedValueBasedOnInput };\n    } else if (shouldReadFromAppCache && appCache) {\n        cachedValueBasedOnInput = appCache.copyTo(cacheKey, requestCache);\n    }\n\n    if (!cachedValueBasedOnInput) {\n        return readCacheEntriesBasedOnCacheKeyFromReturnType(dataServiceRequest, requestCache, appCache, shouldReadFromAppCache, telemetry);\n    }\n    // @ts-ignore\n    logTelemetrySource(cachedValueBasedOnInput, dataServiceRequest, dataServiceRequest._cacheKeyFromInput, telemetry);\n    if (cachedValueBasedOnInput.item instanceof AsyncResult) {\n        if (cachedValueBasedOnInput.item.status !== 'LOADING') {\n            cachedValueBasedOnInput.item = cachedValueBasedOnInput.item.result || cachedValueBasedOnInput.item.error;\n        } else {\n            const asyncResult = cachedValueBasedOnInput.item.then(result => {\n                if (typeof result !== 'object' || result['$ref'] !== true) {\n                    return result;\n                }\n\n                return _resolveCacheEntryReference(dataServiceRequest, result, requestCache, appCache, shouldReadFromAppCache);\n            });\n            return { entry: asyncResult, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };\n        }\n    }\n    if (\n        typeof cachedValueBasedOnInput.item !== 'object' ||\n        // @ts-ignore\n        (cachedValueBasedOnInput.item && cachedValueBasedOnInput.item['$ref'] !== true)\n    ) {\n        return { entry: cachedValueBasedOnInput.item, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };\n    }\n\n    const resolvedRef = _resolveCacheEntryReference(\n        dataServiceRequest,\n        cachedValueBasedOnInput.item,\n        requestCache,\n        appCache,\n        shouldReadFromAppCache,\n        // @ts-ignore\n        isAsyncResult(cachedValueBasedOnInput.item)\n    );\n    return { entry: resolvedRef, shouldRefresh: cachedValueBasedOnInput.shouldRefresh };\n};\n\nconst _saveEntityToCache = (\n    dataServiceRequest: DataServiceRequest,\n    data: any,\n    requestCache: ICache,\n    appCache: ICache,\n    isCacheTypeApplication: boolean\n): { [cacheKey: string]: any } | undefined => {\n    // @ts-ignore\n    if (!data || (!dataServiceRequest._cacheKeyFromInput && !dataServiceRequest._cacheKeyIdentifierFromReturnType)) {\n        return;\n    }\n\n    const cacheEntries = {};\n    const results = data;\n\n    // using Object.prototype instead of Array.isArray because results can be Observable Array which cann't be detected with Array.isArray\n    // @ts-ignore\n    if (!dataServiceRequest._query.isReturnTypeACollection || Object.prototype.toString.call(results) !== '[object Array]') {\n        // @ts-ignore\n        if (dataServiceRequest._cacheKeyIdentifierFromReturnType) {\n            // @ts-ignore\n            const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${\n                // @ts-ignore\n                results[dataServiceRequest._cacheKeyIdentifierFromReturnType]\n            }`;\n            // @ts-ignore\n            cacheEntries[key] = results;\n            // @ts-ignore\n            if (dataServiceRequest._cacheKeyFromInput) {\n                let existingCacheItem = requestCache.get({\n                    // @ts-ignore\n                    typeName: dataServiceRequest._cacheObjectType,\n                    // @ts-ignore\n                    key: dataServiceRequest._cacheKeyFromInput\n                });\n                if (existingCacheItem) {\n                    existingCacheItem = { ...existingCacheItem };\n                }\n                if (\n                    existingCacheItem &&\n                    existingCacheItem.item &&\n                    (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&\n                    // @ts-ignore\n                    (typeof existingCacheItem.item !== 'object' || (existingCacheItem && existingCacheItem.item['$ref'] !== true))\n                ) {\n                    // @ts-ignore\n                    cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;\n                } else {\n                    // @ts-ignore\n                    cacheEntries[dataServiceRequest._cacheKeyFromInput] = {\n                        $ref: true,\n                        // @ts-ignore\n                        type: dataServiceRequest._cacheObjectType,\n                        // @ts-ignore\n                        identifier: dataServiceRequest._cacheKeyIdentifierFromReturnType,\n                        key: [key],\n                        // @ts-ignore\n                        count: dataServiceRequest._totalCount\n                    };\n                }\n            }\n        } else {\n            // @ts-ignore\n            cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;\n        }\n        // @ts-ignore\n    } else if (!dataServiceRequest._cacheKeyIdentifierFromReturnType) {\n        // @ts-ignore\n        cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;\n    } else {\n        const cacheValue = results\n            // @ts-ignore\n            .map(result => {\n                // @ts-ignore\n                const identifierValue = result[dataServiceRequest._cacheKeyIdentifierFromReturnType];\n                if (identifierValue) {\n                    // @ts-ignore\n                    const key = `${dataServiceRequest._cacheKeyIdentifierFromReturnType}-${identifierValue}`;\n                    // @ts-ignore\n                    cacheEntries[key] = result;\n                    return key;\n                }\n            })\n            .filter(Boolean);\n        let existingCacheItem = requestCache.get({\n            // @ts-ignore\n            typeName: dataServiceRequest._cacheObjectType,\n            // @ts-ignore\n            key: dataServiceRequest._cacheKeyFromInput\n        });\n        if (existingCacheItem) {\n            existingCacheItem = { ...existingCacheItem };\n        }\n        if (\n            existingCacheItem &&\n            existingCacheItem.item &&\n            (!(existingCacheItem.item instanceof AsyncResult) || existingCacheItem.item.status === 'SUCCESS') &&\n            // @ts-ignore\n            (typeof existingCacheItem.item !== 'object' || (existingCacheItem && existingCacheItem.item['$ref'] !== true))\n        ) {\n            // @ts-ignore\n            cacheEntries[dataServiceRequest._cacheKeyFromInput] = results;\n        } else {\n            // @ts-ignore\n            cacheEntries[dataServiceRequest._cacheKeyFromInput] = {\n                $ref: true,\n                // @ts-ignore\n                type: existingCacheItem._cacheObjectType,\n                // @ts-ignore\n                identifier: existingCacheItem._cacheKeyIdentifierFromReturnType,\n                // @ts-ignore\n                isCollection: existingCacheItem._query.isReturnTypeACollection,\n                key: cacheValue,\n                // @ts-ignore\n                count: existingCacheItem._totalCount\n            };\n        }\n    }\n\n    if (cacheEntries) {\n        Object.keys(cacheEntries).map(entryKey => {\n            // @ts-ignore\n            requestCache.put({ typeName: dataServiceRequest._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });\n\n            if (appCache && isCacheTypeApplication) {\n                // @ts-ignore\n                appCache.put({ typeName: dataServiceRequest._cacheObjectType, key: entryKey }, { item: cacheEntries[entryKey] });\n            }\n        });\n    }\n\n    return cacheEntries;\n};\n\nexport const saveCacheEntries = (\n    dataServiceRequest: DataServiceRequest,\n    data: AsyncResult<any> | any,\n    requestCache: ICache,\n    appCache: ICache,\n    isCacheTypeApplication: boolean\n): { [cacheKey: string]: any } | undefined => {\n    // if return Entity is collection\n    //        if entity type has identifier/primary key\n    //              1. cache array of primay key value of returned entity collection on input cache key\n    //              2. cache individual entity on primary key\n    //        else\n    //              1. cache output on input cache key\n    //\n    // else  if entity type has identifier/primary key\n    //           2. cache output entity on primary key\n    if (\n        !data ||\n        // @ts-ignore\n        (!dataServiceRequest._cacheKeyFromInput && !dataServiceRequest._cacheKeyIdentifierFromReturnType) ||\n        // @ts-ignore\n        !dataServiceRequest._cacheObjectType\n    ) {\n        return;\n    }\n\n    if (data instanceof AsyncResult) {\n        // For a loading Promise, cache based on input cachekey, and then cache output again once complete\n        if (data.status === 'LOADING') {\n            data.then(result => {\n                // @ts-ignore\n                if (dataServiceRequest._totalCount !== undefined) {\n                    // @ts-ignore\n                    data.metadata.count = dataServiceRequest._totalCount;\n                }\n\n                _saveEntityToCache(dataServiceRequest, result, requestCache, appCache, isCacheTypeApplication);\n                return result;\n            });\n            // @ts-ignore\n            requestCache.put({ typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput }, { item: data });\n\n            if (appCache && isCacheTypeApplication) {\n                // @ts-ignore\n                appCache.put({ typeName: dataServiceRequest._cacheObjectType, key: dataServiceRequest._cacheKeyFromInput }, { item: data });\n            }\n            // For a completed promise, save the action results to the cache\n        } else {\n            // @ts-ignore\n            if (dataServiceRequest._totalCount !== undefined) {\n                // @ts-ignore\n                data.metadata.count = dataServiceRequest._totalCount;\n            }\n\n            _saveEntityToCache(dataServiceRequest, data.result, requestCache, appCache, isCacheTypeApplication);\n            return data.result;\n        }\n    } else {\n        return _saveEntityToCache(dataServiceRequest, data, requestCache, appCache, isCacheTypeApplication);\n    }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
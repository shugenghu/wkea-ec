{"ast":null,"code":"import\"core-js/modules/es.regexp.to-string.js\";import\"core-js/modules/es.string.split.js\";import\"core-js/modules/web.dom-collections.iterator.js\";import{nodeListToArray}from'../utilities/htmlExtensions';import{format,trim}from'../utilities/stringExtensions';import{TtmlContext}from'./ttml-context';import{TtmlSettings,xmlNS}from'./ttml-settings';import{TtmlTimeParser}from'./ttml-time-parser';export class TtmlParser{static getLocalTagName(node){return node.localName||node.baseName;}static getAttributeNS(element,name,namespace){let result=element.getAttributeNS(namespace,name);if(!result){for(const attribute of nodeListToArray(element.attributes)){if(attribute.localName===name&&attribute.lookupNamespaceURI(attribute.prefix)===namespace){result=attribute.value;break;}}}return result;}static parse(ttmlDocument,settingsOverrides){ttmlDocument=typeof ttmlDocument==='string'?TtmlParser._parseXml(ttmlDocument):ttmlDocument;const ttmlContext=new TtmlContext();ttmlContext.settings=new TtmlSettings(settingsOverrides);ttmlContext.root=TtmlParser._verifyRoot(ttmlDocument,ttmlContext);ttmlContext.body=TtmlParser._getFirstElementByTagNameNS(ttmlContext.root,'body',ttmlContext.settings.ttmlNamespace);ttmlContext.events=[];ttmlContext.styleSetCache=[];if(ttmlContext.body){TtmlParser._parseTtAttrs(ttmlContext);const head=TtmlParser._ensureRegions(ttmlContext);const timeBase=TtmlParser.getAttributeNS(ttmlContext.root,'timeBase',ttmlContext.settings.ttmlParameterNamespace)||'media';if(ttmlContext.settings.supportedTimeBase.indexOf(timeBase)!==-1){TtmlParser._processAnonymousSpans(ttmlContext,ttmlContext.body);const timeParser=new TtmlTimeParser(ttmlContext.settings.mediaFrameRate,ttmlContext.settings.mediaTickRate);TtmlParser._applyTiming(ttmlContext,ttmlContext.root,{start:TtmlParser.mediaStart,end:TtmlParser.mediaEnd},true,timeParser);TtmlParser._applyStyling(ttmlContext,head);}ttmlContext.events.push({time:TtmlParser.mediaEnd,element:undefined});ttmlContext.events.sort((event1,event2)=>{return event1.time-event2.time;});}return ttmlContext;}static applyInlineStyles(settings,styleSet,element){for(const attribute of nodeListToArray(element.attributes)){if(attribute.namespaceURI===settings.ttmlStyleNamespace){styleSet[TtmlParser.getLocalTagName(attribute)]=trim(attribute.nodeValue);}}}static _parseXml(xmlString){let xml;if(window.DOMParser){const domParser=new window.DOMParser();xml=domParser.parseFromString(xmlString,'application/xml');}else{const domParser=new window.ActiveXObject('Microsoft.XMLDOM');domParser.async=false;domParser.loadXML(xmlString);xml=domParser;}return xml;}static _verifyRoot(ttmlDocument,ttmlContext){let root;const candidate=ttmlDocument.documentElement;if(TtmlParser.getLocalTagName(candidate)==='tt'){if(candidate.namespaceURI!=='http://www.w3.org/ns/ttml'){ttmlContext.settings.ttmlNamespace=candidate.namespaceURI;ttmlContext.settings.ttmlStyleNamespace=\"\".concat(ttmlContext.settings.ttmlNamespace,\"#styling\");ttmlContext.settings.ttmlParameterNamespace=\"\".concat(ttmlContext.settings.ttmlNamespace,\"#parameter\");ttmlContext.settings.ttmlMetaNamespace=\"\".concat(ttmlContext.settings.ttmlNamespace,\"#metadata\");}root=candidate;}return root;}static _parseTtAttrs(ttmlContext){const cellRes=TtmlParser.getAttributeNS(ttmlContext.root,'cellResolution',ttmlContext.settings.ttmlParameterNamespace);const extent=TtmlParser.getAttributeNS(ttmlContext.root,'extent',ttmlContext.settings.ttmlStyleNamespace);let cellGrid=null;if(cellRes){const parts=trim(cellRes).split(/\\s+/);if(parts.length===2){const columns=Math.round(parseFloat(parts[0]));const rows=Math.round(parseFloat(parts[1]));if(rows>0&&columns>0){cellGrid={rows:rows,columns:columns};}}}if(cellGrid){ttmlContext.settings.cellResolution=cellGrid;}if(extent){if(extent!=='auto'){const coords=extent.split(/\\s+/);if(coords.length===2&&coords[0].substr(coords[0].length-2)==='px'&&coords[1].substr(coords[1].length-2)==='px'){const width=parseFloat(coords[0].substr(0,coords[0].length-2));const height=parseFloat(coords[1].substr(0,coords[1].length-2));ttmlContext.settings.rootContainerRegionDimensions={width:Math.round(width),height:Math.round(height)};}}}}static _ensureRegions(ttmlContext){ttmlContext.rootContainerRegion=ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace,'rootcontainerregion');ttmlContext.root.appendChild(ttmlContext.rootContainerRegion);const extents=ttmlContext.settings.rootContainerRegionDimensions?format('{0}px {1}px',ttmlContext.settings.rootContainerRegionDimensions.width,ttmlContext.settings.rootContainerRegionDimensions.height):'auto';ttmlContext.rootContainerRegion.setAttributeNS(ttmlContext.settings.ttmlStyleNamespace,'extent',extents);let head=TtmlParser._getFirstElementByTagNameNS(ttmlContext.root,'head',ttmlContext.settings.ttmlNamespace);if(!head){head=ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace,'head');ttmlContext.root.appendChild(head);}ttmlContext.layout=TtmlParser._getFirstElementByTagNameNS(head,'layout',ttmlContext.settings.ttmlNamespace);if(!ttmlContext.layout){ttmlContext.layout=ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace,'layout');ttmlContext.root.appendChild(ttmlContext.layout);}const regions=ttmlContext.layout.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace,'region');if(!regions.length){const anonymousRegion=ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace,'region');anonymousRegion.setAttributeNS(xmlNS,'id','anonymous');anonymousRegion.setAttribute('data-isanonymous','1');ttmlContext.layout.appendChild(anonymousRegion);ttmlContext.body.setAttributeNS(ttmlContext.settings.ttmlNamespace,'region','anonymous');}return head;}static _processAnonymousSpans(ttmlContext,element){if(TtmlParser._isTagNS(element,'p',ttmlContext.settings.ttmlNamespace)){const textNodeGroups=[];let prevNodeType=0;for(const child of nodeListToArray(element.childNodes)){if(child.nodeType===Node.TEXT_NODE){if(prevNodeType!==Node.TEXT_NODE){textNodeGroups.push([]);}textNodeGroups[textNodeGroups.length-1].push(child);}prevNodeType=child.nodeType;}for(const group of textNodeGroups){const anonSpan=ttmlContext.root.ownerDocument.createElementNS(ttmlContext.settings.ttmlNamespace,'span');anonSpan.appendChild(group[0].parentNode.replaceChild(anonSpan,group[0]));for(let index=1;index<group.length;index++){anonSpan.appendChild(group[index]);}}}for(const child of nodeListToArray(element.childNodes)){this._processAnonymousSpans(ttmlContext,child);}}static _applyTiming(ttmlContext,element,bound,isParallelContext,timeParser){const beginAttribute=TtmlParser.getAttributeNS(element,'begin',ttmlContext.settings.ttmlNamespace);let startTime=beginAttribute?timeParser.parse(beginAttribute):bound.start;let endTime=0;let duration=0;let end=0;const durationAttribute=TtmlParser.getAttributeNS(element,'dur',ttmlContext.settings.ttmlNamespace);const endAttribute=TtmlParser.getAttributeNS(element,'end',ttmlContext.settings.ttmlNamespace);if(!durationAttribute&&!endAttribute){if(isParallelContext){if(startTime<=bound.end){endTime=bound.end;}else{endTime=0;}}}else if(durationAttribute&&endAttribute){duration=timeParser.parse(durationAttribute);end=timeParser.parse(endAttribute);const minEnd=Math.min(startTime+duration,bound.start+end);endTime=Math.min(minEnd,bound.end);}else if(endAttribute){end=timeParser.parse(endAttribute);endTime=Math.min(bound.start+end,bound.end);}else{duration=timeParser.parse(durationAttribute);endTime=Math.min(startTime+duration,bound.end);}if(endTime<startTime){endTime=startTime;}startTime=Math.floor(startTime);endTime=Math.floor(endTime);element.setAttribute('data-time-start',startTime.toString());element.setAttribute('data-time-end',endTime.toString());if(startTime>=0&&ttmlContext.events.filter(event=>{return event.time===startTime;}).length<=0){ttmlContext.events.push({time:startTime,element:element});}let start=startTime;for(const child of nodeListToArray(element.childNodes)){if(child.nodeType===Node.ELEMENT_NODE){if(TtmlParser.getAttributeNS(element,'timeContainer',ttmlContext.settings.ttmlNamespace)!=='seq'){this._applyTiming(ttmlContext,child,{start:startTime,end:endTime},true,timeParser);}else{this._applyTiming(ttmlContext,child,{start:start,end:endTime},false,timeParser);start=parseInt(child.getAttribute('data-time-end'),10);}}}}static _applyStyling(ttmlContext,head){const styling=TtmlParser._getFirstElementByTagNameNS(head,'styling',ttmlContext.settings.ttmlNamespace);const styles=styling?nodeListToArray(styling.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace,'style')):[];for(const element of nodeListToArray(ttmlContext.root.querySelectorAll('*'))){this._applyStyle(ttmlContext,element,styles);}}static _applyStyle(ttmlContext,element,styles){const styleSet={};this._applyStylesheet(ttmlContext.settings,styleSet,element,styles);TtmlParser.applyInlineStyles(ttmlContext.settings,styleSet,element);let empty=true;for(const style in styleSet){if(styleSet.hasOwnProperty(style)){empty=false;break;}}if(!empty){element.setAttribute('data-styleSet',ttmlContext.styleSetCache.length.toString());ttmlContext.styleSetCache.push(styleSet);}}static _applyStylesheet(settings,styleSet,element,styles){const styleAttribute=TtmlParser.getAttributeNS(element,'style',settings.ttmlNamespace);const ids=styleAttribute?styleAttribute.split(/\\s+/):[];for(const styleId of ids){for(const style of styles){if(TtmlParser.getAttributeNS(style,'id',xmlNS)===styleId){this._applyStylesheet(settings,styleSet,style,styles);TtmlParser.applyInlineStyles(settings,styleSet,style);}}}if(TtmlParser._isTagNS(element,'region',settings.ttmlNamespace)){for(const style of nodeListToArray(element.getElementsByTagNameNS(settings.ttmlNamespace,'style'))){TtmlParser.applyInlineStyles(settings,styleSet,style);}}}static _isTagNS(element,tagName,namespace){return element.namespaceURI===namespace&&this.getLocalTagName(element)===tagName;}static _getFirstElementByTagNameNS(context,tagName,namespace){let result;if(context){const matches=context.getElementsByTagNameNS(namespace,tagName);if(matches&&matches.length){result=matches[0];}}return result;}}TtmlParser.mediaStart=-1;TtmlParser.mediaEnd=99999999;","map":{"version":3,"sources":["videoplayer/components/closed-captions/ttml-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {nodeListToArray} from '../utilities/htmlExtensions';\nimport {format, trim} from '../utilities/stringExtensions';\nimport {IDictionaryStringString, IGrid} from '../utilities/utilities';\nimport {ITtmlContext, TtmlContext} from './ttml-context';\nimport {ITtmlSettings, TtmlSettings, xmlNS} from './ttml-settings';\nimport {TtmlTimeParser} from './ttml-time-parser';\n\n// Timed Text Markup Language (TTML).\n// See http://www.w3.org/TR/ttml1/ for more details.\n\n/*\n* @interface ITtmlEvent\n* @classdesc - The ITtmlEvent interface contract.\n* @export\n*/\nexport interface ITtmlEvent {\n    time: number;\n    element?: Element;\n}\n\n/*\n* @interface ITtmlTimingBounds\n* @classdesc - The ITtmlTimingBounds interface contract.\n* @export\n*/\ninterface ITtmlTimingBounds {\n    start: number;\n    end: number;\n}\n\n/**\n *\n * The TtmlParser class.\n *\n */\n// tslint:disable-next-line: no-unnecessary-class\nexport class TtmlParser {\n    /*\n    * @name - mediaStart\n    * @description - Used as the start time for applyTiming when applying to the entire document.\n    * @static\n    * @private\n    * @type {number}\n    */\n    private static mediaStart: number  = -1;\n\n    /*\n    * @name - mediaEnd\n    * @description - Used as the end time for applyTiming when applying to the entire document.\n    *                Picking a number that should always be greater than any real media end time.\n    * @static\n    * @private\n    * @type {number}\n    */\n    private static mediaEnd: number = 99999999;\n\n    /*\n    * @name - getLocalTagName\n    * @description - Gets the local tagName of a Node.\n    * @static\n    * @public\n    * @param {Node} node - The node to get the tagName of.\n    * @returns {string} - The tagName.\n    */\n   public static getLocalTagName(node: Node): string {\n        // tslint:disable-next-line: no-any\n        return (<Element>node).localName || (<any>node).baseName;\n    }\n\n    /*\n    * @name - getAttributeNS\n    * @description - Gets the value of a namespaced attribute. First tries element.getAttributeNS() but falls back\n    *                to scanning each attribute if that fails.\n    *                If you know which cases go into the fallback code please document it here.\n    * @static\n    * @public\n    * @param {Element} element - The element to get the attribute of.\n    * @param {string} name - The attribute name.\n    * @param {string} namespace - The attribute namespace.\n    * @returns {string} - The attribute value. or an empty string if a matching attribute is not found.\n    */\n   public static getAttributeNS(element: Element, name: string, namespace: string): string {\n        let result = element.getAttributeNS(namespace, name);\n\n        if (!result) {\n            // Go through all the attributes looking for a match.\n            for (const attribute of nodeListToArray(element.attributes)) {\n                // tslint:disable-next-line: no-any\n                if (((<any>attribute).localName === name) && (attribute.lookupNamespaceURI((<any>attribute).prefix) === namespace)) {\n                    // tslint:disable-next-line: no-any\n                    result = (<any>attribute).value;\n                    break;\n                }\n            }\n        }\n\n        return result!;\n    }\n\n    /*\n    * @name - parse\n    * @description - Parses a ttml document and builds a ttmlContext instance from it.\n    * @static\n    * @public\n    * @param {XMLDocument} ttmlDocument - The ttml document to parse.\n    * @param {ITtmlSettings} settingsOverrides - The ttml settings overrides to use.\n    * @returns {ITtmlContext} - The resulting ttmlContext instance that can be used to get cues by time.\n    */\n    public static parse(ttmlDocument: XMLDocument, settingsOverrides: ITtmlSettings): ITtmlContext {\n        ttmlDocument = (typeof ttmlDocument === 'string') ? TtmlParser._parseXml(ttmlDocument) : ttmlDocument;\n\n        const ttmlContext = new TtmlContext();\n\n        // Start initializing the context.\n        ttmlContext.settings = new TtmlSettings(settingsOverrides);\n        ttmlContext.root = TtmlParser._verifyRoot(ttmlDocument, ttmlContext);\n        ttmlContext.body = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'body', ttmlContext.settings.ttmlNamespace);\n        ttmlContext.events = [];\n        ttmlContext.styleSetCache = [];\n\n        if (ttmlContext.body) {\n            // Parse the root <tt> attributes.\n            TtmlParser._parseTtAttrs(ttmlContext);\n\n            // Set up our regions.\n            const head = TtmlParser._ensureRegions(ttmlContext);\n\n            const timeBase = TtmlParser.getAttributeNS(\n                ttmlContext.root,\n                'timeBase',\n                ttmlContext.settings.ttmlParameterNamespace) || 'media';\n\n            if (ttmlContext.settings.supportedTimeBase.indexOf(timeBase) !== -1) {\n                // Process textnodes into anonymous spans.\n                TtmlParser._processAnonymousSpans(ttmlContext, ttmlContext.body);\n\n                const timeParser = new TtmlTimeParser(ttmlContext.settings.mediaFrameRate, ttmlContext.settings.mediaTickRate);\n\n                // Apply the intervals over the tree.\n                TtmlParser._applyTiming(\n                    ttmlContext,\n                    ttmlContext.root,\n                    { start: TtmlParser.mediaStart, end: TtmlParser.mediaEnd },\n                    true,\n                    timeParser);\n\n                // Apply the style inheritance over the tree.\n                TtmlParser._applyStyling(ttmlContext, head);\n            }\n\n            // Add an dummy end event for the captions to appear until end of video.\n            // Not sure why we need to do this, please add to this comment if you know.\n            ttmlContext.events.push({ time: TtmlParser.mediaEnd, element: undefined });\n\n            // Sort events into temporal order.\n            ttmlContext.events.sort((event1: ITtmlEvent, event2: ITtmlEvent) => {\n                return event1.time - event2.time;\n            });\n        }\n\n        return ttmlContext;\n    }\n\n    /*\n    * @name - applyInlineStyles\n    * @description - Applies the elements inline styles into the styleSet.\n    * @static\n    * @public\n    * @param {TtmlSettings} settings - The TtmlSettings for this document.\n    * @param {IDictionaryStringString} styleSet - The styleSet to build upon.\n    * @param {Element} element - The element to apply the styles of.\n    * @returns {void}\n    */\n   public static applyInlineStyles(settings: TtmlSettings, styleSet: IDictionaryStringString, element: Element): void {\n        for (const attribute of nodeListToArray(element.attributes)) {\n            if (attribute.namespaceURI === settings.ttmlStyleNamespace) {\n                // trim() because we see lots of ttml attribute values with trailing space...\n                styleSet[TtmlParser.getLocalTagName(attribute)] = trim(attribute.nodeValue!);\n            }\n        }\n    }\n\n    /*\n    * @name - parseXml\n    * @description - Parses an xml document in string format to an XMLDocument.\n    * @static\n    * @private\n    * @param {string} xmlString - The xml string to parse.\n    * @returns {XMLDocument} - The resulting XMLDocument, or null if the xml string failed to parse.\n    */\n    private static _parseXml(xmlString: string): XMLDocument {\n        let xml: XMLDocument;\n\n        // tslint:disable-next-line: no-any\n        if ((<any>window).DOMParser) {\n            // tslint:disable-next-line: no-any\n            const domParser = new (<any>window).DOMParser();\n            xml = domParser.parseFromString(xmlString, 'application/xml');\n        } else {\n            // tslint:disable-next-line: no-any\n            const domParser = new (<any>window).ActiveXObject('Microsoft.XMLDOM');\n            domParser.async = false;\n            domParser.loadXML(xmlString);\n            xml = <XMLDocument>domParser;\n        }\n        return xml;\n    }\n\n    /*\n    * @name - verifyRoot\n    * @description - Verifies that root <tag> of the specified document is the expected ttml <tt> tagName and\n    *                updates the settings namespaces from it if they are non standard.\n    * @static\n    * @private\n    * @param {XMLDocument} ttmlDocument - The ttml document to verify.\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {Element} - The valid root Element, or or null if the root Element was not valid.\n    */\n    private static _verifyRoot(ttmlDocument: XMLDocument, ttmlContext: TtmlContext): Element {\n        let root: Element;\n        const candidate = ttmlDocument.documentElement;\n\n        if (TtmlParser.getLocalTagName(candidate) === 'tt') {\n            // tslint:disable-next-line: no-http-string\n            if (candidate.namespaceURI !== 'http://www.w3.org/ns/ttml') {\n                ttmlContext.settings.ttmlNamespace = candidate.namespaceURI!;\n                ttmlContext.settings.ttmlStyleNamespace = `${ttmlContext.settings.ttmlNamespace}#styling`;\n                ttmlContext.settings.ttmlParameterNamespace = `${ttmlContext.settings.ttmlNamespace}#parameter`;\n                ttmlContext.settings.ttmlMetaNamespace = `${ttmlContext.settings.ttmlNamespace}#metadata`;\n            }\n\n            root = candidate;\n        }\n\n        return root!;\n    }\n\n    /*\n    * @name - parseTtAttrs\n    * @description - Parses the <tt> tag attributes and initializes ttmlContext properties from them.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {void}\n    */\n    private static _parseTtAttrs(ttmlContext: TtmlContext): void {\n        const cellRes = TtmlParser.getAttributeNS(ttmlContext.root, 'cellResolution', ttmlContext.settings.ttmlParameterNamespace);\n        const extent = TtmlParser.getAttributeNS(ttmlContext.root, 'extent', ttmlContext.settings.ttmlStyleNamespace);\n        let cellGrid: IGrid | null = null;\n\n        if (cellRes) {\n            const parts = trim(cellRes).split(/\\s+/);\n\n            if (parts.length === 2) {\n                const columns = Math.round(parseFloat(parts[0]));\n                const rows = Math.round(parseFloat(parts[1]));\n\n                if ((rows > 0) && (columns > 0)) {\n                    cellGrid = { rows: rows, columns: columns };\n                }\n            }\n        }\n\n        if (cellGrid) {\n            ttmlContext.settings.cellResolution = cellGrid;\n        }\n\n        if (extent) {\n            if (extent !== 'auto') {\n                // Get the individual components.\n                const coords = extent.split(/\\s+/);\n\n                if ((coords.length === 2) &&\n                    (coords[0].substr(coords[0].length - 2) === 'px') &&\n                    (coords[1].substr(coords[1].length - 2) === 'px')) {\n                    const width = parseFloat(coords[0].substr(0, coords[0].length - 2));\n                    const height = parseFloat(coords[1].substr(0, coords[1].length - 2));\n\n                    // Round to integer.\n                    ttmlContext.settings.rootContainerRegionDimensions = { width: Math.round(width), height: Math.round(height) };\n                }\n            }\n        }\n\n    }\n\n    /*\n    * @name - ensureRegions\n    * @description - Ensures we have the elements/regions we require by either finding them or creating them if they are not present.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @returns {Element} - The <head> element.\n    */\n    private static _ensureRegions(ttmlContext: TtmlContext): Element {\n        // Create our rootContainerRegion\n        ttmlContext.rootContainerRegion = <Element>ttmlContext.root.ownerDocument!.createElementNS(\n            ttmlContext.settings.ttmlNamespace, 'rootcontainerregion');\n\n        ttmlContext.root.appendChild(ttmlContext.rootContainerRegion);\n\n        const extents = ttmlContext.settings.rootContainerRegionDimensions ? format('{0}px {1}px',\n                                                                                    ttmlContext.settings.rootContainerRegionDimensions.width, ttmlContext.settings.rootContainerRegionDimensions.height) : 'auto';\n\n        ttmlContext.rootContainerRegion.setAttributeNS(ttmlContext.settings.ttmlStyleNamespace, 'extent', extents);\n\n        let head = TtmlParser._getFirstElementByTagNameNS(ttmlContext.root, 'head', ttmlContext.settings.ttmlNamespace);\n\n        // Ensure we have a <head>\n        if (!head) {\n            // No <head> so we need to create that now.\n            head = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'head');\n            ttmlContext.root.appendChild(head);\n        }\n\n        // Ensure we have a <layout>\n        ttmlContext.layout = TtmlParser._getFirstElementByTagNameNS(head, 'layout', ttmlContext.settings.ttmlNamespace);\n\n        if (!ttmlContext.layout) {\n            // No <layout> so we need to create that now.\n            ttmlContext.layout = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'layout');\n            ttmlContext.root.appendChild(ttmlContext.layout);\n        }\n\n        // Create an anonymous region if we have no regions.\n        const regions = ttmlContext.layout.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'region');\n\n        if (!regions.length) {\n            const anonymousRegion = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'region');\n\n            anonymousRegion.setAttributeNS(xmlNS, 'id', 'anonymous');\n            anonymousRegion.setAttribute('data-isanonymous', '1');\n            ttmlContext.layout.appendChild(anonymousRegion);\n\n            ttmlContext.body.setAttributeNS(ttmlContext.settings.ttmlNamespace, 'region', 'anonymous');\n        }\n\n        return head;\n    }\n\n    /*\n    * @name - processAnonymousSpans\n    * @description - Recurses through all the <p> elements in the document and groups all the contiguous TEXT_NODES together into <span>'s\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to process the TEXT_NODES of.\n    * @returns {void}\n    */\n    private static _processAnonymousSpans(ttmlContext: TtmlContext, element: Element): void {\n        // If this element is <p> then group all contiguous textnodes together in <span>\n        if (TtmlParser._isTagNS(element, 'p', ttmlContext.settings.ttmlNamespace)) {\n            const textNodeGroups: Node[][] = [];\n            let prevNodeType: number = 0;\n\n            for (const child of nodeListToArray(element.childNodes)) {\n                if (child.nodeType === Node.TEXT_NODE) {\n                    if (prevNodeType !== Node.TEXT_NODE) {\n                        textNodeGroups.push([]);\n                    }\n\n                    textNodeGroups[textNodeGroups.length - 1].push(child);\n                }\n\n                prevNodeType = child.nodeType;\n            }\n\n            for (const group of textNodeGroups) {\n                const anonSpan = ttmlContext.root.ownerDocument!.createElementNS(ttmlContext.settings.ttmlNamespace, 'span');\n\n                anonSpan.appendChild(group[0].parentNode!.replaceChild(anonSpan, group[0]));\n\n                for (let index = 1; index < group.length; index++) {\n                    anonSpan.appendChild(group[index]);\n                }\n            }\n        }\n\n        // Then recurse through the contents doing the same thing for those.\n        for (const child of nodeListToArray<Element>(element.childNodes)) {\n            this._processAnonymousSpans(ttmlContext, child);\n        }\n    }\n\n    /*\n    * @name - applyTiming\n    * @description - Recurses through the document element tree to determine the absolute start and end times of all the elements\n    *                using the TTML subset of the SMIL timing model. The reference times passed in 'bound' are absolute times.\n    *                The result of calling this is to set the local start time and end time to absolute times between these two\n    *                reference times, based on the begin, end and dur attributes and to recursively set all of the children.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to apply the timing to.\n    * @param {ITtmlTimingBounds} bound - The bounds for the timing.\n    * @param {boolean} isParallelContext - Indicates whether or not this element is in a parallel timing context.\n    * @param {TtmlTimeParser} timeParser - The TtmlTimeParser to use to parse this elements time attributes.\n    * @returns {void}\n    */\n    private static _applyTiming(\n        ttmlContext: TtmlContext,\n        element: Element,\n        bound: ITtmlTimingBounds,\n        isParallelContext: boolean,\n        timeParser: TtmlTimeParser): void {\n        const beginAttribute = TtmlParser.getAttributeNS(element, 'begin', ttmlContext.settings.ttmlNamespace);\n        let startTime = beginAttribute ? timeParser.parse(beginAttribute) : bound.start;\n        let endTime = 0;\n\n        // Compute the simple duration of the interval.\n        let duration = 0;\n        let end = 0;\n        const durationAttribute = TtmlParser.getAttributeNS(element, 'dur', ttmlContext.settings.ttmlNamespace);\n        const endAttribute = TtmlParser.getAttributeNS(element, 'end', ttmlContext.settings.ttmlNamespace);\n\n        if ((!durationAttribute) && (!endAttribute)) {\n            // No direct timing attested, so use default based on context.\n            // Parallel children have indefinite default duration, truncated by bounds.\n            if (isParallelContext) {\n                // Sequential children have zero default duration.\n                if (startTime <= bound.end) {\n                    endTime = bound.end;\n                } else {\n                    endTime = 0;\n                }\n            }\n        } else if (durationAttribute && endAttribute) {\n            // Both duration and end attested, the minimum interval applies.\n            duration = timeParser.parse(durationAttribute);\n            end = timeParser.parse(endAttribute);\n            const minEnd = Math.min(startTime + duration, bound.start + end);\n            endTime = Math.min(minEnd, bound.end);\n        } else if (endAttribute) {\n            // Only end attested.\n            end = timeParser.parse(endAttribute);\n            endTime = Math.min(bound.start + end, bound.end);\n        } else {\n            // Only dur attested.\n            duration = timeParser.parse(durationAttribute);\n            endTime = Math.min(startTime + duration, bound.end);\n        }\n\n        if (endTime < startTime) {\n            endTime = startTime;\n        }\n\n        startTime = Math.floor(startTime);\n        endTime = Math.floor(endTime);\n\n        element.setAttribute('data-time-start', startTime.toString());\n        element.setAttribute('data-time-end', endTime.toString());\n\n        if ((startTime >= 0) && (ttmlContext.events.filter((event) => { return event.time === startTime; }).length <= 0)) {\n            ttmlContext.events.push({ time: startTime, element: element });\n        }\n\n        let start = startTime;\n\n        for (const child of nodeListToArray<Element>(element.childNodes)) {\n            if (child.nodeType === Node.ELEMENT_NODE) {\n                // Parallel is the default so null is OK here.\n                if (TtmlParser.getAttributeNS(element, 'timeContainer', ttmlContext.settings.ttmlNamespace) !== 'seq') {\n                    this._applyTiming(ttmlContext, child, { start: startTime, end: endTime }, true, timeParser);\n                } else {\n                    this._applyTiming(ttmlContext, child, { start: start, end: endTime }, false, timeParser);\n                    start = parseInt(child.getAttribute('data-time-end')!, 10);\n                }\n            }\n        }\n    }\n\n    /*\n    * @name - applyStyling\n    * @description - Recurses through all the elements in <head> applying the ttml sytling to them based on the <style>'s.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} head - The element to process the TEXT_NODES of.\n    * @returns {void}\n    */\n    private static _applyStyling(ttmlContext: TtmlContext, head: Element): void {\n        // First find all the <style>'s\n        const styling = TtmlParser._getFirstElementByTagNameNS(head, 'styling', ttmlContext.settings.ttmlNamespace);\n        const styles = styling ? nodeListToArray(styling.getElementsByTagNameNS(ttmlContext.settings.ttmlNamespace, 'style')) : [];\n\n        // Apply the styles to every element in the body\n        for (const element of nodeListToArray(ttmlContext.root.querySelectorAll('*'))) {\n            this._applyStyle(ttmlContext, <Element>element, <Element[]>styles);\n        }\n    }\n\n    /*\n    * @name - applyStyle\n    * @description - Applies the ttml styling to the specified element.\n    *                Apply styles in the correct order to element by building a styleSet, adding it\n    *                to the stlyeSetCache, and the adding reference to the cached styleSet to the element.\n    * @static\n    * @private\n    * @param {TtmlContext} ttmlContext - The ttmlContext for this document.\n    * @param {Element} element - The element to apply the ttml styling to.\n    * @param {Element[]} styles - The set of styles to apply.\n    * @returns {void}\n    */\n    private static _applyStyle(ttmlContext: TtmlContext, element: Element, styles: Element[]): void {\n        const styleSet: IDictionaryStringString = {};\n\n        // Find all the applicable styles and set them as properties on styleSet.\n        this._applyStylesheet(ttmlContext.settings, styleSet, element, styles);\n        TtmlParser.applyInlineStyles(ttmlContext.settings, styleSet, element);\n\n        let empty = true;\n\n        // tslint:disable-next-line: no-for-in\n        for (const style in styleSet) {\n            // Just need to see if there's at least one.\n            if (styleSet.hasOwnProperty(style)) {\n                empty = false;\n                break;\n            }\n        }\n\n        if (!empty) {\n            // Record the applied set to the element.\n            element.setAttribute('data-styleSet', ttmlContext.styleSetCache.length.toString());\n            ttmlContext.styleSetCache.push(styleSet);\n        }\n    }\n\n    /*\n    * @name - applyStylesheet\n    * @description - For each style id on the element, find the corresponding style element and then\n    *                apply the stylesheet into styleset; this recurses over the tree of referenced styles.\n    * @static\n    * @private\n    * @param {TtmlSettings} settings - The TtmlSettings for this document.\n    * @param {IDictionaryStringString} styleSet - The styleSet to build upon.\n    * @param {Element} element - The element to apply the styles of.\n    * @param {Element[]} styles - The set of styles to apply.\n    * @returns {void}\n    */\n    private static _applyStylesheet(settings: TtmlSettings, styleSet: IDictionaryStringString, element: Element, styles: Element[]): void {\n        // Find all the style ID references.\n        const styleAttribute = TtmlParser.getAttributeNS(element, 'style', settings.ttmlNamespace);\n        const ids = styleAttribute ? styleAttribute.split(/\\s+/) : [];\n\n        for (const styleId of ids) {\n            for (const style of styles) {\n                // Filter on those whose id is the one we want.\n                if (TtmlParser.getAttributeNS(style, 'id', xmlNS) === styleId) {\n                    // Recurse into its style references.\n                    this._applyStylesheet(settings, styleSet, style, styles);\n\n                    // Do inline styles.\n                    TtmlParser.applyInlineStyles(settings, styleSet, style);\n                }\n            }\n        }\n\n        // If the element is a region do nested styles. NOTE regions can only be referenced from elements in the body.\n        if (TtmlParser._isTagNS(element, 'region', settings.ttmlNamespace)) {\n            // Find all the style elements in the TTML namespace.\n            for (const style of nodeListToArray(element.getElementsByTagNameNS(settings.ttmlNamespace, 'style'))) {\n                TtmlParser.applyInlineStyles(settings, styleSet, <Element>style);\n            }\n        }\n    }\n\n    /*\n    * @name - isTagNS\n    * @description - Determines whether or not the namespace and local tagName of an element matches\n    *                the specified namespace and tag name.\n    * @static\n    * @private\n    * @param {Element} element - The node to compare against.\n    * @param {string} tagName - The tag name.\n    * @param {string} namespace - The attribute namespace.\n    * @returns {boolean} - True if the elements ns/tagName match, otherwise false.\n    */\n    private static _isTagNS(element: Element, tagName: string, namespace: string): boolean {\n        return ((element.namespaceURI === namespace) && this.getLocalTagName(element) === tagName);\n    }\n\n    /*\n    * @name - getFirstElementByTagNameNS\n    * @description - Gets the first matching element that matches the specified tagName and namespace.\n    * @static\n    * @private\n    * @param {Element} context - The context to search within.\n    * @param {string} tagName - The tagName to match.\n    * @param {string} namespace - The namespace to match.\n    * @returns {Element} - The first matching element found, or null if there are no matches.\n    */\n    private static _getFirstElementByTagNameNS(context: Element, tagName: string, namespace: string): Element {\n        let result: Element;\n        if (context) {\n            const matches = context.getElementsByTagNameNS(namespace, tagName);\n\n            if (matches && matches.length) {\n                result = matches[0];\n            }\n        }\n\n        return result!;\n    }\n}"],"sourceRoot":"./src/"},"metadata":{},"sourceType":"module"}
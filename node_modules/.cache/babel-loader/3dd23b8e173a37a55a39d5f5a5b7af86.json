{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{EMPTY,hasElements}from'../extensions/StringExtensions';import{RetailLogger,Tracer}from'../logging';import{ErrorHelper,ErrorTypeEnum}from'./ErrorHelper';import{ProxyError}from'./ProxyError';/**\r\n * Error parser class.\r\n */export var ErrorParser=/*#__PURE__*/function(){function ErrorParser(){_classCallCheck(this,ErrorParser);}_createClass(ErrorParser,null,[{key:\"parseErrorMessage\",/**\r\n     * Parses an error message.\r\n     *\r\n     * @param {any} error The error message.\r\n     * @return {ProxyError[]} The collection of error messages.\r\n     */value:function parseErrorMessage(error){var response=error.response;var errors=[];if(response){var handled=true;Tracer.Information(\"Server response status code is '\".concat(response.statusCode,\"'\"));switch(response.statusCode){case 306:// Custom - Redirection\nvar redirectUrl=response.headers['Location'];error.redirectUrl=redirectUrl;errors=[new ProxyError(ErrorTypeEnum.RETAIL_SERVER_REDIRECT_ERROR,response.statusText,EMPTY,false,error)];break;case 401:// Unauthorized (Generally Expired Token)\nif(process.env.CURRENT_ENVIRONMENT==='web'){var redirectCountQueryString='rdc';var noRedirectQueryString='noredirect';try{var currentUrl=new URL(location.href);if(currentUrl.searchParams.get(noRedirectQueryString)){break;}var rdc=parseInt(currentUrl.searchParams.get(redirectCountQueryString),10)||0;if(rdc&&rdc>=3){break;}currentUrl.searchParams.set(redirectCountQueryString,\"\".concat(rdc+1));location.href=currentUrl.href;}catch(e){break;}}break;case 408:// Request Timeout\nerrors=[new ProxyError(ErrorTypeEnum.SERVER_TIMEOUT,response.statusText,EMPTY,false,error)];break;case 0:// WWAHost reports status code as 0, If server is unreachable.\ncase 502:// Bad Gateway\ncase 503:// Service Unavailable\ncase 504:// Gateway timeout\nerrors=[new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE,response.statusText,EMPTY,false,error)];break;default:handled=false;}if(!handled){errors=ErrorParser.parseError(error);}}// If we couldn't create any error object from error message, add error parsing failure\nif(!errors||!errors.length){errors=[new ProxyError(ErrorTypeEnum.SERVER_ERROR,'Could not parse error message sent by the server.',EMPTY,false,error)];}return errors;}/**\r\n     * Parses an error message sent from Hardware station.\r\n     *\r\n     * @param {any} error The error message.\r\n     * @retunrs {ProxyError[]} The collection of error messages.\r\n     */},{key:\"parseHardwareStationErrorMessage\",value:function parseHardwareStationErrorMessage(error){var errors=[];if(error){try{var response=error.responseText;if(response){var jsonResponse=JSON.parse(response);// Parse errors in json format\nif(jsonResponse){errors=[new ProxyError(jsonResponse.ErrorResourceId?jsonResponse.ErrorResourceId:ErrorTypeEnum.SERVER_ERROR,jsonResponse.Message||'',EMPTY,false,error)];}else{// If not in json, we cannot parse it\nerrors=[new ProxyError(ErrorTypeEnum.SERVER_ERROR,'The value of Content-Type on server response is not supported.',EMPTY,false,error)];}}else{// In case we don't have a body, we don't know the error message but from http status\nerrors=[ErrorHelper.MapResponseStatusCodeToError(error.statusText,error.status,error)];}}catch(ex){var errorMessage=\"parseHardwareStationErrorMessage: Failed parse error message '\".concat(ex.message,\"'.\");Tracer.Error(errorMessage,ex);}}// If we couldn't create any error object from error message, add error parsing failure\nif(!errors||!errors.length){errors=[new ProxyError(ErrorTypeEnum.SERVER_ERROR,'Could not parse error message sent by the server.',EMPTY,false,error)];}return errors;}},{key:\"parseJSONError\",value:function parseJSONError(errorString,errorResponse){var commerceErrors=[];try{var odataError=JSON.parse(errorString);odataError.CorrelationId=errorResponse.data.CorrelationId;// assign parsed data to errorResponse\nerrorResponse.data=odataError;// due to odata json format limitation, a collection of errors is provided in the message field\nvar localizedMessage=odataError.LocalizedMessage;var exceptionType=odataError.ErrorResourceId;if(exceptionType===ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR){commerceErrors=[new ProxyError(ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR,localizedMessage||'Server failed with uncaught exception. Please report this failure.',localizedMessage,false,errorResponse)];}else if(localizedMessage!=null&&exceptionType!=null){commerceErrors=ErrorParser.convertExceptionToErrors(odataError,exceptionType,errorResponse);}else{throw new Error('Server exception is not in expected format.');}}catch(ex){var errorMessage='DataServiceRequest::parseJSONError: Invalid json format from server. It was not possible to parse error message. {0}';Tracer.Error(errorMessage,ex);}if(!hasElements(commerceErrors)){commerceErrors=[new ProxyError(ErrorTypeEnum.GENERICERRORMESSAGE,'Could not parse error message from server. Possible invalid OData request, please check your request.',EMPTY,false,errorResponse)];}return commerceErrors;}},{key:\"convertExceptionToErrors\",value:function convertExceptionToErrors(serverException,exceptionType,errorResponse){var errors=[];switch(exceptionType){// CartValidationExceptionType extends DataValidationExceptionType\ncase ErrorParser.DataValidationExceptionType:case ErrorParser.CartValidationExceptionType:var dataValidation=serverException;// json is in odata format, array has elements inside result member\nerrors=ErrorParser.getErrorsFromDataValidationFailures(dataValidation.ValidationResults);errors.push(new ProxyError(dataValidation.ErrorResourceId||ErrorTypeEnum.SERVER_ERROR,EMPTY,dataValidation.LocalizedMessage,false,errorResponse));break;case ErrorParser.StorageExceptionType:errors.push(new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE,EMPTY,serverException.LocalizedMessage,false,errorResponse));break;}if(errors.length===0){var error=new ProxyError(serverException.ErrorResourceId||ErrorTypeEnum.SERVER_ERROR,EMPTY,serverException.LocalizedMessage,false,errorResponse);error.commerceException=serverException;errors.push(error);}return errors;}},{key:\"getErrorsFromDataValidationFailures\",value:function getErrorsFromDataValidationFailures(failures){var errors=[];failures=failures||[];var _iterator=_createForOfIteratorHelper(failures),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var failure=_step.value;errors.push(new ProxyError(failure.ErrorResourceId||ErrorTypeEnum.SERVER_ERROR,failure.ErrorContext||'',failure.LocalizedMessage,false,{}));}}catch(err){_iterator.e(err);}finally{_iterator.f();}return errors;}/**\r\n     * Parses an error to get the error code and error message.\r\n     *\r\n     * @param {any} error The error message.\r\n     * @retunrs {ProxyError[]} The collection of error messages.\r\n     */},{key:\"parseError\",value:function parseError(error){var response=error.response;var errors=[];if(response.body&&response.data){// If we have a response body\nvar contentType=response.headers&&(response.headers['Content-Type']||response.headers['content-type'])||'';var bodyString=response.data.Exception;// Parse errors in json format\nif(contentType.toLowerCase().indexOf('application/json')!==-1){errors=ErrorParser.parseJSONError(bodyString,error.response);}else{var message=\"Server error has been received with unsupported content type: '\".concat(contentType,\"'.\");RetailLogger.genericWarning(message);}}// if we couldn't parse the errors from the body, we can only rely on status text and status code\nif(!hasElements(errors)){// In case we don't have a body, we don't know the error message but from http status code\nerrors=[ErrorHelper.MapResponseStatusCodeToError(response.statusText,response.statusCode,error)];}return errors;}}]);return ErrorParser;}();ErrorParser.DataValidationExceptionType='Microsoft.Dynamics.Commerce.Runtime.DataValidationException';ErrorParser.CartValidationExceptionType='Microsoft.Dynamics.Commerce.Runtime.CartValidationException';ErrorParser.StorageExceptionType='Microsoft.Dynamics.Commerce.Runtime.StorageException';","map":{"version":3,"sources":["../../src/exceptions/ErrorParser.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { CommerceException, DataValidationException, DataValidationFailure } from '../Entities/CommerceTypes.g';\nimport { EMPTY, hasElements } from '../extensions/StringExtensions';\nimport { RetailLogger, Tracer } from '../logging';\nimport { ErrorHelper, ErrorTypeEnum } from './ErrorHelper';\nimport { ProxyError } from './ProxyError';\n\n/**\n * Error parser class.\n */\nexport class ErrorParser {\n    private static DataValidationExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.DataValidationException';\n    private static CartValidationExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.CartValidationException';\n    private static StorageExceptionType: string = 'Microsoft.Dynamics.Commerce.Runtime.StorageException';\n\n    /**\n     * Parses an error message.\n     *\n     * @param {any} error The error message.\n     * @return {ProxyError[]} The collection of error messages.\n     */\n    public static parseErrorMessage(error: any): ProxyError[] {\n        const response = error.response;\n        let errors: ProxyError[] = [];\n        if (response) {\n            let handled = true;\n            Tracer.Information(`Server response status code is '${response.statusCode}'`);\n            switch (response.statusCode) {\n                case 306: // Custom - Redirection\n                    const redirectUrl = response.headers['Location'];\n                    error.redirectUrl = redirectUrl;\n                    errors = [new ProxyError(ErrorTypeEnum.RETAIL_SERVER_REDIRECT_ERROR, response.statusText, EMPTY, false, error)];\n                    break;\n\n                case 401: // Unauthorized (Generally Expired Token)\n                    if (process.env.CURRENT_ENVIRONMENT === 'web') {\n                        const redirectCountQueryString = 'rdc';\n                        const noRedirectQueryString = 'noredirect';\n                        try {\n                            const currentUrl = new URL(location.href);\n                            if (currentUrl.searchParams.get(noRedirectQueryString)) {\n                                break;\n                            }\n                            const rdc = parseInt(currentUrl.searchParams.get(redirectCountQueryString), 10) || 0;\n                            if (rdc && rdc >= 3) {\n                                break;\n                            }\n                            currentUrl.searchParams.set(redirectCountQueryString, `${rdc + 1}`);\n                            location.href = currentUrl.href;\n                        } catch (e) {\n                            break;\n                        }\n                    }\n\n                    break;\n\n                case 408: // Request Timeout\n                    errors = [new ProxyError(ErrorTypeEnum.SERVER_TIMEOUT, response.statusText, EMPTY, false, error)];\n                    break;\n\n                case 0: // WWAHost reports status code as 0, If server is unreachable.\n                case 502: // Bad Gateway\n                case 503: // Service Unavailable\n                case 504: // Gateway timeout\n                    errors = [new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, response.statusText, EMPTY, false, error)];\n                    break;\n\n                default:\n                    handled = false;\n            }\n\n            if (!handled) {\n                errors = ErrorParser.parseError(error);\n            }\n        }\n\n        // If we couldn't create any error object from error message, add error parsing failure\n        if (!errors || !errors.length) {\n            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];\n        }\n\n        return errors;\n    }\n\n    /**\n     * Parses an error message sent from Hardware station.\n     *\n     * @param {any} error The error message.\n     * @retunrs {ProxyError[]} The collection of error messages.\n     */\n    public static parseHardwareStationErrorMessage(error: any): ProxyError[] {\n        let errors: ProxyError[] = [];\n\n        if (error) {\n            try {\n                const response = error.responseText;\n\n                if (response) {\n                    const jsonResponse = JSON.parse(response);\n\n                    // Parse errors in json format\n                    if (jsonResponse) {\n                        errors = [\n                            new ProxyError(\n                                jsonResponse.ErrorResourceId ? jsonResponse.ErrorResourceId : ErrorTypeEnum.SERVER_ERROR,\n                                jsonResponse.Message || '',\n                                EMPTY,\n                                false,\n                                error\n                            )\n                        ];\n                    } else {\n                        // If not in json, we cannot parse it\n                        errors = [\n                            new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'The value of Content-Type on server response is not supported.', EMPTY, false, error)\n                        ];\n                    }\n                } else {\n                    // In case we don't have a body, we don't know the error message but from http status\n                    errors = [ErrorHelper.MapResponseStatusCodeToError(error.statusText, error.status, error)];\n                }\n            } catch (ex) {\n                const errorMessage: string = `parseHardwareStationErrorMessage: Failed parse error message '${ex.message}'.`;\n                Tracer.Error(errorMessage, ex);\n            }\n        }\n\n        // If we couldn't create any error object from error message, add error parsing failure\n        if (!errors || !errors.length) {\n            errors = [new ProxyError(ErrorTypeEnum.SERVER_ERROR, 'Could not parse error message sent by the server.', EMPTY, false, error)];\n        }\n\n        return errors;\n    }\n\n    public static parseJSONError(errorString: string, errorResponse?: any): ProxyError[] {\n        let commerceErrors: ProxyError[] = [];\n\n        try {\n            const odataError: any = JSON.parse(errorString);\n            odataError.CorrelationId = errorResponse.data.CorrelationId;\n\n            // assign parsed data to errorResponse\n            errorResponse.data = odataError;\n\n            // due to odata json format limitation, a collection of errors is provided in the message field\n            const localizedMessage: string = odataError.LocalizedMessage;\n            const exceptionType: string = odataError.ErrorResourceId;\n\n            if (exceptionType === ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR) {\n                commerceErrors = [\n                    new ProxyError(\n                        ErrorHelper.MICROSOFT_DYNAMICS_SERVER_INTERNAL_ERROR,\n                        localizedMessage || 'Server failed with uncaught exception. Please report this failure.',\n                        localizedMessage,\n                        false,\n                        errorResponse\n                    )\n                ];\n            } else if (localizedMessage != null && exceptionType != null) {\n                commerceErrors = ErrorParser.convertExceptionToErrors(odataError, exceptionType, errorResponse);\n            } else {\n                throw new Error('Server exception is not in expected format.');\n            }\n        } catch (ex) {\n            const errorMessage: string =\n                'DataServiceRequest::parseJSONError: Invalid json format from server. It was not possible to parse error message. {0}';\n            Tracer.Error(errorMessage, ex);\n        }\n\n        if (!hasElements(commerceErrors)) {\n            commerceErrors = [\n                new ProxyError(\n                    ErrorTypeEnum.GENERICERRORMESSAGE,\n                    'Could not parse error message from server. Possible invalid OData request, please check your request.',\n                    EMPTY,\n                    false,\n                    errorResponse\n                )\n            ];\n        }\n\n        return commerceErrors;\n    }\n\n    private static convertExceptionToErrors(serverException: CommerceException, exceptionType: string, errorResponse: any): ProxyError[] {\n        let errors: ProxyError[] = [];\n\n        switch (exceptionType) {\n            // CartValidationExceptionType extends DataValidationExceptionType\n            case ErrorParser.DataValidationExceptionType:\n            case ErrorParser.CartValidationExceptionType:\n                const dataValidation: DataValidationException = serverException as DataValidationException;\n                // json is in odata format, array has elements inside result member\n                errors = ErrorParser.getErrorsFromDataValidationFailures(dataValidation.ValidationResults as any);\n                errors.push(\n                    new ProxyError(dataValidation.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, EMPTY, dataValidation.LocalizedMessage, false, errorResponse)\n                );\n                break;\n\n            case ErrorParser.StorageExceptionType:\n                errors.push(new ProxyError(ErrorTypeEnum.SERVICE_UNAVAILABLE, EMPTY, serverException.LocalizedMessage, false, errorResponse));\n                break;\n        }\n\n        if (errors.length === 0) {\n            const error: ProxyError = new ProxyError(\n                serverException.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR,\n                EMPTY,\n                serverException.LocalizedMessage,\n                false,\n                errorResponse\n            );\n            error.commerceException = serverException;\n            errors.push(error);\n        }\n\n        return errors;\n    }\n\n    private static getErrorsFromDataValidationFailures(failures: DataValidationFailure[]): ProxyError[] {\n        const errors: ProxyError[] = [];\n        failures = failures || [];\n\n        for (const failure of failures) {\n            errors.push(\n                new ProxyError(failure.ErrorResourceId || ErrorTypeEnum.SERVER_ERROR, failure.ErrorContext || '', failure.LocalizedMessage, false, {})\n            );\n        }\n\n        return errors;\n    }\n\n    /**\n     * Parses an error to get the error code and error message.\n     *\n     * @param {any} error The error message.\n     * @retunrs {ProxyError[]} The collection of error messages.\n     */\n    private static parseError(error: any): ProxyError[] {\n        const response = error.response;\n        let errors: ProxyError[] = [];\n        if (response.body && response.data) {\n            // If we have a response body\n            const contentType: string = (response.headers && (response.headers['Content-Type'] || response.headers['content-type'])) || '';\n            const bodyString: string = response.data.Exception;\n            // Parse errors in json format\n            if (contentType.toLowerCase().indexOf('application/json') !== -1) {\n                errors = ErrorParser.parseJSONError(bodyString, error.response);\n            } else {\n                const message: string = `Server error has been received with unsupported content type: '${contentType}'.`;\n                RetailLogger.genericWarning(message);\n            }\n        }\n        // if we couldn't parse the errors from the body, we can only rely on status text and status code\n        if (!hasElements(errors)) {\n            // In case we don't have a body, we don't know the error message but from http status code\n            errors = [ErrorHelper.MapResponseStatusCodeToError(response.statusText, response.statusCode, error)];\n        }\n        return errors;\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import\"core-js/modules/es.promise.js\";import\"core-js/modules/es.string.split.js\";import\"core-js/modules/web.dom-collections.for-each.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{createObservableDataAction}from'@msdyn365-commerce/action-internal';import{readAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';import{getProductRatingsAsync,searchByCriteriaAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';import{getElementsAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';import*as semver from'semver';import{CATEGORY_PAGE_NAME,PDP_PAGE_NAME,PICKS_FOR_YOU_LIST}from'../../consts';import{getProductImageUrls,orderProductSearchResults}from'../../utils/product-list-utils';import getSimpleProducts,{ProductInput}from'../get-simple-products';const actionInputError=missingType=>{throw new Error(\"Input \".concat(missingType,\" is missing and required to run GetProductsByRecommendationId action\"));};const MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS='9.16.8';/**\r\n * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context\r\n * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.\r\n *\r\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\r\n * @param input The ProductListInput provided to the action\r\n * @param context The current action context\r\n */const getCategoryIdForReco=(recommendationCriteria,input,context)=>{let categoryIds=[];if(input.listMetadata.includePageContext||!input.listMetadata.categoryIds||input.listMetadata.categoryIds.length===0){const urlTokens=context.requestContext.urlTokens;if(urlTokens&&urlTokens.pageType&&urlTokens.pageType.toLowerCase()===CATEGORY_PAGE_NAME){if(urlTokens.recordId){categoryIds=[+urlTokens.recordId];}}}else{// Use category from a specific context if provided\nif(input.listMetadata.categoryIds&&input.listMetadata.categoryIds.length>0){categoryIds=input.listMetadata.categoryIds;}}recommendationCriteria.CategoryIds=categoryIds;};/**\r\n * Fetches the current active cart to be used when cart context\r\n * is selected for a reco list\r\n *\r\n * @param ctx The current action context\r\n */const getCart=async ctx=>{let cart;if(ctx.requestContext&&ctx.requestContext.cookies){const cookies=ctx.requestContext&&ctx.requestContext.cookies;const cartCookie=cookies.getCartCookie();const cartCookieParts=cartCookie.split(':');if(cartCookieParts&&cartCookieParts.length===2){if(ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"t\"/* Auth */||!ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"p\"/* Anon */){const readCart=await readAsync({callerContext:ctx},cartCookieParts[1]);if(readCart&&readCart.Id){cart=readCart;}}}}return cart;};/**\r\n * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will\r\n * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.\r\n * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.\r\n *\r\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\r\n * @param input The ProductListInput provided to the action\r\n * @param context The current action context\r\n */const getProductIdForReco=async(recommendationCriteria,input,context)=>{let productIds=[];// If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call\nif(input.listMetadata.includeCart){const cart=await getCart(context);if(cart&&cart.CartLines){const validCartLines=cart.CartLines.filter(element=>element.ProductId!==undefined);const cartProductIds=validCartLines.map(product=>product.ProductId);context.telemetry.debug(\"Products in cart: \".concat(cartProductIds));// If the cart isn't empty, assign the products in the cart to the productIds for seeding\nif(cartProductIds&&cartProductIds.length>0){// @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]\n// however, we filter on undefined product ids first before mapping on product ids so each element must be defined\nproductIds=cartProductIds;}}}else if(input.listMetadata.includePageContext||!input.listMetadata.productIds||input.listMetadata.productIds.length===0){const urlTokens=context.requestContext.urlTokens;if(urlTokens&&urlTokens.recordId&&urlTokens.pageType&&urlTokens.pageType.toLowerCase()===PDP_PAGE_NAME){productIds=[+urlTokens.recordId];}}else{// Use the product from specfic context\nif(input.listMetadata.productIds&&input.listMetadata.productIds.length>0){productIds=[input.listMetadata.productIds[0]];}}recommendationCriteria.ProductIds=productIds;};// tslint:disable-next-line: max-func-body-length\nexport const getProductsByRecommendationList=async(input,context)=>{// If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products\nconst customerAccountNumber=context.requestContext&&context.requestContext.user&&context.requestContext.user.customerAccountNumber;if(input.listMetadata.recommendationListId===PICKS_FOR_YOU_LIST&&!customerAccountNumber){return[];}const recommendationCriteria={};const proxyContext={callerContext:context,queryResultSettings:{Paging:{Top:input.listMetadata.pageSize||10}}};recommendationCriteria.CatalogId=input.catalogId;let reccomendationListId;if(input.listMetadata.recommendationListId){reccomendationListId=input.listMetadata.recommendationListId;}else{actionInputError(\"recommendationListId (from listmetadata)\");}getCategoryIdForReco(recommendationCriteria,input,context);await getProductIdForReco(recommendationCriteria,input,context);if((input.listMetadata.personalization||reccomendationListId===PICKS_FOR_YOU_LIST)&&customerAccountNumber){recommendationCriteria.CustomerAccountNumber=customerAccountNumber;proxyContext.bypassCache='get';}context.telemetry.debug(\"Recommendation Criteria: \".concat(JSON.stringify(recommendationCriteria)));return getElementsAsync(proxyContext,reccomendationListId,recommendationCriteria).then(async recommendedElements=>{if(recommendedElements){const productInputs=[];const productTypeId=[];// Grab all the elements that are products and store the product ids\nfor(let i=0;i<recommendedElements.length;i++){const element=recommendedElements[i];// Element type value of 1 indicates product type\nif(element.ElementId&&element.ElementTypeValue===1){productInputs[i]=new ProductInput(+element.ElementId,context.requestContext.apiSettings);productTypeId[i]=element.ElementId;}}context.telemetry.debug(\"Running recommendation action for list \".concat(input.listMetadata.recommendationListId));context.telemetry.debug(\"Number of products returned: \".concat(productTypeId.length));context.telemetry.debug('Product ids returned',productTypeId);if(productInputs.length){// Check to see if retail proxy version is greater than min version required for new API\nif(semver.gte(semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion)||'',MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS)){const itemIds=productInputs.map(value=>value.productId);const productSearchCriteria={Ids:itemIds,Context:{ChannelId:+context.requestContext.apiSettings.channelId,CatalogId:+context.requestContext.apiSettings.catalogId}};try{let productSearchResults=await searchByCriteriaAsync({callerContext:context},productSearchCriteria);// If the ProductSearchResult API finds the products then populate the product image urls and return\n// otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons\ncontext.telemetry.debug('Product search results returned',JSON.stringify(productSearchResults));if(productSearchResults.length>0){getProductImageUrls(productSearchResults,context.requestContext.apiSettings);productSearchResults=orderProductSearchResults(itemIds,productSearchResults);return productSearchResults;}}catch(e){// In case of an error fall back to legacy flow\ncontext.telemetry.error(\"Error while getting productSearchResult: \".concat(e));}}// Get Product Ratings Block (If needed)\nconst productRatingsPromise=getProductRatingsAsync({callerContext:context},productInputs.map(productInput=>productInput.productId));return getSimpleProducts(productInputs,context).then(products=>{getProductImageUrls(products,context.requestContext.apiSettings);products=orderProductSearchResults(productInputs.map(value=>value.productId),products);return productRatingsPromise.then(productRatings=>{productRatings.forEach(productRating=>{const unratedProduct=products.find(mappedProduct=>mappedProduct.RecordId===productRating.ProductId);if(unratedProduct){unratedProduct.TotalRatings=productRating.TotalRatings;unratedProduct.AverageRating=productRating.AverageRating;}});return products;});});}}return[];}).catch(error=>{context.telemetry.error(\"Error running productByRecommendation action: \".concat(error));throw new Error(error);});};export const getProductsByRecommendationListAction=createObservableDataAction({action:getProductsByRecommendationList,id:'@msdyn365-commerce/products-by-recommendation'});","map":{"version":3,"sources":["../../../../src/hydrators/product-list-actions/products-by-recommendation.action.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { createObservableDataAction } from '@msdyn365-commerce/action-internal';\nimport { IAction, IActionContext } from '@msdyn365-commerce/core-internal';\nimport { readAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';\nimport { getProductRatingsAsync, searchByCriteriaAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';\nimport { getElementsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/RecommendationsDataActions.g';\nimport {\n    Cart,\n    ProductSearchCriteria,\n    ProductSearchResult,\n    RecommendationCriteria,\n    RecommendedElement\n} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';\nimport { IContext } from '@msdyn365-commerce/retail-proxy/dist/Interfaces';\nimport * as semver from 'semver';\nimport { CATEGORY_PAGE_NAME, PDP_PAGE_NAME, PICKS_FOR_YOU_LIST } from '../../consts';\nimport { getProductImageUrls, orderProductSearchResults } from '../../utils/product-list-utils';\nimport getSimpleProducts, { ProductInput } from '../get-simple-products';\nimport { ProductListInput } from '../hydrator-action-inputs';\n\nconst actionInputError = (missingType: string) => {\n    throw new Error(`Input ${missingType} is missing and required to run GetProductsByRecommendationId action`);\n};\n\nconst enum CartTokenPrefix {\n    Auth = 't',\n    Anon = 'p'\n}\n\nconst MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS = '9.16.8';\n\n/**\n * Constructs the category context for a recommendation call. If page context is selected the category dervided from page context\n * (current page) will be used. If instead a spefic category is chosen as context that category will be used instead.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getCategoryIdForReco = (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let categoryIds: number[] = [];\n\n    if (input.listMetadata.includePageContext || !input.listMetadata.categoryIds || input.listMetadata.categoryIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.pageType && urlTokens.pageType.toLowerCase() === CATEGORY_PAGE_NAME) {\n            if (urlTokens.recordId) {\n                categoryIds = [+urlTokens.recordId];\n            }\n        }\n    } else {\n        // Use category from a specific context if provided\n        if (input.listMetadata.categoryIds && input.listMetadata.categoryIds.length > 0) {\n            categoryIds = input.listMetadata.categoryIds;\n        }\n    }\n\n    recommendationCriteria.CategoryIds = categoryIds;\n};\n\n/**\n * Fetches the current active cart to be used when cart context\n * is selected for a reco list\n *\n * @param ctx The current action context\n */\nconst getCart = async (ctx: IActionContext): Promise<Cart | undefined> => {\n    let cart;\n    if (ctx.requestContext && ctx.requestContext.cookies) {\n        const cookies = ctx.requestContext && ctx.requestContext.cookies;\n        const cartCookie = cookies.getCartCookie();\n        const cartCookieParts = cartCookie.split(':');\n        if (cartCookieParts && cartCookieParts.length === 2) {\n            if (\n                (ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Auth) ||\n                (!ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Anon)\n            ) {\n                const readCart = await readAsync({ callerContext: ctx }, cartCookieParts[1]);\n                if (readCart && readCart.Id) {\n                    cart = readCart;\n                }\n            }\n        }\n    }\n    return cart;\n};\n\n/**\n * Constructs the product context for a recommendation call. If cart context is selected, products currently in the active cart will\n * be used as the product ids for the recommendation call. Otherwise, if page context is selected the product derived from page context will be used.\n * Finally, if specific context is selected, a product id will be given to us from the ProductListInput which will be used to seed the product id for the reco call.\n *\n * @param recommendationCriteria The criteria that will be used for the recommendation API call\n * @param input The ProductListInput provided to the action\n * @param context The current action context\n */\nconst getProductIdForReco = async (recommendationCriteria: RecommendationCriteria, input: ProductListInput, context: IActionContext) => {\n    let productIds: number[] = [];\n    // If include cart is set true, fetch the product ids in the cart to append to the product ID list for the recommendation call\n    if (input.listMetadata.includeCart) {\n        const cart = await getCart(context);\n        if (cart && cart.CartLines) {\n            const validCartLines = cart.CartLines.filter(element => element.ProductId !== undefined);\n            const cartProductIds = validCartLines.map(product => product.ProductId);\n            context.telemetry.debug(`Products in cart: ${cartProductIds}`);\n            // If the cart isn't empty, assign the products in the cart to the productIds for seeding\n            if (cartProductIds && cartProductIds.length > 0) {\n                // @ts-ignore compiler alerts that cartProductIds is of type (number | undefined)[]\n                // however, we filter on undefined product ids first before mapping on product ids so each element must be defined\n                productIds = cartProductIds;\n            }\n        }\n    } else if (input.listMetadata.includePageContext || !input.listMetadata.productIds || input.listMetadata.productIds.length === 0) {\n        const urlTokens = context.requestContext.urlTokens;\n\n        if (urlTokens && urlTokens.recordId && urlTokens.pageType && urlTokens.pageType.toLowerCase() === PDP_PAGE_NAME) {\n            productIds = [+urlTokens.recordId];\n        }\n    } else {\n        // Use the product from specfic context\n        if (input.listMetadata.productIds && input.listMetadata.productIds.length > 0) {\n            productIds = [input.listMetadata.productIds[0]];\n        }\n    }\n\n    recommendationCriteria.ProductIds = productIds;\n};\n\n// tslint:disable-next-line: max-func-body-length\nexport const getProductsByRecommendationList = async (input: ProductListInput, context: IActionContext): Promise<ProductSearchResult[]> => {\n    // If the recommendation list is picks for you and the user is not signed do not make the reco API call and return empty list of products\n    const customerAccountNumber =\n        context.requestContext && context.requestContext.user && context.requestContext.user.customerAccountNumber;\n    if (input.listMetadata.recommendationListId === PICKS_FOR_YOU_LIST && !customerAccountNumber) {\n        return [];\n    }\n\n    const recommendationCriteria: RecommendationCriteria = {};\n    const proxyContext: IContext = { callerContext: context, queryResultSettings: { Paging: { Top: input.listMetadata.pageSize || 10 } } };\n    recommendationCriteria.CatalogId = input.catalogId;\n\n    let reccomendationListId;\n    if (input.listMetadata.recommendationListId) {\n        reccomendationListId = input.listMetadata.recommendationListId;\n    } else {\n        actionInputError(`recommendationListId (from listmetadata)`);\n    }\n\n    getCategoryIdForReco(recommendationCriteria, input, context);\n    await getProductIdForReco(recommendationCriteria, input, context);\n\n    if ((input.listMetadata.personalization || reccomendationListId === PICKS_FOR_YOU_LIST) && customerAccountNumber) {\n        recommendationCriteria.CustomerAccountNumber = customerAccountNumber;\n        proxyContext.bypassCache = 'get';\n    }\n\n    context.telemetry.debug(`Recommendation Criteria: ${JSON.stringify(recommendationCriteria)}`);\n\n    return getElementsAsync(proxyContext, reccomendationListId, recommendationCriteria)\n        .then(async (recommendedElements: RecommendedElement[]) => {\n            if (recommendedElements) {\n                const productInputs: ProductInput[] = [];\n                const productTypeId: string[] = [];\n                // Grab all the elements that are products and store the product ids\n                for (let i = 0; i < recommendedElements.length; i++) {\n                    const element = recommendedElements[i];\n                    // Element type value of 1 indicates product type\n                    if (element.ElementId && element.ElementTypeValue === 1) {\n                        productInputs[i] = new ProductInput(+element.ElementId, context.requestContext.apiSettings);\n                        productTypeId[i] = element.ElementId;\n                    }\n                }\n                context.telemetry.debug(`Running recommendation action for list ${input.listMetadata.recommendationListId}`);\n                context.telemetry.debug(`Number of products returned: ${productTypeId.length}`);\n                context.telemetry.debug('Product ids returned', productTypeId);\n\n                if (productInputs.length) {\n                    // Check to see if retail proxy version is greater than min version required for new API\n                    if (\n                        semver.gte(\n                            semver.coerce(context.requestContext.apiSettings.retailServerProxyVersion) || '',\n                            MIN_RETAIL_PROXY_VERSION_FOR_PRODUCT_SEARCH_RESULTS\n                        )\n                    ) {\n                        const itemIds: number[] = productInputs.map(value => value.productId);\n                        const productSearchCriteria: ProductSearchCriteria = {\n                            Ids: itemIds,\n                            Context: {\n                                ChannelId: +context.requestContext.apiSettings.channelId,\n                                CatalogId: +context.requestContext.apiSettings.catalogId\n                            }\n                        };\n                        try {\n                            let productSearchResults = await searchByCriteriaAsync({ callerContext: context }, productSearchCriteria);\n                            // If the ProductSearchResult API finds the products then populate the product image urls and return\n                            // otherwise if the API does not exist or does not return products proceed to the legacy flows for legacy/backward compatibility reasons\n                            context.telemetry.debug('Product search results returned', JSON.stringify(productSearchResults));\n                            if (productSearchResults.length > 0) {\n                                getProductImageUrls(productSearchResults, context.requestContext.apiSettings);\n                                productSearchResults = orderProductSearchResults(itemIds, productSearchResults);\n                                return productSearchResults;\n                            }\n                        } catch (e) {\n                            // In case of an error fall back to legacy flow\n                            context.telemetry.error(`Error while getting productSearchResult: ${e}`);\n                        }\n                    }\n\n                    // Get Product Ratings Block (If needed)\n                    const productRatingsPromise = getProductRatingsAsync(\n                        { callerContext: context },\n                        productInputs.map(productInput => productInput.productId)\n                    );\n\n                    return getSimpleProducts(productInputs, context).then((products: ProductSearchResult[]) => {\n                        getProductImageUrls(products, context.requestContext.apiSettings);\n                        products = orderProductSearchResults(\n                            productInputs.map(value => value.productId),\n                            products\n                        );\n                        return productRatingsPromise.then(productRatings => {\n                            productRatings.forEach(productRating => {\n                                const unratedProduct: ProductSearchResult = <ProductSearchResult>(\n                                    products.find(mappedProduct => mappedProduct.RecordId === productRating.ProductId)\n                                );\n                                if (unratedProduct) {\n                                    unratedProduct.TotalRatings = productRating.TotalRatings;\n                                    unratedProduct.AverageRating = productRating.AverageRating;\n                                }\n                            });\n\n                            return products;\n                        });\n                    });\n                }\n            }\n            return [];\n        })\n        .catch(error => {\n            context.telemetry.error(`Error running productByRecommendation action: ${error}`);\n            throw new Error(error);\n        });\n};\n\nexport const getProductsByRecommendationListAction = createObservableDataAction({\n    action: <IAction<ProductSearchResult[]>>getProductsByRecommendationList,\n    id: '@msdyn365-commerce/products-by-recommendation'\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
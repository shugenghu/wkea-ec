{"ast":null,"code":"import\"core-js/modules/es.array.reduce.js\";import\"core-js/modules/es.string.replace.js\";import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{StaticTelemetry}from'@msdyn365-commerce/telemetry-internal';import url from'url';import{RequestVectorizerInstance}from'./request-vectorizer';import{TTLCache}from'./ttl-cache';/**\r\n * Regular expression to match content inside round braces\r\n */const regexGetRoundBraces=/\\(.+?\\)/gm;/**\r\n * Default client error\r\n */const DEFAULT_ERROR_STATUS_CODE=408;/**\r\n * Formats commerce URL parts used in retail server calls with odata formatting\r\n *\r\n * @param inputString The input string to replace\r\n * @param replaceString The replacement value, default of `(~)`.\r\n */export const replaceIdentifiers=(inputString,replaceString)=>{return(inputString||'').replace(regexGetRoundBraces,replaceString||\"(~)\");};/**\r\n * Helper mapping lowercase keys to real keys in an object. Note this returns the keys only, mapping\r\n * lower case key to the actual cased key name in the dictionary\r\n *\r\n * e.g.\r\n *\r\n * HelloWorld will be returned as 'helloworld' allowing you to look up 'helloworld' to get HelloWorld to index into the real dictionary\r\n * @param objectDictionary the object dictionary\r\n */export const toLowerCaseDict=objectDictionary=>{return Object.keys(objectDictionary||{}).reduce((prevValue,current)=>_objectSpread(_objectSpread({},prevValue),{},{[current.toLocaleLowerCase()]:current}),{});};const ttlRequestCache=new TTLCache();/**\r\n * Error retail se interceptor for axios\r\n *\r\n * @param config The request cofiguration\r\n * @param status The response status code\r\n * @param requestCache The optional request cache to use (mostly for testing)\r\n */export const RSErrorResponseHandler=(config,status,requestCache)=>{if(!requestCache){requestCache=ttlRequestCache;}const headers=config&&config.headers;let requestId;if(headers){const lowercaseHeaders=toLowerCaseDict(headers);requestId=lowercaseHeaders.requestid&&headers[lowercaseHeaders.requestid];}const statusCode=status?status:DEFAULT_ERROR_STATUS_CODE;const properties=requestCache.get(requestId);if(properties){const elapsedTime=StaticTelemetry.stopTimer(requestId);const parsedUrl=url.parse(config&&(config.url||config.baseURL)||'');StaticTelemetry.trackDependency({duration:elapsedTime,method:(properties.m||'unknown').toUpperCase(),name:properties.e,resultCode:statusCode,success:status<400,url:parsedUrl,target:parsedUrl.hostname,properties:{requestId},dependencyName:'RetailServer'});}};/**\r\n * Response interceptor for axios\r\n *\r\n * @param response The resposne\r\n * @param requestCache The optional request cache to use (mostly for testing)\r\n */export const RSResponseInterceptor=(response,requestCache)=>{if(!requestCache){requestCache=ttlRequestCache;}// try get properties from request based on requestid header\nlet requestId;if(process.env.CURRENT_ENVIRONMENT!=='node'){// on web we need to check config\nconst headers=response&&response.config&&response.config.headers;if(headers){const lowercaseHeaders=toLowerCaseDict(headers);requestId=lowercaseHeaders.requestid&&headers[lowercaseHeaders.requestid];}}else{requestId=response&&response.headers&&response.headers.requestid;}const properties=requestCache.get(requestId);if(properties){const elapsedTime=StaticTelemetry.stopTimer(requestId);const{config,status,request}=response;const parsedUrl=url.parse(config&&(config.url||config.baseURL)||'');StaticTelemetry.trackDependency({duration:elapsedTime,method:(properties.m||request&&request.method||'unknown').toUpperCase(),name:properties.e,resultCode:status,success:status<400,url:parsedUrl,target:parsedUrl.hostname,properties:{requestId},dependencyName:'RetailServer'});}return response;};/**\r\n * Captures outgoing calls to retail server\r\n */export const RSRequestInterceptor=request=>{if(!request||!request.headers){return request;}const requestHeaders=request.headers;const caseInsensitiveHeaderMap=toLowerCaseDict(requestHeaders);// check if it's an outgoing request to retail server\nif(caseInsensitiveHeaderMap.oun&&request.url){// get the API endpoint\nconst parsedUrl=url.parse(request.url,false);const apiEndPoint=replaceIdentifiers(parsedUrl.pathname);// associate with the request-id vector\nconst requestIdVector=requestHeaders[caseInsensitiveHeaderMap['request-id']];// associate with the requestid (non-vectored)\nconst caseInsensitiveRequestIdHeaderName=caseInsensitiveHeaderMap.requestid||'requestid';const currentRequestId=requestHeaders[caseInsensitiveRequestIdHeaderName];const requestId=RequestVectorizerInstance.next(currentRequestId);StaticTelemetry.startTimer(requestId);const properties={// method\nm:request.method,// endpoint\ne:apiEndPoint,// request vector\nrv:requestIdVector,// request id\nr:requestId};// add to cache\nttlRequestCache.set(requestId,properties,()=>{StaticTelemetry.stopTimer(requestId);});request.headers[caseInsensitiveRequestIdHeaderName]=requestId;}return request;};export const RSRequestInterceptorErrorHandler=error=>{if(error.request){RSRequestInterceptor(error.request);}throw error;};export const RSResponseInterceptorErrorHandler=error=>{if(error.response){RSResponseInterceptor(error.response);}else if(error.config){RSErrorResponseHandler(error.config,DEFAULT_ERROR_STATUS_CODE);}throw error;};","map":{"version":3,"sources":["../../../../src/_server/inteceptors/rs-logging-interceptor.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { RequestCache } from '@msdyn365-commerce/cache-internal';\nimport { IEventRetailServerRequestProperties, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport url from 'url';\nimport { RequestVectorizerInstance } from './request-vectorizer';\nimport { TTLCache } from './ttl-cache';\n\n/**\n * Regular expression to match content inside round braces\n */\nconst regexGetRoundBraces = /\\(.+?\\)/gm;\n\n/**\n * Default client error\n */\nconst DEFAULT_ERROR_STATUS_CODE = 408;\n\n/**\n * Formats commerce URL parts used in retail server calls with odata formatting\n *\n * @param inputString The input string to replace\n * @param replaceString The replacement value, default of `(~)`.\n */\nexport const replaceIdentifiers = (inputString: string | undefined, replaceString?: string) => {\n    return (inputString || '').replace(regexGetRoundBraces, replaceString || `(~)`);\n};\n\n/**\n * Helper mapping lowercase keys to real keys in an object. Note this returns the keys only, mapping\n * lower case key to the actual cased key name in the dictionary\n *\n * e.g.\n *\n * HelloWorld will be returned as 'helloworld' allowing you to look up 'helloworld' to get HelloWorld to index into the real dictionary\n * @param objectDictionary the object dictionary\n */\nexport const toLowerCaseDict = (objectDictionary): { [lowerCaseKeyName: string]: string } => {\n    return Object.keys(objectDictionary || {}).reduce(\n        (prevValue, current) => ({ ...prevValue, [current.toLocaleLowerCase()]: current }),\n        {}\n    );\n};\n\nconst ttlRequestCache = new TTLCache<IEventRetailServerRequestProperties>();\n\n/**\n * Error retail se interceptor for axios\n *\n * @param config The request cofiguration\n * @param status The response status code\n * @param requestCache The optional request cache to use (mostly for testing)\n */\n\nexport const RSErrorResponseHandler = (\n    config: AxiosRequestConfig,\n    status: number,\n    requestCache?: TTLCache<IEventRetailServerRequestProperties>\n) => {\n    if (!requestCache) {\n        requestCache = ttlRequestCache;\n    }\n    const headers = config && config.headers;\n    let requestId;\n    if (headers) {\n        const lowercaseHeaders = toLowerCaseDict(headers);\n        requestId = lowercaseHeaders.requestid && headers[lowercaseHeaders.requestid];\n    }\n    const statusCode = status ? status : DEFAULT_ERROR_STATUS_CODE;\n    const properties = requestCache.get(requestId);\n    if (properties) {\n        const elapsedTime = StaticTelemetry.stopTimer(requestId);\n        const parsedUrl = url.parse((config && (config.url || config.baseURL)) || '');\n        StaticTelemetry.trackDependency({\n            duration: elapsedTime,\n            method: (properties.m || 'unknown').toUpperCase(),\n            name: properties.e,\n            resultCode: statusCode,\n            success: status < 400,\n            url: parsedUrl,\n            target: parsedUrl.hostname,\n            properties: {\n                requestId\n            },\n            dependencyName: 'RetailServer'\n        });\n    }\n};\n\n/**\n * Response interceptor for axios\n *\n * @param response The resposne\n * @param requestCache The optional request cache to use (mostly for testing)\n */\nexport const RSResponseInterceptor = (response: AxiosResponse, requestCache?: TTLCache<IEventRetailServerRequestProperties>) => {\n    if (!requestCache) {\n        requestCache = ttlRequestCache;\n    }\n    // try get properties from request based on requestid header\n    let requestId;\n    if (process.env.CURRENT_ENVIRONMENT !== 'node') {\n        // on web we need to check config\n        const headers = response && response.config && response.config.headers;\n        if (headers) {\n            const lowercaseHeaders = toLowerCaseDict(headers);\n            requestId = lowercaseHeaders.requestid && headers[lowercaseHeaders.requestid];\n        }\n    } else {\n        requestId = response && response.headers && response.headers.requestid;\n    }\n    const properties = requestCache.get(requestId);\n    if (properties) {\n        const elapsedTime = StaticTelemetry.stopTimer(requestId);\n        const { config, status, request } = response;\n        const parsedUrl = url.parse((config && (config.url || config.baseURL)) || '');\n        StaticTelemetry.trackDependency({\n            duration: elapsedTime,\n            method: (properties.m || (request && request.method) || 'unknown').toUpperCase(),\n            name: properties.e,\n            resultCode: status,\n            success: status < 400,\n            url: parsedUrl,\n            target: parsedUrl.hostname,\n            properties: {\n                requestId\n            },\n            dependencyName: 'RetailServer'\n        });\n    }\n\n    return response;\n};\n\n/**\n * Captures outgoing calls to retail server\n */\nexport const RSRequestInterceptor = (request: AxiosRequestConfig) => {\n    if (!request || !request.headers) {\n        return request;\n    }\n    const requestHeaders = request.headers;\n    const caseInsensitiveHeaderMap = toLowerCaseDict(requestHeaders);\n\n    // check if it's an outgoing request to retail server\n\n    if (caseInsensitiveHeaderMap.oun && request.url) {\n        // get the API endpoint\n        const parsedUrl = url.parse(request.url, false);\n        const apiEndPoint = replaceIdentifiers(parsedUrl.pathname);\n\n        // associate with the request-id vector\n        const requestIdVector = requestHeaders[caseInsensitiveHeaderMap['request-id']];\n\n        // associate with the requestid (non-vectored)\n        const caseInsensitiveRequestIdHeaderName = caseInsensitiveHeaderMap.requestid || 'requestid';\n        const currentRequestId = requestHeaders[caseInsensitiveRequestIdHeaderName];\n        const requestId = RequestVectorizerInstance.next(currentRequestId);\n\n        StaticTelemetry.startTimer(requestId);\n\n        const properties = {\n            // method\n            m: request.method!,\n            // endpoint\n            e: apiEndPoint,\n            // request vector\n            rv: requestIdVector,\n            // request id\n            r: requestId\n        };\n\n        // add to cache\n        ttlRequestCache.set(requestId, properties, () => {\n            StaticTelemetry.stopTimer(requestId);\n        });\n\n        request.headers[caseInsensitiveRequestIdHeaderName] = requestId;\n    }\n\n    return request;\n};\n\nexport const RSRequestInterceptorErrorHandler = (error: AxiosError) => {\n    if (error.request) {\n        RSRequestInterceptor(error.request);\n    }\n\n    throw error;\n};\n\nexport const RSResponseInterceptorErrorHandler = (error: AxiosError) => {\n    if (error.response) {\n        RSResponseInterceptor(error.response);\n    } else if (error.config) {\n        RSErrorResponseHandler(error.config, DEFAULT_ERROR_STATUS_CODE);\n    }\n\n    throw error;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
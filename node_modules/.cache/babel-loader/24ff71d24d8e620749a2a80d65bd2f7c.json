{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"@babel/runtime/helpers/esm/asyncToGenerator\";import _uniq from\"lodash/uniq\";import _difference from\"lodash/difference\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{asSystemMetadata,LogLevel}from'@msdyn365-commerce/telemetry-internal';/**\r\n * @description takes relative path of strings and maps them to script tags that can be rendered with\r\n *              fully qualified baseUrl path\r\n *\r\n * @param baseUrl baseUrl to map in front of file paths, relative from root\r\n * @param pathOrPathsToFiles single or multiple paths to files\r\n */var mapBaseUrlToString=function mapBaseUrlToString(baseUrl,pathOrPathsToFiles,context){return(Array.isArray(pathOrPathsToFiles)?pathOrPathsToFiles:[pathOrPathsToFiles]).map(function(script){// fallback with `statics` in case submissionid is not set\nreturn\"\".concat(baseUrl).concat(process.env.SUBMISSIONID||'statics',\"/\").concat(script);});};var hasNamedChunk=function hasNamedChunk(clientStats,chunkName){return clientStats.assetsByChunkName&&clientStats.assetsByChunkName[chunkName];};var getNamedChunk=function getNamedChunk(clientStats,chunkName){return clientStats.assetsByChunkName[chunkName];};var hasNamedChunkGroup=function hasNamedChunkGroup(clientStats,chunkName){return clientStats.namedChunkGroups&&clientStats.namedChunkGroups[chunkName];};var getNamedChunkGroup=function getNamedChunkGroup(clientStats,chunkName){return clientStats.namedChunkGroups[chunkName];};var CONST_CLIENT='client';var CONST_BOOTSTRAP='bootstrap';/**\r\n * @description checks the named chunks and chunks section of the clientStats generated by webpack\r\n *              and returns the corresponding file paths after mapping the baseUrl to their paths\r\n *\r\n * @param baseUrl baseUrl to map in front of file paths, relative from root\r\n * @param chunkNames list of chunk names\r\n * @param clientStats webpack generated client stats\r\n */ // @ts-ignore -- re-exported type signature from react to make tsc happy\nvar getAssetsByChunkName=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(baseUrl,chunkNames,clientStats,telemetry,context){var result,assets,actualChunkNames;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:try{assets=[];// group vs actual chunk names.\nactualChunkNames=[];chunkNames.map(function(chunkName){// strip off any file extensions eg: .js from the key\nif(typeof chunkName==='string'&&chunkName.endsWith('.js')){// It is possible that the chunkName key here could be *.view.js\n// usually view.js is expected to be grouped along with its module. However, we need to\n// ensure we don't miss out on adding the chunk should webpack groups it into separate chunk\n// see build/public/stats-web.json for more info.\nchunkName=chunkName.split('.js')[0];}// check if we have a named chunk group with this name\nif(hasNamedChunkGroup(clientStats,chunkName)){var namedChunkGroup=getNamedChunkGroup(clientStats,chunkName);assets=assets.concat(namedChunkGroup.assets);actualChunkNames=actualChunkNames.concat(namedChunkGroup.chunks);}else if(hasNamedChunk(clientStats,chunkName)){// possible for this not to be a group but an individual named chunk, which could contain multiple files\nvar namedChunk=getNamedChunk(clientStats,chunkName);assets=assets.concat(Array.isArray(namedChunk)?namedChunk:[namedChunk]);actualChunkNames.push(chunkName);}});result={chunks:_toConsumableArray(actualChunkNames),jsFiles:_uniq(assets.filter(function(assetFile){return assetFile.endsWith('.js');})),cssFiles:_uniq(assets.filter(function(assetFile){return assetFile.endsWith('.css');})),cssScripts:[],jsScripts:[]};result=_objectSpread(_objectSpread({},result),{},{jsScripts:mapBaseUrlToString(baseUrl,result.jsFiles,context),cssScripts:mapBaseUrlToString(baseUrl,result.cssFiles,context)});}catch(e){telemetry.log(LogLevel.Error,'',{exception:e});}return _context.abrupt(\"return\",result);case 2:case\"end\":return _context.stop();}}},_callee);}));return function getAssetsByChunkName(_x,_x2,_x3,_x4,_x5){return _ref.apply(this,arguments);};}();/**\r\n * @description Looks up single chunk information and details\r\n *\r\n * @param baseUrl baseUrl to map in front of file paths, relative from root\r\n * @param chunkName chunk name to look up\r\n * @param clientStats generated webpack client stats\r\n * @param fileTypes extension of files to include from chunk or chunk group\r\n */var getScriptsForChunkName=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(baseUrl,chunkName,clientStats,telemetry){var fileTypes,context,results,namedChunkGroup,namedChunk,_args2=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:fileTypes=_args2.length>4&&_args2[4]!==undefined?_args2[4]:'.js';context=_args2.length>5?_args2[5]:undefined;_context2.prev=2;if(!hasNamedChunkGroup(clientStats,chunkName)){_context2.next=8;break;}namedChunkGroup=getNamedChunkGroup(clientStats,chunkName);results=mapBaseUrlToString(baseUrl,namedChunkGroup.assets.filter(function(asset){return asset.endsWith(fileTypes);}),context);_context2.next=14;break;case 8:if(!hasNamedChunk(clientStats,chunkName)){_context2.next=13;break;}namedChunk=getNamedChunk(clientStats,chunkName);// we're not sure if it's an array, could be a single string, so coerce to array with concat, so we can filter it\nresults=mapBaseUrlToString(baseUrl,[].concat(namedChunk).filter(function(asset){return asset.endsWith(fileTypes);}),context);_context2.next=14;break;case 13:throw new Error(\"Did not find chunk named \".concat(chunkName));case 14:_context2.next=19;break;case 16:_context2.prev=16;_context2.t0=_context2[\"catch\"](2);telemetry.log(LogLevel.Error,'Failed to get chunk named {chunkName}.',{values:[asSystemMetadata(chunkName)],exception:_context2.t0});case 19:return _context2.abrupt(\"return\",results);case 20:case\"end\":return _context2.stop();}}},_callee2,null,[[2,16]]);}));return function getScriptsForChunkName(_x6,_x7,_x8,_x9){return _ref2.apply(this,arguments);};}();/**\r\n * Gets the IDs of each named chunk\r\n *\r\n * @param chunkNames The chunk names for which to get IDs for\r\n * @param clientStats generated webpack client stats\r\n */var getChunkIds=function getChunkIds(chunkNames,clientStats){var ids=[];chunkNames.forEach(function(id){if(hasNamedChunkGroup(clientStats,id)){var chunkIds=getNamedChunkGroup(clientStats,id).chunks;ids=ids.concat(chunkIds);}});return _uniq(ids);};/**\r\n * @description Returns object containing all necessary information to render chunks including\r\n *              paths to files, chunk information (entry, bootstrap, other), and breaks assets up into\r\n *              different groups (css, js)\r\n *\r\n * @param baseUrl baseUrl to map in front of file paths, relative from root\r\n * @param chunkNames list of chunk names to look up\r\n * @param clientStats generated webpack client stats\r\n * @returns {Promise<IUsedChunks>} returns value\r\n */ // @ts-ignore -- re-exported type signature from react to make tsc happy\nexport var processClientStatsForChunking=function processClientStatsForChunking(baseUrl,// tslint:disable-next-line\nchunkNames,clientStats,telemetry,context){var isChunkingEnabled=hasNamedChunkGroup(clientStats,CONST_CLIENT)&&hasNamedChunk(clientStats,CONST_BOOTSTRAP);if(!isChunkingEnabled){return Promise.resolve({isChunkingEnabled:false});}return Promise.all([getScriptsForChunkName(baseUrl,CONST_CLIENT,clientStats,telemetry,undefined,context),getScriptsForChunkName(baseUrl,CONST_BOOTSTRAP,clientStats,telemetry,undefined,context)]).then(function(_ref3){var _ref4=_slicedToArray(_ref3,2),entryChunkScripts=_ref4[0],bootstrapChunkScripts=_ref4[1];return getAssetsByChunkName(baseUrl,chunkNames,clientStats,telemetry,context).then(function(assets){var chunkIds=_uniq(getChunkIds(chunkNames,clientStats).concat(getChunkIds([CONST_CLIENT],clientStats)));return{assets:_objectSpread({},assets),isChunkingEnabled:true,entryChunkScripts:entryChunkScripts,// @TODO @kopik: bootstrap is included in entry chunk as a peer, should we actually look it up?\n// bootstrap chunk is used to make jsonp requests so we definitely need it but for initial page load we can defer probably\nbootstrapChunkScripts:bootstrapChunkScripts,jsScriptChunks:_difference(assets.jsScripts,entryChunkScripts),cssScriptChunks:assets.cssScripts,chunkIds:chunkIds};});});};","map":{"version":3,"sources":["../../../src/_server/chunking.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IGeneric, IRequestContext } from '@msdyn365-commerce/core-internal';\nimport {\n    asSystemMetadata,\n    EVENT_JSCHUNKING_START,\n    EVENT_JSCHUNKING_STOP,\n    IInternalTelemetry,\n    LogLevel\n} from '@msdyn365-commerce/telemetry-internal';\nimport { difference, uniq } from 'lodash';\n// tslint:disable-next-line -- required to make typechecker happy\nimport * as React from 'react';\n\n/**\n * Convenience shorthand for number | type which can be used as a valid key index into an object\n */\nexport type IndexableType = number | string;\n\n/**\n * @description Interface representing returned data for chunks used in rendering pass, <script> and <link> tags,\n *             paths to files, and flag to determine of chunking is currently even enabled\n */\nexport interface IUsedChunks {\n    // is chunking enabled?\n    isChunkingEnabled: boolean;\n    // list of all assets used for current chunks requested\n    assets?: IAssetsByChunkName;\n    // renderable client-side string of entry chunk script(s)\n    entryChunkScripts?: string[];\n    // renderable client-side string of bootstrap (webpack init) chunk script(s)\n    bootstrapChunkScripts?: string[];\n    // renderable client-side string of async js (webpack init) chunk script(s)\n    jsScriptChunks?: string[];\n    // renderable client-side string of css (webpack init) chunk script(s)\n    cssScriptChunks?: string[];\n    // unique ids of chunks used in this render pass (numbered in prod)\n    chunkIds?: IndexableType[];\n}\n\n/**\n * @description Represents assets for chunk names along with <script> & <link> tags\n */\nexport interface IAssetsByChunkName {\n    // chunk names\n    chunks: IndexableType[];\n    // path to js files, relative\n    jsFiles: string[];\n    // path to css files, relative\n    cssFiles: string[];\n    // path to js scripts\n    jsScripts: string[];\n    // path to css scripts\n    cssScripts: string[];\n}\n\n/**\n * @description takes relative path of strings and maps them to script tags that can be rendered with\n *              fully qualified baseUrl path\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param pathOrPathsToFiles single or multiple paths to files\n */\nconst mapBaseUrlToString = (baseUrl: string, pathOrPathsToFiles: string | string[], context: IRequestContext): string[] => {\n    return (Array.isArray(pathOrPathsToFiles) ? pathOrPathsToFiles : [pathOrPathsToFiles]).map((script: string) => {\n        // fallback with `statics` in case submissionid is not set\n        return `${baseUrl}${process.env.SUBMISSIONID || 'statics'}/${script}`;\n    });\n};\n\nconst hasNamedChunk = (clientStats: IGeneric<{}>, chunkName: IndexableType) =>\n    clientStats.assetsByChunkName && clientStats.assetsByChunkName[chunkName];\nconst getNamedChunk = (clientStats: IGeneric<{}>, chunkName: IndexableType) => clientStats.assetsByChunkName[chunkName];\nconst hasNamedChunkGroup = (clientStats: IGeneric<{}>, chunkName: IndexableType) =>\n    clientStats.namedChunkGroups && clientStats.namedChunkGroups[chunkName];\nconst getNamedChunkGroup = (clientStats: IGeneric<{}>, chunkName: IndexableType) => clientStats.namedChunkGroups[chunkName];\nconst CONST_CLIENT = 'client';\nconst CONST_BOOTSTRAP = 'bootstrap';\n\n/**\n * @description checks the named chunks and chunks section of the clientStats generated by webpack\n *              and returns the corresponding file paths after mapping the baseUrl to their paths\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkNames list of chunk names\n * @param clientStats webpack generated client stats\n */\n// @ts-ignore -- re-exported type signature from react to make tsc happy\nconst getAssetsByChunkName = async (\n    baseUrl: string,\n    chunkNames: IndexableType[],\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    context: IRequestContext\n): Promise<IAssetsByChunkName | undefined> => {\n    let result: IAssetsByChunkName | undefined;\n    try {\n        let assets: string[] = [];\n        // group vs actual chunk names.\n        let actualChunkNames: IndexableType[] = [];\n        chunkNames.map((chunkName: IndexableType) => {\n            // strip off any file extensions eg: .js from the key\n            if (typeof chunkName === 'string' && chunkName.endsWith('.js')) {\n                // It is possible that the chunkName key here could be *.view.js\n                // usually view.js is expected to be grouped along with its module. However, we need to\n                // ensure we don't miss out on adding the chunk should webpack groups it into separate chunk\n                // see build/public/stats-web.json for more info.\n                chunkName = chunkName.split('.js')[0];\n            }\n\n            // check if we have a named chunk group with this name\n            if (hasNamedChunkGroup(clientStats, chunkName)) {\n                const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);\n                assets = assets.concat(namedChunkGroup.assets);\n                actualChunkNames = actualChunkNames.concat(namedChunkGroup.chunks);\n            } else if (hasNamedChunk(clientStats, chunkName)) {\n                // possible for this not to be a group but an individual named chunk, which could contain multiple files\n                const namedChunk = getNamedChunk(clientStats, chunkName);\n                assets = assets.concat(Array.isArray(namedChunk) ? namedChunk : [namedChunk]);\n                actualChunkNames.push(chunkName);\n            }\n        });\n\n        result = {\n            chunks: [...actualChunkNames],\n            jsFiles: uniq(assets.filter((assetFile: string) => assetFile.endsWith('.js'))),\n            cssFiles: uniq(assets.filter((assetFile: string) => assetFile.endsWith('.css'))),\n            cssScripts: [],\n            jsScripts: []\n        };\n        result = {\n            ...result,\n            jsScripts: mapBaseUrlToString(baseUrl, result.jsFiles, context),\n            cssScripts: mapBaseUrlToString(baseUrl, result.cssFiles, context)\n        };\n    } catch (e) {\n        telemetry.log(LogLevel.Error, '', { exception: e });\n    }\n\n    return result;\n};\n\n/**\n * @description Looks up single chunk information and details\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkName chunk name to look up\n * @param clientStats generated webpack client stats\n * @param fileTypes extension of files to include from chunk or chunk group\n */\nconst getScriptsForChunkName = async (\n    baseUrl: string,\n    chunkName: IndexableType,\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    fileTypes: string = '.js',\n    context: IRequestContext\n): Promise<string[]> => {\n    let results;\n    try {\n        if (hasNamedChunkGroup(clientStats, chunkName)) {\n            const namedChunkGroup = getNamedChunkGroup(clientStats, chunkName);\n            results = mapBaseUrlToString(\n                baseUrl,\n                namedChunkGroup.assets.filter((asset: string) => asset.endsWith(fileTypes)),\n                context\n            );\n        } else if (hasNamedChunk(clientStats, chunkName)) {\n            const namedChunk = getNamedChunk(clientStats, chunkName);\n            // we're not sure if it's an array, could be a single string, so coerce to array with concat, so we can filter it\n            results = mapBaseUrlToString(\n                baseUrl,\n                [].concat(namedChunk).filter((asset: string) => asset.endsWith(fileTypes)),\n                context\n            );\n        } else {\n            throw new Error(`Did not find chunk named ${chunkName}`);\n        }\n    } catch (e) {\n        telemetry.log(LogLevel.Error, 'Failed to get chunk named {chunkName}.', { values: [asSystemMetadata(chunkName)], exception: e });\n    }\n\n    return results;\n};\n\n/**\n * Gets the IDs of each named chunk\n *\n * @param chunkNames The chunk names for which to get IDs for\n * @param clientStats generated webpack client stats\n */\nconst getChunkIds = (chunkNames: IndexableType[], clientStats: IGeneric<{}>) => {\n    let ids: (string | number)[] = [];\n    chunkNames.forEach((id: IndexableType) => {\n        if (hasNamedChunkGroup(clientStats, id)) {\n            const chunkIds = getNamedChunkGroup(clientStats, id).chunks;\n            ids = ids.concat(chunkIds);\n        }\n    });\n\n    return uniq(ids);\n};\n\n/**\n * @description Returns object containing all necessary information to render chunks including\n *              paths to files, chunk information (entry, bootstrap, other), and breaks assets up into\n *              different groups (css, js)\n *\n * @param baseUrl baseUrl to map in front of file paths, relative from root\n * @param chunkNames list of chunk names to look up\n * @param clientStats generated webpack client stats\n * @returns {Promise<IUsedChunks>} returns value\n */\n// @ts-ignore -- re-exported type signature from react to make tsc happy\nexport const processClientStatsForChunking = (\n    baseUrl: string,\n    // tslint:disable-next-line\n    chunkNames: any,\n    clientStats: IGeneric<{}>,\n    telemetry: IInternalTelemetry,\n    context: IRequestContext\n): Promise<IUsedChunks> => {\n    const isChunkingEnabled = hasNamedChunkGroup(clientStats, CONST_CLIENT) && hasNamedChunk(clientStats, CONST_BOOTSTRAP);\n    if (!isChunkingEnabled) {\n        return Promise.resolve({\n            isChunkingEnabled: false\n        });\n    }\n    return Promise.all([\n        getScriptsForChunkName(baseUrl, CONST_CLIENT, clientStats, telemetry, undefined, context),\n        getScriptsForChunkName(baseUrl, CONST_BOOTSTRAP, clientStats, telemetry, undefined, context)\n    ]).then(([entryChunkScripts, bootstrapChunkScripts]) => {\n        return getAssetsByChunkName(baseUrl, chunkNames, clientStats, telemetry, context).then(assets => {\n            const chunkIds = uniq(getChunkIds(chunkNames, clientStats).concat(getChunkIds([CONST_CLIENT], clientStats)));\n            return {\n                assets: { ...(<IAssetsByChunkName>assets) },\n                isChunkingEnabled: true,\n                entryChunkScripts,\n                // @TODO @kopik: bootstrap is included in entry chunk as a peer, should we actually look it up?\n                // bootstrap chunk is used to make jsonp requests so we definitely need it but for initial page load we can defer probably\n                bootstrapChunkScripts,\n                jsScriptChunks: difference(assets!.jsScripts, entryChunkScripts),\n                cssScriptChunks: assets!.cssScripts,\n                chunkIds\n            };\n        });\n    });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */var _typeof=require(\"@babel/runtime/helpers/typeof\");Object.defineProperty(exports,\"__esModule\",{value:true});var tslib_1=require(\"tslib\");// tslint:disable:no-any\nvar json_schema_ref_parser_1=tslib_1.__importDefault(require(\"json-schema-ref-parser\"));var path=tslib_1.__importStar(require(\"path\"));var extensions_1=require(\"../common/extensions\");var io_1=require(\"./io\");/**\r\n * Marks ref paths to save the url from the ref parser\r\n * @param json JSON object of the module definition\r\n */var markRefPaths=function markRefPaths(json){if(extensions_1.isEmptyOrNullObject(json)){return;}Object.keys(json).forEach(function(key){if(key==='$ref'){// Add reference path marker. This is needed so that json-ref-parser\n// sends the path untouched which is required to decide to look for\n// the definition within 'src' or 'node_modules' scopes\nif(json[key].indexOf('#')!==0){json[key]=\"file://json/\"+json[key];}}else if(_typeof(json[key])==='object'){markRefPaths(json[key]);}});};/**\r\n * Resolves the parent definition file w.r.t child definition file. A definition file can be referenced in a child\r\n * defintion file. The path follows the standard node resolution process i.e. supports paths relative to the child\r\n * and also to the node_modules.\r\n * @param parentDefinitionPath Path to definition file which is referenced in the child definition file\r\n * @param inheritedModuleDir Path to child definition file which is inheriting parent definition or a part of it\r\n */exports.resolveParentDefinitionPath=function(wrappedParentDefinitionPath,inheritedModuleDir){var parentDefinitionPath=wrappedParentDefinitionPath.replace(/file:\\/\\/json\\//,'');if(parentDefinitionPath.startsWith('.')){// path is relative to the current module directory, but resolution is\n// relative to src/. Therefore, lets make it relative to the current module directory\nreturn path.join(inheritedModuleDir,parentDefinitionPath);}// resolve against partner\nvar pathRelativeToPartner=path.join(process.cwd(),'node_modules',parentDefinitionPath);if(io_1.safeFileExistsSync(pathRelativeToPartner)){return pathRelativeToPartner;}// resolve against hoisted path\nreturn path.resolve(path.join(process.cwd(),'../../node_modules',parentDefinitionPath));};/**\r\n * Resolves referenced definition files\r\n * @param moduleDirectory Path to module directory\r\n * @param trace logger\r\n */var refPathResolver=function refPathResolver(moduleDirectory,trace){return{order:1,canRead:true,// tslint:disable-next-line:no-any\nread:function read(wrappedParentDefinitionPath){// Remove reference path marker\nvar parentDefinitionPath=exports.resolveParentDefinitionPath(wrappedParentDefinitionPath.url,moduleDirectory);return io_1.safeReadJson(parentDefinitionPath);}};};/**\r\n * Takes definition json object and resolves all the file references ($ref) defined in definition.\r\n * @param json definition json object\r\n * @param jsonFilePath path to definition file\r\n * @param trace logger\r\n */exports.resolveRef=function(json,jsonFilePath,trace){return tslib_1.__awaiter(void 0,void 0,void 0,function(){var definitionParser,e_1;return tslib_1.__generator(this,function(_a){switch(_a.label){case 0:if(extensions_1.isEmptyOrNullObject(json)){return[2/*return*/];}_a.label=1;case 1:_a.trys.push([1,3,,4]);markRefPaths(json);definitionParser=new json_schema_ref_parser_1[\"default\"]();return[4/*yield*/,definitionParser.dereference(json,{resolve:{file:refPathResolver(path.dirname(jsonFilePath))}})];case 2:return[2/*return*/,_a.sent()];case 3:e_1=_a.sent();trace=trace||console;trace.error(\"error in processing file [\"+jsonFilePath+\"]\");trace.error(e_1);return[2/*return*/,Promise.resolve()];case 4:return[2/*return*/];}});});};","map":{"version":3,"sources":["../../../src/server/json-ref-parser.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable:no-any\nimport parser from 'json-schema-ref-parser';\nimport * as path from 'path';\nimport { isEmptyOrNullObject } from '../common/extensions';\nimport { safeFileExistsSync, safeReadJson } from './io';\n\n/**\n * Marks ref paths to save the url from the ref parser\n * @param json JSON object of the module definition\n */\nconst markRefPaths = (json: any) => {\n    if (isEmptyOrNullObject(json)) {\n        return;\n    }\n\n    Object.keys(json).forEach((key: string) => {\n        if (key === '$ref') {\n            // Add reference path marker. This is needed so that json-ref-parser\n            // sends the path untouched which is required to decide to look for\n            // the definition within 'src' or 'node_modules' scopes\n            if (json[key].indexOf('#') !== 0) {\n                json[key] = `file://json/${json[key]}`;\n            }\n        } else if (typeof json[key] === 'object') {\n            markRefPaths(json[key]);\n        }\n    });\n};\n\n/**\n * Resolves the parent definition file w.r.t child definition file. A definition file can be referenced in a child\n * defintion file. The path follows the standard node resolution process i.e. supports paths relative to the child\n * and also to the node_modules.\n * @param parentDefinitionPath Path to definition file which is referenced in the child definition file\n * @param inheritedModuleDir Path to child definition file which is inheriting parent definition or a part of it\n */\nexport const resolveParentDefinitionPath = (wrappedParentDefinitionPath: string, inheritedModuleDir: string): string => {\n    const parentDefinitionPath = wrappedParentDefinitionPath.replace(/file:\\/\\/json\\//, '');\n    if (parentDefinitionPath.startsWith('.')) {\n        // path is relative to the current module directory, but resolution is\n        // relative to src/. Therefore, lets make it relative to the current module directory\n        return path.join(inheritedModuleDir, parentDefinitionPath);\n    }\n\n    // resolve against partner\n    const pathRelativeToPartner = path.join(process.cwd(), 'node_modules', parentDefinitionPath);\n    if (safeFileExistsSync(pathRelativeToPartner)) {\n        return pathRelativeToPartner;\n    }\n\n    // resolve against hoisted path\n    return path.resolve(path.join(process.cwd(), '../../node_modules', parentDefinitionPath));\n};\n\n/**\n * Resolves referenced definition files\n * @param moduleDirectory Path to module directory\n * @param trace logger\n */\nconst refPathResolver = (moduleDirectory: string, trace?: { error: Function }) => {\n    return {\n        order: 1,\n        canRead: true,\n        // tslint:disable-next-line:no-any\n        read: (wrappedParentDefinitionPath: any): Promise<any> => {\n            // Remove reference path marker\n            const parentDefinitionPath = resolveParentDefinitionPath(wrappedParentDefinitionPath.url, moduleDirectory);\n            return safeReadJson(parentDefinitionPath);\n        }\n    };\n};\n\n/**\n * Takes definition json object and resolves all the file references ($ref) defined in definition.\n * @param json definition json object\n * @param jsonFilePath path to definition file\n * @param trace logger\n */\nexport const resolveRef = async (json: object, jsonFilePath: string, trace?: { error: Function }) => {\n    if (isEmptyOrNullObject(json)) {\n        return;\n    }\n    try {\n        markRefPaths(json);\n        const definitionParser = new parser();\n        return await definitionParser.dereference(json, {\n            resolve: {\n                file: refPathResolver(path.dirname(jsonFilePath))\n            }\n        });\n    } catch (e) {\n        trace = trace || console;\n        trace.error(`error in processing file [${jsonFilePath}]`);\n        trace.error(e);\n        return Promise.resolve();\n    }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}
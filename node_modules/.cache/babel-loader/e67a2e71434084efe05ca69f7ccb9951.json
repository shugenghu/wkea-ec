{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{isAsyncResult}from'@msdyn365-commerce/retail-proxy';import{observable,set,transaction}from'mobx';import{normalizeCacheKey}from'./cache-utils';import{ICacheSource}from'./ICache';/**\r\n * Client cache implementation\r\n */export class RequestCache{constructor(){this.internalCache={};}/**\r\n     * @function        {put}           - Method to insert an item in the cache\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\r\n     */put(cacheKey,item){if(!cacheKey.typeName){throw new Error(\"Invalid type (\".concat(cacheKey.typeName,\" specified)\"));}if(!cacheKey.key){throw new Error(\"Invalid key (\".concat(cacheKey.key,\" specified)\"));}item.s=item.s!==undefined?item.s:ICacheSource.RequestCache;const{typeName,key}=normalizeCacheKey(cacheKey);if(this.internalCache[typeName]===undefined){this.internalCache[typeName]={};}return transaction(()=>{let cacheItem=this.internalCache[typeName][key];// For updating AsyncResults, only update result\nif(cacheItem&&isAsyncResult(cacheItem.item)){if(cacheItem.item.status!=='LOADING'){set(cacheItem.item,'status','LOADING');}set(cacheItem.item,'result',item.item);// Auto resolve promises whos result is being set, as they are essentially being force-completed\nset(cacheItem.item,'status','SUCCESS');}else if(cacheItem){set(cacheItem,'item',item.item);}else{if(!isAsyncResult(item.item)){cacheItem=observable(_objectSpread({},item),undefined,{deep:true,name:\"T:\".concat(typeName,\"_K:\").concat(key)});}else{cacheItem=item;}this.internalCache[typeName][key]=cacheItem;}return true;});}/**\r\n     * @function        {get}           - Method to get the cached item\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @return          {IAny}          - cached value against the given cache key\r\n     */get(cacheKey){if(!cacheKey){throw new Error(\"Invalid cacheKey: \".concat(cacheKey));}if(!cacheKey.typeName){throw new Error(\"Invalid cacheKey type: \".concat(cacheKey.typeName));}cacheKey=normalizeCacheKey(cacheKey);return this.internalCache[cacheKey.typeName]?this.internalCache[cacheKey.typeName][cacheKey.key]:undefined;}/**\r\n     * @function        {get}           - Method to get the cached item\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @return          {IAny}          - cached value against the given cache key\r\n     */getAllItems(typeName){if(!typeName){throw new Error(\"typeName cannot be empty\");}return this.internalCache[typeName.toUpperCase()];}/**\r\n     * @function        {getValue}           - Method to get the cached item\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @return          {IAny}          - cached value against the given cache key\r\n     */getValue(cacheKey){const cachedItem=this.get(cacheKey);return cachedItem?this._value(cachedItem):undefined;}/**\r\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\r\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\r\n     * @return          {ICacheItem}    - cache item that was copied\r\n     */copyTo(cacheKey,toCache){throw new Error('Not Implemented');}/**\r\n     * @function    {del}               - Method to delete an item from the cache\r\n     * @param key   {ICacheKey}       - Array of ICacheGetData items whose values need to be deleted from cache\r\n     * @return      {number}            - returns true if the cache key is deleted successfully. Does not throw errors.\r\n     */del(cacheKey){cacheKey=normalizeCacheKey(cacheKey);const cacheType=this.internalCache[cacheKey.typeName];if(cacheType&&cacheType[cacheKey.key]){delete cacheType[cacheKey.key];return true;}else{return false;}}/**\r\n     * @function    {flushAll}          - Method to flush all data from the cache\r\n     */flushAll(){this.internalCache={};}/**\r\n     * @function    {keys}              - Method to fetch all the keys in the cache\r\n     * @return      {string[]}          - returns a list of all the keys in the cache\r\n     */keys(){return Object.keys(this.internalCache);}/**\r\n     * Get the value out of a cache item\r\n     * This returns the raw value of the item, it will *not* be a MobX observable value\r\n     * @param item The observable cache item to retireve the value from\r\n     */_value(item){return item.item;}}","map":{"version":3,"sources":["../../src/request-cache.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { IDictionary } from '@msdyn365-commerce/core-internal';\nimport { isAsyncResult } from '@msdyn365-commerce/retail-proxy';\nimport { observable, set, transaction } from 'mobx';\nimport { normalizeCacheKey } from './cache-utils';\nimport { ICache, ICacheItem, ICacheKey, ICacheSource } from './ICache';\n\n/**\n * Client cache implementation\n */\nexport class RequestCache implements ICache {\n    private internalCache: { [typeName: string]: IDictionary<ICacheItem<unknown>> } = {};\n\n    /**\n     * @function        {put}           - Method to insert an item in the cache\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param cacheItem {ICacheItem}    - item that needs to be inserted in the cache\n     */\n    public put<T = unknown>(cacheKey: ICacheKey, item: ICacheItem<T>): boolean {\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid type (${cacheKey.typeName} specified)`);\n        }\n\n        if (!cacheKey.key) {\n            throw new Error(`Invalid key (${cacheKey.key} specified)`);\n        }\n\n        item.s = item.s !== undefined ? item.s : ICacheSource.RequestCache;\n        const { typeName, key } = normalizeCacheKey(cacheKey);\n        if (this.internalCache[typeName] === undefined) {\n            this.internalCache[typeName] = {};\n        }\n        return transaction<boolean>(() => {\n            let cacheItem: ICacheItem<T> = <ICacheItem<T>>this.internalCache[typeName][key];\n\n            // For updating AsyncResults, only update result\n            if (cacheItem && isAsyncResult(cacheItem.item)) {\n                if (cacheItem.item.status !== 'LOADING') {\n                    set(cacheItem.item, 'status', 'LOADING');\n                }\n                set(cacheItem.item, 'result', item.item);\n                // Auto resolve promises whos result is being set, as they are essentially being force-completed\n                set(cacheItem.item, 'status', 'SUCCESS');\n            } else if (cacheItem) {\n                set(cacheItem, 'item', item.item);\n            } else {\n                if (!isAsyncResult(item.item)) {\n                    cacheItem = observable<ICacheItem<T>>({ ...item }, undefined, {\n                        deep: true,\n                        name: `T:${typeName}_K:${key}`\n                    });\n                } else {\n                    cacheItem = item;\n                }\n                this.internalCache[typeName][key] = cacheItem;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * @function        {get}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public get<T = unknown>(cacheKey: ICacheKey): ICacheItem<T> | undefined {\n        if (!cacheKey) {\n            throw new Error(`Invalid cacheKey: ${cacheKey}`);\n        }\n\n        if (!cacheKey.typeName) {\n            throw new Error(`Invalid cacheKey type: ${cacheKey.typeName}`);\n        }\n\n        cacheKey = normalizeCacheKey(cacheKey);\n        return this.internalCache[cacheKey.typeName] ? <ICacheItem<T>>this.internalCache[cacheKey.typeName][cacheKey.key] : undefined;\n    }\n\n    /**\n     * @function        {get}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public getAllItems<T = unknown>(typeName: string): IDictionary<ICacheItem<T>> | undefined {\n        if (!typeName) {\n            throw new Error(`typeName cannot be empty`);\n        }\n\n        return <IDictionary<ICacheItem<T>>>this.internalCache[typeName.toUpperCase()];\n    }\n\n    /**\n     * @function        {getValue}           - Method to get the cached item\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @return          {IAny}          - cached value against the given cache key\n     */\n    public getValue<T = unknown>(cacheKey: ICacheKey): T | undefined {\n        const cachedItem: ICacheItem<T> | undefined = this.get<T>(cacheKey);\n        return cachedItem ? this._value<T>(cachedItem) : undefined;\n    }\n\n    /**\n     * @param cacheKey  {ICacheKey}     - object to build the cache key\n     * @param toCache   {ICache}        - cache object to which the item needs to be copied\n     * @return          {ICacheItem}    - cache item that was copied\n     */\n    public copyTo<T = unknown>(cacheKey: ICacheKey, toCache: ICache): ICacheItem<T> | undefined {\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * @function    {del}               - Method to delete an item from the cache\n     * @param key   {ICacheKey}       - Array of ICacheGetData items whose values need to be deleted from cache\n     * @return      {number}            - returns true if the cache key is deleted successfully. Does not throw errors.\n     */\n    public del(cacheKey: ICacheKey): boolean {\n        cacheKey = normalizeCacheKey(cacheKey);\n        const cacheType = this.internalCache[cacheKey.typeName];\n        if (cacheType && cacheType[cacheKey.key]) {\n            delete cacheType[cacheKey.key];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @function    {flushAll}          - Method to flush all data from the cache\n     */\n    public flushAll(): void {\n        this.internalCache = {};\n    }\n\n    /**\n     * @function    {keys}              - Method to fetch all the keys in the cache\n     * @return      {string[]}          - returns a list of all the keys in the cache\n     */\n    public keys(): string[] {\n        return Object.keys(this.internalCache);\n    }\n\n    /**\n     * Get the value out of a cache item\n     * This returns the raw value of the item, it will *not* be a MobX observable value\n     * @param item The observable cache item to retireve the value from\n     */\n    private _value<T>(item: ICacheItem<T>): T {\n        return item.item;\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
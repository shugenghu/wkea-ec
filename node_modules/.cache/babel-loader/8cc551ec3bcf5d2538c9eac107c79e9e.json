{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";import _typeof from\"@babel/runtime/helpers/esm/typeof\";function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{__decorate,__metadata}from\"tslib\";// NOTE: no-any is disabled intentionally, as promises require valid use of the any type\n// tslint:disable:no-any\nimport{observable}from'mobx';export var isAsyncResult=function isAsyncResult(item){return item&&item.toString&&typeof item.toString==='function'&&item.toString()===\"[object AsyncResult]\";};/**\r\n * Utility Methods For AsyncResult\r\n */var isThenable=function isThenable(obj){return obj&&_typeof(obj)==='object'&&typeof obj.then==='function';};/**\r\n * AsyncResult Class\r\n * Promise-style class which allows for observation of the status of the promise\r\n * and it's result during and after is execution.\r\n */export var AsyncResult=/*#__PURE__*/function(){/**\r\n     * Class constructor, which starts running the passed executor\r\n     * @param executor Passed function to be executed, resulting in resolution/rejection\r\n     */function AsyncResult(executor){var _this=this;_classCallCheck(this,AsyncResult);this.status='LOADING';this.metadata={};// @ts-ignore\nthis._type='AsyncResult';this._handlers=[];this._attachHandler=function(handler){_this._handlers.push(handler);_this._executeHandlers();};this._executeHandlers=function(){if(_this.status==='LOADING'){return;}var _iterator=_createForOfIteratorHelper(_this._handlers),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var handler=_step.value;if(_this.status==='FAILED'){handler.onFail(_this.error);}else{handler.onSuccess(_this.result);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}_this._handlers=[];};this._resolve=function(value){return _this._updateStatus(value,'SUCCESS');};this._reject=function(reason){return _this._updateStatus(reason,'FAILED',true);};try{executor(this._resolve,this._reject);}catch(e){this._reject(e);}}_createClass(AsyncResult,[{key:\"run\",/**\r\n     * Method that allows for an executor to be passed to the promise after inital execution,\r\n     * essentially \"rerunning\" the promise.\r\n     * @param executor Passed function to be executed, resulting in resolution/rejection\r\n     */value:function run(executor){this.status='LOADING';this.error=undefined;try{executor(this._resolve,this._reject);}catch(e){this._reject(e);}}/**\r\n     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult\r\n     * @param onSuccess Callback to be run on successful completion of executor\r\n     * @param onFail Callback to be run when executor cannot be successfully completed\r\n     */},{key:\"then\",value:function then(_onSuccess,_onFail){var _this2=this;var asyncResult=new AsyncResult(function(resolve,reject){return _this2._attachHandler({onSuccess:function onSuccess(result){if(!_onSuccess){// @ts-ignore: Type overlap issue\nreturn resolve(result);}try{return resolve(_onSuccess(result));}catch(e){return reject(e);}},onFail:function onFail(reason){if(!_onFail){return reject(reason);}try{return resolve(_onFail(reason));}catch(e){return reject(e);}}});});// Always pass the metadata on a then\nasyncResult.metadata=this.metadata;return asyncResult;}/**\r\n     * Hook to allow callback on the unsuccessful run of an executor\r\n     * @param onFail Callback to run when executor fails\r\n     */},{key:\"catch\",value:function _catch(onFail){var defaultThen=function defaultThen(value){return value;};return this.then(defaultThen,onFail);}/**\r\n     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor\r\n     * @param callback Callback to be run after original AsyncResult is completed\r\n     */},{key:\"finally\",value:function _finally(onfinally){var _this3=this;return new AsyncResult(function(resolve,reject){var value;var failed=false;return _this3.then(function(result){value=result;return onfinally();},function(reason){failed=true;value=reason;return onfinally();}).then(function(){if(failed){return reject(value);}return resolve(value);});});}},{key:\"toString\",value:function toString(){return\"[object AsyncResult]\";}},{key:\"_updateStatus\",value:function _updateStatus(result,newStatus){var _this4=this;var isError=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// Wrap in setTimeout to ensure fully synchronous handlers\n// are still returned AFTER initial class construction\nsetTimeout(function(){if(_this4.status!=='LOADING'){return null;}if(isThenable(result)){return result.then(_this4._resolve,_this4._reject);}if(isError){_this4.error=result;}else{_this4.result=result;}_this4.status=newStatus;return _this4._executeHandlers();},0);}},{key:Symbol.toStringTag,get:function get(){return'[object AsyncResult]';}}],[{key:\"resolve\",value:function resolve(value){return new AsyncResult(function(resolve){return resolve(value);});}},{key:\"reject\",value:function reject(reason){return new AsyncResult(function(resolve,reject){return reject(reason);});}}]);return AsyncResult;}();__decorate([observable,__metadata(\"design:type\",Object)],AsyncResult.prototype,\"result\",void 0);__decorate([observable,__metadata(\"design:type\",String)],AsyncResult.prototype,\"status\",void 0);__decorate([observable,__metadata(\"design:type\",Error)],AsyncResult.prototype,\"error\",void 0);__decorate([observable,__metadata(\"design:type\",Object)],AsyncResult.prototype,\"metadata\",void 0);","map":{"version":3,"sources":["../src/async-result.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// NOTE: no-any is disabled intentionally, as promises require valid use of the any type\n// tslint:disable:no-any\nimport { observable } from 'mobx';\nimport { IODataMetadata } from './interfaces/IODataMetadata';\n\nexport type AsyncResultStatus = 'LOADING' | 'SUCCESS' | 'FAILED';\n\nexport const isAsyncResult = (item: { toString(): string }): item is AsyncResult<unknown> => {\n    return item && item.toString && typeof item.toString === 'function' && item.toString() === `[object AsyncResult]`;\n};\n\n/**\n * Utility Methods For AsyncResult\n */\nconst isThenable = (obj: any) => obj && typeof obj === 'object' && typeof obj.then === 'function';\n\n/**\n * TYPES & INTERFACES\n */\ninterface IHandler<TIn, TOut> {\n    onSuccess: HandlerOnSuccess<TIn, TOut>;\n    onFail: HandlerOnFail<TOut>;\n}\n\ntype HandlerOnSuccess<TIn, TOut> = (value: TIn) => TOut | PromiseLike<TOut>;\ntype HandlerOnFail<TOut = never> = (reason: any) => TOut | PromiseLike<TOut>;\n\ntype Resolve<T> = (value?: T | PromiseLike<T>) => void;\ntype Reject = (value?: any) => void;\n\n/**\n * AsyncResult Class\n * Promise-style class which allows for observation of the status of the promise\n * and it's result during and after is execution.\n */\nexport class AsyncResult<T> implements Promise<T> {\n    @observable public result?: T;\n\n    @observable public status: AsyncResultStatus = 'LOADING';\n\n    @observable public error?: Error;\n\n    @observable public metadata: IODataMetadata = {};\n\n    // @ts-ignore\n    private _type: string = 'AsyncResult';\n\n    private _handlers: Array<IHandler<T, any>> = [];\n\n    public static resolve<U = any>(value?: U | PromiseLike<U>): AsyncResult<U> {\n        return new AsyncResult<U>(resolve => {\n            return resolve(value);\n        });\n    }\n\n    public static reject<U>(reason?: any): AsyncResult<U> {\n        return new AsyncResult<U>((resolve, reject) => {\n            return reject(reason);\n        });\n    }\n\n    /**\n     * Class constructor, which starts running the passed executor\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    constructor(executor: (resolve: Resolve<T>, reject: Reject) => void) {\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method that allows for an executor to be passed to the promise after inital execution,\n     * essentially \"rerunning\" the promise.\n     * @param executor Passed function to be executed, resulting in resolution/rejection\n     */\n    public run(executor: (resolve: Resolve<T>, reject: Reject) => void): void {\n        this.status = 'LOADING';\n        this.error = undefined;\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * Method which allows chaining of callbacks to the end of a fully executed AsyncResult\n     * @param onSuccess Callback to be run on successful completion of executor\n     * @param onFail Callback to be run when executor cannot be successfully completed\n     */\n    public then<TResult1 = T, TResult2 = never>(\n        onSuccess?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onFail?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n    ): AsyncResult<TResult1 | TResult2> {\n        const asyncResult = new AsyncResult<TResult1 | TResult2>((resolve, reject) => {\n            return this._attachHandler({\n                onSuccess: result => {\n                    if (!onSuccess) {\n                        // @ts-ignore: Type overlap issue\n                        return resolve(result);\n                    }\n\n                    try {\n                        return resolve(onSuccess(result));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                },\n                onFail: reason => {\n                    if (!onFail) {\n                        return reject(reason);\n                    }\n\n                    try {\n                        return resolve(onFail(reason));\n                    } catch (e) {\n                        return reject(e);\n                    }\n                }\n            });\n        });\n\n        // Always pass the metadata on a then\n        asyncResult.metadata = this.metadata;\n\n        return asyncResult;\n    }\n\n    /**\n     * Hook to allow callback on the unsuccessful run of an executor\n     * @param onFail Callback to run when executor fails\n     */\n    public catch<TResult = never>(onFail?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): AsyncResult<T | TResult> {\n        const defaultThen = (value: any) => value;\n        return this.then(defaultThen, onFail);\n    }\n\n    /**\n     * Hook to allow a callback to be executed on a successful or unsuccessful run of the executor\n     * @param callback Callback to be run after original AsyncResult is completed\n     */\n    public finally(onfinally?: (() => void) | undefined | null): AsyncResult<T> {\n        return new AsyncResult((resolve, reject) => {\n            let value: T | any;\n            let failed: Boolean = false;\n\n            return this.then(\n                result => {\n                    value = result;\n                    return onfinally();\n                },\n                reason => {\n                    failed = true;\n                    value = reason;\n                    return onfinally();\n                }\n            ).then(() => {\n                if (failed) {\n                    return reject(value);\n                }\n\n                return resolve(value);\n            });\n        });\n    }\n\n    public toString(): string {\n        return `[object AsyncResult]`;\n    }\n\n    get [Symbol.toStringTag](): string {\n        return '[object AsyncResult]';\n    }\n\n    private _attachHandler = (handler: IHandler<T, any>) => {\n        this._handlers.push(handler);\n\n        this._executeHandlers();\n    }\n\n    private _executeHandlers = () => {\n        if (this.status === 'LOADING') {\n            return;\n        }\n\n        for (const handler of this._handlers) {\n            if (this.status === 'FAILED') {\n                handler.onFail(this.error);\n            } else {\n                handler.onSuccess(this.result as T);\n            }\n        }\n\n        this._handlers = [];\n    }\n\n    private _resolve = (value?: T | PromiseLike<T>) => {\n        return this._updateStatus(value, 'SUCCESS');\n    }\n\n    private _reject = (reason: any) => {\n        return this._updateStatus(reason, 'FAILED', true);\n    }\n\n    private _updateStatus(result: T | any, newStatus: AsyncResultStatus, isError: Boolean = false): void {\n        // Wrap in setTimeout to ensure fully synchronous handlers\n        // are still returned AFTER initial class construction\n        setTimeout(() => {\n            if (this.status !== 'LOADING') {\n                return null;\n            }\n\n            if (isThenable(result)) {\n                return (result as PromiseLike<T>).then(this._resolve, this._reject);\n            }\n\n            if (isError) {\n                this.error = result;\n            } else {\n                this.result = result;\n            }\n\n            this.status = newStatus;\n\n            return this._executeHandlers();\n        }, 0);\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import\"core-js/modules/es.promise.js\";import\"core-js/modules/es.string.split.js\";import\"core-js/modules/web.dom-collections.iterator.js\";import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{addCartLinesAsync,addCouponsAsync,createCartAsync,readAsync,removeCartLinesAsync,searchAsync,updateAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';import{getCustomerLoyaltyCardsAsync}from'@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';export default async function getOrCreateActiveCart(ctx){let cart;const cartCookie=ctx.requestContext.cookies.getCartCookie();const cartCookieParts=cartCookie.split(':');try{// Check if there are already is a cart cookie and it is in the format we understand\ncart=await getCartFromCookie(cartCookieParts,ctx);const wasReadFromCookie=!!cart&&cart.Id;// If the customer is authenticated, and the auth cookie didn't give us a cart OR doesn't have a cookie, search for the customer's cart\nif(!(cart&&cart.Id)){cart=await getCartFromCustomer(ctx);}// if the customer just went from anon to signed in state then get that anon cart\n// if the search of carts didn't result in a cart, claim the current anon cart as a new auth cart for the customer\n// if the search resulted in a cart, and the read also resulted in cart, then go ahead an merge the carts\nconst anonCart=await claimAnonCart(cartCookieParts,cart,ctx);if(anonCart){cart=anonCart;}// If there is no cookie or everything else fails, create an empty cart and return that for the customer\nif(!(cart&&cart.Id)){cart=await createNewCart(ctx);}if(!wasReadFromCookie&&ctx.requestContext.user.isAuthenticated&&cart&&!cart.LoyaltyCardId){const card=await getCustomerLoyaltyCardsAsync({callerContext:ctx,queryResultSettings:{}},null);if(card&&card.length>0){cart=await updateAsync({callerContext:ctx},{Id:cart.Id,LoyaltyCardId:card[0].CardNumber});}}}catch(ex){ctx.telemetry.error(\"Caught exception in getting cart: \".concat(ex));cart=await createNewCart(ctx);}return cart;}export async function createNewCart(ctx){const newCart=await createCartAsync({callerContext:ctx},{});if(newCart&&newCart.Id){ctx.requestContext.cookies.setCartCookie(newCart,ctx.requestContext.user.isAuthenticated);return newCart;}return undefined;}export async function getCartFromCookie(cartCookieParts,ctx){if(cartCookieParts&&cartCookieParts.length===2){// If the customer is authenticated and they have an auth cookie\n// OR if the customer is not authenticated and then have an anon cookie\n// just get the cart and return that\nif(ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"t\"/* Auth */||!ctx.requestContext.user.isAuthenticated&&cartCookieParts[0]===\"p\"/* Anon */){const readCart=await readAsync({callerContext:ctx,bypassCache:'none'},cartCookieParts[1]);if(readCart&&readCart.Id){ctx.requestContext.cookies.setCartCookie(readCart,ctx.requestContext.user.isAuthenticated);return readCart;}}}return undefined;}export async function getCartFromCustomer(ctx){if(ctx.requestContext.user.isAuthenticated){const authCarts=await searchCarts(ctx);if(authCarts&&authCarts.length>0){ctx.requestContext.cookies.setCartCookie(authCarts[0],ctx.requestContext.user.isAuthenticated);return authCarts[0];}}return undefined;}export async function claimAnonCart(cartCookieParts,currentCart,ctx){if(ctx.requestContext.user.isAuthenticated&&cartCookieParts&&cartCookieParts.length===2&&cartCookieParts[0]===\"p\"/* Anon */){const anonCurrentCart=await readAsync({callerContext:ctx,bypassCache:'none'},cartCookieParts[1]);if(anonCurrentCart&&!currentCart){const newCart=await claimCart(anonCurrentCart.Id,ctx);if(newCart&&newCart.Id){ctx.requestContext.cookies.setCartCookie(newCart,ctx.requestContext.user.isAuthenticated);return newCart;}}if(anonCurrentCart&&anonCurrentCart.Id&&currentCart){const mergedCart=await addCartLines(anonCurrentCart,currentCart,ctx);// Once updated, take that merged cart ID and store the cart ID in the cookie\nif(!(mergedCart instanceof Error)&&mergedCart.Id){ctx.requestContext.cookies.setCartCookie(mergedCart,ctx.requestContext.user.isAuthenticated);return mergedCart;}}}return undefined;}/**\r\n * Function that copies a cartline for giftcard\r\n * @param cartline Source CartLine you want to copy\r\n */function buildGiftCardLine(cartline){return{DeliveryMode:cartline.DeliveryMode,CatalogId:cartline.CatalogId,Description:cartline.Description,EntryMethodTypeValue:cartline.EntryMethodTypeValue||3,ItemId:cartline.ItemId,ProductId:cartline.ProductId,Quantity:cartline.Quantity,Price:cartline.Price,NetPrice:cartline.NetPrice,GiftCardBalance:cartline.GiftCardBalance,TrackingId:'',UnitOfMeasureSymbol:cartline.UnitOfMeasureSymbol,IsPriceKeyedIn:true,IsGiftCardLine:true,ExtensionProperties:cartline.ExtensionProperties};}/**\r\n * Function that adds cart lines from source cart to destination cart\r\n * @param sourceCart Source cart you want to add cart lines from\r\n * @param destinationCart Destination cart that you want to add cart lines to\r\n * @param ctx Request context\r\n */export async function addCartLines(sourceCart,destinationCart,ctx){let updatedCart;const cartLines=[];const cartLinesToDelete=[];const channelConfiguration=ctx.requestContext.channel;if(destinationCart.Version){if(sourceCart.CartLines&&sourceCart.CartLines.length>0){for(const cartline of sourceCart.CartLines){let newCartLine;if(cartline.IsGiftCardLine){newCartLine=buildGiftCardLine(cartline);}else{newCartLine={};// Copy over BOPIS information from sourceCart to destination cart\nif(cartline.DeliveryMode&&cartline.DeliveryMode!==''&&channelConfiguration&&cartline.DeliveryMode===channelConfiguration.PickupDeliveryModeCode){newCartLine.DeliveryMode=channelConfiguration.PickupDeliveryModeCode;newCartLine.FulfillmentStoreId=cartline.FulfillmentStoreId;newCartLine.ShippingAddress=cartline.ShippingAddress;}newCartLine.ProductId=cartline.ProductId;newCartLine.Quantity=cartline.Quantity;newCartLine.ExtensionProperties=cartline.ExtensionProperties;newCartLine.Description=cartline.Description;}cartLines.push(_objectSpread({},newCartLine));if(cartline.LineId){cartLinesToDelete.push(cartline.LineId);}}}if(cartLines.length>0){try{updatedCart=await addCartLinesAsync({callerContext:ctx},destinationCart.Id,cartLines,destinationCart.Version);if(cartLinesToDelete.length>0){sourceCart=await removeCartLinesAsync({callerContext:ctx},sourceCart.Id,cartLinesToDelete);}}catch(e){ctx.telemetry.error('Error adding cart lines to desination cart');ctx.telemetry.exception(e);return destinationCart;}}// Copy over coupon codes from source cart to destination cart so that the customer doesn't lose couponCodes while migration\nif(sourceCart.Coupons&&sourceCart.Coupons.length>0){const coupons=sourceCart.Coupons.map(coupon=>{return coupon.Code;});try{updatedCart=await addCouponsAsync({callerContext:ctx},destinationCart.Id,coupons,false);}catch(e){ctx.telemetry.error('Error adding existing coupon codes to the cart');ctx.telemetry.exception(e);return destinationCart;}}}return updatedCart||destinationCart;}/**\r\n * Function to claim a cart as auth cart and set the browser cookie accordingly\r\n *\r\n * @param cartId Cart Id to claim as auth cart\r\n * @param ctx Request Context\r\n */export async function claimCart(cartId,ctx){const claimAuthCart=await updateAsync({callerContext:ctx},{Id:cartId});if(!(claimAuthCart instanceof Error)&&claimAuthCart&&claimAuthCart.Id){return claimAuthCart;}else{return{};}}/**\r\n * Function to search carts that belong to a customer\r\n *\r\n * @param ctx Request context\r\n */export async function searchCarts(ctx){const cartSearchCriteria={IncludeAnonymous:false,CartTypeValue:1};const queryResultSettings={Paging:{Top:1,Skip:0},Sorting:{Columns:[{ColumnName:'ModifiedDateTime'}]}};return searchAsync({callerContext:ctx,queryResultSettings:queryResultSettings},cartSearchCriteria);}","map":{"version":3,"sources":["cart-state/get-or-create-active-cart.ts"],"names":[],"mappings":"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","sourcesContent":["import { IActionContext } from '@msdyn365-commerce/core';\nimport { addCartLinesAsync, addCouponsAsync, createCartAsync, readAsync, removeCartLinesAsync, searchAsync, updateAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';\nimport { getCustomerLoyaltyCardsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';\nimport { Cart, CartLine, CartSearchCriteria, Coupon, QueryResultSettings } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';\n\nconst enum CartTokenPrefix {\n    Auth = 't',\n    Anon = 'p'\n}\n\nexport default async function getOrCreateActiveCart(ctx: IActionContext): Promise<Cart | undefined> {\n    let cart: Cart | undefined;\n    const cartCookie: string = ctx.requestContext.cookies.getCartCookie();\n    const cartCookieParts: string[] = cartCookie.split(':');\n    try {\n        // Check if there are already is a cart cookie and it is in the format we understand\n        cart = await getCartFromCookie(cartCookieParts, ctx);\n        const wasReadFromCookie = !!cart && cart.Id;\n\n        // If the customer is authenticated, and the auth cookie didn't give us a cart OR doesn't have a cookie, search for the customer's cart\n        if (!(cart && cart.Id)) {\n            cart = await getCartFromCustomer(ctx);\n        }\n\n        // if the customer just went from anon to signed in state then get that anon cart\n        // if the search of carts didn't result in a cart, claim the current anon cart as a new auth cart for the customer\n        // if the search resulted in a cart, and the read also resulted in cart, then go ahead an merge the carts\n        const anonCart = await claimAnonCart(cartCookieParts, cart, ctx);\n        if (anonCart) {\n            cart = anonCart;\n        }\n\n        // If there is no cookie or everything else fails, create an empty cart and return that for the customer\n        if (!(cart && cart.Id)) {\n            cart = await createNewCart(ctx);\n        }\n        if (!wasReadFromCookie && ctx.requestContext.user.isAuthenticated && cart && !cart.LoyaltyCardId) {\n            const card = await getCustomerLoyaltyCardsAsync({ callerContext: ctx, queryResultSettings: {} }, null);\n            if (card && card.length > 0) {\n\n                cart = await updateAsync(\n                    { callerContext: ctx },\n                    {\n                        Id: cart.Id,\n                        LoyaltyCardId: card[0].CardNumber\n                    }\n                );\n            }\n        }\n\n    } catch (ex) {\n        ctx.telemetry.error(`Caught exception in getting cart: ${ex}`);\n        cart = await createNewCart(ctx);\n    }\n    return cart;\n}\n\nexport async function createNewCart(ctx: IActionContext): Promise<Cart | undefined> {\n    const newCart = await createCartAsync({ callerContext: ctx }, <Cart>{});\n    if (newCart && newCart.Id) {\n        ctx.requestContext.cookies.setCartCookie(newCart, ctx.requestContext.user.isAuthenticated);\n\n        return newCart;\n    }\n\n    return undefined;\n}\n\nexport async function getCartFromCookie(cartCookieParts: string[], ctx: IActionContext): Promise<Cart | undefined> {\n    if (cartCookieParts && cartCookieParts.length === 2) {\n        // If the customer is authenticated and they have an auth cookie\n        // OR if the customer is not authenticated and then have an anon cookie\n        // just get the cart and return that\n\n        if ((ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Auth) ||\n            (!ctx.requestContext.user.isAuthenticated && cartCookieParts[0] === CartTokenPrefix.Anon)) {\n            const readCart = await readAsync({ callerContext: ctx, bypassCache: 'none' }, cartCookieParts[1]);\n\n            if (readCart && readCart.Id) {\n                ctx.requestContext.cookies.setCartCookie(readCart, ctx.requestContext.user.isAuthenticated);\n                return readCart;\n            }\n        }\n    }\n\n    return undefined;\n}\n\nexport async function getCartFromCustomer(ctx: IActionContext): Promise<Cart | undefined> {\n    if (ctx.requestContext.user.isAuthenticated) {\n        const authCarts = await searchCarts(ctx);\n        if (authCarts && authCarts.length > 0) {\n            ctx.requestContext.cookies.setCartCookie(authCarts[0], ctx.requestContext.user.isAuthenticated);\n            return authCarts[0];\n        }\n    }\n\n    return undefined;\n}\n\nexport async function claimAnonCart(cartCookieParts: string[], currentCart: Cart | undefined, ctx: IActionContext): Promise<Cart | undefined> {\n    if (ctx.requestContext.user.isAuthenticated && cartCookieParts && cartCookieParts.length === 2 && cartCookieParts[0] === CartTokenPrefix.Anon) {\n        const anonCurrentCart = await readAsync({ callerContext: ctx, bypassCache: 'none' }, cartCookieParts[1]);\n\n        if (anonCurrentCart && !currentCart) {\n            const newCart = await claimCart(anonCurrentCart.Id, ctx);\n            if (newCart && newCart.Id) {\n                ctx.requestContext.cookies.setCartCookie(newCart, ctx.requestContext.user.isAuthenticated);\n                return newCart;\n            }\n        }\n\n        if (anonCurrentCart && anonCurrentCart.Id && currentCart) {\n            const mergedCart = await addCartLines(anonCurrentCart, currentCart, ctx);\n            // Once updated, take that merged cart ID and store the cart ID in the cookie\n            if (!(mergedCart instanceof Error) && mergedCart.Id) {\n                ctx.requestContext.cookies.setCartCookie(mergedCart, ctx.requestContext.user.isAuthenticated);\n                return mergedCart;\n            }\n        }\n    }\n\n    return undefined;\n}\n\n/**\n * Function that copies a cartline for giftcard\n * @param cartline Source CartLine you want to copy\n */\nfunction buildGiftCardLine(cartline: CartLine): CartLine {\n    return {\n        DeliveryMode: cartline.DeliveryMode,\n        CatalogId: cartline.CatalogId,\n        Description: cartline.Description,\n        EntryMethodTypeValue: cartline.EntryMethodTypeValue || 3,\n        ItemId: cartline.ItemId,\n        ProductId: cartline.ProductId,\n        Quantity: cartline.Quantity,\n        Price: cartline.Price,\n        NetPrice: cartline.NetPrice,\n        GiftCardBalance: cartline.GiftCardBalance,\n        TrackingId: '',\n        UnitOfMeasureSymbol: cartline.UnitOfMeasureSymbol,\n        IsPriceKeyedIn: true,\n        IsGiftCardLine: true,\n        ExtensionProperties: cartline.ExtensionProperties\n    };\n}\n\n/**\n * Function that adds cart lines from source cart to destination cart\n * @param sourceCart Source cart you want to add cart lines from\n * @param destinationCart Destination cart that you want to add cart lines to\n * @param ctx Request context\n */\nexport async function addCartLines(sourceCart: Cart, destinationCart: Cart, ctx: IActionContext): Promise<Cart> {\n    let updatedCart;\n    const cartLines: CartLine[] = [];\n    const cartLinesToDelete: string[] = [];\n\n    const channelConfiguration = ctx.requestContext.channel;\n\n    if (destinationCart.Version) {\n        if (sourceCart.CartLines && sourceCart.CartLines.length > 0) {\n            for (const cartline of sourceCart.CartLines) {\n                let newCartLine: CartLine;\n\n                if (cartline.IsGiftCardLine) {\n                    newCartLine = buildGiftCardLine(cartline);\n                } else {\n                    newCartLine = {};\n                    // Copy over BOPIS information from sourceCart to destination cart\n                    if (cartline.DeliveryMode && cartline.DeliveryMode !== '' && channelConfiguration && cartline.DeliveryMode === channelConfiguration.PickupDeliveryModeCode) {\n                        newCartLine.DeliveryMode = channelConfiguration.PickupDeliveryModeCode;\n                        newCartLine.FulfillmentStoreId = cartline.FulfillmentStoreId;\n                        newCartLine.ShippingAddress = cartline.ShippingAddress;\n                    }\n\n                    newCartLine.ProductId = cartline.ProductId;\n                    newCartLine.Quantity = cartline.Quantity;\n                    newCartLine.ExtensionProperties = cartline.ExtensionProperties;\n                    newCartLine.Description = cartline.Description;\n                }\n\n                cartLines.push({ ...newCartLine });\n                if (cartline.LineId) {\n                    cartLinesToDelete.push(cartline.LineId);\n                }\n            }\n        }\n\n        if (cartLines.length > 0) {\n            try {\n                updatedCart = await addCartLinesAsync({ callerContext: ctx }, destinationCart.Id, cartLines, destinationCart.Version);\n\n                if (cartLinesToDelete.length > 0) {\n                    sourceCart = await removeCartLinesAsync({ callerContext: ctx }, sourceCart.Id, cartLinesToDelete);\n                }\n            } catch (e) {\n                ctx.telemetry.error('Error adding cart lines to desination cart');\n                ctx.telemetry.exception(e);\n                return destinationCart;\n            }\n        }\n\n        // Copy over coupon codes from source cart to destination cart so that the customer doesn't lose couponCodes while migration\n        if (sourceCart.Coupons && sourceCart.Coupons.length > 0) {\n            const coupons = sourceCart.Coupons.map((coupon: Coupon) => {\n                return coupon.Code!;\n            });\n\n            try {\n                updatedCart = await addCouponsAsync({ callerContext: ctx }, destinationCart.Id, coupons, false);\n            } catch (e) {\n                ctx.telemetry.error('Error adding existing coupon codes to the cart');\n                ctx.telemetry.exception(e);\n                return destinationCart;\n            }\n        }\n    }\n\n    return updatedCart || destinationCart;\n}\n\n/**\n * Function to claim a cart as auth cart and set the browser cookie accordingly\n *\n * @param cartId Cart Id to claim as auth cart\n * @param ctx Request Context\n */\nexport async function claimCart(cartId: string, ctx: IActionContext): Promise<Cart> {\n    const claimAuthCart = await updateAsync(\n        { callerContext: ctx },\n        {\n            Id: cartId\n        }\n    );\n    if (!(claimAuthCart instanceof Error) && claimAuthCart && claimAuthCart.Id) {\n        return claimAuthCart;\n    } else {\n        return <Cart>{};\n    }\n}\n\n/**\n * Function to search carts that belong to a customer\n *\n * @param ctx Request context\n */\nexport async function searchCarts(ctx: IActionContext): Promise<Cart[]> {\n    const cartSearchCriteria: CartSearchCriteria = {\n        IncludeAnonymous: false,\n        CartTypeValue: 1\n    };\n\n    const queryResultSettings: QueryResultSettings = {\n        Paging: {\n            Top: 1,\n            Skip: 0\n        },\n        Sorting: {\n            Columns: [\n                {\n                    ColumnName: 'ModifiedDateTime'\n                }\n            ]\n        }\n    };\n\n    return searchAsync({ callerContext: ctx, queryResultSettings: queryResultSettings }, cartSearchCriteria);\n}"],"sourceRoot":"./src/"},"metadata":{},"sourceType":"module"}
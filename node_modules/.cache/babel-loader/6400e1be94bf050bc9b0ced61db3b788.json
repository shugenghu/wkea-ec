{"ast":null,"code":"import\"core-js/modules/web.dom-collections.iterator.js\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */ /**\r\n * Cache with TTL and polling to remove items from it, default implementaiton is to only poll on server\r\n */export class TTLCache{constructor(options){this.removalThresholdInMs=options&&options.removalThresholdInMs||300000;this.intervalForRemovalInMs=options&&options.intervalForRemovalInMs||120000;this._cache=new Map();if(process.env.CURRENT_ENVIRONMENT==='node'){// interval trigger to clear the map -- only on server\nsetInterval(()=>this._cleanCache(),this.intervalForRemovalInMs);}}/**\r\n     * Gets a value from cache\r\n     *\r\n     * @param {string} key the key\r\n     * @returns {(TValue | undefined)} the value, if it exists\r\n     */get(key){const value=this._cache.get(key);if(value){return value[0];}}/**\r\n     * Set a value\r\n     *\r\n     * @param {string} key the key\r\n     * @param {TValue} value the value\r\n     */set(key,value,onRemoveCallback){const now=Date.now();this._cache.set(key,[value,now,onRemoveCallback]);}clear(){this._cache.clear();}// cleans up the map implementation\n_cleanCache(){const now=Date.now();const keys=this._cache.keys();for(const key of keys){const value=this._cache.get(key);if(value&&value.length>1&&now-value[1]>this.removalThresholdInMs){this._cache.delete(key);if(typeof value[2]==='function'){value[2](key);}}}}}","map":{"version":3,"sources":["../../../../src/_server/inteceptors/ttl-cache.ts"],"names":[],"mappings":"wDAAA;;;AAGG,G,CAQH;;AAEG,GACH,MAAM,MAAO,CAAA,QAAQ,CAUjB,WAAA,CAAY,OAAZ,CAAsC,CAClC,KAAK,oBAAL,CAA6B,OAAO,EAAI,OAAO,CAAC,oBAApB,EAA6C,MAAzE,CACA,KAAK,sBAAL,CAA+B,OAAO,EAAI,OAAO,CAAC,sBAApB,EAA+C,MAA7E,CACA,KAAK,MAAL,CAAc,GAAI,CAAA,GAAJ,EAAd,CAEA,GAAI,OAAO,CAAC,GAAR,CAAY,mBAAZ,GAAoC,MAAxC,CAAgD,CAC5C;AACA,WAAW,CAAC,IAAM,KAAK,WAAL,EAAP,CAA2B,KAAK,sBAAhC,CAAX,CACH,CACJ,CAED;;;;;AAKG,OACI,GAAG,CAAC,GAAD,CAAY,CAClB,KAAM,CAAA,KAAK,CAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAd,CACA,GAAI,KAAJ,CAAW,CACP,MAAO,CAAA,KAAK,CAAC,CAAD,CAAZ,CACH,CACJ,CAED;;;;;AAKG,OACI,GAAG,CAAC,GAAD,CAAc,KAAd,CAA6B,gBAA7B,CAAiE,CACvE,KAAM,CAAA,GAAG,CAAG,IAAI,CAAC,GAAL,EAAZ,CACA,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAqB,CAAC,KAAD,CAAQ,GAAR,CAAa,gBAAb,CAArB,EACH,CAEM,KAAK,EAAA,CACR,KAAK,MAAL,CAAY,KAAZ,GACH,CAED;AACQ,WAAW,EAAA,CACf,KAAM,CAAA,GAAG,CAAG,IAAI,CAAC,GAAL,EAAZ,CACA,KAAM,CAAA,IAAI,CAAG,KAAK,MAAL,CAAY,IAAZ,EAAb,CACA,IAAK,KAAM,CAAA,GAAX,GAAkB,CAAA,IAAlB,CAAwB,CACpB,KAAM,CAAA,KAAK,CAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,GAAhB,CAAd,CACA,GAAI,KAAK,EAAI,KAAK,CAAC,MAAN,CAAe,CAAxB,EAA6B,GAAG,CAAG,KAAK,CAAC,CAAD,CAAX,CAAiB,KAAK,oBAAvD,CAA6E,CACzE,KAAK,MAAL,CAAY,MAAZ,CAAmB,GAAnB,EACA,GAAI,MAAO,CAAA,KAAK,CAAC,CAAD,CAAZ,GAAoB,UAAxB,CAAoC,CAChC,KAAK,CAAC,CAAD,CAAL,CAAS,GAAT,EACH,CACJ,CACJ,CACJ,CA9DgB","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nexport interface ITTLCacheOptions {\n    removalThresholdInMs?: number;\n    intervalForRemovalInMs?: number;\n}\n\nexport type TOnRemoveCallback = (removedKey: string) => void;\n/**\n * Cache with TTL and polling to remove items from it, default implementaiton is to only poll on server\n */\nexport class TTLCache<TValue> {\n    // threshold for removal, 5mins\n    public readonly removalThresholdInMs: number;\n\n    // frequency of cleaning, 2mins -- this is the period it'll look for keys older than removalThresholdInMs\n    public readonly intervalForRemovalInMs: number;\n\n    // internal cache\n    private _cache: Map<string, [TValue, number, TOnRemoveCallback?]>;\n\n    constructor(options?: ITTLCacheOptions) {\n        this.removalThresholdInMs = (options && options.removalThresholdInMs) || 300000;\n        this.intervalForRemovalInMs = (options && options.intervalForRemovalInMs) || 120000;\n        this._cache = new Map<string, [TValue, number, TOnRemoveCallback?]>();\n\n        if (process.env.CURRENT_ENVIRONMENT === 'node') {\n            // interval trigger to clear the map -- only on server\n            setInterval(() => this._cleanCache(), this.intervalForRemovalInMs);\n        }\n    }\n\n    /**\n     * Gets a value from cache\n     *\n     * @param {string} key the key\n     * @returns {(TValue | undefined)} the value, if it exists\n     */\n    public get(key: string): TValue | undefined {\n        const value = this._cache.get(key);\n        if (value) {\n            return value[0];\n        }\n    }\n\n    /**\n     * Set a value\n     *\n     * @param {string} key the key\n     * @param {TValue} value the value\n     */\n    public set(key: string, value: TValue, onRemoveCallback?: TOnRemoveCallback): void {\n        const now = Date.now();\n        this._cache.set(key, [value, now, onRemoveCallback]);\n    }\n\n    public clear(): void {\n        this._cache.clear();\n    }\n\n    // cleans up the map implementation\n    private _cleanCache(): void {\n        const now = Date.now();\n        const keys = this._cache.keys();\n        for (const key of keys) {\n            const value = this._cache.get(key);\n            if (value && value.length > 1 && now - value[1] > this.removalThresholdInMs) {\n                this._cache.delete(key);\n                if (typeof value[2] === 'function') {\n                    value[2](key);\n                }\n            }\n        }\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
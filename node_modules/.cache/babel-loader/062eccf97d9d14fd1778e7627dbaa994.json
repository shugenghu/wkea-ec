{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/esm/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */export var MAX_DATA_SERVICE_VERSION='4.0';export var jsonMediaType='application/json';var CONTENT_TYPE_HEADER_NAME='Content-Type';var ODATA_VERSION='OData-Version';var ODATA_MAX_VERSION='OData-MaxVersion';var contentType=function contentType(str){/// <summary>Parses a string into an object with media type and properties.</summary>\n/// <param name=\"str\" type=\"String\">String with media type to parse.</param>\n/// <returns>null if the string is empty; an object with 'mediaType' and a 'properties' dictionary otherwise.</returns>\nif(!str){return null;}var contentTypeParts=str.split(';');var properties={};var i;var len;for(i=1,len=contentTypeParts.length;i<len;i++){var contentTypeParams=contentTypeParts[i].split('=');properties[contentTypeParams[0].trim()]=contentTypeParams[1];}return{mediaType:contentTypeParts[0].trim(),properties:properties};};export var jsonContentType=contentType(jsonMediaType);var contentTypeToString=function contentTypeToString(contentTypeObj){/// <summary>Serializes an object with media type and properties dictionary into a string.</summary>\n/// <param name=\"contentType\">Object with media type and properties dictionary to serialize.</param>\n/// <returns>String representation of the media type object; undefined if contentType is null or undefined.</returns>\nif(!contentTypeObj){return undefined;}var result=contentTypeObj.mediaType;for(var property in contentTypeObj.properties){if(contentTypeObj.properties.hasOwnProperty(property)){result+=';'+property+'='+contentTypeObj.properties[property];}}return result;};var createReadWriteContext=function createReadWriteContext(contentTypeStr,dataServiceVersion,context,handler){/// <summary>Creates an object that is going to be used as the context for the handler's parser and serializer.</summary>\n/// <param name=\"contentType\">Object with media type and properties dictionary.</param>\n/// <param name=\"dataServiceVersion\" type=\"String\">String indicating the version of the protocol to use.</param>\n/// <param name=\"context\">Operation context.</param>\n/// <param name=\"handler\">Handler object that is processing a resquest or response.</param>\n/// <returns>Context object.</returns>\n// First create a clone\nvar rwContext=_objectSpread({},context);// And then override with provided parameters\nrwContext['contentType']=contentTypeStr||jsonContentType;rwContext['dataServiceVersion']=dataServiceVersion;rwContext['handler']=handler;return rwContext;};var versionRE=/^\\s?(\\d+\\.\\d+);?.*$/;var getDataServiceVersion=function getDataServiceVersion(headerVersion){/// <summary>Gets the value of the OData-Version header from a request or response.</summary>\n/// <param name=\"requestOrResponse\">Object representing a request or a response.</param>\n/// <returns type=\"String\">Data service version; undefined if the header cannot be found.</returns>\nif(headerVersion){var matches=versionRE.exec(headerVersion);if(matches&&matches.length){return matches[1];}}};var handlerRead=function handlerRead(handler,response,context){/// <summary>Invokes the parser associated with a handler for reading the payload of a HTTP response.</summary>\n/// <param name=\"handler\">Handler object that is processing the response.</param>\n/// <param name=\"parseCallback\" type=\"Function\">Parser function that will process the response payload.</param>\n/// <param name=\"response\">HTTP response whose payload is going to be processed.</param>\n/// <param name=\"context\">Object used as the context for processing the response.</param>\n/// <returns type=\"Boolean\">True if the handler processed the response payload and the response.data property was set; false otherwise.</returns>\nif(!response||!response.headers){return false;}var cType=contentType(response.headers[CONTENT_TYPE_HEADER_NAME]);var version=getDataServiceVersion(response)||'';var body=response.body;if(!body){return false;}if(jsonMediaType.indexOf(cType.mediaType)>=0){var readContext=createReadWriteContext(cType,version,context,handler);readContext.response=response;response.data=typeof body==='string'?JSON.parse(body):body;return response.data!==undefined;}return false;};var maxVersion=function maxVersion(left,right){/// <summary>Compares to version strings and returns the higher one.</summary>\n/// <param name=\"left\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n/// <param name=\"right\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n/// <returns type=\"String\">The higher version string.</returns>\nif(left===right){return left;}var leftParts=left.split('.');var rightParts=right.split('.');var len=leftParts.length>=rightParts.length?leftParts.length:rightParts.length;for(var i=0;i<len;i++){var leftVersion=leftParts[i]&&parseInt(leftParts[i],10);var rightVersion=rightParts[i]&&parseInt(rightParts[i],10);if(leftVersion>rightVersion){return left;}if(leftVersion<rightVersion){return right;}}};var handlerWrite=function handlerWrite(handler,request,context){/// <summary>Invokes the serializer associated with a handler for generating the payload of a HTTP request.</summary>\n/// <param name=\"handler\">Handler object that is processing the request.</param>\n/// <param name=\"serializeCallback\" type=\"Function\">Serializer function that will generate the request payload.</param>\n/// <param name=\"response\">HTTP request whose payload is going to be generated.</param>\n/// <param name=\"context\">Object used as the context for serializing the request.</param>\n/// <returns type=\"Boolean\">True if the handler serialized the request payload and the request.body property was set; false otherwise.</returns>\nif(!request||!request.headers){return false;}var cType=contentType(request.headers[CONTENT_TYPE_HEADER_NAME]);var version=getDataServiceVersion(request.headers[ODATA_VERSION]);if(!cType||jsonMediaType.indexOf(cType.mediaType)){var writeContext=createReadWriteContext(cType,version,context,handler);writeContext.request=request;request.body=request.data;if(request.body!==undefined){request.headers[ODATA_VERSION]=version?maxVersion(version,'4.0'):'4.0';request.headers.ContentType=request.headers[CONTENT_TYPE_HEADER_NAME]||contentTypeToString(writeContext.contentType);request.headers[ODATA_MAX_VERSION]=request.headers[ODATA_MAX_VERSION]||handler.maxDataServiceVersion;return true;}}return false;};export var jsonHandler={accept:jsonMediaType,maxDataServiceVersion:MAX_DATA_SERVICE_VERSION,read:function read(response,context){return handlerRead(this,response,context);},write:function write(request,context){return handlerWrite(this,request,context);}};","map":{"version":3,"sources":["../../src/externals/handler.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nexport const MAX_DATA_SERVICE_VERSION = '4.0';\nexport const jsonMediaType = 'application/json';\n\nconst CONTENT_TYPE_HEADER_NAME = 'Content-Type';\nconst ODATA_VERSION = 'OData-Version';\nconst ODATA_MAX_VERSION = 'OData-MaxVersion';\n\nconst contentType = str => {\n    /// <summary>Parses a string into an object with media type and properties.</summary>\n    /// <param name=\"str\" type=\"String\">String with media type to parse.</param>\n    /// <returns>null if the string is empty; an object with 'mediaType' and a 'properties' dictionary otherwise.</returns>\n\n    if (!str) {\n        return null;\n    }\n\n    const contentTypeParts = str.split(';');\n    const properties = {};\n\n    let i;\n    let len;\n    for (i = 1, len = contentTypeParts.length; i < len; i++) {\n        const contentTypeParams = contentTypeParts[i].split('=');\n        properties[contentTypeParams[0].trim()] = contentTypeParams[1];\n    }\n\n    return { mediaType: contentTypeParts[0].trim(), properties };\n};\n\nexport const jsonContentType = contentType(jsonMediaType);\n\nconst contentTypeToString = contentTypeObj => {\n    /// <summary>Serializes an object with media type and properties dictionary into a string.</summary>\n    /// <param name=\"contentType\">Object with media type and properties dictionary to serialize.</param>\n    /// <returns>String representation of the media type object; undefined if contentType is null or undefined.</returns>\n\n    if (!contentTypeObj) {\n        return undefined;\n    }\n\n    let result = contentTypeObj.mediaType;\n    for (const property in contentTypeObj.properties) {\n        if (contentTypeObj.properties.hasOwnProperty(property)) {\n            result += ';' + property + '=' + contentTypeObj.properties[property];\n        }\n    }\n    return result;\n};\n\nconst createReadWriteContext = (contentTypeStr, dataServiceVersion, context, handler) => {\n    /// <summary>Creates an object that is going to be used as the context for the handler's parser and serializer.</summary>\n    /// <param name=\"contentType\">Object with media type and properties dictionary.</param>\n    /// <param name=\"dataServiceVersion\" type=\"String\">String indicating the version of the protocol to use.</param>\n    /// <param name=\"context\">Operation context.</param>\n    /// <param name=\"handler\">Handler object that is processing a resquest or response.</param>\n    /// <returns>Context object.</returns>\n\n    // First create a clone\n    const rwContext = { ...context };\n\n    // And then override with provided parameters\n    rwContext['contentType'] = contentTypeStr || jsonContentType;\n    rwContext['dataServiceVersion'] = dataServiceVersion;\n    rwContext['handler'] = handler;\n\n    return rwContext;\n};\n\nconst versionRE = /^\\s?(\\d+\\.\\d+);?.*$/;\nconst getDataServiceVersion = headerVersion => {\n    /// <summary>Gets the value of the OData-Version header from a request or response.</summary>\n    /// <param name=\"requestOrResponse\">Object representing a request or a response.</param>\n    /// <returns type=\"String\">Data service version; undefined if the header cannot be found.</returns>\n\n    if (headerVersion) {\n        const matches = versionRE.exec(headerVersion);\n        if (matches && matches.length) {\n            return matches[1];\n        }\n    }\n};\n\nconst handlerRead = (handler, response, context) => {\n    /// <summary>Invokes the parser associated with a handler for reading the payload of a HTTP response.</summary>\n    /// <param name=\"handler\">Handler object that is processing the response.</param>\n    /// <param name=\"parseCallback\" type=\"Function\">Parser function that will process the response payload.</param>\n    /// <param name=\"response\">HTTP response whose payload is going to be processed.</param>\n    /// <param name=\"context\">Object used as the context for processing the response.</param>\n    /// <returns type=\"Boolean\">True if the handler processed the response payload and the response.data property was set; false otherwise.</returns>\n\n    if (!response || !response.headers) {\n        return false;\n    }\n\n    const cType = contentType(response.headers[CONTENT_TYPE_HEADER_NAME]);\n    const version = getDataServiceVersion(response) || '';\n    const body = response.body;\n\n    if (!body) {\n        return false;\n    }\n\n    if (jsonMediaType.indexOf(cType.mediaType) >= 0) {\n        const readContext = createReadWriteContext(cType, version, context, handler);\n        readContext.response = response;\n        response.data = typeof body === 'string' ? JSON.parse(body) : body;\n        return response.data !== undefined;\n    }\n\n    return false;\n};\n\nconst maxVersion = (left, right) => {\n    /// <summary>Compares to version strings and returns the higher one.</summary>\n    /// <param name=\"left\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n    /// <param name=\"right\" type=\"String\">Version string in the form \"major.minor.rev\"</param>\n    /// <returns type=\"String\">The higher version string.</returns>\n\n    if (left === right) {\n        return left;\n    }\n\n    const leftParts = left.split('.');\n    const rightParts = right.split('.');\n\n    const len = leftParts.length >= rightParts.length ? leftParts.length : rightParts.length;\n\n    for (let i = 0; i < len; i++) {\n        const leftVersion = leftParts[i] && parseInt(leftParts[i], 10);\n        const rightVersion = rightParts[i] && parseInt(rightParts[i], 10);\n        if (leftVersion > rightVersion) {\n            return left;\n        }\n        if (leftVersion < rightVersion) {\n            return right;\n        }\n    }\n};\n\nconst handlerWrite = (handler, request, context) => {\n    /// <summary>Invokes the serializer associated with a handler for generating the payload of a HTTP request.</summary>\n    /// <param name=\"handler\">Handler object that is processing the request.</param>\n    /// <param name=\"serializeCallback\" type=\"Function\">Serializer function that will generate the request payload.</param>\n    /// <param name=\"response\">HTTP request whose payload is going to be generated.</param>\n    /// <param name=\"context\">Object used as the context for serializing the request.</param>\n    /// <returns type=\"Boolean\">True if the handler serialized the request payload and the request.body property was set; false otherwise.</returns>\n    if (!request || !request.headers) {\n        return false;\n    }\n\n    const cType = contentType(request.headers[CONTENT_TYPE_HEADER_NAME]);\n    const version = getDataServiceVersion(request.headers[ODATA_VERSION]);\n\n    if (!cType || jsonMediaType.indexOf(cType.mediaType)) {\n        const writeContext = createReadWriteContext(cType, version, context, handler);\n        writeContext.request = request;\n        request.body = request.data;\n\n        if (request.body !== undefined) {\n            request.headers[ODATA_VERSION] = version ? maxVersion(version, '4.0') : '4.0';\n            request.headers.ContentType = request.headers[CONTENT_TYPE_HEADER_NAME] || contentTypeToString(writeContext.contentType);\n            request.headers[ODATA_MAX_VERSION] = request.headers[ODATA_MAX_VERSION] || handler.maxDataServiceVersion;\n            return true;\n        }\n    }\n\n    return false;\n};\n\nexport const jsonHandler = {\n    accept: jsonMediaType,\n    maxDataServiceVersion: MAX_DATA_SERVICE_VERSION,\n    read(response, context) {\n        return handlerRead(this, response, context);\n    },\n\n    write(request, context) {\n        return handlerWrite(this, request, context);\n    }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _asyncToGenerator from\"@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{LogLevel,StaticTelemetry}from'@msdyn365-commerce/telemetry-internal';import axios from'axios';import{coerce,lt}from'semver';// Cache timings for access and key vault secrets\nexport var DEFAULT_ACCESS_TOKEN_SECRET_TTL=86400;export var DEFAULT_ACCESS_TOKEN_SECRET_TTR=500;export var DEFAULT_KV_SECRET_TTL=86400;export var DEFAULT_KV_SECRET_TTR=500;export var ACCESS_TOKEN_SECRET_CACHE_TYPE='ACCESSTOKEN';export var KEY_VAULT_SECRET_CACHE_TYPE='KEYVAULT';export var ACCESS_TOKEN_SECRET_KEY='RETAIL_SERVER';var X_IDENTITY_HEADER='X-IDENTITY-HEADER';var MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS='9.24.2';export var AppSecretRefreshType;(function(AppSecretRefreshType){AppSecretRefreshType[\"ACCESS_TOKEN\"]=\"ACCESSTOKEN\";AppSecretRefreshType[\"KEY_VAULT\"]=\"KEYVAULT\";})(AppSecretRefreshType||(AppSecretRefreshType={}));/**\r\n * SecretManager class exposes one public method used to access customer secrets from key-vault\r\n * Access token (used to talk to the RS API that will retrive customer secrets) and secrets are cached in\r\n * an app-cache entry. The instantiated class is available on the global msdyn365Commerce object but only server-side\r\n */export var SecretManager=/*#__PURE__*/function(){function SecretManager(appSecretsCache,localSecrets){_classCallCheck(this,SecretManager);this._appSecretsCache=appSecretsCache;this._localSecrets=localSecrets;}/**\r\n     * Returns the customer defined secret value given a secret key.\r\n     * If the secret key could not be found an empty string is returned\r\n     *\r\n     * @param secretKey The secret key\r\n     */_createClass(SecretManager,[{key:\"getSecretValue\",value:function(){var _getSecretValue=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(secretKey,baseRetailServerURL){var accessTokenCacheKey,keyVaultSecretCacheKey,rsAccessToken,customerSecretValue;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(process.env.NODE_ENV==='development')){_context.next=2;break;}return _context.abrupt(\"return\",this._localSecrets&&this._localSecrets[secretKey]?{value:this._localSecrets[secretKey],expiresOn:1}:{value:'',error:new Error(\"Unable to find local secrets file or secrey key does not exist in local secrets file.\"),expiresOn:1});case 2:if(!(process.env.DEPLOYMENT_ENV!=='WEBAPP')){_context.next=4;break;}return _context.abrupt(\"return\",{value:'',error:new Error(\"KeyVault Access only supported in App Service Environments\"),expiresOn:1});case 4:if(!lt(coerce(process.env.MSDyn365Commerce_RSVERSION)||'',MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS)){_context.next=6;break;}return _context.abrupt(\"return\",{value:'',error:new Error(\"Retail Proxy version \".concat(MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS,\" or greater is required\")),expiresOn:1});case 6:accessTokenCacheKey={typeName:ACCESS_TOKEN_SECRET_CACHE_TYPE,key:ACCESS_TOKEN_SECRET_KEY};keyVaultSecretCacheKey={typeName:KEY_VAULT_SECRET_CACHE_TYPE,key:secretKey.toUpperCase()};// Get the cached access token or fetch the new token if it does not exist in the cache/has expired\n_context.next=10;return this._readCachedAppSecrets(accessTokenCacheKey,{refreshType:AppSecretRefreshType.ACCESS_TOKEN,parameters:[]});case 10:rsAccessToken=_context.sent;if(!(!rsAccessToken||rsAccessToken.error||rsAccessToken.expiresOn<=Math.floor(Date.now()/1000)||rsAccessToken.error)){_context.next=20;break;}_context.next=14;return this._getRSAccessToken();case 14:rsAccessToken=_context.sent;if(!rsAccessToken.error){_context.next=19;break;}return _context.abrupt(\"return\",rsAccessToken);case 19:this._appSecretsCache.put(accessTokenCacheKey,{item:rsAccessToken});case 20:_context.next=22;return this._readCachedAppSecrets(keyVaultSecretCacheKey,{refreshType:AppSecretRefreshType.KEY_VAULT,parameters:[rsAccessToken.value,secretKey,baseRetailServerURL]});case 22:customerSecretValue=_context.sent;if(!(!customerSecretValue||customerSecretValue.error||customerSecretValue.expiresOn<=Math.floor(Date.now()/1000))){_context.next=32;break;}_context.next=26;return this._getKVSecretValue(rsAccessToken.value,secretKey,baseRetailServerURL);case 26:customerSecretValue=_context.sent;if(!customerSecretValue.error){_context.next=31;break;}return _context.abrupt(\"return\",customerSecretValue);case 31:this._appSecretsCache.put(keyVaultSecretCacheKey,{item:customerSecretValue});case 32:return _context.abrupt(\"return\",customerSecretValue);case 33:case\"end\":return _context.stop();}}},_callee,this);}));function getSecretValue(_x,_x2){return _getSecretValue.apply(this,arguments);}return getSecretValue;}()},{key:\"_readCachedAppSecrets\",value:function(){var _readCachedAppSecrets2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cacheKey,appSecretRefreshOptions){var _this=this;var appSecretsEntry,appSecretsItem,refresh;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:appSecretsItem=this._appSecretsCache.get(cacheKey);if(appSecretsItem&&appSecretsItem.shouldRefresh){// doing background refresh here.\n// tslint:disable-next-line:no-any\nrefresh=new Promise(function(res,rej){var newAppSecretsItem;switch(appSecretRefreshOptions.refreshType){case AppSecretRefreshType.ACCESS_TOKEN:newAppSecretsItem=_this._getRSAccessToken();break;case AppSecretRefreshType.KEY_VAULT:newAppSecretsItem=_this._getKVSecretValue(appSecretRefreshOptions.parameters[0],appSecretRefreshOptions.parameters[1],appSecretRefreshOptions.parameters[2]);break;default:}res(newAppSecretsItem);});refresh.then(function(newSecretValue){_this._appSecretsCache.put(cacheKey,{item:newSecretValue});})[\"catch\"](function(err){StaticTelemetry.log(LogLevel.Error,\"Background refresh for secret manager type \".concat(appSecretRefreshOptions.refreshType.toString(),\" failed\"),{exception:err});});}appSecretsEntry=appSecretsItem?appSecretsItem.item:undefined;return _context2.abrupt(\"return\",appSecretsEntry);case 4:case\"end\":return _context2.stop();}}},_callee2,this);}));function _readCachedAppSecrets(_x3,_x4){return _readCachedAppSecrets2.apply(this,arguments);}return _readCachedAppSecrets;}()/**\r\n     * Fetches the bearer access token that Node will use to authenticate with retail server\r\n     */},{key:\"_getRSAccessToken\",value:function(){var _getRSAccessToken2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){var response,clientId,headers,data,_response,err;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;clientId=process.env.IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC;if(clientId){_context3.next=4;break;}throw new Error(\"User Assigned MSI Client ID env variable is missing. IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC is not defined\");case 4:headers={};headers[X_IDENTITY_HEADER]=\"\".concat(process.env.IDENTITY_HEADER);_context3.next=8;return axios.get(\"\".concat(process.env.IDENTITY_ENDPOINT,\"/?resource=https://commerce.dynamics.com&api-version=2019-08-01&client_id=\").concat(clientId),{headers:headers});case 8:response=_context3.sent;_context3.next=15;break;case 11:_context3.prev=11;_context3.t0=_context3[\"catch\"](0);StaticTelemetry.log(LogLevel.Error,\"Unable to retireve retail server access token.\",{exception:_context3.t0});return _context3.abrupt(\"return\",{value:'',error:_context3.t0,expiresOn:1});case 15:if(!(response&&response.data&&response.status===200)){_context3.next=20;break;}data=response.data;return _context3.abrupt(\"return\",{value:data.access_token,expiresOn:data.expires_on});case 20:err=new Error(\"Access Token Fetch failed with response \".concat((_response=response)===null||_response===void 0?void 0:_response.status));StaticTelemetry.log(LogLevel.Error,\"Unable to retireve retail server access token.\",{exception:err});return _context3.abrupt(\"return\",{value:'',error:err,expiresOn:1});case 23:case\"end\":return _context3.stop();}}},_callee3,null,[[0,11]]);}));function _getRSAccessToken(){return _getRSAccessToken2.apply(this,arguments);}return _getRSAccessToken;}()/**\r\n     * Returns the secret value for the given secret key\r\n     *\r\n     * @param accessToken The access token obtained from user assigned identity\r\n     * @param secretKey The secret key\r\n     * @param baseRsURL The base retail server url where the key was configured\r\n     */},{key:\"_getKVSecretValue\",value:function(){var _getKVSecretValue2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(accessToken,secretKey,baseRsURL){var response,data,_response2,err;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.prev=0;_context4.next=3;return axios.get(\"\".concat(baseRsURL,\"Commerce/GetUserDefinedSecretString(secretName='\").concat(secretKey,\"')\"),{headers:{Authorization:\"Bearer \".concat(accessToken),OUN:'128'}});case 3:response=_context4.sent;_context4.next=10;break;case 6:_context4.prev=6;_context4.t0=_context4[\"catch\"](0);StaticTelemetry.log(LogLevel.Error,\"Unable to retrieve secret value from Retail Server for key \".concat(secretKey),{exception:_context4.t0});return _context4.abrupt(\"return\",{value:'',error:_context4.t0,expiresOn:1});case 10:if(!(response&&response.data&&response.status===200)){_context4.next=15;break;}data=response.data;return _context4.abrupt(\"return\",{value:data.value,expiresOn:Math.floor((Date.now()+86400000)/1000)});case 15:err=new Error(\"Key value fetch failed with response \".concat((_response2=response)===null||_response2===void 0?void 0:_response2.status));StaticTelemetry.log(LogLevel.Error,\"Unable to retrieve secret value from Retail Server for key \".concat(secretKey),{exception:err});return _context4.abrupt(\"return\",{value:'',error:err,expiresOn:1});case 18:case\"end\":return _context4.stop();}}},_callee4,null,[[0,6]]);}));function _getKVSecretValue(_x5,_x6,_x7){return _getKVSecretValue2.apply(this,arguments);}return _getKVSecretValue;}()}]);return SecretManager;}();","map":{"version":3,"sources":["../../../src/utils/secret-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\nimport { ICache, ICacheKey } from '@msdyn365-commerce/cache-internal';\nimport { IDictionary, ISecretManager, ISecretValue } from '@msdyn365-commerce/core-internal';\nimport { LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport axios, { AxiosResponse } from 'axios';\nimport { coerce, lt } from 'semver';\n\n// Cache timings for access and key vault secrets\nexport const DEFAULT_ACCESS_TOKEN_SECRET_TTL = 86400;\nexport const DEFAULT_ACCESS_TOKEN_SECRET_TTR = 500;\nexport const DEFAULT_KV_SECRET_TTL = 86400;\nexport const DEFAULT_KV_SECRET_TTR = 500;\nexport const ACCESS_TOKEN_SECRET_CACHE_TYPE = 'ACCESSTOKEN';\nexport const KEY_VAULT_SECRET_CACHE_TYPE = 'KEYVAULT';\nexport const ACCESS_TOKEN_SECRET_KEY = 'RETAIL_SERVER';\nconst X_IDENTITY_HEADER = 'X-IDENTITY-HEADER';\n\nconst MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS = '9.24.2';\n\nexport enum AppSecretRefreshType {\n    ACCESS_TOKEN = 'ACCESSTOKEN',\n    KEY_VAULT = 'KEYVAULT'\n}\n\nexport interface IAppSecretRefreshOptions {\n    refreshType: AppSecretRefreshType;\n    parameters: string[];\n}\n\n/**\n * SecretManager class exposes one public method used to access customer secrets from key-vault\n * Access token (used to talk to the RS API that will retrive customer secrets) and secrets are cached in\n * an app-cache entry. The instantiated class is available on the global msdyn365Commerce object but only server-side\n */\nexport class SecretManager implements ISecretManager {\n    private _appSecretsCache: ICache;\n    private _localSecrets: IDictionary<string> | undefined;\n\n    constructor(appSecretsCache: ICache, localSecrets?: IDictionary<string>) {\n        this._appSecretsCache = appSecretsCache;\n        this._localSecrets = localSecrets;\n    }\n\n    /**\n     * Returns the customer defined secret value given a secret key.\n     * If the secret key could not be found an empty string is returned\n     *\n     * @param secretKey The secret key\n     */\n    public async getSecretValue(secretKey: string, baseRetailServerURL: string): Promise<ISecretValue> {\n        // In local dev scenario, read the secrets from the local secrets file\n        if (process.env.NODE_ENV === 'development') {\n            return this._localSecrets && this._localSecrets[secretKey]\n                ? { value: this._localSecrets[secretKey], expiresOn: 1 }\n                : {\n                      value: '',\n                      error: new Error(`Unable to find local secrets file or secrey key does not exist in local secrets file.`),\n                      expiresOn: 1\n                  };\n        }\n        // Non web app deployments are not supported for KV access at this time\n        if (process.env.DEPLOYMENT_ENV !== 'WEBAPP') {\n            return { value: '', error: new Error(`KeyVault Access only supported in App Service Environments`), expiresOn: 1 };\n        }\n\n        // If the current retail-proxy version does not support this API return error response\n        if (lt(coerce(process.env.MSDyn365Commerce_RSVERSION) || '', MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS)) {\n            return {\n                value: '',\n                error: new Error(`Retail Proxy version ${MIN_RETAIL_PROXY_VERSION_FOR_KV_ACCESS} or greater is required`),\n                expiresOn: 1\n            };\n        }\n        const accessTokenCacheKey: ICacheKey = {\n            typeName: ACCESS_TOKEN_SECRET_CACHE_TYPE,\n            key: ACCESS_TOKEN_SECRET_KEY\n        };\n        const keyVaultSecretCacheKey: ICacheKey = {\n            typeName: KEY_VAULT_SECRET_CACHE_TYPE,\n            key: secretKey.toUpperCase()\n        };\n        // Get the cached access token or fetch the new token if it does not exist in the cache/has expired\n        let rsAccessToken = await this._readCachedAppSecrets(accessTokenCacheKey, {\n            refreshType: AppSecretRefreshType.ACCESS_TOKEN,\n            parameters: []\n        });\n        // expiresOn property is the unix timestamp in seconds when token will expire\n        if (!rsAccessToken || rsAccessToken.error || rsAccessToken.expiresOn <= Math.floor(Date.now() / 1000) || rsAccessToken.error) {\n            rsAccessToken = await this._getRSAccessToken();\n            if (rsAccessToken.error) {\n                return rsAccessToken;\n            } else {\n                this._appSecretsCache.put<ISecretValue>(accessTokenCacheKey, { item: rsAccessToken });\n            }\n        }\n        // Use the access token to call the retail server API to retrive customer secret\n        let customerSecretValue = await this._readCachedAppSecrets(keyVaultSecretCacheKey, {\n            refreshType: AppSecretRefreshType.KEY_VAULT,\n            parameters: [rsAccessToken.value, secretKey, baseRetailServerURL]\n        });\n        if (!customerSecretValue || customerSecretValue.error || customerSecretValue.expiresOn <= Math.floor(Date.now() / 1000)) {\n            customerSecretValue = await this._getKVSecretValue(rsAccessToken.value, secretKey, baseRetailServerURL);\n            if (customerSecretValue.error) {\n                return customerSecretValue;\n            } else {\n                this._appSecretsCache.put<ISecretValue>(keyVaultSecretCacheKey, { item: customerSecretValue });\n            }\n        }\n        // Return the secret value\n        return customerSecretValue;\n    }\n\n    private async _readCachedAppSecrets(\n        cacheKey: ICacheKey,\n        appSecretRefreshOptions: IAppSecretRefreshOptions\n    ): Promise<ISecretValue | undefined> {\n        let appSecretsEntry: ISecretValue | undefined;\n        const appSecretsItem = this._appSecretsCache.get<ISecretValue>(cacheKey);\n        if (appSecretsItem && appSecretsItem.shouldRefresh) {\n            // doing background refresh here.\n            // tslint:disable-next-line:no-any\n            const refresh = new Promise<any>((res, rej) => {\n                let newAppSecretsItem;\n                switch (appSecretRefreshOptions.refreshType) {\n                    case AppSecretRefreshType.ACCESS_TOKEN:\n                        newAppSecretsItem = this._getRSAccessToken();\n                        break;\n                    case AppSecretRefreshType.KEY_VAULT:\n                        newAppSecretsItem = this._getKVSecretValue(\n                            appSecretRefreshOptions.parameters[0],\n                            appSecretRefreshOptions.parameters[1],\n                            appSecretRefreshOptions.parameters[2]\n                        );\n                        break;\n                    default:\n                }\n                res(newAppSecretsItem);\n            });\n            refresh\n                .then((newSecretValue: ISecretValue) => {\n                    this._appSecretsCache.put<ISecretValue>(cacheKey, { item: newSecretValue });\n                })\n                .catch(err => {\n                    StaticTelemetry.log(\n                        LogLevel.Error,\n                        `Background refresh for secret manager type ${appSecretRefreshOptions.refreshType.toString()} failed`,\n                        { exception: err }\n                    );\n                });\n        }\n        appSecretsEntry = appSecretsItem ? appSecretsItem.item : undefined;\n        return appSecretsEntry;\n    }\n\n    /**\n     * Fetches the bearer access token that Node will use to authenticate with retail server\n     */\n    private async _getRSAccessToken(): Promise<ISecretValue> {\n        let response: AxiosResponse;\n        try {\n            const clientId = process.env.IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC;\n            if (!clientId) {\n                throw new Error(\n                    `User Assigned MSI Client ID env variable is missing. IDENTITY_USER_ASSIGNED_CLIENTID_ENVSPECIFIC is not defined`\n                );\n            }\n            const headers: IDictionary<string> = {};\n            headers[X_IDENTITY_HEADER] = `${process.env.IDENTITY_HEADER}`;\n            response = await axios.get(\n                `${process.env.IDENTITY_ENDPOINT}/?resource=https://commerce.dynamics.com&api-version=2019-08-01&client_id=${clientId}`,\n                {\n                    headers: headers\n                }\n            );\n        } catch (err) {\n            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n        if (response && response.data && response.status === 200) {\n            const data = response.data;\n            return { value: data.access_token, expiresOn: data.expires_on };\n        } else {\n            const err = new Error(`Access Token Fetch failed with response ${response?.status}`);\n            StaticTelemetry.log(LogLevel.Error, `Unable to retireve retail server access token.`, { exception: err });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n    }\n\n    /**\n     * Returns the secret value for the given secret key\n     *\n     * @param accessToken The access token obtained from user assigned identity\n     * @param secretKey The secret key\n     * @param baseRsURL The base retail server url where the key was configured\n     */\n    private async _getKVSecretValue(accessToken: string, secretKey: string, baseRsURL: string): Promise<ISecretValue> {\n        let response: AxiosResponse;\n        try {\n            response = await axios.get(`${baseRsURL}Commerce/GetUserDefinedSecretString(secretName='${secretKey}')`, {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`,\n                    OUN: '128'\n                }\n            });\n        } catch (err) {\n            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {\n                exception: err\n            });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n        if (response && response.data && response.status === 200) {\n            const data = response.data;\n            return { value: data.value, expiresOn: Math.floor((Date.now() + 86400000) / 1000) };\n        } else {\n            const err = new Error(`Key value fetch failed with response ${response?.status}`);\n            StaticTelemetry.log(LogLevel.Error, `Unable to retrieve secret value from Retail Server for key ${secretKey}`, {\n                exception: err\n            });\n            return { value: '', error: err, expiresOn: 1 };\n        }\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import{isNullOrWhiteSpace,trim}from'./stringExtensions';export function getText(element){return!!element?element.textContent||'':'';}export function addClass(element,cssClass){if(!!element&&!isNullOrWhiteSpace(cssClass)&&!hasClass(element,cssClass)){if(element.classList){element.classList.add(cssClass);}else{element.className=trim(\"\".concat(element.className,\" \").concat(cssClass));}}}export function hasClass(element,cssClass){if(!element||isNullOrWhiteSpace(cssClass)){return false;}else if(element.classList){return element.classList.contains(cssClass);}else{return\"' ' \".concat(element.className,\" ' '\").indexOf(\"' ' \".concat(trim(cssClass),\"  ' '\"))>-1;}}export function nodeListToArray(nodeList){if(!nodeList){return[];}var elements=[];for(var n=0;n<nodeList.length;n++){elements.push(nodeList[n]);}return elements;}export function selectElements(selector,context){return selectElementsT(selector,context);}export function selectElementsT(selector,context){if(isNullOrWhiteSpace(selector)||selector==='#'){return[];}var currentContext=context||document;if(/^[\\#.]?[\\w-]+$/.test(selector)){switch(selector[0]){case'.':if(currentContext.getElementsByClassName){return nodeListToArray(currentContext.getElementsByClassName(selector.slice(1)));}else{return nodeListToArray(currentContext.querySelectorAll(selector));}case'#':var element=currentContext.querySelector(selector);return element?[element]:[];}return nodeListToArray(currentContext.getElementsByTagName(selector));}return nodeListToArray(currentContext.querySelectorAll(selector));}export function css(element,property,value){if(!element){return null;}if(!!value||value===''){element.style[property]=value;}else{value=element.style[property];if(isNullOrWhiteSpace(value)){value=getComputedStyle(element);value=value[property];}return value;}}export function removeInnerHtml(parentElement){if(parentElement){parentElement.innerHTML='';}}export function selectFirstElement(selector,context){var elementsSelected=selectElementsT(selector,context);return!elementsSelected||!elementsSelected.length?null:elementsSelected[0];}","map":{"version":3,"sources":["videoplayer/components/utilities/htmlExtensions.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNullOrWhiteSpace, trim} from './stringExtensions';\n\nexport function getText(element?: HTMLElement | Element): string {\n    return !!element ? element.textContent || '' : '';\n}\n\n/* Add a css class to an element.\n* @param  {HTMLElement} element - The element to add the css class to.\n* @param  {string} cssClass - The css class to add.\n*/\nexport function addClass(element: HTMLElement, cssClass: string): void {\n    if ((!!element) && (!isNullOrWhiteSpace(cssClass)) && (!hasClass(element, cssClass))) {\n        if (element.classList) {\n            element.classList.add(cssClass);\n        } else {\n            element.className = trim(`${element.className} ${cssClass}`);\n        }\n    }\n}\n\n/* Checks for the presence of a css class on an element.\n* @param  {HTMLElement} element - The element to check the css class of.\n* @param  {string} cssClass - The css class to check for.\n* @return True if the element's className has the specified class, otherwise false.\n*/\n// TODO: user classList for supported browsers\nexport function hasClass(element: HTMLElement, cssClass: string): boolean {\n    if ((!element) || isNullOrWhiteSpace(cssClass)) {\n        return false;\n    } else if (element.classList) {\n        return element.classList.contains(cssClass);\n    } else {\n        return (`' ' ${element.className} ' '`).indexOf(`' ' ${trim(cssClass)}  ' '`) > -1;\n    }\n}\n\n/*\n* Convert node list to array.\n* @param  {NodeListOf<T extends Node>} nodeList\n*/\nexport function nodeListToArray<T extends Node>(nodeList: NodeListOf<T> | NodeListOf<Element> |\n    HTMLCollection | NodeList | NamedNodeMap): T[] {\n    if (!nodeList) {\n        return [];\n    }\n\n    const elements: T[] = [];\n\n    // tslint:disable-next-line: prefer-for-of\n    for (let n = 0; n < nodeList.length; n++) {\n        elements.push(<T>nodeList[n]);\n    }\n\n    return elements;\n}\n\n/** Select elements in a context.\n * @param  {string} selector - can be class, id or tag selector.\n * @param  {HTMLElement} [context] - any element to scope the selection. It's optional. If not provided document will be assumed.\n * @returns HTMLElement[]\n */\nexport function selectElements(selector: string, context?: HTMLElement): HTMLElement[] {\n    return selectElementsT<HTMLElement>(selector, context);\n}\n\n/** Select elements in a context.\n * @param  {string} selector - can be class, id or tag selector.\n * @param  {HTMLElement} [context] - any element to scope the selection. It's optional. If not provided document will be assumed.\n * @returns T[]\n */\nexport function selectElementsT<T extends HTMLElement>(selector: string, context?: HTMLElement): T[] {\n    if (isNullOrWhiteSpace(selector) || selector === '#') {\n        return <T[]>[];\n    }\n\n    const currentContext: HTMLElement | Document = context || document;\n\n    // check if the first character is class or id.\n    if (/^[\\#.]?[\\w-]+$/.test(selector)) {\n        // tslint:disable-next-line: switch-default\n        switch (selector[0]) {\n            case '.':\n                if (currentContext.getElementsByClassName) {\n                    return nodeListToArray(currentContext.getElementsByClassName!(selector.slice(1)));\n                } else {\n                    return nodeListToArray(<NodeListOf<T>>currentContext.querySelectorAll(selector));\n                }\n            case '#':\n                const element = currentContext.querySelector(selector);\n                return <T[]>(element ? [element] : []);\n        }\n\n        return nodeListToArray(currentContext.getElementsByTagName(selector));\n    }\n\n    return nodeListToArray(<NodeListOf<T>>currentContext.querySelectorAll(selector));\n}\n\n/* Sets or gets CSS properties\n* @param  {HTMLElement} element\n* @param  {string} property - The CSS property name\n* @param  {any} [value] - The value to set on the CSS property\n* @returns {any} - The value of the CSS property\n*/\n// tslint:disable-next-line: no-any\nexport function css(element: HTMLElement | Node, property: string, value?: any): any {\n    if (!element) {\n        return null;\n    }\n\n    if (!!value || value === '') {\n    // tslint:disable-next-line: no-any\n        (<any>element).style[property] = value;\n    } else {\n    // tslint:disable-next-line: no-any\n        value = (<any>element).style[property];\n\n        if (isNullOrWhiteSpace(value)) {\n        // tslint:disable-next-line: no-any tslint:disable-next-line: prefer-type-cast\n            value = getComputedStyle(element as any);\n            value = value[property];\n        }\n\n        return value;\n    }\n}\n\n/**\n * Remove all inner HTML from a parent element - used to delete child elements\n * @param {HTMLElement} parentElement - the parent element from which all children should be removed\n * @returns void\n */\nexport function removeInnerHtml(parentElement: HTMLElement): void {\n    if (parentElement) {\n    // tslint:disable-next-line: no-inner-html\n        parentElement.innerHTML = '';\n    }\n}\n\n/** Select first element from the selected elements using provided selector.\n * @param {string} selector - element selector.\n * @param {HTMLElement} [context] - an optional context to scope the selection.\n * @returns {HTMLElement} - the first element from the match.\n */\nexport function selectFirstElement(selector: string, context?: HTMLElement): HTMLElement | null {\n    const elementsSelected = selectElementsT<HTMLElement>(selector, context);\n    return (!elementsSelected || !elementsSelected.length) ? null : elementsSelected[0];\n}\n"],"sourceRoot":"./src/"},"metadata":{},"sourceType":"module"}
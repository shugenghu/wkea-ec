{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _slicedToArray from\"@babel/runtime/helpers/esm/slicedToArray\";import _asyncToGenerator from\"@babel/runtime/helpers/esm/asyncToGenerator\";import _toConsumableArray from\"@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"@babel/runtime/helpers/esm/createClass\";import _uniqWith from\"lodash/uniqWith\";import _get2 from\"lodash/get\";function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{msdyn365Commerce}from'@msdyn365-commerce/core-internal';import{AsyncResult,DataServiceRequest,ErrorTypeEnum,isAsyncResult,ProxyError}from'@msdyn365-commerce/retail-proxy';import{LogLevel,StaticTelemetry}from'@msdyn365-commerce/telemetry-internal';import{toJS}from'mobx';import uuidv1 from'uuid/v1';import{ActionError}from'./action-error';import{ActionRegistrar}from'./action-registrar';import{isAppCacheData,shouldReadFromAppCache,shouldWriteToAppCache}from'./action-runtime-utils';import{readCacheEntries,saveCacheEntries}from'./cache/retail-cache-helper';import EventHelper from'./event-emitter';var defaultTimeoutInMS=4000;var defaultHookTimeoutInMS=1000;var Timer=function Timer(timeoutInMS,message){return new Promise(function(resolve){return setTimeout(resolve.bind(resolve,message),timeoutInMS);});};var ActionTimer=function ActionTimer(timeoutInMS){return new Promise(function(_resolve,reject){return setTimeout(reject.bind(reject,\"Timeout\"/* Timeout */),timeoutInMS);});};var ObservableActionTimer=function ObservableActionTimer(timeoutInMS){return new AsyncResult(function(_resolve,reject){return setTimeout(reject.bind(reject,\"Timeout\"/* Timeout */),timeoutInMS);});};/**\r\n * This class contains the logic to batch and de-dupe the actions that can be executed.\r\n * This class is also responsible for checking and saving the action response to cache.\r\n */ /* @internal */var ActionExecutor=/*#__PURE__*/function(){/**\r\n     * @param action the action to execute\r\n     * @param inputs the action input\r\n     */function ActionExecutor(action,inputs,telemetry,dataActionOption){var _this=this;_classCallCheck(this,ActionExecutor);this.action=action;this.eventId=uuidv1();this.inputs=_toConsumableArray(inputs);// Cloning it DO NOT use the reference\nthis.isBatched=action.prototype.isBatched;this.isObservable=action.prototype.isObservable;// Cache all the calls on browser\nvar masterInput=inputs[0];if(masterInput&&masterInput.dataCacheType){this.cacheType=masterInput.dataCacheType();}else if(masterInput&&masterInput.shouldCacheOutput){this.cacheType=masterInput.shouldCacheOutput()?'request':'none';telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');}else{this.cacheType=dataActionOption&&dataActionOption.cacheType||'none';// for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.\n// this is used for later check if the data acton should be read from app cache.\ninputs.forEach(function(input){input.dataCacheType=function(){return _this.cacheType;};});telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to \"none\"');}}/**\r\n     *\r\n     * @param inputs add more inputs\r\n     */_createClass(ActionExecutor,[{key:\"addInputs\",value:function addInputs(inputs){var _this$inputs;(_this$inputs=this.inputs).push.apply(_this$inputs,_toConsumableArray(inputs));}/** Execute the action  */ // tslint:disable-next-line:max-func-body-length\n},{key:\"execute\",value:function(){var _execute=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(context,requestCache,appCache,bypassAppCache){var refreshingInputs,unique,isRefreshingAction,actionId,_this$_checkForCached,_this$_checkForCached2,uncached,needsRefresh,cachedActions,outputs,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:refreshingInputs=_args.length>4&&_args[4]!==undefined?_args[4]:[];unique=refreshingInputs&&refreshingInputs.length>0?this._removeDuplicates(refreshingInputs):this._removeDuplicates(this.inputs);if(unique.length){_context.next=4;break;}return _context.abrupt(\"return\",[]);case 4:isRefreshingAction=refreshingInputs&&refreshingInputs.length>0;// execute readOnly pre hook with\nactionId=this._getActionIdFromInputs(unique);this._runPreReadHooks(actionId,unique,context).then(function(){return null;})[\"catch\"](function(err){return null;});// execte preReaderHook\nthis._runPreReaderHooks(actionId,unique,context).then(function(){return null;})[\"catch\"](function(err){return null;});_this$_checkForCached=this._checkForCachedData(unique,context,requestCache,appCache,bypassAppCache,isRefreshingAction),_this$_checkForCached2=_slicedToArray(_this$_checkForCached,2),uncached=_this$_checkForCached2[0],needsRefresh=_this$_checkForCached2[1];if(uncached.length){_context.next=15;break;}_context.next=12;return this._fetchOutputsAndRunPostReadHook(actionId,unique,requestCache,context);case 12:return _context.abrupt(\"return\",needsRefresh);case 15:cachedActions=unique.filter(function(value){return!uncached.includes(value);});if(!cachedActions.length){_context.next=19;break;}_context.next=19;return this._fetchOutputsAndRunPostReadHook(actionId,cachedActions,requestCache,context);case 19:outputs=[];// VNext observable promise based flow\n// Create the AsyncResult and immediately return it\nif(!this.isObservable){_context.next=23;break;}if(this.isBatched){this._executeBatchedObservableActions(uncached,requestCache,appCache,context,isRefreshingAction);}else{this._executeObservableAction(uncached[0],requestCache,appCache,context,isRefreshingAction);}return _context.abrupt(\"return\",needsRefresh);case 23:if(!this.isBatched){_context.next=30;break;}_context.next=26;return this._actionWrapper(uncached,context,isRefreshingAction);case 26:outputs=_context.sent;if(outputs&&outputs.length!==uncached.length){// TODO Throw\ncontext.telemetry.log(LogLevel.Trace,'Length of input array {uncached_length} does not meet the output array {outputs_length}',{values:[uncached.length,outputs.length]});}_context.next=33;break;case 30:_context.next=32;return this._actionWrapper(uncached[0],context,isRefreshingAction);case 32:outputs[0]=_context.sent;case 33:if(!(!outputs||outputs.length===0)){_context.next=35;break;}return _context.abrupt(\"return\",needsRefresh);case 35:this._saveResponseToCache(uncached,outputs,context,requestCache,appCache);return _context.abrupt(\"return\",needsRefresh);case 37:case\"end\":return _context.stop();}}},_callee,this);}));function execute(_x,_x2,_x3,_x4){return _execute.apply(this,arguments);}return execute;}()// the retail proxy data actions who do not have return type should not interact with cache.\n},{key:\"_checkShouldInteractWithCache\",value:function _checkShouldInteractWithCache(input,typeName){return!(input instanceof DataServiceRequest)||!!typeName;}},{key:\"_fetchOutputsAndRunPostReadHook\",value:function(){var _fetchOutputsAndRunPostReadHook2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(actionId,inputs,requestCache,context){var _this2=this;var outputs;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:outputs=inputs.map(function(i){var cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};// if the retail data action does not have return type, we do not read the output from cache.\nvar cacheItem;if(_this2._checkShouldInteractWithCache(i,cacheKey.typeName)){cacheItem=requestCache.get(cacheKey);}return!!cacheItem?requestCache.getValue(cacheKey):null;});this._runPostReadHooks(actionId,inputs,outputs,context).then(function(){return null;})[\"catch\"](function(err){return null;});this._runPostReaderHooks(actionId,inputs,outputs,context).then(function(){return null;})[\"catch\"](function(err){return null;});case 3:case\"end\":return _context2.stop();}}},_callee2,this);}));function _fetchOutputsAndRunPostReadHook(_x5,_x6,_x7,_x8){return _fetchOutputsAndRunPostReadHook2.apply(this,arguments);}return _fetchOutputsAndRunPostReadHook;}()},{key:\"_removeDuplicates\",value:function _removeDuplicates(inputs){if(!this.isBatched){return inputs;}return _uniqWith(inputs,function(inputA,inputB){return inputA.getCacheKey()===inputB.getCacheKey()&&inputA.getCacheObjectType()===inputB.getCacheObjectType();});}},{key:\"_getActionIdFromInputs\",value:function _getActionIdFromInputs(inputs){var inputsActionId;var _iterator=_createForOfIteratorHelper(Array.isArray(inputs)?inputs:[inputs]),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var input=_step.value;if(typeof input.getActionId==='function'){inputsActionId=input.getActionId();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return inputsActionId||this.action.prototype.id;}},{key:\"_getActionFromId\",value:function _getActionFromId(actionId){var action=this.action;if(actionId){var registration=ActionRegistrar.resolveRegistration(actionId,action);if(registration){action=registration.action;return ActionRegistrar.unwrapAction(action);}}return action;}},{key:\"_runPreReadHooks\",value:function(){var _runPreReadHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id,inputs,context){var preReadHooks,hookTimeout,timer,preReadHooksArray;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:preReadHooks=ActionRegistrar.getPreReadHooks(id);if(preReadHooks){_context4.next=3;break;}return _context4.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);preReadHooksArray=Array.from(preReadHooks);return _context4.abrupt(\"return\",preReadHooksArray.reduce(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(previousTask,currentTask){return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return previousTask;case 2:_context3.prev=2;_context3.next=5;return Promise.race([timer,currentTask(inputs,context)]);case 5:_context3.next=10;break;case 7:_context3.prev=7;_context3.t0=_context3[\"catch\"](2);context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:_context3.t0});case 10:return _context3.abrupt(\"return\",Promise.resolve());case 11:case\"end\":return _context3.stop();}}},_callee3,null,[[2,7]]);}));return function(_x12,_x13){return _ref.apply(this,arguments);};}(),Promise.resolve()));case 7:case\"end\":return _context4.stop();}}},_callee4);}));function _runPreReadHooks(_x9,_x10,_x11){return _runPreReadHooks2.apply(this,arguments);}return _runPreReadHooks;}()},{key:\"_runPostReaderHooks\",value:function(){var _runPostReaderHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(id,inputs,actionResult,context){var postReaderHooks,hookTimeout,timer,postReaderHooksArray;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:postReaderHooks=ActionRegistrar.getPostReaderHooks(id);if(postReaderHooks){_context6.next=3;break;}return _context6.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);postReaderHooksArray=Array.from(postReaderHooks);return _context6.abrupt(\"return\",postReaderHooksArray.reduce(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(previousTask,currentTask){return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return previousTask;case 2:_context5.prev=2;_context5.next=5;return Promise.race([timer,currentTask(inputs,actionResult,context)]);case 5:_context5.next=10;break;case 7:_context5.prev=7;_context5.t0=_context5[\"catch\"](2);context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:_context5.t0});case 10:return _context5.abrupt(\"return\",Promise.resolve());case 11:case\"end\":return _context5.stop();}}},_callee5,null,[[2,7]]);}));return function(_x18,_x19){return _ref2.apply(this,arguments);};}(),Promise.resolve()));case 7:case\"end\":return _context6.stop();}}},_callee6);}));function _runPostReaderHooks(_x14,_x15,_x16,_x17){return _runPostReaderHooks2.apply(this,arguments);}return _runPostReaderHooks;}()},{key:\"_runPreReaderHooks\",value:function(){var _runPreReaderHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(id,inputs,context){var preReaderHooks,hookTimeout,timer,preReaderHooksArray;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:preReaderHooks=ActionRegistrar.getPreReaderHooks(id);if(preReaderHooks){_context8.next=3;break;}return _context8.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);preReaderHooksArray=Array.from(preReaderHooks);return _context8.abrupt(\"return\",preReaderHooksArray.reduce(/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(previousTask,currentTask){return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.next=2;return previousTask;case 2:_context7.prev=2;_context7.next=5;return Promise.race([timer,currentTask(inputs,context)]);case 5:_context7.next=10;break;case 7:_context7.prev=7;_context7.t0=_context7[\"catch\"](2);context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:_context7.t0});case 10:return _context7.abrupt(\"return\",Promise.resolve());case 11:case\"end\":return _context7.stop();}}},_callee7,null,[[2,7]]);}));return function(_x23,_x24){return _ref3.apply(this,arguments);};}(),Promise.resolve()));case 7:case\"end\":return _context8.stop();}}},_callee8);}));function _runPreReaderHooks(_x20,_x21,_x22){return _runPreReaderHooks2.apply(this,arguments);}return _runPreReaderHooks;}()},{key:\"_runPreHooks\",value:function(){var _runPreHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(id,inputs,context){var preHooks,hookTimeout,timer,preHooksArray;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:preHooks=ActionRegistrar.getPreHooks(id);if(preHooks){_context10.next=3;break;}return _context10.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);preHooksArray=Array.from(preHooks);return _context10.abrupt(\"return\",preHooksArray.reduce(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(previousTask,currentTask){var prevInput,tmpNextInput,finalNextInput;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return previousTask;case 2:prevInput=_context9.sent;_context9.prev=3;_context9.next=6;return Promise.race([timer,currentTask(prevInput,context)]);case 6:tmpNextInput=_context9.sent;_context9.next=12;break;case 9:_context9.prev=9;_context9.t0=_context9[\"catch\"](3);throw _context9.t0;case 12:finalNextInput=tmpNextInput===\"Hook Timeout\"/* HookTimeout */||!tmpNextInput?prevInput:tmpNextInput;return _context9.abrupt(\"return\",Promise.resolve(finalNextInput));case 14:case\"end\":return _context9.stop();}}},_callee9,null,[[3,9]]);}));return function(_x28,_x29){return _ref4.apply(this,arguments);};}(),Promise.resolve(inputs)));case 7:case\"end\":return _context10.stop();}}},_callee10);}));function _runPreHooks(_x25,_x26,_x27){return _runPreHooks2.apply(this,arguments);}return _runPreHooks;}()},{key:\"_runPostReadHooks\",value:function(){var _runPostReadHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12(id,inputs,actionResult,context){var postHooks,hookTimeout,timer,postReadHooksArray;return _regeneratorRuntime.wrap(function _callee12$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:postHooks=ActionRegistrar.getPostReadHooks(id);if(postHooks){_context12.next=3;break;}return _context12.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);postReadHooksArray=Array.from(postHooks);return _context12.abrupt(\"return\",postReadHooksArray.reduce(/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(previousTask,currentTask){return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:_context11.next=2;return previousTask;case 2:_context11.prev=2;_context11.next=5;return Promise.race([timer,currentTask(inputs,actionResult,context)]);case 5:_context11.next=10;break;case 7:_context11.prev=7;_context11.t0=_context11[\"catch\"](2);context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:_context11.t0});case 10:return _context11.abrupt(\"return\",Promise.resolve());case 11:case\"end\":return _context11.stop();}}},_callee11,null,[[2,7]]);}));return function(_x34,_x35){return _ref5.apply(this,arguments);};}(),Promise.resolve()));case 7:case\"end\":return _context12.stop();}}},_callee12);}));function _runPostReadHooks(_x30,_x31,_x32,_x33){return _runPostReadHooks2.apply(this,arguments);}return _runPostReadHooks;}()},{key:\"_runPostHooks\",value:function(){var _runPostHooks2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee14(id,inputs,actionResult,context){var postHooks,hookTimeout,timer,postHooksArray;return _regeneratorRuntime.wrap(function _callee14$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:postHooks=ActionRegistrar.getPostHooks(id);if(postHooks){_context14.next=3;break;}return _context14.abrupt(\"return\");case 3:hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);postHooksArray=Array.from(postHooks);return _context14.abrupt(\"return\",postHooksArray.reduce(/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee13(previousTask,currentTask){var prevOutput,tmpNextOutput,finalNextOutput;return _regeneratorRuntime.wrap(function _callee13$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:_context13.next=2;return previousTask;case 2:prevOutput=_context13.sent;_context13.prev=3;_context13.next=6;return Promise.race([timer,currentTask(inputs,prevOutput,context)]);case 6:tmpNextOutput=_context13.sent;_context13.next=12;break;case 9:_context13.prev=9;_context13.t0=_context13[\"catch\"](3);throw _context13.t0;case 12:finalNextOutput=tmpNextOutput===\"Hook Timeout\"/* HookTimeout */||!tmpNextOutput?prevOutput:tmpNextOutput;return _context13.abrupt(\"return\",Promise.resolve(finalNextOutput));case 14:case\"end\":return _context13.stop();}}},_callee13,null,[[3,9]]);}));return function(_x40,_x41){return _ref6.apply(this,arguments);};}(),Promise.resolve(actionResult)));case 7:case\"end\":return _context14.stop();}}},_callee14);}));function _runPostHooks(_x36,_x37,_x38,_x39){return _runPostHooks2.apply(this,arguments);}return _runPostHooks;}()/**\r\n     * Add performance logging before and after calling the action?\r\n     */ // tslint:disable-next-line: cyclomatic-complexity\n},{key:\"_actionWrapper\",value:function(){var _actionWrapper2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee15(inputs,context,isRefreshing){var actionId,action,_inputs,convertedError,actionResult,timeOut,features,customerTimout,promises,timeOutValue,_convertedError,error,result,_convertedError2;return _regeneratorRuntime.wrap(function _callee15$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:// tslint:disable-next-line: max-func-body-length\nactionId=this._getActionIdFromInputs(inputs);action=this._getActionFromId(actionId);_context15.prev=2;_context15.next=5;return this._runPreHooks(actionId,inputs,context);case 5:_inputs=_context15.sent;if(_inputs){inputs=_inputs;}_context15.next=14;break;case 9:_context15.prev=9;_context15.t0=_context15[\"catch\"](2);convertedError=this._convertToJSError(_context15.t0);StaticTelemetry.log(LogLevel.Error,\"Error executing pre-hooks for \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',convertedError.name,convertedError.data?convertedError.data.CorrelationId:''],exception:_context15.t0});return _context15.abrupt(\"return\",new ActionError(_context15.t0));case 14:_context15.prev=14;timeOut=Number(_get2(context,'requestContext.query.actionTimeout'));features=_get2(context,'requestContext.features',{});customerTimout=msdyn365Commerce.platformSettings&&msdyn365Commerce.platformSettings.dataActionTimeoutInMs;if(process.env.CURRENT_ENVIRONMENT==='node'&&features.action_timeout||customerTimout){timeOutValue=(features.action_timeout?timeOut:customerTimout)||defaultTimeoutInMS;promises=[this.isObservable?ObservableActionTimer(timeOutValue):ActionTimer(timeOutValue),action(inputs,context)];}else{promises=[action(inputs,context)];}// run the data action\n_context15.next=21;return Promise.race(promises);case 21:actionResult=_context15.sent;_context15.next=31;break;case 24:_context15.prev=24;_context15.t1=_context15[\"catch\"](14);_convertedError=this._convertToJSError(_context15.t1);StaticTelemetry.log(LogLevel.Error,\"Error executing \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',_convertedError.name,_convertedError.data?_convertedError.data.CorrelationId:''],exception:_context15.t1});error=new ActionError(_context15.t1);// For AsyncResult, we need to signal that this was a rejection by throwing\nif(this.isObservable){// Proxy Errors come wrapped as an array\nif(Array.isArray(_context15.t1)){error=_context15.t1[0]._errorCode===ErrorTypeEnum.SERVICE_UNAVAILABLE?new ActionError(\"Service Unavailable\"/* ServiceUnavailable */):ProxyError.toError(_context15.t1[0]);}else{error=_context15.t1._errorCode===ErrorTypeEnum.SERVICE_UNAVAILABLE?new ActionError(\"Service Unavailable\"/* ServiceUnavailable */):new ActionError(_context15.t1);}}throw error;case 31:_context15.prev=31;_context15.next=34;return this._runPostHooks(actionId,inputs,actionResult,context);case 34:result=_context15.sent;if(result){actionResult=result;}this._runPostReadHooks(actionId,inputs,actionResult,context).then(function(){return null;})[\"catch\"](function(err){return null;});this._runPostReaderHooks(actionId,inputs,actionResult,context).then(function(){return null;})[\"catch\"](function(err){return null;});_context15.next=44;break;case 40:_context15.prev=40;_context15.t2=_context15[\"catch\"](31);_convertedError2=this._convertToJSError(_context15.t2);StaticTelemetry.log(LogLevel.Error,\"Error executing post-hooks for \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',_convertedError2.name,_convertedError2.data?_convertedError2.data.CorrelationId:''],exception:_context15.t2});case 44:return _context15.abrupt(\"return\",actionResult);case 45:case\"end\":return _context15.stop();}}},_callee15,this,[[2,9],[14,24],[31,40]]);}));function _actionWrapper(_x42,_x43,_x44){return _actionWrapper2.apply(this,arguments);}return _actionWrapper;}()},{key:\"_saveResponseToCache\",value:function _saveResponseToCache(uncached,outputs,context,requestCache,appCache){var _this3=this;var log=context.telemetry.log;uncached.forEach(function(i,idx){var actionId=_this3._getActionIdFromInputs(i);// @ts-ignore\nif(i instanceof DataServiceRequest&&!!i.getCacheObjectType()){try{// @ts-ignore\nsaveCacheEntries(i,outputs[idx],requestCache,appCache,shouldWriteToAppCache(i,appCache));}catch(e){var action=_this3.action;log(LogLevel.Trace,'Error execution action \\'{actionName}\\', returning null',{values:[actionId||action&&action.name||'unnamed'],exception:e});return null;}}else{var entityId=i.getCacheKey();var entityType=i.getCacheObjectType();if(!!entityId&&!!entityType){var entry=outputs[idx];var cacheKey={typeName:entityType,key:entityId};if(ActionError.isActionError(entry)){if(!ActionError.isTimeoutError(entry)){requestCache.put(cacheKey,{item:entry.error,error:true});}// else do nothing\n}else{if(appCache&&shouldWriteToAppCache(i,appCache)){appCache.put(cacheKey,{item:entry});}var cacheEntry={item:entry};if(i.dataCacheType&&i.dataCacheType()==='instance'){Object.assign(cacheEntry,{instance:'instance'});}requestCache.put(cacheKey,cacheEntry);}}}});}/**\r\n     * Method that executes a set of batchable observable data actions\r\n     * @param uncached The uncached action inputs\r\n     * @param requestCache The request cache\r\n     * @param appCache The application cache, if available\r\n     * @param context The action context\r\n     */},{key:\"_executeBatchedObservableActions\",value:function _executeBatchedObservableActions(uncached,requestCache,appCache,context){var _this4=this;var isRefreshing=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var unresolvedSet=new Set();var uncachedInputs=[];// Create an OP for each input in the batch that does not yet exist in cache\nvar asyncOutputs=uncached.map(function(input,index){unresolvedSet.add(index);var executor=function executor(resolve,reject){// When the side promise completes, update each individual OP to have it's piece of the entire batched result\nnew Promise(function(innerResolve,innerReject){var onEventIdCompletion=function onEventIdCompletion(value){innerResolve(value);};var onEventIdFinalCompletion=function onEventIdFinalCompletion(){innerResolve();};var onEventIdFailure=function onEventIdFailure(error){innerReject(error);};// Standard success event\nEventHelper.on(\"\".concat(_this4.eventId,\"-complete-\").concat(index,\"-\").concat(input.getCacheKey()),onEventIdCompletion);// No response closing event\nEventHelper.on(\"\".concat(_this4.eventId,\"-final-complete-\").concat(index,\"-\").concat(input.getCacheKey()),onEventIdFinalCompletion);// Failure event\nEventHelper.on(\"\".concat(_this4.eventId,\"-failure\"),onEventIdFailure);}).then(function(result){EventHelper.removeAllListeners(\"\".concat(_this4.eventId,\"-complete-\").concat(index,\"-\").concat(input.getCacheKey()));EventHelper.removeAllListeners(\"\".concat(_this4.eventId,\"-final-complete-\").concat(index,\"-\").concat(input.getCacheKey()));resolve(result);})[\"catch\"](function(error){EventHelper.removeAllListeners(\"\".concat(_this4.eventId,\"-failure\"));reject(error);});};// Already cached OP logic (rerun)\n// we only try to fetch the saved promise from cache when the retail proxy data action has cached type\nvar cachedPromise;if(_this4._checkShouldInteractWithCache(input,input.getCacheObjectType())){cachedPromise=requestCache.getValue({key:input.getCacheKey(),typeName:input.getCacheObjectType()});}if(cachedPromise&&isAsyncResult(cachedPromise)&&!isRefreshing){cachedPromise.run(executor);return;}// Not yet cached OP logic (initialize, run)\nuncachedInputs.push(input);return new AsyncResult(executor);}).filter(Boolean);// Save never before cached OPs to cache\nthis._saveResponseToCache(uncachedInputs,asyncOutputs,context,requestCache,appCache);// Run the actual action\n// tslint:disable-next-line: no-floating-promises\nthis._actionWrapper(uncached,context,isRefreshing).then(function(actionResults){// Emit events with the associated result so that each individual OP in the cache\n// can be updated appropriately\nactionResults.forEach(function(actionResult,index){unresolvedSet[\"delete\"](index);EventHelper.emit(\"\".concat(_this4.eventId,\"-complete-\").concat(index,\"-\").concat(uncached[index].getCacheKey()),actionResult);});})[\"catch\"](function(error){EventHelper.emit(\"\".concat(_this4.eventId,\"-failure\"),error);})[\"finally\"](function(){// In the event some inputs do not have results, we need to resolve the promises anyhow\nunresolvedSet.forEach(function(unresolvedIndex){var index=unresolvedIndex;EventHelper.emit(\"\".concat(_this4.eventId,\"-final-complete-\").concat(index,\"-\").concat(uncached[index].getCacheKey()));});});}/**\r\n     * Executes a standard (non-batched) observable data action\r\n     * @param input The action input\r\n     * @param requestCache The request cache\r\n     * @param appCache The application cache, if available\r\n     * @param context The action context\r\n     */},{key:\"_executeObservableAction\",value:function _executeObservableAction(input,requestCache,appCache,context){var _this5=this;var isRefreshing=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var cacheKey={key:input.getCacheKey(),typeName:input.getCacheObjectType()};var executor=function executor(resolve,reject){_this5._actionWrapper(input,context,isRefreshing).then(function(result){resolve(result);})[\"catch\"](function(error){// If error is timeout error, lookup app-cache if there\n// is a valid entity for the given cacheKey in app-cache\nif(ActionError.isServiceUnavailable(error)&&isAppCacheData(input,appCache)){var cachedItem=appCache===null||appCache===void 0?void 0:appCache.getValue(cacheKey);if(cachedItem){return resolve(cachedItem);}}return reject(error);});};// we only try to fetch the saved promise from cache when the retail proxy data action has cached type\nvar cachedPromise;if(this._checkShouldInteractWithCache(input,input.getCacheObjectType())){cachedPromise=requestCache.getValue({key:input.getCacheKey(),typeName:input.getCacheObjectType()});}// If OP is already in cache, just rerun it\nif(cachedPromise&&isAsyncResult(cachedPromise)&&!isRefreshing){cachedPromise.run(executor);return;}// Uncached promises need to be saved to cache\nvar asyncOutput=new AsyncResult(executor);this._saveResponseToCache([input],[asyncOutput],context,requestCache,appCache);}},{key:\"_checkForCachedData\",value:function _checkForCachedData(inputs,context,requestCache,appCache,bypassAppCache,refreshing){var _this6=this;var mock=_get2(context,'requestContext.query.actionMock');var log=context.telemetry.log;if(mock){inputs=this._interceptCacheForMocks(inputs,context,requestCache);}// if the cache type is set a none don't check cache for data and return inputs for execution\n// lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side\nif(this.cacheType==='none'||refreshing){return[inputs,[]];}var uncached=[];var refresh=[];/* tslint:disable */inputs.forEach(function(i,idx){var actionId=_this6._getActionIdFromInputs(i);var cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};// if the retail proxy action does not have return type, we do not check if its in the cache\nif(i instanceof DataServiceRequest&&!cacheKey.typeName){uncached.push(i);return;}var cacheItem=requestCache.get(cacheKey);if(cacheItem&&isAsyncResult(cacheItem.item)&&cacheItem.item.status==='FAILED'){uncached.push(i);}else if(cacheItem&&cacheItem.item&&cacheItem.item.status==='LOADING'&&cacheItem.item.runOn==='client'){// Ideally, an action configured to runOn client should never interfere with actions running on server.\n// However, it is possible that parent action with runon 'server' could be dependent on an action that is configured\n// by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets\n// include such actions in the uncached list so that it gets picked and executed later.\nuncached.push(i);// @ts-ignore\n}else if(i instanceof DataServiceRequest){try{var cacheEntries=readCacheEntries(i,requestCache,// @ts-ignore\nappCache,!!!bypassAppCache&&shouldReadFromAppCache(i,appCache));if(!cacheEntries.entry){uncached.push(i);}if(cacheEntries&&cacheEntries.shouldRefresh){refresh.push(i);}}catch(e){var action=_this6.action;log(LogLevel.Trace,\"Error execution action '{actionName}', returning null\",{values:[actionId||action&&action.name||'unnamed'],exception:e});uncached.push(i);}}else{if(!cacheItem&&!!!bypassAppCache&&appCache&&shouldReadFromAppCache(i,appCache)){cacheItem=appCache.copyTo(cacheKey,requestCache);if(cacheItem&&cacheItem.shouldRefresh){refresh.push(i);}}if(!cacheItem||!cacheItem.item){uncached.push(i);return;}}});return[uncached,refresh];}/**\r\n     * Searches cache for mocks matching the inputs\r\n     * @param inputs Current action inputs\r\n     * @param context Current action context\r\n     * @param requestCache Current request cache\r\n     */},{key:\"_interceptCacheForMocks\",value:function _interceptCacheForMocks(inputs,context,requestCache){var _this7=this;var uncached=[];var actionId=this.action.prototype.id;inputs.forEach(function(i){var mockItem=_this7._getMockItem(i.getCacheObjectType(),i.getCacheKey(),requestCache);if(!mockItem&&actionId){mockItem=_this7._getMockItem(actionId,i.getCacheKey(),requestCache);}var existingItem;if(_this7._checkShouldInteractWithCache(i,i.getCacheObjectType())){existingItem=requestCache.get({typeName:i.getCacheObjectType(),key:i.getCacheKey()});}if(!!mockItem&&!!mockItem.item&&!existingItem){if(_this7.isObservable){requestCache.put({typeName:i.getCacheObjectType(),key:i.getCacheKey()},{item:AsyncResult.resolve(toJS(mockItem.item))});}else{requestCache.put({typeName:i.getCacheObjectType(),key:i.getCacheKey()},{item:toJS(mockItem.item)});}}else{uncached.push(i);}});return uncached;}},{key:\"_getMockItem\",value:function _getMockItem(cacheNamespace,cacheKey,requestCache){return requestCache.get({typeName:'__MOCK',key:\"\".concat(cacheNamespace,\":\").concat(cacheKey)})||requestCache.get({typeName:'__MOCK',key:\"\".concat(cacheNamespace,\":*\")});}},{key:\"_convertToJSError\",value:function _convertToJSError(e){// Proxy Error usually comes wrapped in an array\n// If it is, unbox it and conver to regular Error\nif(Array.isArray(e)){var proxyError=e[0];if(proxyError.ErrorCode){return ProxyError.toError(proxyError);}}else if(e.ErrorCode){return ProxyError.toError(e);}// Return regular Error if not ProxyError\nreturn new Error(e.message||'');}}]);return ActionExecutor;}();export{ActionExecutor as default};","map":{"version":3,"sources":["../../src/action-executor.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable:no-any\nimport { ICache, ICacheItem } from '@msdyn365-commerce/cache-internal';\nimport { CacheType, IActionContext, IActionInput, IAnyAction, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, ErrorTypeEnum, isAsyncResult, ProxyError } from '@msdyn365-commerce/retail-proxy';\nimport { ITelemetry, LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { get as _get, uniqWith } from 'lodash';\nimport { toJS } from 'mobx';\nimport uuidv1 from 'uuid/v1';\nimport { ActionError, ActionErrorStatus } from './action-error';\nimport { ActionRegistrar } from './action-registrar';\nimport { isAppCacheData, shouldReadFromAppCache, shouldWriteToAppCache } from './action-runtime-utils';\nimport { readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\nconst defaultTimeoutInMS: number = 4000;\nconst defaultHookTimeoutInMS: number = 1000;\n\nconst Timer = (timeoutInMS: number, message: unknown) => new Promise(resolve => setTimeout(resolve.bind(resolve, message), timeoutInMS));\n\nconst ActionTimer = (timeoutInMS: number) =>\n    new Promise((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\nconst ObservableActionTimer = (timeoutInMS: number) =>\n    new AsyncResult((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\n/**\n * This class contains the logic to batch and de-dupe the actions that can be executed.\n * This class is also responsible for checking and saving the action response to cache.\n */\n/* @internal */\nexport default class ActionExecutor {\n    public readonly action: Function;\n    public readonly cacheType: CacheType;\n    private readonly isBatched: boolean;\n    private readonly eventId: string;\n    private readonly isObservable: boolean;\n\n    private inputs: IActionInput[];\n    /**\n     * @param action the action to execute\n     * @param inputs the action input\n     */\n    constructor(action: Function, inputs: IActionInput[], telemetry: ITelemetry, dataActionOption?:IDataActionOptions) {\n        this.action = action;\n        this.eventId = uuidv1();\n        this.inputs = [...inputs]; // Cloning it DO NOT use the reference\n        this.isBatched = action.prototype.isBatched;\n\n        this.isObservable = action.prototype.isObservable;\n\n        // Cache all the calls on browser\n        const masterInput = inputs[0];\n\n        if (masterInput && masterInput.dataCacheType) {\n            this.cacheType = masterInput.dataCacheType();\n        } else if (masterInput && masterInput.shouldCacheOutput) {\n            this.cacheType = masterInput.shouldCacheOutput() ? 'request' : 'none';\n            telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');\n        } else {\n            this.cacheType = dataActionOption && dataActionOption.cacheType || 'none';\n            // for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.\n            // this is used for later check if the data acton should be read from app cache.\n            inputs.forEach((input)=> {\n                input.dataCacheType = () => this.cacheType;\n            });\n            telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to \"none\"');\n        }\n    }\n\n    /**\n     *\n     * @param inputs add more inputs\n     */\n    public addInputs(inputs: IActionInput[]): void {\n        this.inputs.push(...inputs);\n    }\n\n    /** Execute the action  */\n    // tslint:disable-next-line:max-func-body-length\n    public async execute(\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshingInputs: IActionInput[] = []\n    ): Promise<IActionInput[]> {\n        const unique: IActionInput[] =\n            refreshingInputs && refreshingInputs.length > 0\n                ? this._removeDuplicates(refreshingInputs)\n                : this._removeDuplicates(this.inputs);\n        if (!unique.length) {\n            return [];\n        }\n        const isRefreshingAction = refreshingInputs && refreshingInputs.length > 0;\n\n        // execute readOnly pre hook with\n        const actionId = this._getActionIdFromInputs(unique);\n        this._runPreReadHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n\n        // execte preReaderHook\n        this._runPreReaderHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n        const [uncached, needsRefresh]: IActionInput[][] = this._checkForCachedData(\n            unique,\n            context,\n            requestCache,\n            appCache,\n            bypassAppCache,\n            isRefreshingAction\n        );\n\n        if (!uncached.length) {\n            // excute readOnly post hook with all cached actions ouptput\n            await this._fetchOutputsAndRunPostReadHook(actionId, unique, requestCache, context);\n            return needsRefresh;\n        } else {\n            const cachedActions = unique.filter(value => !uncached.includes(value));\n            if (cachedActions.length) {\n                // fetch the output for all cached data action, and run readOnly hooks. The uncached actions will be excuted later.\n                await this._fetchOutputsAndRunPostReadHook(actionId, cachedActions, requestCache, context);\n            }\n        }\n\n        let outputs: any[] = [];\n\n        // VNext observable promise based flow\n        // Create the AsyncResult and immediately return it\n        if (this.isObservable) {\n            if (this.isBatched) {\n                this._executeBatchedObservableActions(uncached, requestCache, appCache, context, isRefreshingAction);\n            } else {\n                this._executeObservableAction(uncached[0], requestCache, appCache, context, isRefreshingAction);\n            }\n            return needsRefresh;\n        }\n\n        if (this.isBatched) {\n            // TODO: Have a max batch count on the action\n            outputs = await this._actionWrapper(uncached, context, isRefreshingAction);\n\n            if (outputs && outputs.length !== uncached.length) {\n                // TODO Throw\n                context.telemetry.log(\n                    LogLevel.Trace,\n                    'Length of input array {uncached_length} does not meet the output array {outputs_length}',\n                    { values: [uncached.length, outputs.length] }\n                );\n            }\n        } else {\n            outputs[0] = await this._actionWrapper(uncached[0], context, isRefreshingAction);\n        }\n\n        if (!outputs || outputs.length === 0) {\n            return needsRefresh;\n        }\n\n        this._saveResponseToCache(uncached, outputs, context, requestCache, appCache);\n        return needsRefresh;\n    }\n\n    // the retail proxy data actions who do not have return type should not interact with cache.\n    private _checkShouldInteractWithCache(input: IActionInput, typeName: string | undefined): boolean {\n        return !(input instanceof DataServiceRequest) || !!typeName;\n    }\n\n    private async _fetchOutputsAndRunPostReadHook(\n        actionId: string,\n        inputs: IActionInput[],\n        requestCache: ICache,\n        context: IActionContext\n    ): Promise<void> {\n        const outputs = inputs.map(i => {\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail data action does not have return type, we do not read the output from cache.\n            let cacheItem;\n            if (this._checkShouldInteractWithCache(i, cacheKey.typeName)) {\n                cacheItem = requestCache.get<ICacheItem<unknown>>(cacheKey);\n            }\n            return !!cacheItem ? requestCache.getValue(cacheKey) : null;\n        });\n        this._runPostReadHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n        this._runPostReaderHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n    }\n    private _removeDuplicates(inputs: IActionInput[]): IActionInput[] {\n        if (!this.isBatched) {\n            return inputs;\n        }\n\n        return uniqWith(\n            inputs,\n            (inputA: IActionInput, inputB: IActionInput) =>\n                inputA.getCacheKey() === inputB.getCacheKey() && inputA.getCacheObjectType() === inputB.getCacheObjectType()\n        );\n    }\n\n    private _getActionIdFromInputs(inputs: IActionInput | IActionInput[]): string {\n        let inputsActionId;\n        for (const input of Array.isArray(inputs) ? inputs : [inputs]) {\n            if (typeof input.getActionId === 'function') {\n                inputsActionId = input.getActionId();\n            }\n        }\n        return inputsActionId || (<IAnyAction<unknown>>this.action).prototype.id;\n    }\n\n    private _getActionFromId(actionId?: string): Function {\n        let { action } = this;\n        if (actionId) {\n            const registration = ActionRegistrar.resolveRegistration(actionId, <IAnyAction<unknown>>action);\n            if (registration) {\n                action = <IAnyAction<unknown>>registration.action;\n                return ActionRegistrar.unwrapAction(<IAnyAction<unknown>>action);\n            }\n        }\n        return action;\n    }\n\n    private async _runPreReadHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReadHooks = ActionRegistrar.getPreReadHooks(id);\n        if (!preReadHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReadHooksArray = Array.from(preReadHooks);\n        return preReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                              Promise.resolve());\n    }\n\n    private async _runPostReaderHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postReaderHooks = ActionRegistrar.getPostReaderHooks(id);\n        if (!postReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReaderHooksArray = Array.from(postReaderHooks);\n        return postReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                 Promise.resolve());\n    }\n\n    private async _runPreReaderHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReaderHooks = ActionRegistrar.getPreReaderHooks(id);\n        if (!preReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReaderHooksArray = Array.from(preReaderHooks);\n        return preReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                Promise.resolve());\n    }\n\n    private async _runPreHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        context: IActionContext\n    ): Promise<IActionInput | IActionInput[] | void> {\n        const preHooks = ActionRegistrar.getPreHooks(id);\n        if (!preHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preHooksArray = Array.from(preHooks);\n        return preHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevInput = await previousTask;\n            let tmpNextInput: unknown;\n            try {\n                tmpNextInput = await Promise.race([timer, currentTask(prevInput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextInput: IActionInput | IActionInput[];\n            finalNextInput =\n                tmpNextInput === ActionErrorStatus.HookTimeout || !tmpNextInput ? prevInput : <IActionInput | IActionInput[]>tmpNextInput;\n            return Promise.resolve(finalNextInput);\n        },                          Promise.resolve(inputs));\n    }\n\n    private async _runPostReadHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostReadHooks(id);\n        if (!postHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReadHooksArray = Array.from(postHooks);\n        return postReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                               Promise.resolve());\n    }\n\n    private async _runPostHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostHooks(id);\n        if (!postHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postHooksArray = Array.from(postHooks);\n        return postHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevOutput = await previousTask;\n            let tmpNextOutput: unknown;\n            try {\n                tmpNextOutput = await Promise.race([timer, currentTask(inputs, prevOutput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextOutput;\n            finalNextOutput = tmpNextOutput === ActionErrorStatus.HookTimeout || !tmpNextOutput ? prevOutput : tmpNextOutput;\n            return Promise.resolve(finalNextOutput);\n        },                           Promise.resolve(actionResult));\n    }\n\n    /**\n     * Add performance logging before and after calling the action?\n     */\n    // tslint:disable-next-line: cyclomatic-complexity\n    private async _actionWrapper(inputs: IActionInput | IActionInput[], context: IActionContext, isRefreshing?: boolean): Promise<any> {\n        // tslint:disable-next-line: max-func-body-length\n        const actionId = this._getActionIdFromInputs(inputs);\n        const action = this._getActionFromId(actionId);\n\n        try {\n            // Run pre data action hooks\n            const _inputs = await this._runPreHooks(actionId, inputs, context);\n            if (_inputs) {\n                inputs = _inputs;\n            }\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing pre-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            return new ActionError(e);\n        }\n        let actionResult;\n        try {\n            const timeOut = Number(_get(context, 'requestContext.query.actionTimeout'));\n            const features = _get(context, 'requestContext.features', {});\n            const customerTimout = msdyn365Commerce.platformSettings && msdyn365Commerce.platformSettings.dataActionTimeoutInMs;\n            let promises;\n            if ((process.env.CURRENT_ENVIRONMENT === 'node' && features.action_timeout) || customerTimout) {\n                const timeOutValue = (features.action_timeout ? timeOut : customerTimout) || defaultTimeoutInMS;\n                promises = [this.isObservable ? ObservableActionTimer(timeOutValue) : ActionTimer(timeOutValue), action(inputs, context)];\n            } else {\n                promises = [action(inputs, context)];\n            }\n            // run the data action\n            actionResult = await Promise.race(promises);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            let error = new ActionError(e);\n            // For AsyncResult, we need to signal that this was a rejection by throwing\n            if (this.isObservable) {\n                // Proxy Errors come wrapped as an array\n                if (Array.isArray(e)) {\n                    error =\n                        e[0]._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : ProxyError.toError(<ProxyError>e[0]);\n                } else {\n                    error =\n                        e._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : new ActionError(e);\n                }\n            }\n\n            throw error;\n        }\n\n        try {\n            // Run post data action hooks\n            const result = await this._runPostHooks(actionId, inputs, actionResult, context);\n            if (result) {\n                actionResult = result;\n            }\n            this._runPostReadHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n            this._runPostReaderHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing post-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n        }\n        return actionResult;\n    }\n\n    private _saveResponseToCache(\n        uncached: IActionInput[],\n        outputs: any[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null\n    ): void {\n        const { log } = context.telemetry;\n        uncached.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            // @ts-ignore\n            if (i instanceof DataServiceRequest && !!i.getCacheObjectType()) {\n                try {\n                    // @ts-ignore\n                    saveCacheEntries(i, outputs[idx], requestCache, appCache, shouldWriteToAppCache(i, appCache));\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, 'Error execution action \\'{actionName}\\', returning null', {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    return null;\n                }\n            } else {\n                const entityId = i.getCacheKey();\n                const entityType = i.getCacheObjectType();\n\n                if (!!entityId && !!entityType) {\n                    const entry = outputs[idx];\n                    const cacheKey = { typeName: entityType, key: entityId };\n                    if (ActionError.isActionError(entry)) {\n                        if (!ActionError.isTimeoutError(entry)) {\n                            requestCache.put(cacheKey, { item: (<ActionError>(<unknown>entry)).error, error: true });\n                        }\n                        // else do nothing\n                    } else {\n                        if (appCache && shouldWriteToAppCache(i, appCache)) {\n                            appCache.put(cacheKey, { item: entry });\n                        }\n                        const cacheEntry = { item: entry };\n                        if (i.dataCacheType && i.dataCacheType() === 'instance') {\n                            Object.assign(cacheEntry, { instance: 'instance' });\n                        }\n                        requestCache.put(cacheKey, cacheEntry);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Method that executes a set of batchable observable data actions\n     * @param uncached The uncached action inputs\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeBatchedObservableActions(\n        uncached: IActionInput[],\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const unresolvedSet = new Set();\n        const uncachedInputs: IActionInput[] = [];\n        // Create an OP for each input in the batch that does not yet exist in cache\n        const asyncOutputs = uncached\n            .map((input, index) => {\n                unresolvedSet.add(index);\n                const executor = (resolve: any, reject: any) => {\n                    // When the side promise completes, update each individual OP to have it's piece of the entire batched result\n                    new Promise((innerResolve, innerReject) => {\n                        const onEventIdCompletion = (value: any) => {\n                            innerResolve(<{}>value);\n                        };\n\n                        const onEventIdFinalCompletion = () => {\n                            innerResolve();\n                        };\n\n                        const onEventIdFailure = (error: any) => {\n                            innerReject(error);\n                        };\n\n                        // Standard success event\n                        EventHelper.on(`${this.eventId}-complete-${index}-${input.getCacheKey()}`, onEventIdCompletion);\n\n                        // No response closing event\n                        EventHelper.on(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`, onEventIdFinalCompletion);\n\n                        // Failure event\n                        EventHelper.on(`${this.eventId}-failure`, onEventIdFailure);\n                    })\n                        .then(result => {\n                            EventHelper.removeAllListeners(`${this.eventId}-complete-${index}-${input.getCacheKey()}`);\n                            EventHelper.removeAllListeners(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`);\n                            resolve(result);\n                        })\n                        .catch(error => {\n                            EventHelper.removeAllListeners(`${this.eventId}-failure`);\n                            reject(error);\n                        });\n                };\n\n                // Already cached OP logic (rerun)\n                // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n                let cachedPromise;\n                if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n                    cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n                }\n                if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n                    (<AsyncResult<unknown>>cachedPromise).run(executor);\n                    return;\n                }\n\n                // Not yet cached OP logic (initialize, run)\n                uncachedInputs.push(input);\n                return new AsyncResult(executor);\n            })\n            .filter(Boolean);\n\n        // Save never before cached OPs to cache\n        this._saveResponseToCache(uncachedInputs, asyncOutputs, context, requestCache, appCache);\n\n        // Run the actual action\n        // tslint:disable-next-line: no-floating-promises\n        this._actionWrapper(uncached, context, isRefreshing)\n            .then((actionResults: unknown[]) => {\n                // Emit events with the associated result so that each individual OP in the cache\n                // can be updated appropriately\n                actionResults.forEach((actionResult, index) => {\n                    unresolvedSet.delete(index);\n                    EventHelper.emit(`${this.eventId}-complete-${index}-${uncached[index].getCacheKey()}`, actionResult);\n                });\n            })\n            .catch(error => {\n                EventHelper.emit(`${this.eventId}-failure`, error);\n            })\n            .finally(() => {\n                // In the event some inputs do not have results, we need to resolve the promises anyhow\n                unresolvedSet.forEach(unresolvedIndex => {\n                    const index = <number>unresolvedIndex;\n                    EventHelper.emit(`${this.eventId}-final-complete-${index}-${uncached[index].getCacheKey()}`);\n                });\n            });\n    }\n\n    /**\n     * Executes a standard (non-batched) observable data action\n     * @param input The action input\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeObservableAction(\n        input: IActionInput,\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const cacheKey = { key: input.getCacheKey(), typeName: input.getCacheObjectType() };\n        const executor = (resolve: any, reject: any) => {\n            this._actionWrapper(input, context, isRefreshing)\n                .then(result => {\n                    resolve(result);\n                })\n                .catch(error => {\n                    // If error is timeout error, lookup app-cache if there\n                    // is a valid entity for the given cacheKey in app-cache\n                    if (ActionError.isServiceUnavailable(error) && isAppCacheData(input, appCache)) {\n                        const cachedItem = appCache?.getValue(cacheKey);\n                        if (cachedItem) {\n                            return resolve(cachedItem);\n                        }\n                    }\n                    return reject(error);\n                });\n        };\n        // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n        let cachedPromise;\n        if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n            cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n        }\n        // If OP is already in cache, just rerun it\n        if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n            (<AsyncResult<unknown>>cachedPromise).run(executor);\n            return;\n        }\n\n        // Uncached promises need to be saved to cache\n        const asyncOutput = new AsyncResult(executor);\n        this._saveResponseToCache([input], [asyncOutput], context, requestCache, appCache);\n    }\n\n    private _checkForCachedData(\n        inputs: IActionInput[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshing?: boolean\n    ): IActionInput[][] {\n        const mock = _get(context, 'requestContext.query.actionMock');\n        const { log } = context.telemetry;\n\n        if (mock) {\n            inputs = this._interceptCacheForMocks(inputs, context, requestCache);\n        }\n\n        // if the cache type is set a none don't check cache for data and return inputs for execution\n        // lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side\n        if (this.cacheType === 'none' || refreshing) {\n            return [inputs, []];\n        }\n\n        const uncached: IActionInput[] = [];\n        const refresh: IActionInput[] = [];\n        /* tslint:disable */\n        inputs.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail proxy action does not have return type, we do not check if its in the cache\n            if (i instanceof DataServiceRequest && !cacheKey.typeName) {\n                uncached.push(i);\n                return;\n            }\n            let cacheItem: ICacheItem<any> | undefined = requestCache.get(cacheKey);\n            if (cacheItem && isAsyncResult(<object>cacheItem.item) && (<AsyncResult<unknown>>cacheItem.item).status === 'FAILED') {\n                uncached.push(i);\n            } else if (cacheItem && cacheItem.item && cacheItem.item.status === 'LOADING' && cacheItem.item.runOn === 'client') {\n                // Ideally, an action configured to runOn client should never interfere with actions running on server.\n                // However, it is possible that parent action with runon 'server' could be dependent on an action that is configured\n                // by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets\n                // include such actions in the uncached list so that it gets picked and executed later.\n                uncached.push(i);\n                // @ts-ignore\n            } else if (i instanceof DataServiceRequest) {\n                try {\n                    const cacheEntries = readCacheEntries(\n                        i,\n                        requestCache,\n                        // @ts-ignore\n                        appCache,\n                        !!!bypassAppCache && shouldReadFromAppCache(i, appCache)\n                    );\n                    if (!cacheEntries.entry) {\n                        uncached.push(i);\n                    }\n                    if (cacheEntries && cacheEntries.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, \"Error execution action '{actionName}', returning null\", {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    uncached.push(i);\n                }\n            } else {\n                if (!cacheItem && !!!bypassAppCache && appCache && shouldReadFromAppCache(i, appCache)) {\n                    cacheItem = appCache.copyTo(cacheKey, requestCache);\n                    if (cacheItem && cacheItem.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                }\n\n                if (!cacheItem || !cacheItem.item) {\n                    uncached.push(i);\n                    return;\n                }\n            }\n        });\n        return [uncached, refresh];\n    }\n\n    /**\n     * Searches cache for mocks matching the inputs\n     * @param inputs Current action inputs\n     * @param context Current action context\n     * @param requestCache Current request cache\n     */\n    private _interceptCacheForMocks(inputs: IActionInput[], context: IActionContext, requestCache: ICache): IActionInput[] {\n        const uncached: IActionInput[] = [];\n        const actionId: string = this.action.prototype.id;\n        inputs.forEach(i => {\n            let mockItem = this._getMockItem(i.getCacheObjectType(), i.getCacheKey(), requestCache);\n            if (!mockItem && actionId) {\n                mockItem = this._getMockItem(actionId, i.getCacheKey(), requestCache);\n            }\n            let existingItem;\n            if (this._checkShouldInteractWithCache(i, i.getCacheObjectType())) {\n                existingItem = requestCache.get({ typeName: i.getCacheObjectType(), key: i.getCacheKey() });\n            }\n\n            if (!!mockItem && !!mockItem.item && !existingItem) {\n                if (this.isObservable) {\n                    requestCache.put(\n                        { typeName: i.getCacheObjectType(), key: i.getCacheKey() },\n                        { item: AsyncResult.resolve(toJS(mockItem.item)) }\n                    );\n                } else {\n                    requestCache.put({ typeName: i.getCacheObjectType(), key: i.getCacheKey() }, { item: toJS(mockItem.item) });\n                }\n            } else {\n                uncached.push(i);\n            }\n        });\n        return uncached;\n    }\n\n    private _getMockItem(cacheNamespace: string, cacheKey: string, requestCache: ICache): ICacheItem<unknown> | undefined {\n        return (\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:${cacheKey}` }) ||\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:*` })\n        );\n    }\n\n    private _convertToJSError(e: any): Error {\n        // Proxy Error usually comes wrapped in an array\n        // If it is, unbox it and conver to regular Error\n        if (Array.isArray(e)) {\n            const proxyError: ProxyError = e[0];\n            if (proxyError.ErrorCode) {\n                return ProxyError.toError(proxyError);\n            }\n        } else if (e.ErrorCode) {\n            return ProxyError.toError(e);\n        }\n        // Return regular Error if not ProxyError\n        return new Error(e.message || '');\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import\"core-js/modules/es.array.reduce.js\";import\"core-js/modules/es.object.assign.js\";import\"core-js/modules/es.promise.js\";import\"core-js/modules/es.promise.finally.js\";import\"core-js/modules/es.string.includes.js\";import\"core-js/modules/web.dom-collections.for-each.js\";import\"core-js/modules/web.dom-collections.iterator.js\";import _uniqWith from\"lodash/uniqWith\";import _get2 from\"lodash/get\";/*!\r\n * Copyright (c) Microsoft Corporation.\r\n * All rights reserved. See LICENSE in the project root for license information.\r\n */import{msdyn365Commerce}from'@msdyn365-commerce/core-internal';import{AsyncResult,DataServiceRequest,ErrorTypeEnum,isAsyncResult,ProxyError}from'@msdyn365-commerce/retail-proxy';import{LogLevel,StaticTelemetry}from'@msdyn365-commerce/telemetry-internal';import{toJS}from'mobx';import uuidv1 from'uuid/v1';import{ActionError}from'./action-error';import{ActionRegistrar}from'./action-registrar';import{isAppCacheData,shouldReadFromAppCache,shouldWriteToAppCache}from'./action-runtime-utils';import{readCacheEntries,saveCacheEntries}from'./cache/retail-cache-helper';import EventHelper from'./event-emitter';const defaultTimeoutInMS=4000;const defaultHookTimeoutInMS=1000;const Timer=(timeoutInMS,message)=>new Promise(resolve=>setTimeout(resolve.bind(resolve,message),timeoutInMS));const ActionTimer=timeoutInMS=>new Promise((_resolve,reject)=>setTimeout(reject.bind(reject,\"Timeout\"/* Timeout */),timeoutInMS));const ObservableActionTimer=timeoutInMS=>new AsyncResult((_resolve,reject)=>setTimeout(reject.bind(reject,\"Timeout\"/* Timeout */),timeoutInMS));/**\r\n * This class contains the logic to batch and de-dupe the actions that can be executed.\r\n * This class is also responsible for checking and saving the action response to cache.\r\n */ /* @internal */export default class ActionExecutor{/**\r\n     * @param action the action to execute\r\n     * @param inputs the action input\r\n     */constructor(action,inputs,telemetry,dataActionOption){this.action=action;this.eventId=uuidv1();this.inputs=[...inputs];// Cloning it DO NOT use the reference\nthis.isBatched=action.prototype.isBatched;this.isObservable=action.prototype.isObservable;// Cache all the calls on browser\nconst masterInput=inputs[0];if(masterInput&&masterInput.dataCacheType){this.cacheType=masterInput.dataCacheType();}else if(masterInput&&masterInput.shouldCacheOutput){this.cacheType=masterInput.shouldCacheOutput()?'request':'none';telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');}else{this.cacheType=dataActionOption&&dataActionOption.cacheType||'none';// for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.\n// this is used for later check if the data acton should be read from app cache.\ninputs.forEach(input=>{input.dataCacheType=()=>this.cacheType;});telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to \"none\"');}}/**\r\n     *\r\n     * @param inputs add more inputs\r\n     */addInputs(inputs){this.inputs.push(...inputs);}/** Execute the action  */ // tslint:disable-next-line:max-func-body-length\nasync execute(context,requestCache,appCache,bypassAppCache){let refreshingInputs=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];const unique=refreshingInputs&&refreshingInputs.length>0?this._removeDuplicates(refreshingInputs):this._removeDuplicates(this.inputs);if(!unique.length){return[];}const isRefreshingAction=refreshingInputs&&refreshingInputs.length>0;// execute readOnly pre hook with\nconst actionId=this._getActionIdFromInputs(unique);this._runPreReadHooks(actionId,unique,context).then(()=>null).catch(err=>null);// execte preReaderHook\nthis._runPreReaderHooks(actionId,unique,context).then(()=>null).catch(err=>null);const[uncached,needsRefresh]=this._checkForCachedData(unique,context,requestCache,appCache,bypassAppCache,isRefreshingAction);if(!uncached.length){// excute readOnly post hook with all cached actions ouptput\nawait this._fetchOutputsAndRunPostReadHook(actionId,unique,requestCache,context);return needsRefresh;}else{const cachedActions=unique.filter(value=>!uncached.includes(value));if(cachedActions.length){// fetch the output for all cached data action, and run readOnly hooks. The uncached actions will be excuted later.\nawait this._fetchOutputsAndRunPostReadHook(actionId,cachedActions,requestCache,context);}}let outputs=[];// VNext observable promise based flow\n// Create the AsyncResult and immediately return it\nif(this.isObservable){if(this.isBatched){this._executeBatchedObservableActions(uncached,requestCache,appCache,context,isRefreshingAction);}else{this._executeObservableAction(uncached[0],requestCache,appCache,context,isRefreshingAction);}return needsRefresh;}if(this.isBatched){// TODO: Have a max batch count on the action\noutputs=await this._actionWrapper(uncached,context,isRefreshingAction);if(outputs&&outputs.length!==uncached.length){// TODO Throw\ncontext.telemetry.log(LogLevel.Trace,'Length of input array {uncached_length} does not meet the output array {outputs_length}',{values:[uncached.length,outputs.length]});}}else{outputs[0]=await this._actionWrapper(uncached[0],context,isRefreshingAction);}if(!outputs||outputs.length===0){return needsRefresh;}this._saveResponseToCache(uncached,outputs,context,requestCache,appCache);return needsRefresh;}// the retail proxy data actions who do not have return type should not interact with cache.\n_checkShouldInteractWithCache(input,typeName){return!(input instanceof DataServiceRequest)||!!typeName;}async _fetchOutputsAndRunPostReadHook(actionId,inputs,requestCache,context){const outputs=inputs.map(i=>{const cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};// if the retail data action does not have return type, we do not read the output from cache.\nlet cacheItem;if(this._checkShouldInteractWithCache(i,cacheKey.typeName)){cacheItem=requestCache.get(cacheKey);}return!!cacheItem?requestCache.getValue(cacheKey):null;});this._runPostReadHooks(actionId,inputs,outputs,context).then(()=>null).catch(err=>null);this._runPostReaderHooks(actionId,inputs,outputs,context).then(()=>null).catch(err=>null);}_removeDuplicates(inputs){if(!this.isBatched){return inputs;}return _uniqWith(inputs,(inputA,inputB)=>inputA.getCacheKey()===inputB.getCacheKey()&&inputA.getCacheObjectType()===inputB.getCacheObjectType());}_getActionIdFromInputs(inputs){let inputsActionId;for(const input of Array.isArray(inputs)?inputs:[inputs]){if(typeof input.getActionId==='function'){inputsActionId=input.getActionId();}}return inputsActionId||this.action.prototype.id;}_getActionFromId(actionId){let{action}=this;if(actionId){const registration=ActionRegistrar.resolveRegistration(actionId,action);if(registration){action=registration.action;return ActionRegistrar.unwrapAction(action);}}return action;}async _runPreReadHooks(id,inputs,context){const preReadHooks=ActionRegistrar.getPreReadHooks(id);if(!preReadHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const preReadHooksArray=Array.from(preReadHooks);return preReadHooksArray.reduce(async(previousTask,currentTask)=>{await previousTask;try{await Promise.race([timer,currentTask(inputs,context)]);}catch(error){context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:error});}return Promise.resolve();},Promise.resolve());}async _runPostReaderHooks(id,inputs,actionResult,context){const postReaderHooks=ActionRegistrar.getPostReaderHooks(id);if(!postReaderHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const postReaderHooksArray=Array.from(postReaderHooks);return postReaderHooksArray.reduce(async(previousTask,currentTask)=>{await previousTask;try{await Promise.race([timer,currentTask(inputs,actionResult,context)]);}catch(error){context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:error});}return Promise.resolve();},Promise.resolve());}async _runPreReaderHooks(id,inputs,context){const preReaderHooks=ActionRegistrar.getPreReaderHooks(id);if(!preReaderHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const preReaderHooksArray=Array.from(preReaderHooks);return preReaderHooksArray.reduce(async(previousTask,currentTask)=>{await previousTask;try{await Promise.race([timer,currentTask(inputs,context)]);}catch(error){context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:error});}return Promise.resolve();},Promise.resolve());}async _runPreHooks(id,inputs,context){const preHooks=ActionRegistrar.getPreHooks(id);if(!preHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const preHooksArray=Array.from(preHooks);return preHooksArray.reduce(async(previousTask,currentTask)=>{const prevInput=await previousTask;let tmpNextInput;try{tmpNextInput=await Promise.race([timer,currentTask(prevInput,context)]);}catch(error){throw error;}let finalNextInput;finalNextInput=tmpNextInput===\"Hook Timeout\"/* HookTimeout */||!tmpNextInput?prevInput:tmpNextInput;return Promise.resolve(finalNextInput);},Promise.resolve(inputs));}async _runPostReadHooks(id,inputs,actionResult,context){const postHooks=ActionRegistrar.getPostReadHooks(id);if(!postHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const postReadHooksArray=Array.from(postHooks);return postReadHooksArray.reduce(async(previousTask,currentTask)=>{await previousTask;try{await Promise.race([timer,currentTask(inputs,actionResult,context)]);}catch(error){context.telemetry.log(LogLevel.Trace,'Error execution hook of action_id \\'{id}\\', returning null',{values:[id||'unnamed'],exception:error});}return Promise.resolve();},Promise.resolve());}async _runPostHooks(id,inputs,actionResult,context){const postHooks=ActionRegistrar.getPostHooks(id);if(!postHooks){return;}const hookTimeout=Number(_get2(context,'requestContext.query.actionHookTimeout'))||defaultHookTimeoutInMS;const timer=Timer(hookTimeout,\"Hook Timeout\"/* HookTimeout */);const postHooksArray=Array.from(postHooks);return postHooksArray.reduce(async(previousTask,currentTask)=>{const prevOutput=await previousTask;let tmpNextOutput;try{tmpNextOutput=await Promise.race([timer,currentTask(inputs,prevOutput,context)]);}catch(error){throw error;}let finalNextOutput;finalNextOutput=tmpNextOutput===\"Hook Timeout\"/* HookTimeout */||!tmpNextOutput?prevOutput:tmpNextOutput;return Promise.resolve(finalNextOutput);},Promise.resolve(actionResult));}/**\r\n     * Add performance logging before and after calling the action?\r\n     */ // tslint:disable-next-line: cyclomatic-complexity\nasync _actionWrapper(inputs,context,isRefreshing){// tslint:disable-next-line: max-func-body-length\nconst actionId=this._getActionIdFromInputs(inputs);const action=this._getActionFromId(actionId);try{// Run pre data action hooks\nconst _inputs=await this._runPreHooks(actionId,inputs,context);if(_inputs){inputs=_inputs;}}catch(e){const convertedError=this._convertToJSError(e);StaticTelemetry.log(LogLevel.Error,\"Error executing pre-hooks for \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',convertedError.name,convertedError.data?convertedError.data.CorrelationId:''],exception:e});return new ActionError(e);}let actionResult;try{const timeOut=Number(_get2(context,'requestContext.query.actionTimeout'));const features=_get2(context,'requestContext.features',{});const customerTimout=msdyn365Commerce.platformSettings&&msdyn365Commerce.platformSettings.dataActionTimeoutInMs;let promises;if(process.env.CURRENT_ENVIRONMENT==='node'&&features.action_timeout||customerTimout){const timeOutValue=(features.action_timeout?timeOut:customerTimout)||defaultTimeoutInMS;promises=[this.isObservable?ObservableActionTimer(timeOutValue):ActionTimer(timeOutValue),action(inputs,context)];}else{promises=[action(inputs,context)];}// run the data action\nactionResult=await Promise.race(promises);}catch(e){const convertedError=this._convertToJSError(e);StaticTelemetry.log(LogLevel.Error,\"Error executing \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',convertedError.name,convertedError.data?convertedError.data.CorrelationId:''],exception:e});let error=new ActionError(e);// For AsyncResult, we need to signal that this was a rejection by throwing\nif(this.isObservable){// Proxy Errors come wrapped as an array\nif(Array.isArray(e)){error=e[0]._errorCode===ErrorTypeEnum.SERVICE_UNAVAILABLE?new ActionError(\"Service Unavailable\"/* ServiceUnavailable */):ProxyError.toError(e[0]);}else{error=e._errorCode===ErrorTypeEnum.SERVICE_UNAVAILABLE?new ActionError(\"Service Unavailable\"/* ServiceUnavailable */):new ActionError(e);}}throw error;}try{// Run post data action hooks\nconst result=await this._runPostHooks(actionId,inputs,actionResult,context);if(result){actionResult=result;}this._runPostReadHooks(actionId,inputs,actionResult,context).then(()=>null).catch(err=>null);this._runPostReaderHooks(actionId,inputs,actionResult,context).then(()=>null).catch(err=>null);}catch(e){const convertedError=this._convertToJSError(e);StaticTelemetry.log(LogLevel.Error,\"Error executing post-hooks for \".concat(isRefreshing?'Refreshing':'',\" action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'\"),// @ts-ignore\n{// @ts-ignore\nvalues:[actionId||action&&action.name||'unnamed',convertedError.name,convertedError.data?convertedError.data.CorrelationId:''],exception:e});}return actionResult;}_saveResponseToCache(uncached,outputs,context,requestCache,appCache){const{log}=context.telemetry;uncached.forEach((i,idx)=>{const actionId=this._getActionIdFromInputs(i);// @ts-ignore\nif(i instanceof DataServiceRequest&&!!i.getCacheObjectType()){try{// @ts-ignore\nsaveCacheEntries(i,outputs[idx],requestCache,appCache,shouldWriteToAppCache(i,appCache));}catch(e){const{action}=this;log(LogLevel.Trace,'Error execution action \\'{actionName}\\', returning null',{values:[actionId||action&&action.name||'unnamed'],exception:e});return null;}}else{const entityId=i.getCacheKey();const entityType=i.getCacheObjectType();if(!!entityId&&!!entityType){const entry=outputs[idx];const cacheKey={typeName:entityType,key:entityId};if(ActionError.isActionError(entry)){if(!ActionError.isTimeoutError(entry)){requestCache.put(cacheKey,{item:entry.error,error:true});}// else do nothing\n}else{if(appCache&&shouldWriteToAppCache(i,appCache)){appCache.put(cacheKey,{item:entry});}const cacheEntry={item:entry};if(i.dataCacheType&&i.dataCacheType()==='instance'){Object.assign(cacheEntry,{instance:'instance'});}requestCache.put(cacheKey,cacheEntry);}}}});}/**\r\n     * Method that executes a set of batchable observable data actions\r\n     * @param uncached The uncached action inputs\r\n     * @param requestCache The request cache\r\n     * @param appCache The application cache, if available\r\n     * @param context The action context\r\n     */_executeBatchedObservableActions(uncached,requestCache,appCache,context){let isRefreshing=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;const unresolvedSet=new Set();const uncachedInputs=[];// Create an OP for each input in the batch that does not yet exist in cache\nconst asyncOutputs=uncached.map((input,index)=>{unresolvedSet.add(index);const executor=(resolve,reject)=>{// When the side promise completes, update each individual OP to have it's piece of the entire batched result\nnew Promise((innerResolve,innerReject)=>{const onEventIdCompletion=value=>{innerResolve(value);};const onEventIdFinalCompletion=()=>{innerResolve();};const onEventIdFailure=error=>{innerReject(error);};// Standard success event\nEventHelper.on(\"\".concat(this.eventId,\"-complete-\").concat(index,\"-\").concat(input.getCacheKey()),onEventIdCompletion);// No response closing event\nEventHelper.on(\"\".concat(this.eventId,\"-final-complete-\").concat(index,\"-\").concat(input.getCacheKey()),onEventIdFinalCompletion);// Failure event\nEventHelper.on(\"\".concat(this.eventId,\"-failure\"),onEventIdFailure);}).then(result=>{EventHelper.removeAllListeners(\"\".concat(this.eventId,\"-complete-\").concat(index,\"-\").concat(input.getCacheKey()));EventHelper.removeAllListeners(\"\".concat(this.eventId,\"-final-complete-\").concat(index,\"-\").concat(input.getCacheKey()));resolve(result);}).catch(error=>{EventHelper.removeAllListeners(\"\".concat(this.eventId,\"-failure\"));reject(error);});};// Already cached OP logic (rerun)\n// we only try to fetch the saved promise from cache when the retail proxy data action has cached type\nlet cachedPromise;if(this._checkShouldInteractWithCache(input,input.getCacheObjectType())){cachedPromise=requestCache.getValue({key:input.getCacheKey(),typeName:input.getCacheObjectType()});}if(cachedPromise&&isAsyncResult(cachedPromise)&&!isRefreshing){cachedPromise.run(executor);return;}// Not yet cached OP logic (initialize, run)\nuncachedInputs.push(input);return new AsyncResult(executor);}).filter(Boolean);// Save never before cached OPs to cache\nthis._saveResponseToCache(uncachedInputs,asyncOutputs,context,requestCache,appCache);// Run the actual action\n// tslint:disable-next-line: no-floating-promises\nthis._actionWrapper(uncached,context,isRefreshing).then(actionResults=>{// Emit events with the associated result so that each individual OP in the cache\n// can be updated appropriately\nactionResults.forEach((actionResult,index)=>{unresolvedSet.delete(index);EventHelper.emit(\"\".concat(this.eventId,\"-complete-\").concat(index,\"-\").concat(uncached[index].getCacheKey()),actionResult);});}).catch(error=>{EventHelper.emit(\"\".concat(this.eventId,\"-failure\"),error);}).finally(()=>{// In the event some inputs do not have results, we need to resolve the promises anyhow\nunresolvedSet.forEach(unresolvedIndex=>{const index=unresolvedIndex;EventHelper.emit(\"\".concat(this.eventId,\"-final-complete-\").concat(index,\"-\").concat(uncached[index].getCacheKey()));});});}/**\r\n     * Executes a standard (non-batched) observable data action\r\n     * @param input The action input\r\n     * @param requestCache The request cache\r\n     * @param appCache The application cache, if available\r\n     * @param context The action context\r\n     */_executeObservableAction(input,requestCache,appCache,context){let isRefreshing=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;const cacheKey={key:input.getCacheKey(),typeName:input.getCacheObjectType()};const executor=(resolve,reject)=>{this._actionWrapper(input,context,isRefreshing).then(result=>{resolve(result);}).catch(error=>{// If error is timeout error, lookup app-cache if there\n// is a valid entity for the given cacheKey in app-cache\nif(ActionError.isServiceUnavailable(error)&&isAppCacheData(input,appCache)){const cachedItem=appCache===null||appCache===void 0?void 0:appCache.getValue(cacheKey);if(cachedItem){return resolve(cachedItem);}}return reject(error);});};// we only try to fetch the saved promise from cache when the retail proxy data action has cached type\nlet cachedPromise;if(this._checkShouldInteractWithCache(input,input.getCacheObjectType())){cachedPromise=requestCache.getValue({key:input.getCacheKey(),typeName:input.getCacheObjectType()});}// If OP is already in cache, just rerun it\nif(cachedPromise&&isAsyncResult(cachedPromise)&&!isRefreshing){cachedPromise.run(executor);return;}// Uncached promises need to be saved to cache\nconst asyncOutput=new AsyncResult(executor);this._saveResponseToCache([input],[asyncOutput],context,requestCache,appCache);}_checkForCachedData(inputs,context,requestCache,appCache,bypassAppCache,refreshing){const mock=_get2(context,'requestContext.query.actionMock');const{log}=context.telemetry;if(mock){inputs=this._interceptCacheForMocks(inputs,context,requestCache);}// if the cache type is set a none don't check cache for data and return inputs for execution\n// lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side\nif(this.cacheType==='none'||refreshing){return[inputs,[]];}const uncached=[];const refresh=[];/* tslint:disable */inputs.forEach((i,idx)=>{const actionId=this._getActionIdFromInputs(i);const cacheKey={typeName:i.getCacheObjectType(),key:i.getCacheKey()};// if the retail proxy action does not have return type, we do not check if its in the cache\nif(i instanceof DataServiceRequest&&!cacheKey.typeName){uncached.push(i);return;}let cacheItem=requestCache.get(cacheKey);if(cacheItem&&isAsyncResult(cacheItem.item)&&cacheItem.item.status==='FAILED'){uncached.push(i);}else if(cacheItem&&cacheItem.item&&cacheItem.item.status==='LOADING'&&cacheItem.item.runOn==='client'){// Ideally, an action configured to runOn client should never interfere with actions running on server.\n// However, it is possible that parent action with runon 'server' could be dependent on an action that is configured\n// by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets\n// include such actions in the uncached list so that it gets picked and executed later.\nuncached.push(i);// @ts-ignore\n}else if(i instanceof DataServiceRequest){try{const cacheEntries=readCacheEntries(i,requestCache,// @ts-ignore\nappCache,!!!bypassAppCache&&shouldReadFromAppCache(i,appCache));if(!cacheEntries.entry){uncached.push(i);}if(cacheEntries&&cacheEntries.shouldRefresh){refresh.push(i);}}catch(e){const{action}=this;log(LogLevel.Trace,\"Error execution action '{actionName}', returning null\",{values:[actionId||action&&action.name||'unnamed'],exception:e});uncached.push(i);}}else{if(!cacheItem&&!!!bypassAppCache&&appCache&&shouldReadFromAppCache(i,appCache)){cacheItem=appCache.copyTo(cacheKey,requestCache);if(cacheItem&&cacheItem.shouldRefresh){refresh.push(i);}}if(!cacheItem||!cacheItem.item){uncached.push(i);return;}}});return[uncached,refresh];}/**\r\n     * Searches cache for mocks matching the inputs\r\n     * @param inputs Current action inputs\r\n     * @param context Current action context\r\n     * @param requestCache Current request cache\r\n     */_interceptCacheForMocks(inputs,context,requestCache){const uncached=[];const actionId=this.action.prototype.id;inputs.forEach(i=>{let mockItem=this._getMockItem(i.getCacheObjectType(),i.getCacheKey(),requestCache);if(!mockItem&&actionId){mockItem=this._getMockItem(actionId,i.getCacheKey(),requestCache);}let existingItem;if(this._checkShouldInteractWithCache(i,i.getCacheObjectType())){existingItem=requestCache.get({typeName:i.getCacheObjectType(),key:i.getCacheKey()});}if(!!mockItem&&!!mockItem.item&&!existingItem){if(this.isObservable){requestCache.put({typeName:i.getCacheObjectType(),key:i.getCacheKey()},{item:AsyncResult.resolve(toJS(mockItem.item))});}else{requestCache.put({typeName:i.getCacheObjectType(),key:i.getCacheKey()},{item:toJS(mockItem.item)});}}else{uncached.push(i);}});return uncached;}_getMockItem(cacheNamespace,cacheKey,requestCache){return requestCache.get({typeName:'__MOCK',key:\"\".concat(cacheNamespace,\":\").concat(cacheKey)})||requestCache.get({typeName:'__MOCK',key:\"\".concat(cacheNamespace,\":*\")});}_convertToJSError(e){// Proxy Error usually comes wrapped in an array\n// If it is, unbox it and conver to regular Error\nif(Array.isArray(e)){const proxyError=e[0];if(proxyError.ErrorCode){return ProxyError.toError(proxyError);}}else if(e.ErrorCode){return ProxyError.toError(e);}// Return regular Error if not ProxyError\nreturn new Error(e.message||'');}}","map":{"version":3,"sources":["../../src/action-executor.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation.\n * All rights reserved. See LICENSE in the project root for license information.\n */\n\n// tslint:disable:no-any\nimport { ICache, ICacheItem } from '@msdyn365-commerce/cache-internal';\nimport { CacheType, IActionContext, IActionInput, IAnyAction, IDataActionOptions, msdyn365Commerce } from '@msdyn365-commerce/core-internal';\nimport { AsyncResult, DataServiceRequest, ErrorTypeEnum, isAsyncResult, ProxyError } from '@msdyn365-commerce/retail-proxy';\nimport { ITelemetry, LogLevel, StaticTelemetry } from '@msdyn365-commerce/telemetry-internal';\nimport { get as _get, uniqWith } from 'lodash';\nimport { toJS } from 'mobx';\nimport uuidv1 from 'uuid/v1';\nimport { ActionError, ActionErrorStatus } from './action-error';\nimport { ActionRegistrar } from './action-registrar';\nimport { isAppCacheData, shouldReadFromAppCache, shouldWriteToAppCache } from './action-runtime-utils';\nimport { readCacheEntries, saveCacheEntries } from './cache/retail-cache-helper';\nimport EventHelper from './event-emitter';\n\nconst defaultTimeoutInMS: number = 4000;\nconst defaultHookTimeoutInMS: number = 1000;\n\nconst Timer = (timeoutInMS: number, message: unknown) => new Promise(resolve => setTimeout(resolve.bind(resolve, message), timeoutInMS));\n\nconst ActionTimer = (timeoutInMS: number) =>\n    new Promise((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\nconst ObservableActionTimer = (timeoutInMS: number) =>\n    new AsyncResult((_resolve, reject) => setTimeout(reject.bind(reject, ActionErrorStatus.Timeout), timeoutInMS));\n\n/**\n * This class contains the logic to batch and de-dupe the actions that can be executed.\n * This class is also responsible for checking and saving the action response to cache.\n */\n/* @internal */\nexport default class ActionExecutor {\n    public readonly action: Function;\n    public readonly cacheType: CacheType;\n    private readonly isBatched: boolean;\n    private readonly eventId: string;\n    private readonly isObservable: boolean;\n\n    private inputs: IActionInput[];\n    /**\n     * @param action the action to execute\n     * @param inputs the action input\n     */\n    constructor(action: Function, inputs: IActionInput[], telemetry: ITelemetry, dataActionOption?:IDataActionOptions) {\n        this.action = action;\n        this.eventId = uuidv1();\n        this.inputs = [...inputs]; // Cloning it DO NOT use the reference\n        this.isBatched = action.prototype.isBatched;\n\n        this.isObservable = action.prototype.isObservable;\n\n        // Cache all the calls on browser\n        const masterInput = inputs[0];\n\n        if (masterInput && masterInput.dataCacheType) {\n            this.cacheType = masterInput.dataCacheType();\n        } else if (masterInput && masterInput.shouldCacheOutput) {\n            this.cacheType = masterInput.shouldCacheOutput() ? 'request' : 'none';\n            telemetry.trace('shouldCacheOutput property has been deprecated. Please update the IActionInput to use dataCacheType');\n        } else {\n            this.cacheType = dataActionOption && dataActionOption.cacheType || 'none';\n            // for data actions who do not have dataCacheType function, we add customer defined cachtype to the action.\n            // this is used for later check if the data acton should be read from app cache.\n            inputs.forEach((input)=> {\n                input.dataCacheType = () => this.cacheType;\n            });\n            telemetry.trace('Neither dataCacheType nor shouldCacheOutput are set. Caching strategy will fall back to \"none\"');\n        }\n    }\n\n    /**\n     *\n     * @param inputs add more inputs\n     */\n    public addInputs(inputs: IActionInput[]): void {\n        this.inputs.push(...inputs);\n    }\n\n    /** Execute the action  */\n    // tslint:disable-next-line:max-func-body-length\n    public async execute(\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshingInputs: IActionInput[] = []\n    ): Promise<IActionInput[]> {\n        const unique: IActionInput[] =\n            refreshingInputs && refreshingInputs.length > 0\n                ? this._removeDuplicates(refreshingInputs)\n                : this._removeDuplicates(this.inputs);\n        if (!unique.length) {\n            return [];\n        }\n        const isRefreshingAction = refreshingInputs && refreshingInputs.length > 0;\n\n        // execute readOnly pre hook with\n        const actionId = this._getActionIdFromInputs(unique);\n        this._runPreReadHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n\n        // execte preReaderHook\n        this._runPreReaderHooks(actionId, unique, context)\n            .then(() => null)\n            .catch(err => null);\n        const [uncached, needsRefresh]: IActionInput[][] = this._checkForCachedData(\n            unique,\n            context,\n            requestCache,\n            appCache,\n            bypassAppCache,\n            isRefreshingAction\n        );\n\n        if (!uncached.length) {\n            // excute readOnly post hook with all cached actions ouptput\n            await this._fetchOutputsAndRunPostReadHook(actionId, unique, requestCache, context);\n            return needsRefresh;\n        } else {\n            const cachedActions = unique.filter(value => !uncached.includes(value));\n            if (cachedActions.length) {\n                // fetch the output for all cached data action, and run readOnly hooks. The uncached actions will be excuted later.\n                await this._fetchOutputsAndRunPostReadHook(actionId, cachedActions, requestCache, context);\n            }\n        }\n\n        let outputs: any[] = [];\n\n        // VNext observable promise based flow\n        // Create the AsyncResult and immediately return it\n        if (this.isObservable) {\n            if (this.isBatched) {\n                this._executeBatchedObservableActions(uncached, requestCache, appCache, context, isRefreshingAction);\n            } else {\n                this._executeObservableAction(uncached[0], requestCache, appCache, context, isRefreshingAction);\n            }\n            return needsRefresh;\n        }\n\n        if (this.isBatched) {\n            // TODO: Have a max batch count on the action\n            outputs = await this._actionWrapper(uncached, context, isRefreshingAction);\n\n            if (outputs && outputs.length !== uncached.length) {\n                // TODO Throw\n                context.telemetry.log(\n                    LogLevel.Trace,\n                    'Length of input array {uncached_length} does not meet the output array {outputs_length}',\n                    { values: [uncached.length, outputs.length] }\n                );\n            }\n        } else {\n            outputs[0] = await this._actionWrapper(uncached[0], context, isRefreshingAction);\n        }\n\n        if (!outputs || outputs.length === 0) {\n            return needsRefresh;\n        }\n\n        this._saveResponseToCache(uncached, outputs, context, requestCache, appCache);\n        return needsRefresh;\n    }\n\n    // the retail proxy data actions who do not have return type should not interact with cache.\n    private _checkShouldInteractWithCache(input: IActionInput, typeName: string | undefined): boolean {\n        return !(input instanceof DataServiceRequest) || !!typeName;\n    }\n\n    private async _fetchOutputsAndRunPostReadHook(\n        actionId: string,\n        inputs: IActionInput[],\n        requestCache: ICache,\n        context: IActionContext\n    ): Promise<void> {\n        const outputs = inputs.map(i => {\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail data action does not have return type, we do not read the output from cache.\n            let cacheItem;\n            if (this._checkShouldInteractWithCache(i, cacheKey.typeName)) {\n                cacheItem = requestCache.get<ICacheItem<unknown>>(cacheKey);\n            }\n            return !!cacheItem ? requestCache.getValue(cacheKey) : null;\n        });\n        this._runPostReadHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n        this._runPostReaderHooks(actionId, inputs, outputs, context)\n            .then(() => null)\n            .catch(err => null);\n    }\n    private _removeDuplicates(inputs: IActionInput[]): IActionInput[] {\n        if (!this.isBatched) {\n            return inputs;\n        }\n\n        return uniqWith(\n            inputs,\n            (inputA: IActionInput, inputB: IActionInput) =>\n                inputA.getCacheKey() === inputB.getCacheKey() && inputA.getCacheObjectType() === inputB.getCacheObjectType()\n        );\n    }\n\n    private _getActionIdFromInputs(inputs: IActionInput | IActionInput[]): string {\n        let inputsActionId;\n        for (const input of Array.isArray(inputs) ? inputs : [inputs]) {\n            if (typeof input.getActionId === 'function') {\n                inputsActionId = input.getActionId();\n            }\n        }\n        return inputsActionId || (<IAnyAction<unknown>>this.action).prototype.id;\n    }\n\n    private _getActionFromId(actionId?: string): Function {\n        let { action } = this;\n        if (actionId) {\n            const registration = ActionRegistrar.resolveRegistration(actionId, <IAnyAction<unknown>>action);\n            if (registration) {\n                action = <IAnyAction<unknown>>registration.action;\n                return ActionRegistrar.unwrapAction(<IAnyAction<unknown>>action);\n            }\n        }\n        return action;\n    }\n\n    private async _runPreReadHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReadHooks = ActionRegistrar.getPreReadHooks(id);\n        if (!preReadHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReadHooksArray = Array.from(preReadHooks);\n        return preReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                              Promise.resolve());\n    }\n\n    private async _runPostReaderHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postReaderHooks = ActionRegistrar.getPostReaderHooks(id);\n        if (!postReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReaderHooksArray = Array.from(postReaderHooks);\n        return postReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                 Promise.resolve());\n    }\n\n    private async _runPreReaderHooks(id: string, inputs: IActionInput | IActionInput[], context: IActionContext): Promise<void> {\n        const preReaderHooks = ActionRegistrar.getPreReaderHooks(id);\n        if (!preReaderHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preReaderHooksArray = Array.from(preReaderHooks);\n        return preReaderHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                                Promise.resolve());\n    }\n\n    private async _runPreHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        context: IActionContext\n    ): Promise<IActionInput | IActionInput[] | void> {\n        const preHooks = ActionRegistrar.getPreHooks(id);\n        if (!preHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n\n        const preHooksArray = Array.from(preHooks);\n        return preHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevInput = await previousTask;\n            let tmpNextInput: unknown;\n            try {\n                tmpNextInput = await Promise.race([timer, currentTask(prevInput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextInput: IActionInput | IActionInput[];\n            finalNextInput =\n                tmpNextInput === ActionErrorStatus.HookTimeout || !tmpNextInput ? prevInput : <IActionInput | IActionInput[]>tmpNextInput;\n            return Promise.resolve(finalNextInput);\n        },                          Promise.resolve(inputs));\n    }\n\n    private async _runPostReadHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostReadHooks(id);\n        if (!postHooks) {\n            return;\n        }\n\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postReadHooksArray = Array.from(postHooks);\n        return postReadHooksArray.reduce(async (previousTask, currentTask) => {\n            await previousTask;\n            try {\n                await Promise.race([timer, currentTask(inputs, actionResult, context)]);\n            } catch (error) {\n                context.telemetry.log(LogLevel.Trace, 'Error execution hook of action_id \\'{id}\\', returning null', {\n                    values: [id || 'unnamed'],\n                    exception: error\n                });\n            }\n            return Promise.resolve();\n        },                               Promise.resolve());\n    }\n\n    private async _runPostHooks(\n        id: string,\n        inputs: IActionInput | IActionInput[],\n        actionResult: unknown,\n        context: IActionContext\n    ): Promise<unknown | void> {\n        const postHooks = ActionRegistrar.getPostHooks(id);\n        if (!postHooks) {\n            return;\n        }\n        const hookTimeout = Number(_get(context, 'requestContext.query.actionHookTimeout')) || defaultHookTimeoutInMS;\n        const timer = Timer(hookTimeout, ActionErrorStatus.HookTimeout);\n        const postHooksArray = Array.from(postHooks);\n        return postHooksArray.reduce(async (previousTask, currentTask) => {\n            const prevOutput = await previousTask;\n            let tmpNextOutput: unknown;\n            try {\n                tmpNextOutput = await Promise.race([timer, currentTask(inputs, prevOutput, context)]);\n            } catch (error) {\n                throw error;\n            }\n            let finalNextOutput;\n            finalNextOutput = tmpNextOutput === ActionErrorStatus.HookTimeout || !tmpNextOutput ? prevOutput : tmpNextOutput;\n            return Promise.resolve(finalNextOutput);\n        },                           Promise.resolve(actionResult));\n    }\n\n    /**\n     * Add performance logging before and after calling the action?\n     */\n    // tslint:disable-next-line: cyclomatic-complexity\n    private async _actionWrapper(inputs: IActionInput | IActionInput[], context: IActionContext, isRefreshing?: boolean): Promise<any> {\n        // tslint:disable-next-line: max-func-body-length\n        const actionId = this._getActionIdFromInputs(inputs);\n        const action = this._getActionFromId(actionId);\n\n        try {\n            // Run pre data action hooks\n            const _inputs = await this._runPreHooks(actionId, inputs, context);\n            if (_inputs) {\n                inputs = _inputs;\n            }\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing pre-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            return new ActionError(e);\n        }\n        let actionResult;\n        try {\n            const timeOut = Number(_get(context, 'requestContext.query.actionTimeout'));\n            const features = _get(context, 'requestContext.features', {});\n            const customerTimout = msdyn365Commerce.platformSettings && msdyn365Commerce.platformSettings.dataActionTimeoutInMs;\n            let promises;\n            if ((process.env.CURRENT_ENVIRONMENT === 'node' && features.action_timeout) || customerTimout) {\n                const timeOutValue = (features.action_timeout ? timeOut : customerTimout) || defaultTimeoutInMS;\n                promises = [this.isObservable ? ObservableActionTimer(timeOutValue) : ActionTimer(timeOutValue), action(inputs, context)];\n            } else {\n                promises = [action(inputs, context)];\n            }\n            // run the data action\n            actionResult = await Promise.race(promises);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n            let error = new ActionError(e);\n            // For AsyncResult, we need to signal that this was a rejection by throwing\n            if (this.isObservable) {\n                // Proxy Errors come wrapped as an array\n                if (Array.isArray(e)) {\n                    error =\n                        e[0]._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : ProxyError.toError(<ProxyError>e[0]);\n                } else {\n                    error =\n                        e._errorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE\n                            ? new ActionError(ActionErrorStatus.ServiceUnavailable)\n                            : new ActionError(e);\n                }\n            }\n\n            throw error;\n        }\n\n        try {\n            // Run post data action hooks\n            const result = await this._runPostHooks(actionId, inputs, actionResult, context);\n            if (result) {\n                actionResult = result;\n            }\n            this._runPostReadHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n            this._runPostReaderHooks(actionId, inputs, actionResult, context)\n                .then(() => null)\n                .catch(err => null);\n        } catch (e) {\n            const convertedError = this._convertToJSError(e);\n            StaticTelemetry.log(\n                LogLevel.Error,\n                `Error executing post-hooks for ${\n                    isRefreshing ? 'Refreshing' : ''\n                } action '{actionName}', returning null. Error '{errorName}'. CorrelationId: '{CorrelationId}'`,\n                // @ts-ignore\n                {\n                    // @ts-ignore\n                    values: [actionId || (action && action.name) || 'unnamed', convertedError.name, convertedError.data ? convertedError.data.CorrelationId : ''],\n                    exception: e\n                }\n            );\n        }\n        return actionResult;\n    }\n\n    private _saveResponseToCache(\n        uncached: IActionInput[],\n        outputs: any[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null\n    ): void {\n        const { log } = context.telemetry;\n        uncached.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            // @ts-ignore\n            if (i instanceof DataServiceRequest && !!i.getCacheObjectType()) {\n                try {\n                    // @ts-ignore\n                    saveCacheEntries(i, outputs[idx], requestCache, appCache, shouldWriteToAppCache(i, appCache));\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, 'Error execution action \\'{actionName}\\', returning null', {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    return null;\n                }\n            } else {\n                const entityId = i.getCacheKey();\n                const entityType = i.getCacheObjectType();\n\n                if (!!entityId && !!entityType) {\n                    const entry = outputs[idx];\n                    const cacheKey = { typeName: entityType, key: entityId };\n                    if (ActionError.isActionError(entry)) {\n                        if (!ActionError.isTimeoutError(entry)) {\n                            requestCache.put(cacheKey, { item: (<ActionError>(<unknown>entry)).error, error: true });\n                        }\n                        // else do nothing\n                    } else {\n                        if (appCache && shouldWriteToAppCache(i, appCache)) {\n                            appCache.put(cacheKey, { item: entry });\n                        }\n                        const cacheEntry = { item: entry };\n                        if (i.dataCacheType && i.dataCacheType() === 'instance') {\n                            Object.assign(cacheEntry, { instance: 'instance' });\n                        }\n                        requestCache.put(cacheKey, cacheEntry);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Method that executes a set of batchable observable data actions\n     * @param uncached The uncached action inputs\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeBatchedObservableActions(\n        uncached: IActionInput[],\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const unresolvedSet = new Set();\n        const uncachedInputs: IActionInput[] = [];\n        // Create an OP for each input in the batch that does not yet exist in cache\n        const asyncOutputs = uncached\n            .map((input, index) => {\n                unresolvedSet.add(index);\n                const executor = (resolve: any, reject: any) => {\n                    // When the side promise completes, update each individual OP to have it's piece of the entire batched result\n                    new Promise((innerResolve, innerReject) => {\n                        const onEventIdCompletion = (value: any) => {\n                            innerResolve(<{}>value);\n                        };\n\n                        const onEventIdFinalCompletion = () => {\n                            innerResolve();\n                        };\n\n                        const onEventIdFailure = (error: any) => {\n                            innerReject(error);\n                        };\n\n                        // Standard success event\n                        EventHelper.on(`${this.eventId}-complete-${index}-${input.getCacheKey()}`, onEventIdCompletion);\n\n                        // No response closing event\n                        EventHelper.on(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`, onEventIdFinalCompletion);\n\n                        // Failure event\n                        EventHelper.on(`${this.eventId}-failure`, onEventIdFailure);\n                    })\n                        .then(result => {\n                            EventHelper.removeAllListeners(`${this.eventId}-complete-${index}-${input.getCacheKey()}`);\n                            EventHelper.removeAllListeners(`${this.eventId}-final-complete-${index}-${input.getCacheKey()}`);\n                            resolve(result);\n                        })\n                        .catch(error => {\n                            EventHelper.removeAllListeners(`${this.eventId}-failure`);\n                            reject(error);\n                        });\n                };\n\n                // Already cached OP logic (rerun)\n                // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n                let cachedPromise;\n                if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n                    cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n                }\n                if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n                    (<AsyncResult<unknown>>cachedPromise).run(executor);\n                    return;\n                }\n\n                // Not yet cached OP logic (initialize, run)\n                uncachedInputs.push(input);\n                return new AsyncResult(executor);\n            })\n            .filter(Boolean);\n\n        // Save never before cached OPs to cache\n        this._saveResponseToCache(uncachedInputs, asyncOutputs, context, requestCache, appCache);\n\n        // Run the actual action\n        // tslint:disable-next-line: no-floating-promises\n        this._actionWrapper(uncached, context, isRefreshing)\n            .then((actionResults: unknown[]) => {\n                // Emit events with the associated result so that each individual OP in the cache\n                // can be updated appropriately\n                actionResults.forEach((actionResult, index) => {\n                    unresolvedSet.delete(index);\n                    EventHelper.emit(`${this.eventId}-complete-${index}-${uncached[index].getCacheKey()}`, actionResult);\n                });\n            })\n            .catch(error => {\n                EventHelper.emit(`${this.eventId}-failure`, error);\n            })\n            .finally(() => {\n                // In the event some inputs do not have results, we need to resolve the promises anyhow\n                unresolvedSet.forEach(unresolvedIndex => {\n                    const index = <number>unresolvedIndex;\n                    EventHelper.emit(`${this.eventId}-final-complete-${index}-${uncached[index].getCacheKey()}`);\n                });\n            });\n    }\n\n    /**\n     * Executes a standard (non-batched) observable data action\n     * @param input The action input\n     * @param requestCache The request cache\n     * @param appCache The application cache, if available\n     * @param context The action context\n     */\n    private _executeObservableAction(\n        input: IActionInput,\n        requestCache: ICache,\n        appCache: ICache | null,\n        context: IActionContext,\n        isRefreshing: boolean = false\n    ): void {\n        const cacheKey = { key: input.getCacheKey(), typeName: input.getCacheObjectType() };\n        const executor = (resolve: any, reject: any) => {\n            this._actionWrapper(input, context, isRefreshing)\n                .then(result => {\n                    resolve(result);\n                })\n                .catch(error => {\n                    // If error is timeout error, lookup app-cache if there\n                    // is a valid entity for the given cacheKey in app-cache\n                    if (ActionError.isServiceUnavailable(error) && isAppCacheData(input, appCache)) {\n                        const cachedItem = appCache?.getValue(cacheKey);\n                        if (cachedItem) {\n                            return resolve(cachedItem);\n                        }\n                    }\n                    return reject(error);\n                });\n        };\n        // we only try to fetch the saved promise from cache when the retail proxy data action has cached type\n        let cachedPromise;\n        if (this._checkShouldInteractWithCache(input, input.getCacheObjectType())) {\n            cachedPromise = requestCache.getValue({ key: input.getCacheKey(), typeName: input.getCacheObjectType() });\n        }\n        // If OP is already in cache, just rerun it\n        if (cachedPromise && isAsyncResult(<object>cachedPromise) && !isRefreshing) {\n            (<AsyncResult<unknown>>cachedPromise).run(executor);\n            return;\n        }\n\n        // Uncached promises need to be saved to cache\n        const asyncOutput = new AsyncResult(executor);\n        this._saveResponseToCache([input], [asyncOutput], context, requestCache, appCache);\n    }\n\n    private _checkForCachedData(\n        inputs: IActionInput[],\n        context: IActionContext,\n        requestCache: ICache,\n        appCache: ICache | null,\n        bypassAppCache?: boolean,\n        refreshing?: boolean\n    ): IActionInput[][] {\n        const mock = _get(context, 'requestContext.query.actionMock');\n        const { log } = context.telemetry;\n\n        if (mock) {\n            inputs = this._interceptCacheForMocks(inputs, context, requestCache);\n        }\n\n        // if the cache type is set a none don't check cache for data and return inputs for execution\n        // lazyresponse == true means it has been called from load-data on browser. In this case, data is already present in request-cache due to run on server side\n        if (this.cacheType === 'none' || refreshing) {\n            return [inputs, []];\n        }\n\n        const uncached: IActionInput[] = [];\n        const refresh: IActionInput[] = [];\n        /* tslint:disable */\n        inputs.forEach((i, idx) => {\n            const actionId = this._getActionIdFromInputs(i);\n            const cacheKey = { typeName: i.getCacheObjectType(), key: i.getCacheKey() };\n            // if the retail proxy action does not have return type, we do not check if its in the cache\n            if (i instanceof DataServiceRequest && !cacheKey.typeName) {\n                uncached.push(i);\n                return;\n            }\n            let cacheItem: ICacheItem<any> | undefined = requestCache.get(cacheKey);\n            if (cacheItem && isAsyncResult(<object>cacheItem.item) && (<AsyncResult<unknown>>cacheItem.item).status === 'FAILED') {\n                uncached.push(i);\n            } else if (cacheItem && cacheItem.item && cacheItem.item.status === 'LOADING' && cacheItem.item.runOn === 'client') {\n                // Ideally, an action configured to runOn client should never interfere with actions running on server.\n                // However, it is possible that parent action with runon 'server' could be dependent on an action that is configured\n                // by partner to be runOn 'client'. In this case, the child action implicitly becomes a server action. Therefore, lets\n                // include such actions in the uncached list so that it gets picked and executed later.\n                uncached.push(i);\n                // @ts-ignore\n            } else if (i instanceof DataServiceRequest) {\n                try {\n                    const cacheEntries = readCacheEntries(\n                        i,\n                        requestCache,\n                        // @ts-ignore\n                        appCache,\n                        !!!bypassAppCache && shouldReadFromAppCache(i, appCache)\n                    );\n                    if (!cacheEntries.entry) {\n                        uncached.push(i);\n                    }\n                    if (cacheEntries && cacheEntries.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                } catch (e) {\n                    const { action } = this;\n                    log(LogLevel.Trace, \"Error execution action '{actionName}', returning null\", {\n                        values: [actionId || (action && action.name) || 'unnamed'],\n                        exception: e\n                    });\n                    uncached.push(i);\n                }\n            } else {\n                if (!cacheItem && !!!bypassAppCache && appCache && shouldReadFromAppCache(i, appCache)) {\n                    cacheItem = appCache.copyTo(cacheKey, requestCache);\n                    if (cacheItem && cacheItem.shouldRefresh) {\n                        refresh.push(i);\n                    }\n                }\n\n                if (!cacheItem || !cacheItem.item) {\n                    uncached.push(i);\n                    return;\n                }\n            }\n        });\n        return [uncached, refresh];\n    }\n\n    /**\n     * Searches cache for mocks matching the inputs\n     * @param inputs Current action inputs\n     * @param context Current action context\n     * @param requestCache Current request cache\n     */\n    private _interceptCacheForMocks(inputs: IActionInput[], context: IActionContext, requestCache: ICache): IActionInput[] {\n        const uncached: IActionInput[] = [];\n        const actionId: string = this.action.prototype.id;\n        inputs.forEach(i => {\n            let mockItem = this._getMockItem(i.getCacheObjectType(), i.getCacheKey(), requestCache);\n            if (!mockItem && actionId) {\n                mockItem = this._getMockItem(actionId, i.getCacheKey(), requestCache);\n            }\n            let existingItem;\n            if (this._checkShouldInteractWithCache(i, i.getCacheObjectType())) {\n                existingItem = requestCache.get({ typeName: i.getCacheObjectType(), key: i.getCacheKey() });\n            }\n\n            if (!!mockItem && !!mockItem.item && !existingItem) {\n                if (this.isObservable) {\n                    requestCache.put(\n                        { typeName: i.getCacheObjectType(), key: i.getCacheKey() },\n                        { item: AsyncResult.resolve(toJS(mockItem.item)) }\n                    );\n                } else {\n                    requestCache.put({ typeName: i.getCacheObjectType(), key: i.getCacheKey() }, { item: toJS(mockItem.item) });\n                }\n            } else {\n                uncached.push(i);\n            }\n        });\n        return uncached;\n    }\n\n    private _getMockItem(cacheNamespace: string, cacheKey: string, requestCache: ICache): ICacheItem<unknown> | undefined {\n        return (\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:${cacheKey}` }) ||\n            requestCache.get({ typeName: '__MOCK', key: `${cacheNamespace}:*` })\n        );\n    }\n\n    private _convertToJSError(e: any): Error {\n        // Proxy Error usually comes wrapped in an array\n        // If it is, unbox it and conver to regular Error\n        if (Array.isArray(e)) {\n            const proxyError: ProxyError = e[0];\n            if (proxyError.ErrorCode) {\n                return ProxyError.toError(proxyError);\n            }\n        } else if (e.ErrorCode) {\n            return ProxyError.toError(e);\n        }\n        // Return regular Error if not ProxyError\n        return new Error(e.message || '');\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
import 'jest';

import * as core from '@msdyn365-commerce/core';
import { MapStoreSelectorStateManager } from '../map-store-selector-state-manager';
import { IListMapViewState, IStoreSelectorStateManager } from '../i-store-selection-state-manager';

import MockMapLocationsResponse from '../__mocks__/map-locations-response.json';

describe('geoLocate Tests', () => {
    let stateManager: IStoreSelectorStateManager;
    let mockRequestContext: core.IRequestContext;

    let crypto: Crypto;
    let body: HTMLElement;

    beforeAll(() => {
        stateManager = new MapStoreSelectorStateManager();
    });

    beforeEach(() => {
        crypto = window.crypto;
        body = window.document.body;

        mockRequestContext = {
            // @ts-ignore partial mock
            channel: {
                BingMapsApiKey: '1001',
                BingMapsEnabled: true
            }
        };

        // @ts-ignore Overriding read only for test purposes
        window.crypto = {
            getRandomValues: jest.fn().mockReturnValue('1')
        };

        window.document.body.appendChild = jest.fn().mockImplementation(script => {
            expect(window['mapSearchCallback_1']).toBeDefined();
            window['mapSearchCallback_1'](undefined);
            expect(window['mapSearchCallback_1']).toBeUndefined();

            return script;
        });

        window.document.body.removeChild = jest.fn();
    });

    it('Returns undefined if search term is undefined', async () => {
        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('', actionContext);

        expect(window.crypto.getRandomValues).not.toBeCalled();
        expect(window.document.body.appendChild).not.toBeCalled();
        expect(window.document.body.removeChild).not.toBeCalled();

        expect(result).toBeUndefined();
    });

    it('Returns undefined if channel not set', async () => {
        mockRequestContext.channel = undefined;

        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('Seattle', actionContext);

        expect(window.crypto.getRandomValues).not.toBeCalled();
        expect(window.document.body.appendChild).not.toBeCalled();
        expect(window.document.body.removeChild).not.toBeCalled();

        expect(result).toBeUndefined();
    });

    it('Returns undefined if API key not present', async () => {
        mockRequestContext.channel!.BingMapsApiKey = undefined;

        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('Seattle', actionContext);

        expect(window.crypto.getRandomValues).not.toBeCalled();
        expect(window.document.body.appendChild).not.toBeCalled();
        expect(window.document.body.removeChild).not.toBeCalled();

        expect(result).toBeUndefined();
    });

    it('Returns undefined if Map not enabled ', async () => {
        mockRequestContext.channel!.BingMapsEnabled = false;

        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('Seattle', actionContext);

        expect(window.crypto.getRandomValues).not.toBeCalled();
        expect(window.document.body.appendChild).not.toBeCalled();
        expect(window.document.body.removeChild).not.toBeCalled();

        expect(result).toBeUndefined();
    });

    it('Returns undefined if search callback returns undefined', async () => {
        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('Seattle', actionContext);

        expect(window.crypto.getRandomValues).toBeCalled();
        expect(window.document.body.appendChild).toBeCalled();
        expect(window.document.body.removeChild).toBeCalled();

        expect(result).toBeUndefined();
    });

    it('Returns lat lon pair if search callback returns valid data', async () => {
        window.document.body.appendChild = jest.fn().mockImplementation(script => {
            expect(window['mapSearchCallback_1']).toBeDefined();
            window['mapSearchCallback_1'](MockMapLocationsResponse);
            expect(window['mapSearchCallback_1']).toBeUndefined();

            return script;
        });

        const actionContext = core.buildMockActionContext({ requestContext: mockRequestContext });

        const result = await stateManager.geoLocate('Seattle', actionContext);

        expect(result).toEqual(expect.objectContaining(
            {
                latitude: 40.714550018310547,
                longitude: -74.00714111328125
            }
        ));
    });

    afterEach(() => {
        // @ts-ignore Overriding read only for test purposes
        window.crypto = crypto;
        window.document.body = body;
    });
});

describe('openDialog tests', () => {
    let stateManager: IStoreSelectorStateManager;

    beforeEach(() => {
        stateManager = new MapStoreSelectorStateManager();
    });

    it('isDialogOpen starts off as closed', () => {
        expect(stateManager.isDialogOpen).toBe(false);
    });

    it('isDialogOpen is open after open dialog called', () => {
        stateManager.openDialog({
            product: undefined,
            alreadySelectedLocation: undefined,
            onLocationSelected: jest.fn()
        });

        expect(stateManager.isDialogOpen).toBe(true);
    });

    it('isDialogOpen sets proper contect', () => {
        const mockContext = {
            product: undefined,
            alreadySelectedLocation: undefined,
            onLocationSelected: jest.fn()
        };

        stateManager.openDialog(mockContext);

        expect(stateManager.context).toBeDefined();
        expect(stateManager.context).toEqual(mockContext);

        stateManager.context!.onLocationSelected({});

        expect(mockContext.onLocationSelected).toBeCalled();
    });

    it('isDialogOpen is closed after close dialog called', () => {
        stateManager.openDialog({
            product: undefined,
            alreadySelectedLocation: undefined,
            onLocationSelected: (location) => Promise.resolve()
        });

        stateManager.closeDialog();

        expect(stateManager.isDialogOpen).toBe(false);
    });

    it('openDialog rejects if already open', async () => {
        await expect(stateManager.openDialog({
            product: undefined,
            alreadySelectedLocation: undefined,
            onLocationSelected: jest.fn()
        })).resolves.toBeUndefined();

        await expect(stateManager.openDialog({
            product: undefined,
            alreadySelectedLocation: undefined,
            onLocationSelected: jest.fn()
        })).rejects.toEqual(expect.anything());
    });
});

describe('loadMapApi Tests', () => {
    let stateManager: IStoreSelectorStateManager;

    beforeEach(() => {
        stateManager = new MapStoreSelectorStateManager();
    });

    it('isMapApiLoaded starts off as undefined', () => {
        expect(stateManager.isMapApiLoaded).toBe(undefined);
    });

    it('mapApi is ready after the callback', async () => {
        const mockLoadMapApiInput = {
            key: 'A1B2C3',
            lang: 'fr',
            market: 'fr-FR'
        };

        stateManager.loadMapApi(mockLoadMapApiInput).then(() => {
            expect(window['mapAPIReady']).toBeDefined();
            expect(stateManager.isMapApiLoaded).toBe(true);
        }).catch(() => {
            expect(window['mapAPIReady']).toBeUndefined();
            expect(stateManager.isMapApiLoaded).toBe(undefined);
        });
    });
});

describe('Toggle List/Map view state test', () => {
    let stateManager: IStoreSelectorStateManager;

    beforeEach(() => {
        stateManager = new MapStoreSelectorStateManager();
    });

    it('listMapViewState is intialized', () => {
        const listMapViewState: IListMapViewState = stateManager.listMapViewState;
        expect(listMapViewState.displayList).toBe(true);
        expect(listMapViewState.displayMap).toBe(false);
    });

    it('Toggles the value of displayList and displayMap', async () => {
        const listMapViewState: IListMapViewState = stateManager.listMapViewState;
        stateManager.toggleListMapViewState().then(() => {
            expect(listMapViewState.displayList).toBe(false);
            expect(listMapViewState.displayMap).toBe(true);
        }).catch(() => {
            expect(listMapViewState.displayList).toBe(true);
            expect(listMapViewState.displayMap).toBe(false);
        });
    });
});
{"version":3,"file":"utilities.js","sourceRoot":"./src/","sources":["modules/search-result-container/components/utilities.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITelemetry } from '@msdyn365-commerce/core';\nimport { ProductRefinerValue } from '@msdyn365-commerce/retail-proxy';\nimport { IRefineItemToggleNotification } from './refine-item-toggle-notification';\n\n/**\n * Types of product refiner values\n */\nexport const enum ProductRefinerValueDataTypeValue {\n    /**\n     * Range slider is used for selections like price\n     */\n    Range = 1,\n\n    /**\n     * Range input is a different way to specify ranges and can be expressed with input boxes\n     * as well as a set of discrete single-select type values\n     */\n    RangeInput = 4,\n\n    /**\n     * This is a discrete list item, either multi-select or single-select\n     */\n    List = 5,\n\n    /**\n     * Boolean types allows only single-select\n     */\n    Boolean = 6\n}\n\n/**\n * Types of product refiners\n */\nexport const enum ProductRefinerTypeValue {\n    /**\n     * Refiner values are single-select\n     */\n    Single = 0,\n\n    /**\n     * Refiner values are multi-select\n     */\n    Multi = 1\n}\n\n/**\n * ProductRefinerSource enum type.\n */\nexport const enum ProductRefinerSource {\n    /**\n     * The None member.\n     */\n    None = 0,\n    /**\n     * The Attribute member.\n     */\n    Attribute = 1,\n    /**\n     * The Category member.\n     */\n    Category = 2,\n    /**\n     * The Price member.\n     */\n    Price = 3,\n    /**\n     * The Rating member.\n     */\n    Rating = 4\n}\n\n/**\n * Find the refinement criterion associated with this product refiner value\n * @param productRefinerValue product refiner value to match\n * @param refinementCriteria selected refinement criteria\n */\nexport function findMatchingRefinementCriterion(\n    productRefinerValue: ProductRefinerValue,\n    refinementCriteria: ProductRefinerValue[]\n): ProductRefinerValue | undefined {\n    // if the value is a range, then match only on data type value; otherwise match on item string\n    return refinementCriteria.find(\n        (refinementCriterion: ProductRefinerValue) => isMatchingRefinementCriterion(productRefinerValue, refinementCriterion)\n    );\n}\n\n/**\n * Find the refinement criterion associated with this product refiner value\n * @param productRefinerValue product refiner value to match\n * @param refinementCriteria selected refinement criteria\n */\nexport function isMatchingRefinementCriterion(\n    productRefinerValue: ProductRefinerValue,\n    refinementCriterion: ProductRefinerValue\n): boolean {\n    // if the value is a range, then match only on data type value; otherwise match on item string\n    return (\n        refinementCriterion.RefinerRecordId === productRefinerValue.RefinerRecordId &&\n        refinementCriterion.RefinerSourceValue === productRefinerValue.RefinerSourceValue &&\n        refinementCriterion.DataTypeValue === productRefinerValue.DataTypeValue &&\n        (refinementCriterion.DataTypeValue === ProductRefinerValueDataTypeValue.Range ||\n            refinementCriterion.LeftValueBoundString === productRefinerValue.LeftValueBoundString)\n    );\n}\n\nexport function getUpdatedRefinementCriteria(\n    itemToggleNotification: IRefineItemToggleNotification,\n    currentRefinementCriteria: ProductRefinerValue[]): ProductRefinerValue[] {\n    const updatedRefinementCriteria: ProductRefinerValue[] = [];\n    let toggledItemFound = false;\n    currentRefinementCriteria.forEach((selectedCriterion: ProductRefinerValue) => {\n        if (isMatchingRefinementCriterion(itemToggleNotification.productRefinerValue, selectedCriterion)) {\n            toggledItemFound = true;\n            if (itemToggleNotification.isSelecting) {\n                const next = {\n                    ...selectedCriterion,\n                    LeftValueBoundString: itemToggleNotification.rangeStart !== undefined && `${itemToggleNotification.rangeStart}` || selectedCriterion.LeftValueBoundString,\n                    RightValueBoundString: itemToggleNotification.rangeEnd !== undefined && `${itemToggleNotification.rangeEnd}` || selectedCriterion.RightValueBoundString,\n                };\n                updatedRefinementCriteria.push(next);\n\n            } // else the item is being de-selected, so omit it from the refinement criteria\n        } else {\n            // keep existing criterion because it is not in the item toggle notification\n            updatedRefinementCriteria.push(selectedCriterion);\n        }\n    });\n\n    if (!toggledItemFound) {\n        const next = {\n            ...itemToggleNotification.productRefinerValue,\n            LeftValueBoundString: itemToggleNotification.rangeStart !== undefined && `${itemToggleNotification.rangeStart}` || itemToggleNotification.productRefinerValue.LeftValueBoundString,\n            RightValueBoundString: itemToggleNotification.rangeEnd !== undefined && `${itemToggleNotification.rangeEnd}` || itemToggleNotification.productRefinerValue.RightValueBoundString,\n        };\n        updatedRefinementCriteria.push(next);\n\n        // If single select, then deselect any others in the parent refiner group\n        if ((itemToggleNotification.productRefinerValue.DataTypeValue === ProductRefinerValueDataTypeValue.List || itemToggleNotification.productRefinerValue.DataTypeValue === ProductRefinerValueDataTypeValue.Boolean)  &&\n            itemToggleNotification.parentProductRefinerHierarchy.RefinerTypeValue === ProductRefinerTypeValue.Single) {\n            itemToggleNotification.parentProductRefinerHierarchy.Values.forEach((child: ProductRefinerValue) => {\n                if (child.RefinerRecordId === next.RefinerRecordId && child.LeftValueBoundString === next.LeftValueBoundString) {\n                    // do nothing\n                } else {\n                    const matchingIndex = updatedRefinementCriteria.findIndex((criterion: ProductRefinerValue) => isMatchingRefinementCriterion(child, criterion));\n                    if (matchingIndex > -1) {\n                        updatedRefinementCriteria.splice(matchingIndex, 1);\n                    }\n                }\n            });\n        }\n    }\n\n    return updatedRefinementCriteria;\n}\n\nexport function formatPrice(\n    amount: string | undefined,\n    currency: string | undefined,\n    locale: string | undefined,\n    telemetry: ITelemetry): string {\n    if (!amount || !currency) {\n        telemetry.trace(`[refine-menu.utilities.formatPrice] could not format price for ${amount} ${currency}`);\n        return amount || '';\n    }\n    const priceAmount = (amount && Number(amount)) || 0;\n    let result: string;\n\n    try {\n        result = new Intl.NumberFormat(locale, {\n            style: 'currency',\n            currencyDisplay: 'symbol',\n            currency: currency,\n            minimumFractionDigits: 0\n        }).format(priceAmount);\n    } catch (e) {\n        result = `${priceAmount} ${currency}`;\n        telemetry.warning(`[refine-menu.utilities.formatPrice] Failed to format price for ${result}: ${e}`);\n    }\n\n    return result;\n}"]}
export function findMatchingRefinementCriterion(productRefinerValue, refinementCriteria) {
    return refinementCriteria.find((refinementCriterion) => isMatchingRefinementCriterion(productRefinerValue, refinementCriterion));
}
export function isMatchingRefinementCriterion(productRefinerValue, refinementCriterion) {
    return (refinementCriterion.RefinerRecordId === productRefinerValue.RefinerRecordId &&
        refinementCriterion.RefinerSourceValue === productRefinerValue.RefinerSourceValue &&
        refinementCriterion.DataTypeValue === productRefinerValue.DataTypeValue &&
        (refinementCriterion.DataTypeValue === 1 ||
            refinementCriterion.LeftValueBoundString === productRefinerValue.LeftValueBoundString));
}
export function getUpdatedRefinementCriteria(itemToggleNotification, currentRefinementCriteria) {
    const updatedRefinementCriteria = [];
    let toggledItemFound = false;
    currentRefinementCriteria.forEach((selectedCriterion) => {
        if (isMatchingRefinementCriterion(itemToggleNotification.productRefinerValue, selectedCriterion)) {
            toggledItemFound = true;
            if (itemToggleNotification.isSelecting) {
                const next = {
                    ...selectedCriterion,
                    LeftValueBoundString: itemToggleNotification.rangeStart !== undefined && `${itemToggleNotification.rangeStart}` || selectedCriterion.LeftValueBoundString,
                    RightValueBoundString: itemToggleNotification.rangeEnd !== undefined && `${itemToggleNotification.rangeEnd}` || selectedCriterion.RightValueBoundString,
                };
                updatedRefinementCriteria.push(next);
            }
        }
        else {
            updatedRefinementCriteria.push(selectedCriterion);
        }
    });
    if (!toggledItemFound) {
        const next = {
            ...itemToggleNotification.productRefinerValue,
            LeftValueBoundString: itemToggleNotification.rangeStart !== undefined && `${itemToggleNotification.rangeStart}` || itemToggleNotification.productRefinerValue.LeftValueBoundString,
            RightValueBoundString: itemToggleNotification.rangeEnd !== undefined && `${itemToggleNotification.rangeEnd}` || itemToggleNotification.productRefinerValue.RightValueBoundString,
        };
        updatedRefinementCriteria.push(next);
        if ((itemToggleNotification.productRefinerValue.DataTypeValue === 5 || itemToggleNotification.productRefinerValue.DataTypeValue === 6) &&
            itemToggleNotification.parentProductRefinerHierarchy.RefinerTypeValue === 0) {
            itemToggleNotification.parentProductRefinerHierarchy.Values.forEach((child) => {
                if (child.RefinerRecordId === next.RefinerRecordId && child.LeftValueBoundString === next.LeftValueBoundString) {
                }
                else {
                    const matchingIndex = updatedRefinementCriteria.findIndex((criterion) => isMatchingRefinementCriterion(child, criterion));
                    if (matchingIndex > -1) {
                        updatedRefinementCriteria.splice(matchingIndex, 1);
                    }
                }
            });
        }
    }
    return updatedRefinementCriteria;
}
export function formatPrice(amount, currency, locale, telemetry) {
    if (!amount || !currency) {
        telemetry.trace(`[refine-menu.utilities.formatPrice] could not format price for ${amount} ${currency}`);
        return amount || '';
    }
    const priceAmount = (amount && Number(amount)) || 0;
    let result;
    try {
        result = new Intl.NumberFormat(locale, {
            style: 'currency',
            currencyDisplay: 'symbol',
            currency: currency,
            minimumFractionDigits: 0
        }).format(priceAmount);
    }
    catch (e) {
        result = `${priceAmount} ${currency}`;
        telemetry.warning(`[refine-menu.utilities.formatPrice] Failed to format price for ${result}: ${e}`);
    }
    return result;
}
//# sourceMappingURL=utilities.js.map
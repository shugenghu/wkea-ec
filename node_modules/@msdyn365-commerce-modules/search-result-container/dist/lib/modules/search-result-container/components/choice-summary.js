import { __decorate } from "tslib";
import { getPayloadObject, getTelemetryAttributes } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { get } from 'lodash';
import { computed } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { isMatchingRefinementCriterion } from './utilities';
let ChoiceSummary = class ChoiceSummary extends React.Component {
    constructor(props) {
        super(props);
        this.closeButtonGlyph = 'msi-close-btn';
        this._onClick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const target = e.currentTarget;
            const clearAll = target.getAttribute('class').indexOf('choice-summary__clear-all') > -1;
            const selectedRefiner = clearAll ? undefined : this._getSelectedRefinerChoice(target);
            if (this.props.onChoiceClicked) {
                this.props.onChoiceClicked({
                    clearAll: clearAll,
                    itemClicked: target,
                    choiceClicked: selectedRefiner,
                    nextItemToFocus: target.nextSibling
                });
            }
        };
        this.payLoad = getPayloadObject('click', this.props.telemetryContent, '');
    }
    get selectedRefinersMap() {
        const { selectedChoices } = this.props;
        return selectedChoices.map((selectedRefiner) => {
            return {
                key: this._getKeyForRefinerValue(selectedRefiner),
                value: selectedRefiner
            };
        });
    }
    render() {
        const { clearAllText, label, classNames, choiceAriaLabel } = this.props;
        const items = this.selectedRefinersMap;
        this.payLoad.contentAction.etext = clearAllText;
        const clearAllAttributes = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
        return (React.createElement("div", { className: 'msc-choice-summary' },
            items.length > 0 && label && React.createElement("span", { className: 'msc-choice-summary__label' }, label),
            React.createElement("ul", { className: classnames(classNames, 'msc-choice-summary__list', 'list-unstyled') }, items.map((item, index) => {
                const listItemProps = {
                    'aria-posinset': index,
                    'aria-setsize': items.length
                };
                this.payLoad.contentAction.etext = item.key;
                const attribute = getTelemetryAttributes(this.props.telemetryContent, this.payLoad);
                return (React.createElement("li", Object.assign({ className: 'msc-choice-summary__list-item', key: item.key }, listItemProps),
                    React.createElement("a", Object.assign({ className: 'msc-choice-summary__item', href: this.props.urlBuilder(item.value, false), "aria-label": `${item.key} ${choiceAriaLabel}`, onClick: this._onClick }, attribute),
                        item.key,
                        React.createElement("span", { className: `${this.closeButtonGlyph} msc-choice-summary__glyph` }))));
            })),
            items.length > 0 && clearAllText && React.createElement("a", Object.assign({ href: this.props.urlBuilder({}, true), className: 'msc-choice-summary__clear-all' }, clearAllAttributes, { onClick: this._onClick }), clearAllText)));
    }
    _getKeyForRefinerValue(productRefinerValue) {
        const { choiceFormat, choiceRangeValueFormat, refinerHierarchy, telemetry } = this.props;
        const overallFormat = choiceFormat || '{1}';
        const rangeFormat = choiceRangeValueFormat;
        let refinerName = '';
        if (refinerHierarchy && refinerHierarchy.find) {
            const parent = refinerHierarchy.find((hierarchy) => !!hierarchy.Values.find((value) => isMatchingRefinementCriterion(value, productRefinerValue)));
            if (!parent) {
                telemetry.warning('[choice-summary] could not find parent of selected refiner value');
            }
            else {
                refinerName = parent.KeyName || '';
            }
        }
        let refinerValueName;
        switch (productRefinerValue.DataTypeValue) {
            case 1:
            case 4:
                refinerValueName = rangeFormat
                    .replace('{0}', this._formatPrice(productRefinerValue.LeftValueBoundString, productRefinerValue.UnitText))
                    .replace('{1}', this._formatPrice(productRefinerValue.RightValueBoundString, productRefinerValue.UnitText));
                break;
            default:
                refinerValueName = productRefinerValue.LeftValueBoundLocalizedString || productRefinerValue.LeftValueBoundString || '';
        }
        return overallFormat.replace('{0}', refinerName).replace('{1}', refinerValueName);
    }
    _formatPrice(amount, currency) {
        if (!amount || !currency) {
            this.props.telemetry.trace('[choice-summary] could not format price');
            return amount || '';
        }
        const priceAmount = (amount && Number(amount)) || 0;
        const locale = get(this.props, 'context.request.locale', 'en-US');
        let result;
        try {
            result = new Intl.NumberFormat(locale, {
                style: 'currency',
                currencyDisplay: 'symbol',
                currency: currency,
                minimumFractionDigits: 0
            }).format(priceAmount);
        }
        catch (e) {
            result = `${priceAmount} ${currency}`;
            this.props.telemetry.warning(`Failed to format price for ${result}: ${e}`);
        }
        return result;
    }
    _getSelectedRefinerChoice(itemClicked) {
        const result = this.selectedRefinersMap.find(selected => (itemClicked.innerText && itemClicked.innerText.trim()) === selected.key);
        return (result && result.value) || undefined;
    }
};
__decorate([
    computed
], ChoiceSummary.prototype, "selectedRefinersMap", null);
ChoiceSummary = __decorate([
    observer
], ChoiceSummary);
export default ChoiceSummary;
//# sourceMappingURL=choice-summary.js.map
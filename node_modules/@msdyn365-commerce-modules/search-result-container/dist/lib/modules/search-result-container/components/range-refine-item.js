import { __decorate } from "tslib";
import { Slider } from '@msdyn365-commerce-modules/utilities';
import debounce from 'lodash/debounce';
import { computed } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { formatPrice } from './utilities';
let RangeRefineItem = class RangeRefineItem extends React.Component {
    constructor(props) {
        super(props);
        this._formattedPriceReverseLookup = new Map();
        this._onRangeUpdate = this._onRangeUpdate.bind(this);
        this._onRangeUpdateEnd = this._onRangeUpdateEnd.bind(this);
        this._handleRangeTooltipText = this._handleRangeTooltipText.bind(this);
        this._changeMin = this._changeMin.bind(this);
        this._changeMax = this._changeMax.bind(this);
        this._finishChangeMin = this._finishChangeMin.bind(this);
        this._finishChangeMax = this._finishChangeMax.bind(this);
        this.minInput = React.createRef();
        this.maxInput = React.createRef();
        const { selectedRefinementCriterion } = this.props;
        const initialMin = selectedRefinementCriterion && selectedRefinementCriterion.LeftValueBoundString || '0';
        const initialMax = selectedRefinementCriterion && selectedRefinementCriterion.RightValueBoundString || undefined;
        this.state = {
            isChecked: false,
            validationErrorMin: undefined,
            validationErrorMax: undefined,
            selectedMin: initialMin,
            selectedMax: initialMax,
            touchedMin: false,
            touchedMax: false
        };
    }
    get currencyCode() {
        return this.props.productRefinerValue.UnitText || '';
    }
    render() {
        const { productRefinerValue, parentProductRefinerHierarchy, refineItemCommonProps } = this.props;
        if (!productRefinerValue || !parentProductRefinerHierarchy) {
            refineItemCommonProps.telemetry.error('Cannot render refine value range without productRefinerValue and parentProductRefinerHierarchy');
            return undefined;
        }
        if (this.props.rangeType === 'input') {
            return this._renderInputFields();
        }
        return this._renderSlider();
    }
    _renderInputFields() {
        const { isDisabled, parentProductRefinerHierarchy, refineItemCommonProps } = this.props;
        const { selectedMin, selectedMax, touchedMin, touchedMax, validationErrorMin, validationErrorMax } = this.state;
        const rangeAriaLabel = (refineItemCommonProps.rangeNameFormat || '{0}').replace('{0}', (parentProductRefinerHierarchy.KeyName || ''));
        const formAttrs = {
            'aria-label': rangeAriaLabel,
            'aria-disabled': isDisabled
        };
        const minInputClassName = `ms-refine-submenu__input-range refine-submenu__input-range-min ${validationErrorMin ? 'refine-submenu__input-range--error' : ''}`;
        const maxInputClassName = `ms-refine-submenu__input-range refine-submenu__input-range-max ${validationErrorMax ? 'refine-submenu__input-range--error' : ''}`;
        const minLabelClassName = 'ms-refine-submenu__input-range-label refine-submenu__input-range-label-min';
        const maxLabelClassName = 'ms-refine-submenu__input-range-label refine-submenu__input-range-label-max';
        const formattedSelectedMin = this._getFormattedSelectedValue(selectedMin, touchedMin, validationErrorMin);
        const formattedSelectedMax = this._getFormattedSelectedValue(selectedMax, touchedMax, validationErrorMax);
        return (React.createElement("form", Object.assign({ className: 'ms-refine-submenu__input-range-refiner' }, formAttrs),
            React.createElement("label", { className: minLabelClassName },
                refineItemCommonProps.minLabel,
                React.createElement("input", { className: minInputClassName, onChange: this._changeMin, onFocus: this._changeMin, onBlur: this._finishChangeMin, value: formattedSelectedMin, ref: this.minInput })),
            React.createElement("label", { className: maxLabelClassName },
                refineItemCommonProps.maxLabel,
                React.createElement("input", { className: maxInputClassName, placeholder: formattedSelectedMax ? undefined : refineItemCommonProps.placeholderTextMax, onChange: this._changeMax, onFocus: this._changeMax, onBlur: this._finishChangeMax, value: formattedSelectedMax, ref: this.maxInput })),
            validationErrorMin &&
                React.createElement("span", { className: 'ms-refine-submenu__input-range-error-text refine-submenu__input-range-min-error-text' }, validationErrorMin),
            validationErrorMax && validationErrorMin !== validationErrorMax &&
                React.createElement("span", { className: 'ms-refine-submenu__input-range-error-text refine-submenu__input-range-max-error-text' }, validationErrorMax)));
    }
    _renderSlider() {
        const { isDisabled, productRefinerValue, parentProductRefinerHierarchy, selectedRefinementCriterion } = this.props;
        const min = productRefinerValue.LeftValueBoundString;
        const max = productRefinerValue.RightValueBoundString;
        const selectedMin = selectedRefinementCriterion && selectedRefinementCriterion.LeftValueBoundString || productRefinerValue.LeftValueBoundString || '0';
        const selectedMax = selectedRefinementCriterion && selectedRefinementCriterion.RightValueBoundString || productRefinerValue.RightValueBoundString || max;
        const sliderId = `slider_${parentProductRefinerHierarchy.RecordId}_${productRefinerValue.RefinerRecordId}`;
        const ariaAttributes = {
            'aria-disabled': isDisabled
        };
        const minPrice = this._formatPrice(min);
        const maxPrice = this._formatPrice(max);
        const selectedMinPrice = this._formatPrice(selectedMin);
        const selectedMaxPrice = this._formatPrice(selectedMax);
        return (React.createElement(Slider, Object.assign({ className: 'ms-refine-submenu__range-refiner', key: sliderId, id: sliderId, inForm: false, min: min && Number(min) || undefined, max: max && Number(max) || undefined, step: 1, orientation: 'horizontal', labels: [
                {
                    labelId: `${sliderId}_start`,
                    labelString: `${minPrice}`,
                    labelPositioning: 'start'
                },
                {
                    labelId: `${sliderId}_end`,
                    labelString: `${maxPrice}`,
                    labelPositioning: 'end'
                }
            ], showLabels: true, showTooltip: true, sliderThumbs: [
                {
                    id: `${sliderId}_slider_thumb_start`,
                    value: selectedMin && Number(selectedMin) || 0,
                    ariaLabel: `${this.props.minValueSliderThumbAriaLabel} ${this.currencyCode}`,
                    ariaValueText: `${selectedMinPrice}`
                },
                {
                    id: `${sliderId}_slider_thumb_end`,
                    value: Number(selectedMax) || Number(maxPrice),
                    ariaLabel: `${this.props.maxValueSliderThumbAriaLabel} ${this.currencyCode}`,
                    ariaValueText: `${selectedMaxPrice}`
                }
            ], onChangeEnd: this._onRangeUpdateEnd, onChange: debounce(this._onRangeUpdate, 500), handleTooltipText: this._handleRangeTooltipText }, ariaAttributes)));
    }
    _changeMin(event) {
        this._changeValue(event, 'Min');
    }
    _changeMax(event) {
        this._changeValue(event, 'Max');
    }
    _changeValue(event, inputType) {
        const selectedKey = `selected${inputType}`;
        const touchedKey = `touched${inputType}`;
        this.setState({
            [selectedKey]: this._getInputWithoutFormatting(event.currentTarget.value),
            [touchedKey]: true
        });
    }
    _finishChangeMin(event) {
        const selectedMinValue = this._getInputWithoutFormatting(event.currentTarget.value);
        this.setState({
            selectedMin: selectedMinValue,
            minTouched: false
        });
        const minInput = Number(selectedMinValue);
        const { onToggle, parentProductRefinerHierarchy, productRefinerValue, refineItemCommonProps, selectedRefinementCriterion } = this.props;
        const max = selectedRefinementCriterion && selectedRefinementCriterion.RightValueBoundString || undefined;
        const maxNum = max ? Number(max) : undefined;
        if (isNaN(minInput)) {
            this.setState({ validationErrorMin: refineItemCommonProps.validationErrorNaN });
            this._focus('Min');
            return false;
        }
        if (this._validateRange(minInput, maxNum)) {
            onToggle({
                parentProductRefinerHierarchy: parentProductRefinerHierarchy,
                productRefinerValue: productRefinerValue,
                isSelecting: true,
                rangeStart: minInput,
                rangeEnd: maxNum
            });
            return true;
        }
        else {
            this._focus('Min');
        }
        return false;
    }
    _finishChangeMax(event) {
        const selectedMaxValue = this._getInputWithoutFormatting(event.currentTarget.value);
        this.setState({
            selectedMax: selectedMaxValue,
            maxTouched: false
        });
        const maxInput = Number(selectedMaxValue);
        const { onToggle, parentProductRefinerHierarchy, productRefinerValue, refineItemCommonProps, selectedRefinementCriterion } = this.props;
        const min = selectedRefinementCriterion && selectedRefinementCriterion.LeftValueBoundString || '0';
        const minNum = Number(min);
        if (isNaN(maxInput)) {
            this.setState({ validationErrorMax: refineItemCommonProps.validationErrorNaN });
            this._focus('Max');
            return false;
        }
        if (this._validateRange(minNum, maxInput)) {
            if (productRefinerValue) {
                onToggle({
                    parentProductRefinerHierarchy: parentProductRefinerHierarchy,
                    productRefinerValue: productRefinerValue,
                    isSelecting: true,
                    rangeStart: minNum,
                    rangeEnd: maxInput
                });
            }
            else {
                this._focus('Max');
            }
            return true;
        }
        return false;
    }
    _focus(inputType) {
        const ref = inputType === 'Max' ? this.maxInput : this.minInput;
        setTimeout(() => {
            if (ref && ref.current) {
                ref.current.focus();
            }
        }, 50);
    }
    _getFormattedSelectedValue(selected, touched, validationError) {
        if (touched || validationError || selected === undefined) {
            return selected;
        }
        return this._formatPrice(selected);
    }
    _validateRange(min, max) {
        const { refineItemCommonProps } = this.props;
        if (max === undefined) {
            return true;
        }
        if (min > max) {
            this.setState({
                validationErrorMin: refineItemCommonProps.validationErrorRange,
                validationErrorMax: refineItemCommonProps.validationErrorRange
            });
            return false;
        }
        return true;
    }
    _formatPrice(amount) {
        const locale = this.props.refineItemCommonProps.locale;
        const result = formatPrice(amount, this.currencyCode, locale, this.props.refineItemCommonProps.telemetry);
        if (amount !== undefined && !this._formattedPriceReverseLookup.has(result)) {
            this._formattedPriceReverseLookup.set(result, amount);
        }
        return result;
    }
    _getInputWithoutFormatting(input) {
        const inputAsNum = Number(input);
        if (!isNaN(inputAsNum)) {
            return input;
        }
        const reverseLookupResult = this._formattedPriceReverseLookup.get(input);
        return reverseLookupResult || input;
    }
    _onRangeUpdate(sliderChangeNotification) {
        if (sliderChangeNotification.eventType !== 'mousemove') {
            const { onToggle, parentProductRefinerHierarchy, productRefinerValue } = this.props;
            if (productRefinerValue && sliderChangeNotification) {
                onToggle({
                    parentProductRefinerHierarchy: parentProductRefinerHierarchy,
                    productRefinerValue: productRefinerValue,
                    isSelecting: true,
                    rangeStart: sliderChangeNotification.firstThumbValue,
                    rangeEnd: sliderChangeNotification.secondThumbValue
                });
                this._focusOnSliderThumb(sliderChangeNotification);
            }
        }
    }
    _onRangeUpdateEnd(sliderChangeNotification) {
        const { onToggle, parentProductRefinerHierarchy, productRefinerValue } = this.props;
        if (productRefinerValue && sliderChangeNotification) {
            onToggle({
                parentProductRefinerHierarchy: parentProductRefinerHierarchy,
                productRefinerValue: productRefinerValue,
                isSelecting: true,
                rangeStart: sliderChangeNotification.firstThumbValue,
                rangeEnd: sliderChangeNotification.secondThumbValue
            });
            this._focusOnSliderThumb(sliderChangeNotification);
        }
    }
    _focusOnSliderThumb(sliderChangeNotification) {
        if (sliderChangeNotification.id) {
            const element = document.getElementById(`${sliderChangeNotification.id}range`);
            if (!!element) {
                setTimeout(() => {
                    element.focus();
                }, 0);
            }
        }
    }
    _handleRangeTooltipText(tooltip) {
        return this._formatPrice(`${tooltip}`);
    }
};
__decorate([
    computed
], RangeRefineItem.prototype, "currencyCode", null);
RangeRefineItem = __decorate([
    observer
], RangeRefineItem);
export default RangeRefineItem;
//# sourceMappingURL=range-refine-item.js.map
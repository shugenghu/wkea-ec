var SearchResultContainer_1;
import { __decorate } from "tslib";
import { getTelemetryObject, LabeledDropdown, UncontrolledPagination } from '@msdyn365-commerce-modules/utilities';
import MsDyn365 from '@msdyn365-commerce/core';
import { format } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import { computed, observable, reaction, transaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { buildListPageUrl, getCollectionProducts, getCurrentUrl, GetFullProductsByCollectionInput, parseQueryParam, sortOptions, } from './actions';
import { ErrorMessage, FeatureSearchResultItem, getUpdatedRefinementCriteria, isMatchingRefinementCriterion, Link, ModalToggle, ProductSearchResultItems, SearchResultModal, Separator, Title } from './components';
import ChoiceSummary from './components/choice-summary';
import RefineSubmenu from './components/refine-submenu';
let SearchResultContainer = SearchResultContainer_1 = class SearchResultContainer extends React.PureComponent {
    constructor(props, state) {
        super(props);
        this.sortByDropdownOptions = [
            { key: sortOptions.sortByOptionRelevanceDesc, value: this.props.resources.sortByOptionRelevanceDesc },
            { key: sortOptions.sortByOptionNameAsc, value: this.props.resources.sortByOptionNameAsc },
            { key: sortOptions.sortByOptionNameDesc, value: this.props.resources.sortByOptionNameDesc },
            { key: sortOptions.sortByOptionPriceAsc, value: this.props.resources.sortByOptionPriceAsc },
            { key: sortOptions.sortByOptionPriceDesc, value: this.props.resources.sortByOptionPriceDesc },
            { key: sortOptions.sortByOptionRatingDesc, value: this.props.resources.sortByOptionRatingDesc },
        ];
        this._pageType = this.props.context.request.urlTokens.pageType;
        this.expandrefinerCount = 0;
        this._getSearchResultModal = () => {
            const { resources } = this.props;
            return SearchResultModal({
                resources: {
                    modalCloseButtonText: resources.modalCloseButtonText,
                    modalTitle: resources.modalTitle
                },
                isOpen: this.state.modalIsOpen,
                returnRef: this._modalToggleRef,
                onModalToggle: this._toggleModal
            });
        };
        this._getCollectionTitle = () => {
            const { data, context, resources } = this.props;
            let collectionTitle = '';
            if (context && context.request && context.request.query && context.request.query.q) {
                collectionTitle = `"${context.request.query.q}"`;
            }
            else {
                collectionTitle = (data.category.result && SearchResultContainer_1.getFriendlyName(context.request.locale, data.category.result.NameTranslations)) ||
                    (data.category.result && data.category.result.Name);
            }
            let productCountText = '';
            let productCountNumber;
            if (data.listPageState && data.listPageState.result && data.listPageState.result.totalProductCount !== undefined) {
                productCountNumber = data.listPageState.result.totalProductCount;
            }
            else if (data.products && data.products.result) {
                productCountNumber = data.products.result.count;
            }
            if (productCountNumber && productCountNumber !== 0) {
                productCountText = productCountNumber !== 1 ? format(this.props.resources.numberOfProducts, productCountNumber) : this.props.resources.oneProduct;
            }
            else {
                productCountText = format(this.props.resources.numberOfProducts, 0);
            }
            const titlePrefix = React.createElement(Title, { className: 'ms-search-result__collection-title-prefix', text: resources.searchTextPrefix });
            const titleText = collectionTitle && React.createElement(Title, { className: 'ms-search-result__collection-title-text', text: collectionTitle });
            const titleCount = React.createElement(Title, { className: 'ms-search-result__collection-title-count', text: productCountText });
            return {
                TitleContainer: { className: 'ms-search-result-container__title' },
                title: {
                    titlePrefix: titlePrefix,
                    titleText: titleText,
                    titleCount: titleCount
                }
            };
        };
        this._getCategoryHierarchy = () => {
            const { data } = this.props;
            const categoryHierarchy = data.categoryHierarchy.result;
            const categoryLinks = categoryHierarchy && categoryHierarchy.map((value, index) => {
                return (React.createElement(Link, { key: index, text: value.Name, ariaLabel: `${this.props.resources.categoryLinkAriaLabel} ${value.Name}`, href: value.Url }));
            });
            const categoryLinkSeparator = React.createElement(Separator, { separator: '/' });
            return {
                CategoryHierarchyContainer: { tag: 'nav', className: 'ms-search-result-container__category-hierarchy' },
                categoryHierarchyList: categoryLinks,
                categoryHierarchySeparator: categoryLinkSeparator
            };
        };
        this._getSortingDropDown = () => {
            const { resources } = this.props;
            const activeDropdown = this._getCurrentlySelectedOption() || this.state.sortingState.selectedSortByOption;
            const dropdown = (React.createElement(LabeledDropdown, { labelClassname: 'reviews-list-sort-by', labelText: resources.sortByDropdownLabel, dropdownId: 'categorySortByDropdown', dropdownClassname: 'reviews-list-dropdown', toggleColor: 'link', dropdownOptions: this.sortByDropdownOptions, selectedOption: activeDropdown, onSelectOption: this._updateSortByDropdown, ref: this._sortAndFilterContainerRef }));
            return {
                SortingContainer: { className: 'ms-search-result-container__Sort-by-category' },
                sortByDropDown: dropdown
            };
        };
        this._getPagination = () => {
            const { config, context, data, resources } = this.props;
            const listPageState = data && data.listPageState && data.listPageState.result;
            const fullUrl = getCurrentUrl(context.request);
            const itemsPerPage = config.itemsPerPage || 10;
            const skipCount = listPageState && listPageState.currentPageNumber !== null ?
                (listPageState.currentPageNumber * (this.props.config.itemsPerPage || 10)) :
                ((this.props.context.request.query && +this.props.context.request.query.skip) || 0);
            const totalItems = listPageState && listPageState.totalProductCount || 0;
            const previousText = resources.flipperPrevious;
            const nextText = resources.flipperNext;
            if (totalItems <= itemsPerPage) {
                return null;
            }
            return (React.createElement(UncontrolledPagination, { className: 'ms-search-result-container__pagination', role: 'navigation', "aria-label": resources.paginationAriaLabel, url: fullUrl.href, qsp: 'skip', items: totalItems, itemsPerPage: itemsPerPage, startingItem: skipCount, previousText: React.createElement("div", { className: 'msc-pagination__prev' },
                    React.createElement("span", { className: 'ms-search-result__pagination-left', "aria-hidden": 'true' }),
                    React.createElement("span", { className: 'prev-text' }, previousText)), nextText: React.createElement("div", { className: 'msc-pagination__next' },
                    React.createElement("span", { className: 'next-text' }, nextText),
                    React.createElement("span", { className: 'ms-search-result__pagination-right', "aria-hidden": 'true' })), previousAriaLabel: previousText, nextAriaLabel: nextText, telemetryContent: this.telemetryContent }));
        };
        this._getRefineMenu = () => {
            const { data, context, config } = this.props;
            const tempRangeTypeTODO = context.request.query && context.request.query.inputRange ? 'input' : 'slider';
            const validRefiners = data.refiners.result && data.refiners.result.filter(refiner => {
                return refiner.Values.length > 0;
            });
            const activeRefiners = (data.listPageState.result && data.listPageState.result.activeFilters) || [];
            this._getexpandRefinerCount(config.expandRefinersCount);
            const refinelist = this.expandrefinerCount === undefined ? 0 : this.expandrefinerCount;
            const expandedRefiners = refinelist === 0 ? validRefiners && validRefiners.length : refinelist;
            const subMenus = validRefiners && validRefiners.map((productRefinerHierarchy, index) => {
                return (data.listPageState.result.totalProductCount !== 0 ?
                    (React.createElement(RefineSubmenu, { productRefinerHierarchy: productRefinerHierarchy, selectedRefinerValues: activeRefiners, refineItemCommonProps: this._refineItemCommonProps, minValueSliderThumbAriaLabel: this.props.resources.minValueSliderThumbAriaLabel, maxValueSliderThumbAriaLabel: this.props.resources.maxValueSliderThumbAriaLabel, key: index, onUpdateRefiners: this._onUpdateRefiners, urlBuilder: this._buildRefinerUrl, isDisabled: false, isExpandedOnInitialLoad: expandedRefiners && expandedRefiners > index ? true : false, tempRangeTypeTODO: tempRangeTypeTODO, context: context, moduleId: this.props.id, moduleTypeName: this.props.typeName, telemetryContent: this.telemetryContent })) : null);
            });
            return {
                RefineMenuContainer: { className: 'ms-search-result-container__refine-menu' },
                RefinerSectionContainer: { className: 'ms-search-result-container__refiner-section' },
                refiners: subMenus
            };
        };
        this._getChoiceSummary = () => {
            const { resources, data, telemetry } = this.props;
            const selectedRefiners = (data.listPageState.result && data.listPageState.result.activeFilters) || [];
            return (React.createElement(ChoiceSummary, { classNames: 'ms-choice-summary-by-category', clearAllText: resources.clearAllText, label: resources.choiceSummaryLabel, selectedChoices: selectedRefiners, refinerHierarchy: data.refiners.result, choiceFormat: resources.choiceFormat, choiceRangeValueFormat: resources.choiceRangeValueFormat, telemetry: telemetry, onChoiceClicked: this._onChoiceClicked, urlBuilder: this._buildRefinerUrlForChoiceSummary, choiceAriaLabel: resources.choiceAriaLabel, telemetryContent: this.telemetryContent }));
        };
        this._updateSortByDropdown = (notification) => {
            const { context } = this.props;
            const requestContext = context && context.request;
            const actionContext = context && context.actionContext;
            if (!requestContext || !actionContext || !this.props.data.listPageState.result) {
                const error = `[sort-by-category] cannot sort without context: ${!requestContext ? 'requestContext ' : ''} ${!actionContext ? 'actionContext ' : ''} could not be found`;
                this.props.telemetry.warning(error);
            }
            window.history.pushState({}, '', buildListPageUrl(getCurrentUrl(this.props.context.request), undefined, [this._getSortColumnFromSelectedOption(notification.selectedOption)], undefined));
            transaction(() => {
                this.props.data.listPageState.result.currentPageNumber = 0;
                this.props.data.listPageState.result.sortingCritera = { Columns: [this._getSortColumnFromSelectedOption(notification.selectedOption)] };
            });
        };
        this._getSortColumnFromSelectedOption = (option) => {
            const { data } = this.props;
            if (!data.searchConfiguration.result) {
                return {};
            }
            const mappedConfiguration = data.searchConfiguration.result.find((searchConfiguration) => { return searchConfiguration.key === option.key; });
            if (mappedConfiguration) {
                return mappedConfiguration.sortColumn;
            }
            return {};
        };
        this._getCurrentlySelectedOption = () => {
            const { data } = this.props;
            const sortCriteria = data.listPageState.result && data.listPageState.result.sortingCritera;
            const activeSortColumn = (sortCriteria && sortCriteria.Columns && sortCriteria.Columns[0]) ||
                (parseQueryParam('sorting', this.props.context.request) || [])[0];
            if (activeSortColumn && data.searchConfiguration.result) {
                const activeMappedConfig = data.searchConfiguration.result.find((mappedSearchConfig) => {
                    return (mappedSearchConfig.sortColumn.ColumnName === activeSortColumn.ColumnName) &&
                        (mappedSearchConfig.sortColumn.IsDescending === activeSortColumn.IsDescending);
                });
                if (activeMappedConfig) {
                    return this.sortByDropdownOptions.find((dropdownOption) => dropdownOption.key === activeMappedConfig.key);
                }
            }
            return;
        };
        this._onUpdateRefiners = (itemToggleNotification) => {
            const { context } = this.props;
            const requestContext = context && context.request;
            const actionContext = context && context.actionContext;
            if (!requestContext || !actionContext || !this.props.data.listPageState.result) {
                const error = `Refine menu cannot refine search criteria: ${!requestContext ? 'requestContext ' : ''} ${!actionContext ? 'actionContext ' : ''} could not be found`;
                this.props.telemetry.warning(error);
            }
            const updatedRefinementCriteria = getUpdatedRefinementCriteria(itemToggleNotification, this.props.data.listPageState.result && this.props.data.listPageState.result.activeFilters || []);
            window.history.pushState({}, '', buildListPageUrl(getCurrentUrl(this.props.context.request), updatedRefinementCriteria));
            transaction(() => {
                this.props.data.listPageState.result.currentPageNumber = 0;
                this.props.data.listPageState.result.activeFilters = updatedRefinementCriteria;
            });
        };
        this._buildRefinerUrl = (itemToggleNotification) => {
            if (this.props.data.listPageState.result) {
                const newRefinementCriteria = getUpdatedRefinementCriteria(itemToggleNotification, this.props.data.listPageState.result.activeFilters || []);
                return buildListPageUrl(getCurrentUrl(this.props.context.request), newRefinementCriteria);
            }
            else {
                this.props.telemetry.warning(`[buildRefinerQueryString]List Page State Not available, unable to build refiner URL`);
                return '';
            }
        };
        this._onChoiceClicked = (notification) => {
            const { data, telemetry } = this.props;
            if (!data.listPageState.result) {
                telemetry.warning('[choice-summary-by-category._onChoiceClicked]ListPageState unavailable, unable to update refiners.');
                return;
            }
            let currentRefinementCriteria = (data.listPageState.result && data.listPageState.result.activeFilters) || [];
            if (!notification.clearAll) {
                const selectedChoice = notification.choiceClicked;
                if (!selectedChoice) {
                    telemetry.warning('[choice-summary-by-category._onChoiceClicked] Choice could not be determined');
                    return;
                }
                currentRefinementCriteria = currentRefinementCriteria.filter((selectedCriterion) => !isMatchingRefinementCriterion(selectedChoice, selectedCriterion));
            }
            else {
                currentRefinementCriteria = [];
                const dropdownElementId = this._sortAndFilterContainerRef.current && this._sortAndFilterContainerRef.current.props.dropdownId;
                const dropdownElement = dropdownElementId && document.getElementById(dropdownElementId);
                setTimeout(() => {
                    dropdownElement && dropdownElement.focus();
                }, 50);
            }
            const fullUrl = getCurrentUrl(this.props.context.request);
            window.history.pushState({}, '', buildListPageUrl(fullUrl, currentRefinementCriteria));
            data.listPageState.result.currentPageNumber = 0;
            data.listPageState.result.activeFilters = currentRefinementCriteria;
        };
        this._buildRefinerUrlForChoiceSummary = (selectedRefiner, isClearAll) => {
            const { data, telemetry } = this.props;
            const fullUrl = getCurrentUrl(this.props.context.request);
            if (!data.listPageState.result) {
                telemetry.warning('[choice-summary-by-category._buildRefinerUrl]ListPageState unavailable, unable to create refiner URL.');
                return fullUrl.href;
            }
            let currentRefinementCriteria = (data.listPageState.result && data.listPageState.result.activeFilters) || [];
            if (!isClearAll) {
                if (!selectedRefiner) {
                    telemetry.warning('[choice-summary-by-category._buildRefinerUrl] URL for Choice could not be determined');
                    return fullUrl.href;
                }
                currentRefinementCriteria = currentRefinementCriteria.filter((selectedCriterion) => !isMatchingRefinementCriterion(selectedRefiner, selectedCriterion));
            }
            else {
                currentRefinementCriteria = [];
            }
            return buildListPageUrl(fullUrl, currentRefinementCriteria);
        };
        this._getexpandRefinerCount = (refinerCount) => {
            switch (refinerCount) {
                case "all":
                    this.expandrefinerCount = 0;
                    break;
                case "one":
                    this.expandrefinerCount = 1;
                    break;
                case "two":
                    this.expandrefinerCount = 2;
                    break;
                case "three":
                    this.expandrefinerCount = 3;
                    break;
                case "four":
                    this.expandrefinerCount = 4;
                    break;
                default:
                    this.expandrefinerCount = 0;
            }
        };
        this._viewport = props.context.request && props.context.request.device && props.context.request.device.Type === 'Mobile' ? 'xs' : 'lg';
        this._modalToggleRef = React.createRef();
        this._sortAndFilterContainerRef = React.createRef();
        this._toggleModal = this._toggleModal.bind(this);
        this._updateViewport = this._updateViewport.bind(this);
        this.state = {
            sortingState: {
                pending: false,
                selectedSortByOption: this.sortByDropdownOptions[0]
            },
            modalIsOpen: false
        };
        const { placeholderTextMax, minLabel, maxLabel, rangeNameFormat } = this.props.resources;
        const locale = this.props.context.request.locale;
        const telemetry = this.props.telemetry;
        const validationErrorNaN = this.props.resources.validationErrorNotNumber;
        const validationErrorRange = this.props.resources.validationErrorNotRange;
        this._refineItemCommonProps = {
            telemetry,
            locale,
            placeholderTextMax,
            minLabel,
            maxLabel,
            rangeNameFormat,
            validationErrorNaN,
            validationErrorRange
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
        this.props.data.products.then((products) => {
            this.props.data.listPageState.then((listPageState) => {
                if (this._pageType === 'Category') {
                    listPageState.pageType = 'Category';
                }
                else {
                    listPageState.pageType = 'Search';
                }
                let querySorting = [];
                if (this.props.context.request.query && this.props.context.request.query.sorting) {
                    querySorting = JSON.parse(decodeURIComponent(this.props.context.request.query.sorting));
                }
                listPageState.currentPageNumber = this.props.context.request.query && (+this.props.context.request.query.skip / (this.props.config.itemsPerPage || 10)) || 0;
                listPageState.sortingCritera = { Columns: querySorting };
                listPageState.pageSize = this.props.config.itemsPerPage || 10;
                listPageState.activeProducts = products.products;
                listPageState.totalProductCount = products.count;
                reaction(() => {
                    return [listPageState.activeFilters && listPageState.activeFilters.length, listPageState.currentPageNumber, listPageState.sortingCritera && listPageState.sortingCritera.Columns && listPageState.sortingCritera.Columns.length];
                }, () => {
                    const input = new GetFullProductsByCollectionInput(listPageState.pageType, this.props.context.request.apiSettings, { Paging: { Top: this.props.config.itemsPerPage, Skip: Math.max((listPageState.pageSize * (listPageState.currentPageNumber || 0)), 0) }, count: true, Sorting: listPageState.sortingCritera || {} }, listPageState.activeFilters || [], +(this.props.context.request.urlTokens.itemId || 0), this.props.context.request.query && this.props.context.request.query.q ? this.props.context.request.query.q : this.props.context.request.query?.productId, this.props && this.props.config && this.props.config.includeAttributes !== undefined && this.props.config.includeAttributes === true ? true : false, this.props.context.request.locale);
                    getCollectionProducts(input, this.props.context.actionContext).then(productResults => {
                        listPageState.activeProducts = productResults.products;
                        listPageState.totalProductCount = productResults.count;
                    });
                });
            });
        });
        if (this.props.context.request.query?.productId) {
            this.props.data.featureProduct.then((products) => {
                this.props.data.listPageState.then((listPageStateFeature) => {
                    listPageStateFeature.featureProduct = products;
                });
            });
        }
        this._updateViewport();
    }
    get isMobile() {
        return (this._viewport === 'xs' || this._viewport === 'sm');
    }
    static getFriendlyName(locale, nameTranslations) {
        let nameTranslation;
        if (locale && nameTranslations && nameTranslations.length > 0) {
            nameTranslation = nameTranslations.find(item => item.Language.toLowerCase() === locale.toLowerCase());
        }
        return nameTranslation && nameTranslation.Text;
    }
    componentDidMount() {
        if (MsDyn365.isBrowser && window.addEventListener) {
            window.addEventListener('resize', this._updateViewport);
            this._updateViewport();
        }
    }
    componentWillUnmount() {
        if (MsDyn365.isBrowser && window.removeEventListener) {
            window.removeEventListener('resize', this._updateViewport);
        }
    }
    render() {
        const { imageSettings, className, allowBackNavigation } = this.props.config;
        const { resources } = this.props;
        const products = (this.props.data.listPageState.result && this.props.data.listPageState.result.activeProducts) || [];
        const searchProduct = (this.props.data.listPageState.result && this.props.data.listPageState.result.featureProduct) || null;
        let errorText = '';
        const breaCrumbType = this.props.context.app.config.breadcrumbType;
        const allowBack = allowBackNavigation && (breaCrumbType === 'back' || breaCrumbType === 'categoryAndBack');
        if (!products || products.length === 0) {
            errorText = this._pageType === 'Category' ? resources.resultCategoryNotFoundText : resources.resultSearchNotFoundText;
        }
        const productsComponent = (React.createElement(ProductSearchResultItems, { products: products, context: this.props.context, imageSettings: imageSettings, resources: resources, moduleType: this.props.typeName, moduleId: this.props.id, allowBackNavigation: allowBack, telemetryContent: this.telemetryContent }));
        const featureComponent = (React.createElement(FeatureSearchResultItem, { product: searchProduct, context: this.props.context, imageSettings: imageSettings, resources: resources, moduleType: this.props.typeName, moduleId: this.props.id, telemetryContent: this.telemetryContent }));
        const searchResultContainerViewProps = {
            ...this.props,
            products: productsComponent,
            TitleViewProps: this._getCollectionTitle(),
            categoryHierarchy: !this.props.config.disableHierarchy && this._getCategoryHierarchy(),
            refineMenu: this._getRefineMenu(),
            className: classnames('ms-search-result-container', className),
            SearchResultContainer: {
                moduleProps: this.props,
                className: classnames('ms-search-result-container', className)
            },
            sortByOptions: this.props.data.listPageState.result && this.props.data.listPageState.result.totalProductCount !== 0 ? this._getSortingDropDown() : null,
            pagination: this._getPagination(),
            ProductsContainer: { className: 'ms-search-result-container__Products' },
            ProductSectionContainer: { className: 'ms-search-result-container__product-section' },
            CategoryNavContainer: { className: 'ms-search-result-container__category-nav-section' },
            RefineAndProductSectionContainer: { className: 'ms-search-result-container__refine-product-section' },
            choiceSummary: this._getChoiceSummary(),
            modalToggle: this.props.data.listPageState.result && this.props.data.listPageState.result.totalProductCount !== 0 ?
                (React.createElement(ModalToggle, { text: resources.modalTitle, ariaLabel: resources.modalTitle, innerRef: this._modalToggleRef, onClick: this._toggleModal, id: 'search-result-modal' })) : null,
            searchResultModal: this._getSearchResultModal(),
            isMobile: this.isMobile,
            errorMessage: errorText && (React.createElement(ErrorMessage, { text: errorText })),
            FeatureSearchContainer: { className: 'ms-feature-search-result' },
            similarLookProduct: this.props.data.listPageState.result && (this.props.data.listPageState.result.featureProduct !== null && this.props.data.listPageState.result.featureProduct !== undefined) ? featureComponent : null
        };
        return this.props.renderView(searchResultContainerViewProps);
    }
    _getViewport() {
        const { context } = this.props;
        if (context.request && context.request.device && context.request.device.Type === 'Mobile') {
            return 'xs';
        }
        if (MsDyn365.isBrowser && window.innerWidth) {
            const gridSettings = context.request.gridSettings;
            if (gridSettings) {
                if (gridSettings.xs && window.innerWidth <= gridSettings.xs.w) {
                    return 'xs';
                }
                else if (gridSettings.sm && window.innerWidth <= gridSettings.sm.w) {
                    return 'sm';
                }
                else if (gridSettings.md && window.innerWidth <= gridSettings.md.w) {
                    return 'md';
                }
                else if (gridSettings.lg && window.innerWidth <= gridSettings.lg.w) {
                    return 'lg';
                }
                else {
                    return 'xl';
                }
            }
        }
        return 'lg';
    }
    _toggleModal() {
        this.setState({
            modalIsOpen: !this.state.modalIsOpen
        });
    }
    _updateViewport() {
        this._viewport = this._getViewport();
        if (this.state.modalIsOpen && !this.isMobile) {
            this._toggleModal();
        }
    }
};
__decorate([
    computed
], SearchResultContainer.prototype, "isMobile", null);
__decorate([
    observable
], SearchResultContainer.prototype, "_viewport", void 0);
SearchResultContainer = SearchResultContainer_1 = __decorate([
    observer
], SearchResultContainer);
export default SearchResultContainer;
//# sourceMappingURL=search-result-container.js.map
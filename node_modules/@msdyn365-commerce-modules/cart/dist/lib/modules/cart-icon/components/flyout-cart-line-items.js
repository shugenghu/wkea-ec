import { getProductUrlSync } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, TelemetryConstant } from '@msdyn365-commerce-modules/utilities';
import { CartLineItemComponent } from '@msdyn365-commerce/components';
import * as React from 'react';
const _getProduct = (productId, products) => {
    if (productId !== undefined && products) {
        return products.find(product => {
            return productId === product.RecordId;
        });
    }
    return undefined;
};
const _getCartItemMaxQuantity = (outOfStockThreshold, maxCartlineQuantity, isStockCheckEnabled, productAvailability) => {
    if (isStockCheckEnabled) {
        if (!productAvailability || !productAvailability.AvailableQuantity || productAvailability.AvailableQuantity <= 0 || productAvailability.AvailableQuantity <= outOfStockThreshold) {
            return 0;
        }
        return productAvailability.AvailableQuantity - outOfStockThreshold;
    }
    return maxCartlineQuantity;
};
const _assembleNode = (cartline, product, props, index, foundProductAvailability, foundProductDeliveryOptions) => {
    const { imageSettings, gridSettings, id, typeName, context, resources, removeButtonText, removeItemClickHandler } = props;
    const maxQuantity = _getCartItemMaxQuantity(props.outOfStockThreshold, props.maxCartlineQuantity, props.isStockCheckEnabled, foundProductAvailability);
    const PRODUCTASSERVICE = 2;
    const isServiceItem = product.ItemTypeValue === PRODUCTASSERVICE;
    const onRemoveClickHandler = (event) => { removeItemClickHandler(cartline); };
    const payLoad = getPayloadObject('click', props.telemetryContent, TelemetryConstant.RemoveCartItem);
    const removeCartItemAttribute = getTelemetryAttributes(props.telemetryContent, payLoad);
    return {
        data: {
            product: product,
            cartline: cartline
        },
        hasError: (!isServiceItem && props.isStockCheckEnabled) ? cartline.Quantity > maxQuantity : false,
        cartline: (React.createElement(CartLineItemComponent, { data: {
                cartLine: cartline,
                product: product
            }, currentQuantity: cartline.Quantity, maxQuantity: maxQuantity, isOutOfStock: (!isServiceItem && props.isStockCheckEnabled) ? (maxQuantity <= 0 ? true : false) : false, gridSettings: gridSettings, imageSettings: imageSettings, id: id, typeName: typeName, productUrl: getProductUrlSync(product, props.context.actionContext, undefined), context: context, resources: resources, key: index, isQuantityEditable: false, primaryImageUrl: product.PrimaryImageUrl, displayMode: 'COMPACT', telemetryContent: props.telemetryContent })),
        remove: (React.createElement(Button, Object.assign({ className: 'msc-cart-line__remove-item', onClick: onRemoveClickHandler, title: removeButtonText }, removeCartItemAttribute), removeButtonText)),
        storeLocation: (_renderStoreLocation(cartline, props))
    };
};
const _renderStoreLocation = (cartLine, props) => {
    if (cartLine && cartLine.FulfillmentStoreId) {
        const orgUnitName = _getOrgUnitName(cartLine.FulfillmentStoreId, props.orgUnitLocations);
        if (orgUnitName) {
            return (React.createElement("div", { className: `msc-cart-line__bopis-method` },
                React.createElement("span", { className: `pick-up` }, orgUnitName)));
        }
    }
    return null;
};
const _getOrgUnitName = (fulfillmentStoreId, orgUnitLocations) => {
    if (!orgUnitLocations || !fulfillmentStoreId || !(orgUnitLocations.length > 0)) {
        return '';
    }
    const foundLocation = orgUnitLocations.find(orgUnitLocation => {
        return orgUnitLocation.OrgUnitNumber === fulfillmentStoreId;
    });
    if (foundLocation) {
        return foundLocation.OrgUnitName;
    }
    else {
        return fulfillmentStoreId;
    }
};
const _assembleCartlines = (cartlines, products, props) => {
    const reactNodes = [];
    if (!products || products.length === 0) {
        props.context.telemetry.error('Cartlines content is empty, module wont render');
        return null;
    }
    cartlines.map((cartline, index) => {
        const product = _getProduct(cartline.ProductId, products);
        let foundProductAvailability;
        if (props.productAvailabilites && props.productAvailabilites.length > 0) {
            foundProductAvailability = props.productAvailabilites.find((productAvailability) => {
                return productAvailability.ProductAvailableQuantity?.ProductId === cartline.ProductId;
            });
        }
        let foundProductDeliveryOption;
        if (props.productDeliveryOptions && props.productDeliveryOptions.length > 0) {
            foundProductDeliveryOption = props.productDeliveryOptions.find((deliveryOption) => {
                return deliveryOption && deliveryOption.ProductId === cartline.ProductId;
            });
        }
        if (product) {
            reactNodes.push(_assembleNode(cartline, product, props, index, foundProductAvailability?.ProductAvailableQuantity, foundProductDeliveryOption));
        }
    });
    return reactNodes;
};
export const FlyoutCartLineItems = (props) => {
    const { products, cartlines } = props;
    return (_assembleCartlines(cartlines, products, props));
};
//# sourceMappingURL=flyout-cart-line-items.js.map
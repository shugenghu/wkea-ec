import { getProductUrlSync } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes } from '@msdyn365-commerce-modules/utilities';
import { AddToOrderTemplateComponent, AddToWishlistComponent, CartLineItemComponent } from '@msdyn365-commerce/components';
import { TelemetryEvent } from '@msdyn365-commerce/core';
import * as React from 'react';
import { PickUpInStore } from './cart-pick-up-in-store';
const _getProduct = (productId, products) => {
    if (productId !== undefined && products) {
        return products.find(product => {
            return productId === product.RecordId;
        });
    }
    return undefined;
};
const _getCartItemMaxQuantity = (maxCartlineQuantity, isStockCheckEnabled, productAvailability) => {
    if (isStockCheckEnabled) {
        if (!productAvailability || !productAvailability.ProductAvailableQuantity || !productAvailability.IsProductAvailable || !productAvailability.ProductAvailableQuantity.AvailableQuantity) {
            return 0;
        }
        return productAvailability.ProductAvailableQuantity.AvailableQuantity >= maxCartlineQuantity ? maxCartlineQuantity : productAvailability.ProductAvailableQuantity.AvailableQuantity;
    }
    return maxCartlineQuantity;
};
const _getErrorMessage = (maxQuantity, currentQuantity, props) => {
    if (maxQuantity <= 0) {
        return props.outOfStockText;
    }
    else if (maxQuantity < currentQuantity) {
        if (maxQuantity === 1) {
            return props.outOfRangeOneText;
        }
        else {
            return props.outOfRangeFormatText.replace('{numLeft}', maxQuantity.toString());
        }
    }
    return undefined;
};
const _assembleNode = (cartline, product, props, index, foundProductAvailability, foundProductDeliveryOptions) => {
    const { imageSettings, gridSettings, id, typeName, context, resources, removeButtonText, removeItemClickHandler, moveToWishlistSuccessHandler, addToOrderTemplateButtonText, addToOrderTemplateDialogResources, createOrderTemplateDialogResources, itemAddedToOrderTemplateDialogResources, duplicateItemsWhenAddingToOrderTemplateDialogResources, addToWishlistButtonText, removeFromWishlistButtonText, orderTemplates, customerInformation, wishlists, defaultWishlistName } = props;
    const isAuthenticated = context.request.user.isAuthenticated;
    const nameOfWishlist = wishlists && wishlists.length > 0 && wishlists[0].Name ? wishlists[0].Name : defaultWishlistName;
    const maxQuantity = _getCartItemMaxQuantity(props.maxCartlineQuantity, props.isStockCheckEnabled, foundProductAvailability);
    const PRODUCTASSERVICE = 2;
    const isServiceItem = product.ItemTypeValue === PRODUCTASSERVICE;
    const errorMessage = props.includeErrors && !isServiceItem && props.isStockCheckEnabled ? _getErrorMessage(maxQuantity, cartline.Quantity, props) : undefined;
    const onRemoveClickHandler = (event) => { removeItemClickHandler(cartline); };
    const payload = getPayloadObject(TelemetryEvent.RemoveFromCart, props.telemetryContent, removeButtonText, '');
    const attributes = getTelemetryAttributes(props.telemetryContent, payload);
    const inventoryLbl = foundProductAvailability?.StockLevelLabel;
    const inventoryCode = foundProductAvailability ? `ms-cart-line__inventory-code-${foundProductAvailability.StockLevelCode?.toLowerCase()}` : undefined;
    return {
        data: {
            product: product,
            cartline: cartline
        },
        error: errorMessage,
        cartline: (React.createElement(CartLineItemComponent, { data: {
                cartLine: cartline,
                product: product
            }, currentQuantity: cartline.Quantity, maxQuantity: maxQuantity, isOutOfStock: (!isServiceItem && props.isStockCheckEnabled) ? (maxQuantity <= 0 ? true : false) : false, gridSettings: gridSettings, imageSettings: imageSettings, id: id, typeName: typeName, productUrl: getProductUrlSync(product, props.context.actionContext, undefined), context: context, resources: resources, key: index, isQuantityEditable: true, quantityOnChange: props.updateCartLinesQuantitySuccessHandler, primaryImageUrl: product.PrimaryImageUrl, errorMessage: errorMessage, inventoryInformationLabel: inventoryLbl, inventoryLabelClassName: inventoryCode, isCartStateReady: props.cartState?.status === 'READY', showShippingChargesForLineItems: props.showShippingChargesForLineItems, telemetryContent: props.telemetryContent })),
        pickUpInStore: (PickUpInStore({
            cartState: props.cartState,
            cartline: cartline,
            product: product,
            shipitText: props.shipItText,
            pickUpInStoreText: props.pickitUpText,
            changeStoreText: props.changeStoreText,
            storeSelectorStateManager: props.storeSelectorStateManager,
            orgUnitLocations: props.orgUnitLocations,
            deliveryOptions: foundProductDeliveryOptions,
            pickupDeliveryModeCode: props.pickupDeliveryModeCode,
        })),
        remove: (React.createElement(Button, Object.assign({ className: 'msc-cart-line__remove-item', onClick: onRemoveClickHandler, title: removeButtonText }, attributes), removeButtonText)),
        addToWishlist: (isAuthenticated ? (React.createElement(AddToWishlistComponent, { className: 'msc-cart-line__add-to-wishlist', addToWishlistButtonText: addToWishlistButtonText, removeFromWishlistButtonText: removeFromWishlistButtonText, context: context, id: id, key: cartline.LineId, typeName: typeName, nameOfWishlist: nameOfWishlist, cartline: cartline, showButtonText: true, showStatusMessage: false, showRemoveButton: false, showButtonTooltip: false, data: {
                wishlists: wishlists,
                product: product
            }, onSuccess: moveToWishlistSuccessHandler })) :
            undefined),
        addToOrderTemplate: (isAuthenticated && orderTemplates ? (React.createElement(AddToOrderTemplateComponent, { className: 'msc-cart-line__add-to-order-template', addToOrderTemplateButtonText: addToOrderTemplateButtonText, addToOrderTemplateDialogResources: addToOrderTemplateDialogResources, createOrderTemplateDialogResources: createOrderTemplateDialogResources, itemAddedToOrderTemplateDialogResources: itemAddedToOrderTemplateDialogResources, duplicateItemsWhenAddingToOrderTemplateDialogResources: duplicateItemsWhenAddingToOrderTemplateDialogResources, data: { product: product, quantity: cartline.Quantity || 1, orderTemplates: orderTemplates, customerInformation: customerInformation }, context: context, showButtonText: true, showButtonTooltip: false, id: id, typeName: typeName })) :
            undefined)
    };
};
const _assembleCartlines = (cartlines, products, props) => {
    const reactNodes = [];
    if (!products || products.length === 0) {
        props.context.telemetry.error('Products content is empty, module wont render');
        return null;
    }
    cartlines.map((cartline, index) => {
        const product = _getProduct(cartline.ProductId, products);
        let foundProductAvailability;
        if (props.productAvailabilites && props.productAvailabilites.length > 0) {
            foundProductAvailability = props.productAvailabilites.find((productAvailability) => {
                return productAvailability.ProductAvailableQuantity?.ProductId === cartline.ProductId;
            });
        }
        let foundProductDeliveryOption;
        if (props.productDeliveryOptions && props.productDeliveryOptions.length > 0) {
            foundProductDeliveryOption = props.productDeliveryOptions.find((deliveryOption) => {
                return deliveryOption && deliveryOption.ProductId === cartline.ProductId;
            });
        }
        if (product) {
            reactNodes.push(_assembleNode(cartline, product, props, index, foundProductAvailability, foundProductDeliveryOption));
        }
    });
    return reactNodes;
};
export const CartLineItems = (props) => {
    const { products, cartlines } = props;
    return (_assembleCartlines(cartlines, products, props));
};
//# sourceMappingURL=cart-line-items.js.map
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, INodeProps, ITelemetryContent, TelemetryConstant, UncontrolledTooltip } from '@msdyn365-commerce-modules/utilities';
import { CartIconComponent } from '@msdyn365-commerce/components';
import { getUrlSync, IDictionary, IImageSettings, msdyn365Commerce, TelemetryEvent } from '@msdyn365-commerce/core';
import { CartLine, OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import React from 'react';
import { ICartIconData } from './cart-icon.data';
import { ICartIconProps } from './cart-icon.props.autogenerated';
import { FlyoutCartLineItems, IFlyoutCartLineItemViewProps } from './components/flyout-cart-line-items';
import { getMiniCartData, IMiniCartData } from './utils/get-products-in-mini-cart';

export interface IMiniCartState {
    miniCartData: IMiniCartData;
    orgUnitLocations?: OrgUnitLocation[];
}

export interface ICartIconViewProps extends ICartIconProps<ICartIconData> {
    className: string;
    cartIcon: React.ReactNode;

    FlyoutContainer?: INodeProps;

    CartlinesWrapper: INodeProps;
    miniCartWrapper: INodeProps;
    miniCartItemWrapper: INodeProps;
    cartlines?: IFlyoutCartLineItemViewProps[];
    flyoutTitle: React.ReactNode;
    totalPrice: React.ReactNode;

    checkoutAsGuestButton?: React.ReactNode;
    checkoutAsSignInUserButton?: React.ReactNode;
    goToCartButton?: React.ReactNode;
    waitingComponent?: React.ReactNode;

    isCartLoading: boolean;

    removeItemClickHandler(cartlineToRemove: CartLine): void;
}

/**
 *
 * Cart component
 * @extends {React.PureComponent<ICartProps<ICartData>>}
 */
@observer
class CartIcon extends React.Component<ICartIconProps<ICartIconData>, IMiniCartState> {
    private telemetryContent: ITelemetryContent;
    private checkoutBySignInAttributes: IDictionary<string> | undefined;
    private checkoutByGuestAttributes: IDictionary<string> | undefined;
    private viewShoppingBagAttributes: IDictionary<string> | undefined;
    constructor(props: ICartIconProps<ICartIconData>) {
        super(props);
        this.state = { miniCartData: {} };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
        const payload = getPayloadObject(TelemetryEvent.CheckOut, this.telemetryContent, TelemetryConstant.Checkout);
        this.checkoutBySignInAttributes = getTelemetryAttributes(this.telemetryContent, payload);

        payload.contentAction.etext = TelemetryConstant.GuestCheckout;
        this.checkoutByGuestAttributes = getTelemetryAttributes(this.telemetryContent, payload);

        payload.contentAction.etext = TelemetryConstant.ViewShoppingBag;
        this.viewShoppingBagAttributes = getTelemetryAttributes(this.telemetryContent, payload);
    }

    public async componentDidMount(): Promise<void> {
        const context = this.props.context.actionContext;

        if(this.props.data.cart && this.props.data.cart.result && this.props.data.cart.result.cart.CartLines) {
            this.setState({
                miniCartData: await getMiniCartData(context)
            });
        }

        reaction(
            () => this.props.data.cart.result?.cart.CartLines,
            async () => {
                this.setState({
                    miniCartData: await getMiniCartData(context)
                });
            }
        );

        this.setState({
            orgUnitLocations: this.props.data.orgUnitLocations.result
        });
    }

    public render(): JSX.Element | null {
        const {
            id,
            typeName,
            data: {
                cart: { result: cart }
            },
            config: {
                enableHoverCart
            },
            context: {
                request: {
                    user: {
                        isAuthenticated,
                        signInUrl
                    }
                }
            },
            context,
            resources
        } = this.props;

        const guestCheckoutUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
        const cartUrl = getUrlSync('cart', this.props.context.actionContext) || '';
        const checkoutURL = this._getCheckoutURL(isAuthenticated, guestCheckoutUrl, signInUrl || '');
        const isCartEmpty = cart && cart.cart.CartLines && cart.cart.CartLines.length === 0;
        const cartLines = this._getCartLines();
        const hasErrors = cartLines ? cartLines.some(cartline => cartline.hasError) : false;
        const includeFlyout = this.props.data.cart.status === 'SUCCESS' && enableHoverCart;
        const cartSize = cartLines ? cartLines.length : 0;
        const goToCartButtonText = resources.goToCartButtonTitle.replace('{count}', cartSize.toString());
        const flyoutTitle = resources.flyoutTitle;
        const price = cart && cart.cart.TotalAmount || undefined;
        const priceString = price ? resources.totalPriceFormatString.replace('{price}', context.cultureFormatter.formatCurrency(price)) : '';

        const viewProps = {
            ...this.props,
            cartIcon: cart && (
                <CartIconComponent
                    cartLabel={resources.cartLabel}
                    context={context}
                    id={id}
                    typeName={typeName}
                    data={{cart: cart}}
                    telemetryContent={this.telemetryContent}
                />
            ),
            cartlines: cartLines,
            FlyoutContainer: includeFlyout ? {
                tag: UncontrolledTooltip,
                placement: 'bottom-end',
                hideArrow: true,
                className: 'ms-cart-icon__flyout-container',
                trigger: 'hover focus',
                displayMode: 'FLYOUT',
                target: id
            } : undefined,
            CartlinesWrapper: {
                className: 'ms-cart-icon__cart-lines'
            },
            miniCartWrapper: {
                className: classnames('ms-cart-icon'),
                id: this.props.id
            },
            miniCartItemWrapper: {
                className: classnames('msc-cart-lines-item')
            },
            checkoutAsSignInUserButton: (!isCartEmpty) ?
            (
                <Button disabled={hasErrors} className={'ms-cart-icon__btn-checkout'} href={checkoutURL} title={resources.checkoutButtonTitle}{...this.checkoutBySignInAttributes}>{resources.checkoutButtonTitle}</Button>
            ) : null,
            checkoutAsGuestButton: (!isCartEmpty && !isAuthenticated) ?
            (
                <Button disabled={hasErrors} className={'ms-cart-icon__btn-guestcheckout'} href={guestCheckoutUrl} title={resources.guestCheckoutButtonTitle}{...this.checkoutByGuestAttributes}>{resources.guestCheckoutButtonTitle}</Button>
            ) : null,
            goToCartButton:
            (
                <Button className={'ms-cart-icon__btn-gotocart'} href={cartUrl} title={goToCartButtonText} {...this.viewShoppingBagAttributes}>{goToCartButtonText}</Button>
            ),
            flyoutTitle:
            (
                <span className={`ms-cart-icon__flyout-title`}>{flyoutTitle}</span>
            ),
            totalPrice:
            (
                <div className={`ms-cart-icon__subtotal`}>{priceString}</div>
            )
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private _getCheckoutURL(isAuthenticated: boolean, guestCheckoutUrl: string, signInUrl: string): string {
        if (isAuthenticated) {
            return guestCheckoutUrl;
        }

        const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
        const isAbsoluteUrl = absoluteUrlRegExp.test(guestCheckoutUrl);
        let returnURL = guestCheckoutUrl;
        if (msdyn365Commerce.isBrowser && !isAbsoluteUrl) {
            returnURL = `${window.location.origin}${guestCheckoutUrl}`;
        }

        return `${signInUrl}${signInUrl.indexOf('?') === -1 ? '?' : '&'}ru=${returnURL}`;
    }

    private _getCartLines(): IFlyoutCartLineItemViewProps[] | null {
        const {
            data: {
                cart: { result: cart }
            },
            context: {
                request: {
                    channel: {
                        PickupDeliveryModeCode
                    } = { PickupDeliveryModeCode: undefined }
                }
            },
            config: config,
            telemetry,
            resources
        } = this.props;

        const imageSettings = this._getImageSettings(config.imageSettings);

        return this.state.miniCartData.products && cart && cart.cart.CartLines && cart.cart.CartLines.length > 0 ?
        (
            FlyoutCartLineItems({
                cartlines: cart.cart.CartLines,
                products: this.state.miniCartData.products,
                productAvailabilites: this.state.miniCartData.productAvailabilites,
                productDeliveryOptions: this.state.miniCartData.deliveryOptions,
                imageSettings: imageSettings,
                outOfStockThreshold: this.props.context.app.config.outOfStockThreshold || 0,
                isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                maxCartlineQuantity: this.props.context.app.config.maxQuantityForCartLineItem,
                gridSettings: this.props.context.request.gridSettings!,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                resources: {
                    sizeString: resources.productDimensionTypeSize,
                    colorString: resources.productDimensionTypeColor,
                    configString: resources.productDimensionTypeConfiguration,
                    styleString: resources.productDimensionTypeStyle,
                    quantityDisplayString: resources.quantityDisplayText,
                    inputQuantityAriaLabel: '', // not used
                    discountStringText: '', // not used
                    originalPriceText: '',
                    currentPriceText: '',
                    shippingChargesText: ''
                },
                telemetry: telemetry,
                removeButtonText: resources.removeCartButtonText,
                outOfStockText: '', // not used
                outOfRangeOneText: '', // not used
                outOfRangeFormatText: '', // not used
                cartState: this.props.data.cart.result,
                orgUnitLocations: this.state.orgUnitLocations,
                removeItemClickHandler: this._removeItemFromCartHandler,
                pickupDeliveryModeCode: PickupDeliveryModeCode,
                telemetryContent: this.telemetryContent
            })
        ) : null;
    }

    private _getImageSettings = (imageSettings: IImageSettings | undefined): IImageSettings => {
        return imageSettings || {
            viewports: {
                xs: { q: `w=80&h=94&m=6`, w: 0, h: 0 },
                sm: { q: `w=148&h=174&m=6`, w: 0, h: 0 },
                lg: { q: `w=148&h=174&m=6`, w: 0, h: 0 }
            },
            lazyload: true
        };
    }

    private _removeItemFromCartHandler = (cartlineToRemove: CartLine) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineIds: [cartlineToRemove.LineId!.toString()]
            };
            this.props.data.cart.result.removeCartLines(input)
                .catch((error) => {
                    this.props.telemetry.warning(error);
                    this.props.telemetry.debug('Unable to Remove Cart Line');
                });
        }
    }
}

export default CartIcon;

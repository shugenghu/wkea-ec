/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { IOrderSummaryLines, OrderSummary } from '@msdyn365-commerce-modules/order-summary-utilities';
import { Alert, Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, INodeProps, IPayLoad, ITelemetryContent, TelemetryConstant, Waiting } from '@msdyn365-commerce-modules/utilities';
import {
    IAddToOrderTemplateDialogResources, IDuplicateItemsWhenAddingToOrderTemplateDialogResources,
    IItemAddedToOrderTemplateDialogResources, ILinesAddedToOrderTemplateDialogResources, IOrderTemplateNameDialogResources,
    IWishlistActionSuccessResult, PromoCodeComponent, SaveCartToOrderTemplateComponent } from '@msdyn365-commerce/components';
import MsDyn365, { getUrlSync, IImageSettings } from '@msdyn365-commerce/core';
import { ICartState } from '@msdyn365-commerce/global-state';
import { CartLine } from '@msdyn365-commerce/retail-proxy';
import { ReleasedProductType } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import classnames from 'classnames';
import { observer } from 'mobx-react';
import React from 'react';
import { ICartData } from './cart.data';
import { ICartProps, ICartResources } from './cart.props.autogenerated';
import { CartLineItems, ICartlinesViewProps } from './components/cart-line-items';

export interface ICartViewProps extends ICartProps<ICartData> {
    className: string;
    title?: React.ReactNode;
    CartlinesWrapper: INodeProps;
    cartlines?: ICartlinesViewProps[];
    cart: ICartState | undefined;
    orderSummaryHeading: React.ReactNode;
    orderSummaryLineitems?: IOrderSummaryLines;
    OrderSummaryWrapper: INodeProps;
    OrderSummaryItems: INodeProps;
    OrderSummaryErrors?: IOrderSummaryErrors;
    checkoutAsGuestButton: React.ReactNode;
    checkoutAsSignInUserButton: React.ReactNode;
    storeSelector?: React.ReactNode;
    backToShoppingButton: React.ReactNode;
    waitingComponent: React.ReactNode;
    promoCode: React.ReactNode;
    cartLoadingStatus: string;
    cartDataResult: boolean;
    createTemplateFromCartButton: React.ReactNode;
    telemetryContent?: ITelemetryContent;
    removeItemClickHandler(cartlineToRemove: CartLine): void;
    moveToWishlistSuccessHandler(result: IWishlistActionSuccessResult, cartlineId: CartLine): void;
}

export interface IOrderSummaryErrors {
    Wrapper: INodeProps;

    header: React.ReactNode;
    errors: React.ReactNode[];
}

/**
 *
 * Cart component
 * @extends {React.PureComponent<ICartProps<ICartData>>}
 */
@observer
class Cart extends React.Component<ICartProps<ICartData>> {
    private telemetryContent: ITelemetryContent;
    private payLoad: IPayLoad;

    constructor(props: ICartProps<ICartData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
                                                   this.props.friendlyName,
                                                   this.props.telemetry);
        this.payLoad = getPayloadObject('click', this.telemetryContent, '');
    }

    public render(): JSX.Element | null {
        const {
            data: {
                cart: { result: cart }
            },
            context: {
                request: {
                    user: {
                        isAuthenticated,
                        signInUrl
                    }
                }
            },
            resources
        } = this.props;

        const guestCheckoutUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
        const backToShoppingUrl = getUrlSync('home', this.props.context.actionContext) || '';
        const checkoutURL = this._getCheckoutURL(isAuthenticated, guestCheckoutUrl, signInUrl || '');
        const isCartEmpty = cart && cart.cart.CartLines && cart.cart.CartLines.length === 0;
        const cartLines = this._getCartLines();

        this.payLoad.contentAction.etext = TelemetryConstant.Checkout;
        const checkoutBySignInAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);

        this.payLoad.contentAction.etext = TelemetryConstant.GuestCheckout;
        const checkoutByGuestAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);

        this.payLoad.contentAction.etext = TelemetryConstant.BackToShopping;
        const backtoShoppingAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);

        const hasErrors = cartLines ? cartLines.some(cartline => cartline.error !== undefined) : false;

        const viewProps = {
            ...this.props,
            className: classnames('ms-cart'),
            title: <h1 className={'msc-cart__heading'}>{resources.cartTitle}</h1>,
            CartlinesWrapper: { className: 'msc-cartline-wraper' },
            OrderSummaryWrapper: { className: 'msc-order-summary-wrapper' },
            OrderSummaryItems: { className: 'msc-order-summary__items' },
            cartlines: cartLines,
            promoCode: this._getPromoCode(),
            cart: this.props.data.cart.result,
            context: this.props.context,
            typeName: this.props.typeName,
            telemetry: this.props.telemetry,
            id: this.props.id,
            removePromoAriaLabelFormat: resources.removePromoAriaLabelFormat,
            orderSummaryHeading: this.props.data.products && this.props.data.products.result && cart && cart.cart.CartLines && cart.cart.CartLines.length > 0 ?
                (
                    <h2 className={'msc-order-summary__heading'}>{resources.orderSummaryTitle}</h2>
                ) : null,
            orderSummaryLineitems: this._getOrderSummaryLineItems(),
            checkoutAsSignInUserButton: (!isCartEmpty) ?
                (
                    <Button disabled={hasErrors} className={'msc-cart__btn-checkout'} href={checkoutURL} title={resources.checkoutButtonTitle}{...checkoutBySignInAttributes} >{resources.checkoutButtonTitle}</Button>
                ) : null,
            checkoutAsGuestButton: (!isCartEmpty && !isAuthenticated) ?
                (
                    <Button disabled={hasErrors} className={'msc-cart__btn-guestcheckout'} href={guestCheckoutUrl} title={resources.guestCheckoutButtonTitle}{...checkoutByGuestAttributes}>{resources.guestCheckoutButtonTitle}</Button>
                ) : null,
            backToShoppingButton: <Button className={'msc-cart__btn-backtoshopping'} {...backtoShoppingAttributes} href={backToShoppingUrl} title={resources.backToShoppingButtonTitle}>{resources.backToShoppingButtonTitle}</Button>,
            createTemplateFromCartButton: (this._displayAddCartToTemplate()) ?
                (
                    <SaveCartToOrderTemplateComponent
                        addToOrderTemplateDialogResources={this._generateAddToOrderTemplateDialogResources(resources)}
                        createOrderTemplateDialogResources={this._generateOrderTemplateNameDialogResources(resources)}
                        linesAddedToOrderTemplateDialogResources={this._generateLinesAddedToOrderTemplateDialogResources(resources)}
                        createOrderTemplateFromCartButton={resources.createOrderTemplateFromCartButton}
                        context={this.props.context}
                        id={this.props.id}
                        typeName={this.props.typeName}
                        data={{
                            orderTemplates: this.props.data.orderTemplates.result!,
                            cartLines: this.props.data.cart.result!.cart.CartLines!,
                            customerInformation: this.props.data.customerInformation.result
                        }}
                    />
                ) : null,
            storeSelector: this.props.slots.storeSelector && this.props.slots.storeSelector.length > 0 ? this.props.slots.storeSelector[0] : null,
            removeItemClickHandler: this._removeItemFromCartHandler,
            moveToWishlistSuccessHandler: this._moveToWishlistSuccessHandler,
            waitingComponent: <Waiting className='msc-waiting-circular msc-waiting-lg' />,
            cartLoadingStatus: this.props.data.cart.status === 'FAILED' ? this.props.resources.cartLoadingErrorMessage : null,
            cartDataResult: this.props.data.cart.result && this.props.data.cart.result.isEmpty,
            OrderSummaryErrors: this._getOrderSummaryErrors(cartLines),
            telemetryContent: this.telemetryContent
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private _displayAddCartToTemplate(): boolean {
        const RetailB2BEcommerceFeatureState = this.props.data.featureState.result?.find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailB2BEcommerceFeature');
        if (RetailB2BEcommerceFeatureState?.IsEnabled && this.props.data.customerInformation.result?.IsB2b && this.props.data.orderTemplates.result &&
            this.props.data.cart.result?.cart?.CartLines?.length && this.props.data.cart.result.cart.CartLines.length > 0 &&
            this.props.data.customerInformation.result) {
            return true;
        }

        return false;
    }

    private _getOrderSummaryErrors(cartLines: ICartlinesViewProps[] | null): IOrderSummaryErrors | undefined {
        const allErrors = cartLines && cartLines.map(cartline => {

            // check if the product is service or not by product type
            const PRODUCTASSERVICE = 2 as ReleasedProductType.Service;
            const isServiceItem = cartline.data?.product.ItemTypeValue === PRODUCTASSERVICE;

            if (!isServiceItem && cartline.error) {
                const fullError = (cartline.data && cartline.data.product.Name) ? `${cartline.data.product.Name}: ${cartline.error}` : cartline.error;

                return (
                    <div className='msc-alert__line'>{fullError}</div>
                );
            }

            return null;
        }).filter((line): line is JSX.Element => !!line) || [];

        return {
            Wrapper: {
                tag: Alert,
                className: 'msc-alert',
                isOpen: allErrors.length > 0,
                color: 'danger',
                assertive: true,
                'aria-label': this.props.resources.outOfStockErrorMessageHeader
            },
            header: (
                <div className='msc-alert__header' aria-hidden='true'>
                    <span className='msi-exclamation-triangle' />
                    <span>{this.props.resources.outOfStockErrorMessageHeader}</span>
                </div>
            ),
            errors: allErrors
        };
    }

    private _getOrderSummaryLineItems(): IOrderSummaryLines | undefined {
        const {
            data: {
                cart: { result: cart }
            },
            telemetry,
            resources
        } = this.props;

        const channelConfiguration = this.props.context && this.props.context.request && this.props.context.request.channel;

        return cart && cart.cart && channelConfiguration && cart.cart.CartLines && cart.cart.CartLines.length > 0 ?
            (
                OrderSummary({
                    cart: cart.cart,
                    subTotalLabel: resources.itemsWithCountLabel,
                    shippingLabel: resources.estimatedShippingLabel,
                    otherChargeLabel: resources.otherCharges,
                    taxLabel: resources.estimatedTaxLabel,
                    orderTotalLabel: resources.orderTotal,
                    totalDiscountsLabel: resources.totalDiscountsLabel,
                    context: this.props.context,
                    typeName: this.props.typeName,
                    id: this.props.id,
                    toBeCalculatedText: resources.yetToBeCalculatedText,
                    freeText: resources.priceFree,
                    channelConfiguration: channelConfiguration,
                    telemetry: telemetry
                })
            ) : undefined;
    }

    private _getPromoCode(): React.ReactNode {
        const {
            data: {
                cart: { result: cart }
            },
            resources
        } = this.props;

        return cart && (
            <PromoCodeComponent
                cart={cart}
                promoCodeHeadingText={resources.promoCodeHeadingText}
                promoPlaceholderText={resources.promoPlaceholderText}
                promoCodeApplyButtonText={resources.promoCodeApplyButtonText}
                appliedPromoCodeHeadingText={resources.appliedPromoCodeHeadingText}
                collapseTimeOut={350}
                removePromoAriaLabelFormat={resources.removePromoAriaLabelFormat}
                removePromoText={resources.removePromoText}
                invalidPromoCodeErrorText={resources.invalidPromoCodeErrorText}
                failedToAddPromoCodeErrorText={resources.failedToAddPromoCodeErrorText}
                failedToRemovePromoCodeErrorText={resources.failedToRemovePromoCodeErrorText}
                duplicatePromoCodeErrorText={resources.duplicatePromotionErrorText}
                context={this.props.context}
                id={this.props.id}
                typeName={this.props.typeName}
                data={{}}
                telemetryContent={this.telemetryContent}
            />
        );
    }

    private _generateAddToOrderTemplateDialogResources(resources: ICartResources): IAddToOrderTemplateDialogResources {
        return {
            addToOrderTemplateHeader: resources.addToOrderTemplateHeader,

            noOrderTemplatesMessage: resources.noOrderTemplatesMessage,
            noOrderTemplatesDescription: resources.noOrderTemplatesDescription,

            createAnOrderTemplateButtonText: resources.createAnOrderTemplateButtonText,
            createNewOrderTemplateButtonText: resources.createNewOrderTemplateButtonText,
            cancelOrderTemplateCreationButtonText: resources.cancelOrderTemplateCreationButtonText,

            selectTemplatesText: resources.selectTemplatesText,
            addToTemplateButtonText: resources.addToTemplateButtonText,
            lineItemsText: resources.lineItemsText
        };
    }

    private _generateItemAddedToOrderTemplateDialogResources(resources: ICartResources): IItemAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            itemAddedToOrderTemplateHeaderItemOneText: resources.itemAddedToOrderTemplateHeaderItemOneText,
            itemAddedToOrderTemplateHeaderItemFormatText: resources.itemAddedToOrderTemplateHeaderItemFormatText,
            itemAddedToOrderTemplateHeaderMessageText: resources.itemAddedToOrderTemplateHeaderMessageText,
            freePriceText: resources.freePriceText,
            originalPriceText: resources.originalPriceText,
            currentPriceText: resources.currentPriceText
        };
    }

    private _generateLinesAddedToOrderTemplateDialogResources(resources: ICartResources): ILinesAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            linesAddedToOrderTemplateHeaderItemsOneText: resources.linesAddedToOrderTemplateHeaderItemsOneText,
            linesAddedToOrderTemplateHeaderItemsFormatText: resources.linesAddedToOrderTemplateHeaderItemsFormatText,
            linesAddedToOrderTemplateHeaderLinesOneText: resources.linesAddedToOrderTemplateHeaderLinesOneText,
            linesAddedToOrderTemplateHeaderLinesFormatText: resources.linesAddedToOrderTemplateHeaderLinesFormatText,
            linesAddedToOrderTemplateHeaderMessageText: resources.linesAddedToOrderTemplateHeaderMessageText
        };
    }

    private _generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(resources: ICartResources): IDuplicateItemsWhenAddingToOrderTemplateDialogResources {
        return {
            duplicatedProductsHeader: resources.duplicatedProductsHeader,
            duplicatedProductsDescription: resources.duplicatedProductsDescription,
            updateQuantityButtonText: resources.updateQuantityButtonText,
            cancelDuplicateItemsButtonText: resources.cancelDuplicateItemsButtonText
        };
    }

    private _generateOrderTemplateNameDialogResources(resources: ICartResources): IOrderTemplateNameDialogResources {
        return {
            orderTemplateHeaderLabel: resources.createOrderTemplateHeader,
            orderTemplateTitleLabel: resources.orderTemplateTitle,
            orderTemplateNameAriaLabel: resources.orderTemplateNameAriaLabel,
            orderTemplateDescription: resources.createOrderTemplateDescription,

            defaultOrderTemplateName: resources.defaultOrderTemplateName,

            orderTemplateButtonLabel: resources.createOrderTemplateButtonText,
            orderTemplateCancelButtonLabel: resources.cancelNewOrderTemplateCreationButtonText
        };
    }

    private _getCartLines(): ICartlinesViewProps[] | null {
        const {
            data: {
                cart: { result: cart },
                wishlists: { result: wishlists },
                orderTemplates: { result: orderTemplates },
                customerInformation: { result: customerInformation }
            },
            context: {
                request: {
                    channel: {
                        PickupDeliveryModeCode
                    } = { PickupDeliveryModeCode: undefined }
                }
            },
            config: config,
            telemetry,
            resources
        } = this.props;

        const imageSettings = this._getImageSettings(config.imageSettings);

        return this.props.data.products && this.props.data.products.result && cart && cart.cart.CartLines && cart.cart.CartLines.length > 0 ? (
            CartLineItems({
                cartlines: cart.cart.CartLines,
                products: this.props.data.products.result,
                productAvailabilites: this.props.data.productAvailabilites.result,
                productDeliveryOptions: this.props.data.deliveryOptions.result,
                imageSettings: imageSettings,
                isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                maxCartlineQuantity: this.props.context.app.config.maxQuantityForCartLineItem,
                gridSettings: this.props.context.request.gridSettings!,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                resources: {
                    sizeString: resources.productDimensionTypeSize,
                    colorString: resources.productDimensionTypeColor,
                    configString: resources.productDimensionTypeConfiguration,
                    styleString: resources.productDimensionTypeStyle,
                    quantityDisplayString: resources.quantityDisplayText,
                    inputQuantityAriaLabel: resources.inputQuantityAriaLabel,
                    decrementButtonAriaLabel: resources.decrementButtonAriaLabel,
                    incrementButtonAriaLabel: resources.incrementButtonAriaLabel,
                    discountStringText: resources.discountStringText,
                    originalPriceText: resources.originalPriceText,
                    currentPriceText:resources.currentPriceText,
                    shippingChargesText:resources.shippingCharges
                },
                telemetry: telemetry,
                addToWishlistButtonText: resources.addToWishlistButtonText,
                removeFromWishlistButtonText: resources.removeFromWishlistButtonText,
                removeButtonText: resources.removeCartButtonText,
                shipItText: resources.shipInsteadDisplayText,
                pickitUpText: resources.pickItUpDisplayText,
                changeStoreText: resources.changeStoreDisplayText,
                storeSelectorStateManager: this.props.data.storeSelectorStateManager.result,
                outOfStockText: resources.outOfStockErrorMessage,
                outOfRangeOneText: resources.errorMessageOutOfRangeOneLeft,
                outOfRangeFormatText: resources.errorMessageOutOfRangeFormat,
                cartState: this.props.data.cart.result,
                orgUnitLocations: this.props.data.orgUnitLocations.result,
                removeItemClickHandler: this._removeItemFromCartHandler,
                moveToWishlistSuccessHandler: this._moveToWishlistSuccessHandler,
                updateCartLinesQuantitySuccessHandler: this._updateCartlineQuantity,
                wishlists: wishlists,
                defaultWishlistName: resources.defaultWishlistName,
                pickupDeliveryModeCode: PickupDeliveryModeCode,
                includeErrors: config.showOutOfStockErrors,
                showShippingChargesForLineItems: config.showShippingChargesForLineItems,
                telemetryContent: this.telemetryContent,

                addToOrderTemplateDialogResources: this._generateAddToOrderTemplateDialogResources(resources),
                createOrderTemplateDialogResources: this._generateOrderTemplateNameDialogResources(resources),
                itemAddedToOrderTemplateDialogResources: this._generateItemAddedToOrderTemplateDialogResources(resources),
                duplicateItemsWhenAddingToOrderTemplateDialogResources: this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(resources),

                addToOrderTemplateButtonText: resources.addToOrderTemplateButtonText,
                addToOrderTemplateMessage: resources.addToOrderTemplateMessage,
                addItemToOrderTemplateError: resources.addItemToOrderTemplateError,
                orderTemplates: orderTemplates,
                customerInformation: customerInformation
            })
        ) : null;
    }

    private _getCheckoutURL(isAuthenticated: boolean, guestCheckoutUrl: string, signInUrl: string): string {
        if (isAuthenticated) {
            return guestCheckoutUrl;
        }

        const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
        const isAbsoluteUrl = absoluteUrlRegExp.test(guestCheckoutUrl);
        let returnURL = guestCheckoutUrl;
        if (MsDyn365.isBrowser && !isAbsoluteUrl) {
            returnURL = `${window.location.origin}${guestCheckoutUrl}`;
        }

        return `${signInUrl}${signInUrl.indexOf('?') === -1 ? '?' : '&'}ru=${returnURL}`;
    }

    private _getImageSettings = (imageSettings: IImageSettings | undefined): IImageSettings => {
        return imageSettings || {
            viewports: {
                xs: { q: `w=80&h=94&m=6`, w: 0, h: 0 },
                sm: { q: `w=148&h=174&m=6`, w: 0, h: 0 },
                lg: { q: `w=148&h=174&m=6`, w: 0, h: 0 }
            },
            lazyload: true
        };
    }

    private _removeItemFromCartHandler = (cartlineToRemove: CartLine) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineIds: [cartlineToRemove.LineId!.toString()]
            };
            this.props.data.cart.result.removeCartLines(input)
                .catch((error) => {
                    this.props.telemetry.warning(error);
                    this.props.telemetry.debug('Unable to Remove Cart Line');
                });
        }
    }

    private _moveToWishlistSuccessHandler = (result: IWishlistActionSuccessResult, cartline?: CartLine) => {
        if (result.status === 'ADDED' && cartline) {
            this._removeItemFromCartHandler(cartline);
        }
    }

    private _updateCartlineQuantity = (cartlineToUpdate: CartLine, quantity: number) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineId: cartlineToUpdate.LineId!.toString(),
                newQuantity: quantity
            };
            this.props.data.cart.result.updateCartLineQuantity(input)
                .catch((error) => {
                    this.props.telemetry.warning(error);
                    this.props.telemetry.debug('Unable to update Cart Line quantity');
                });
        }
    }
}

export default Cart;

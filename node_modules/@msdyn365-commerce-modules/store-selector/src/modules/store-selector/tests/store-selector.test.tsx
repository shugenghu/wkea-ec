/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IStoreSelectorStateManager } from '@msdyn365-commerce-modules/bopis-utilities';
import { AsyncResult, buildMockCoreContext, buildMockModuleProps, ICoreContext } from '@msdyn365-commerce/core';
import { OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import { mount } from 'enzyme';
import { observable } from 'mobx';
import * as React from 'react';
import { IStoreSelectorData, IStoreSelectorProps, IStoreSelectorViewProps } from '../../..';
import * as RetailActions from '../../../../../retail-actions';
import { IStoreSelectorSearchFormProps } from '../components';
import StoreSelector from '../store-selector';
import { IStoreSelectorConfig, IStoreSelectorResources, mode, searchRadiusUnit, style } from '../store-selector.props.autogenerated';

const mockContext = buildMockCoreContext({
    app: {
        config: {
            outOfStockThreshold: 5,
            enableStockCheck: true
        }
    },
    actionContext: {
        requestContext: {
            // @ts-ignore
            channel: {
                BingMapsApiKey: '1001',
                BingMapsEnabled: true
            }
        }
    }
    // tslint:disable-next-line:no-any
}) as ICoreContext<any>;

const mockData: IStoreSelectorData = {
    storeSelectorStateManager: {
        status: 'SUCCESS',
        result: {}
    } as AsyncResult<IStoreSelectorStateManager>,
    availabilitiesWithHours: {} as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
    storeLocations: {} as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>
};

const mockConfig: IStoreSelectorConfig = {
    lookupRadius: 100,
    searchRadiusUnit: searchRadiusUnit.kilometers
};

const mockResources: IStoreSelectorResources = {
    emptyLocationsText: 'No Nearby Locations',
    selectStoreText: 'Pick Up Here',
    selectStoreAriaFormatText: 'Pick Up At {StoreName}',
    timeText: 'Store Hours',
    captionText: 'Weâ€™re expanding our pick-up-in-store service to more Microsoft Store locations every day.',
    milesShortText: 'mi',
    kilometersShortText: 'mi',
    outOfStockText: 'Out of stock',
    inStockText: 'In Stock',
    selectedStoreLocationText: 'Selected store location',
    contactText: 'Contact',
    availabilityText: 'Availability',
    productDimensionTypeColor: 'Color',
    productDimensionTypeConfiguration: 'Configuration',
    productDimensionTypeSize: 'Size',
    productDimensionTypeStyle: 'Style',
    storeHoursClosedText: 'Closed',
    storeHoursMondayText: 'Mon',
    storeHoursTuesdayText: 'Tue',
    storeHoursWednesdayText: 'Wed',
    storeHoursThursdayText: 'Thur',
    storeHoursFridayText: 'Fri',
    storeHoursSaturdayText: 'Sat',
    storeHoursSundayText: 'Sun',
    storeHoursMondayFullText: 'Monday',
    storeHoursTuesdayFullText: 'Tuesday',
    storeHoursWednesdayFullText: 'Wednesday',
    storeHoursThursdayFullText: 'Thursday',
    storeHoursFridayFullText: 'Friday',
    storeHoursSaturdayFullText: 'Saturday',
    storeHoursSundayFullText: 'Sunday',
    storeAddressAriaLabel: 'Store address',
    storePhoneAriaLabel: 'Store phone',
    storeCountMessage: 'We found {count} stores within {radius} miles of you.',
    storeAllCountMessage: 'We found {count} stores.',
    storeCountMessageInKm: 'We found {count} stores within {radius} kilometers of you.',
    searchPlaceholderText: 'Search',
    searchInputAriaLabel: 'Search input',
    searchButtonAriaLabel: 'Search',
    storeSelectorHeaderText: 'Pick a store',
    storeLocatorHeaderText: 'Store Locator',
    seeAllStoresText: 'See all stores',
    setAsPreferredStoreText: 'Set as preferred store',
    setAsPreferredStoreTextAriaLabel: 'Set as preferred store',
    preferredStoreText: 'Preferred store',
    preferredStoreAriaLabel: 'Set as preferred store',
    viewMapText: 'View Map',
    viewListText: 'View List'
};

describe('searchForm tests', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    beforeEach(() => {
        jest.clearAllMocks();

        // @ts-ignore
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockResolvedValue(undefined);
    });

    it('doesnt do search if dialog not open', () => {
        const mockDataNoStoreSelectorStateManager = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('does search when getAndUpdateUserLocation callback fired', async () => {
        // @ts-ignore Overriding read only for test purposes
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };

        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        } as AsyncResult<IStoreSelectorStateManager>;

        // Clear mocks to reset call count
        jest.clearAllMocks();

        expect(viewProps.callbacks.getAndUpdateUserLocation());

        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalled();
    });

    it('does search if dialog open property changes', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        }) as IStoreSelectorData;

        // @ts-ignore Overriding read only for test purposes
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        } as AsyncResult<IStoreSelectorStateManager>;

        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalled();
    });

    it('doesn\'t search if can\'t get location due to navigator not being found', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        }) as IStoreSelectorData;

        // @ts-ignore Overriding read only for test purposes
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                failure('Error');
            })
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        } as AsyncResult<IStoreSelectorStateManager>;

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('doesn\'t search if getting location errors out', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        }) as IStoreSelectorData;

        // @ts-ignore Overriding read only for test purposes
        window.navigator.geolocation = undefined;

        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        } as AsyncResult<IStoreSelectorStateManager>;

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
});

describe('onDialogClosed tests', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    it('no-ops if no state manager', async () => {
        const mockDataNoStoreSelectorStateManager = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        await expect(viewProps.callbacks.closeDialog()).resolves.toBeUndefined();
    });

    it('calls closeDialog on state manager', async () => {
        const mockDataLocal = {
            ...mockData,
            // @ts-ignore lint doesn't like mocking
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    closeDialog: jest.fn()
                }
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataLocal, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        await expect(viewProps.callbacks.closeDialog()).resolves.toBeUndefined();

        expect(mockDataLocal.storeSelectorStateManager.result!.closeDialog).toBeCalled();
    });
});

describe('searchForm tests', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    beforeEach(() => {
        jest.clearAllMocks();

        // @ts-ignore
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockResolvedValue(undefined);
    });

    it('searchTermChanged callback updates state', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    geoLocate: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();
        expect(result.state('searchTerm')).toEqual('');
        await expect(viewProps.callbacks.searchTermChanged('Seattle')).resolves.toBeUndefined();
        expect(result.state('searchTerm')).toEqual('Seattle');
    });

    it('search callback no-ops if no search term passed', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    geoLocate: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('search callback no-ops if no state manager', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('search is disabled if missing BingMapsApiKey', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    geoLocate: jest.fn().mockResolvedValue(undefined)
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true
                }
            },
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    channel: {
                        BingMapsApiKey: undefined,
                        BingMapsEnabled: true
                    }
                }
            }
            // tslint:disable-next-line:no-any
        }) as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        expect(searchFormProps.isMapDisabled).toBe(true);
    });

    it('search callback skips future steps if no location returned by geoLocate', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    geoLocate: jest.fn().mockResolvedValue(undefined)
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        expect(searchFormProps.isMapDisabled).toBe(false);

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('search callback calls getFullAvailableInventoryNearby if location returned by geoLocate', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: 10, longitude: 15 })
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('   ')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(
            expect.objectContaining({
                latitude: 10,
                longitude: 15,
                radius: 100,
                productId: 25
            }),
            expect.anything()
        );
    });

    it('search callback cleanly handles if getFullAvailableInventoryNearby throws', async () => {
        // @ts-ignore
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValueOnce('Fail');

        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: 10, longitude: 15 })
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(
            expect.objectContaining({
                latitude: 10,
                longitude: 15,
                radius: 100,
                productId: 25
            }),
            expect.anything()
        );
    });

    it('search callback calls getFullAvailableInventoryNearby if location returned by geoLocate has expected default values', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
            // tslint:disable-next-line:no-any
        }) as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(
            expect.objectContaining({
                latitude: 0,
                longitude: 0,
                radius: 50,
                productId: 25
            }),
            expect.anything()
        );
    });

    it('search callback calls doesnt call getFullAvailableInventoryNearby if no product found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    context: {
                        product: undefined
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
            // tslint:disable-next-line:no-any
        }) as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });

    it('cleanly handles getFullAvailableInventoryNearby failure', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        // @ts-ignore
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValueOnce('Fail');

        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
            // tslint:disable-next-line:no-any
        }) as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.search).toBeDefined();

        // @ts-ignore
        const searchFormProps: IStoreSelectorSearchFormProps = viewProps.search!.props as IStoreSelectorSearchFormProps;

        expect(searchFormProps).toBeDefined();

        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
    });
});

describe('locationsList tests', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    it('locationsList is empty if no availabilitiesWithHours', async () => {
        const mockDataNoLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataNoLocations, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).toBe(undefined);
    });

    it('locationsList is empty if availabilitiesWithHours is empty', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).toBe(undefined);
    });

    it('locationsList is not empty if availabilitiesWithHours is not empty', async () => {
        const mockDataValidLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataValidLocations, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        expect(locationLinesProps.outOfStockThreshold).toEqual(5);
        expect(locationLinesProps.enableOutOfStockCheck).toEqual(true);
        expect(locationLinesProps.alreadySelectedLocation).toBeUndefined();
    });

    it('Passes already selected location if present', async () => {
        const orgUnitLocation: OrgUnitLocation = {};

        const mockDataValidLocations = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    context: {
                        alreadySelectedLocation: orgUnitLocation
                    }
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataValidLocations, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        expect(locationLinesProps.alreadySelectedLocation).toEqual(orgUnitLocation);
    });

    it('locationsList is gets default values if not present in config', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        expect(locationLinesProps.outOfStockThreshold).toEqual(0);
        expect(locationLinesProps.enableOutOfStockCheck).toEqual(false);
    });

    it('locationsList onLocationSelected callback cleanly no-ops if no state found', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };

        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await expect(locationLinesProps.onLocationSelected(undefined)).resolves.toBeUndefined();
    });

    it('locationsList onLocationSelected skips onLocationSelected but closes dialog if no context found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    closeDialog: jest.fn(),
                    context: undefined
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();

        expect(localMockData.storeSelectorStateManager.result!.closeDialog).toBeCalled();
    });

    it('locationsList onLocationSelected calls onLocationSelected and closes dialog if context found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    closeDialog: jest.fn(),
                    context: {
                        onLocationSelected: jest.fn().mockResolvedValue(undefined)
                    }
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();

        expect(localMockData.storeSelectorStateManager.result!.closeDialog).toBeCalled();
        expect(localMockData.storeSelectorStateManager.result!.context!.onLocationSelected).toBeCalled();
    });

    it('locationsList onLocationSelected closes dialog even if onLocationSelected throws', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    closeDialog: jest.fn(),
                    context: {
                        onLocationSelected: jest.fn().mockRejectedValue('Fail')
                    }
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();

        expect(localMockData.storeSelectorStateManager.result!.closeDialog).toBeCalled();
        expect(localMockData.storeSelectorStateManager.result!.context!.onLocationSelected).toBeCalled();
    });
});

describe('Map tests', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('Doesn\'t load map script if BingMapsApiKey is missing', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    loadMapApi: jest.fn().mockResolvedValue(undefined)
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        const localMockContext = buildMockCoreContext({
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    channel: {
                        BingMapsApiKey: undefined,
                        BingMapsEnabled: true
                    }
                }
            },
            app: {
                config: {}
            }
        });

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(localMockData.storeSelectorStateManager.result?.loadMapApi).not.toBeCalled();
    });

    it('Doesn\'t load map script if Map in disabled in HQ', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    loadMapApi: jest.fn().mockResolvedValue(undefined)
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
        };

        const localMockContext = buildMockCoreContext({
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    channel: {
                        BingMapsApiKey: 'A1001',
                        BingMapsEnabled: false
                    }
                }
            },
            app: {
                config: {}
            }
        });

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(localMockData.storeSelectorStateManager.result?.loadMapApi).not.toBeCalled();
    });

    it('Attaches map autosuggest', async () => {

        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.callbacks.attachMapAutoSuggest());

        expect(result.exists('#ms-store-select__search-box'));

        expect(result.exists('#ms-store-select__search-box-container'));
    });
});

describe('Find stores test', () => {
    let moduleProps: IStoreSelectorProps<IStoreSelectorData>;

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('doesn\'t do inventory check but checks store locations only if findStore is passed in config', () => {

        // @ts-ignore
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValue(undefined);
        // @ts-ignore
        RetailActions.getOrgUnitLocationsByArea = jest.fn().mockResolvedValue(undefined);

        // @ts-ignore Overriding read only for test purposes
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };

        const mockConfigFindStores: IStoreSelectorConfig = {
            mode: mode.findStores,
            style: style.inline,
            lookupRadius:100
        };

        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfigFindStores, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const mockLocation = {} as OrgUnitLocation;

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.callbacks.getAndUpdateUserLocation());

        expect(RetailActions.getOrgUnitLocationsByArea).toBeCalled();

        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();

        expect(viewProps.callbacks.setOrgUnitStoreInformation(mockLocation));
    });

    it('Sets preferred store', async () => {

        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setPreferredStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const mockConfigPreferredStore: IStoreSelectorConfig = {
            setAsPreferredStore: true,
            lookupRadius:100
        };

        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    cookies: {
                        isConsentGiven: () => true
                    }
                }
            }
            // tslint:disable-next-line:no-any
        } as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onSetAsPreferredStore('SEATTLE');

        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));

        expect(localMockData.storeSelectorStateManager.result!.setPreferredStoreLocationId).toBeCalled();
    });

    it('Doesn\'t set preferred store if store id is undefined', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setPreferredStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const mockConfigPreferredStore: IStoreSelectorConfig = {
            setAsPreferredStore: true,
            lookupRadius:100
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onSetAsPreferredStore(undefined);

        expect(viewProps.callbacks.setPreferredStore(undefined));

        expect(localMockData.storeSelectorStateManager.result!.setPreferredStoreLocationId).not.toBeCalled();
    });

    it('Sets selected store', async () => {

        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setSelectedStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onClick('SEATTLE');

        expect(viewProps.callbacks.setSelectedStore('SEATTLE'));

        expect(localMockData.storeSelectorStateManager.result!.setSelectedStoreLocationId).toBeCalled();
    });

    it('Sets preferred store', async () => {

        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setPreferredStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const mockConfigPreferredStore: IStoreSelectorConfig = {
            setAsPreferredStore: true,
            lookupRadius:100
        };

        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    cookies: {
                        isConsentGiven: () => true
                    }
                }
            }
            // tslint:disable-next-line:no-any
        } as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onSetAsPreferredStore('SEATTLE');

        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));

        expect(localMockData.storeSelectorStateManager.result!.setPreferredStoreLocationId).toBeCalled();
    });

    it('Doesn\'t set preferred store if store id is undefined', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setPreferredStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const mockConfigPreferredStore: IStoreSelectorConfig = {
            setAsPreferredStore: true,
            lookupRadius:100
        };

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, mockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onSetAsPreferredStore(undefined);

        expect(viewProps.callbacks.setPreferredStore(undefined));

        expect(localMockData.storeSelectorStateManager.result!.setPreferredStoreLocationId).not.toBeCalled();
    });

    it('Doesn\'t set preferred store if no cookie concent given', async () => {

        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                // @ts-ignore partial mock
                result: {
                    setPreferredStoreLocationId: jest.fn()
                } as IStoreSelectorStateManager
            } as AsyncResult<IStoreSelectorStateManager>,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}] as RetailActions.IFullOrgUnitAvailability[]
            } as AsyncResult<RetailActions.IFullOrgUnitAvailability[]>,
        };

        const mockConfigPreferredStore: IStoreSelectorConfig = {
            setAsPreferredStore: true,
            lookupRadius:100
        };

        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    // @ts-ignore
                    cookies: {
                        isConsentGiven: () => false
                    }
                }
            }
            // tslint:disable-next-line:no-any
        } as ICoreContext<any>;

        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext) as IStoreSelectorProps<IStoreSelectorData>,
            resources: mockResources,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />; })
        };

        const result = mount(<StoreSelector {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IStoreSelectorViewProps = result.childAt(0).props().props;

        expect(viewProps).toBeDefined();

        expect(viewProps.locationsList).not.toBe(false);

        // @ts-ignore
        const locationLinesProps: IStoreSelectorLocationLinesProps = viewProps.locationsList!.props;

        expect(locationLinesProps).toBeDefined();

        await locationLinesProps.onSetAsPreferredStore('SEATTLE');

        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));

        expect(localMockData.storeSelectorStateManager.result!.setPreferredStoreLocationId).not.toBeCalled();

    });

});

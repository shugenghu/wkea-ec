/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// tslint:disable:no-reference
/// <reference path="types/MicrosoftMaps/Microsoft.Maps.All.d.ts" />

import * as Msdyn365 from '@msdyn365-commerce/core';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { IStoreSelectorData } from './store-selector.data';
import { IStoreSelectorProps, mode as modeEnum, searchRadiusUnit, style as stylyEnum } from './store-selector.props.autogenerated';

import {
    StoreSelectorEmptyMessage,
    StoreSelectorFoundLocationsMessage,
    StoreSelectorLocationLines,
    StoreSelectorSearchForm,
    StoreSelectorTermsOfService,
    StoreSelectorWaiting
} from './components';

import { getFullAvailableInventoryNearby, GetFullAvailableInventoryNearbyInput, getOrgUnitLocationsByArea, GetOrgUnitLocationsByAreaInput, IFullOrgUnitAvailability } from '@msdyn365-commerce-modules/retail-actions';

import { getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, Modal, ModalBody, ModalFooter, ModalHeader, NodeTag } from '@msdyn365-commerce-modules/utilities';
import { OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import classname from 'classnames';
export interface IStoreSelectorState {
    isSearchInProgress: boolean;
    searchTerm?: string;
    isSeeAllStoreValue: boolean;
    isLocationDisabled?: boolean;
}

export interface IStoreSelectorViewProps extends IStoreSelectorProps<IStoreSelectorData> {
    state: IStoreSelectorState;

    // Containers:
    ModuleProps: IModuleProps;
    BodyContainerProps: INodeProps;
    FooterContainerProps: INodeProps;
    HeaderContainerProps: INodeProps;
    HeaderProps?: React.ReactNode;

    // Components
    locationsMessage?: React.ReactNode;
    search?: React.ReactNode;
    spinner?: React.ReactNode;
    locationsList?: React.ReactNode;
    noLocationsMessage?: React.ReactNode;
    terms?: React.ReactNode;
    headerText?: React.ReactNode;

    callbacks: {
        closeDialog(): Promise<void>;
        searchTermChanged(searchTerm: string): Promise<void>;
        performSearch(searchTerm: string): Promise<void>;
        selectedLocation(location: OrgUnitLocation | undefined): Promise<void>;
        getAndUpdateUserLocation(): Promise<void>;
        attachMapAutoSuggest(): Promise<void>;
        onSuggestionSelected(result: Microsoft.Maps.ISuggestionResult): Promise<void>;
        setPreferredStore(storeId: string | undefined): Promise<void>;
        removePreferredStore(): Promise<void>;
        setSelectedStore(storeId: string | undefined): Promise<void>;
        setOrgUnitStoreInformation(location: OrgUnitLocation | undefined): Promise<void>;
    };
}

/**
 *
 * Pick Up In Store module
 * @extends React.Component<IPickUpInStoreProps<IPickUpInStoreData>>}
 */
@observer
class StoreSelector extends React.Component<IStoreSelectorProps<IStoreSelectorData>, IStoreSelectorState> {
    private autoSuggestManager: Microsoft.Maps.AutosuggestManager | undefined;
    private preferredStoreLocalStorageKey: string = '_msdyn365__preferredStore_';
    private telemetryContent: ITelemetryContent;

    constructor(props: IStoreSelectorProps<IStoreSelectorData>) {
        super(props);
        this.state = { isSearchInProgress: true, searchTerm: '', isSeeAllStoreValue: false };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
                                                   this.props.friendlyName,
                                                   this.props.telemetry);
    }

    public componentDidMount(): void {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: {
                        channel
                    }
                }
            },
            config: {
                autoSuggestionEnabled
            }
        } = this.props;

        this._getAndUpdateStoreLocation();

        reaction(
            () => this.props.data.storeSelectorStateManager.result && this.props.data.storeSelectorStateManager.result.isDialogOpen,
            () => {
                this._getAndUpdateStoreLocation();
            }
        );

        if (channel && !channel.BingMapsApiKey) {
            telemetry.error('BingMapsApiKey is missing.');
            return;
        }

        if (channel && !channel.BingMapsEnabled) {
            telemetry.error('Map is disabled from HQ.');
            return;
        }

        if (this.props.data.storeSelectorStateManager.result?.loadMapApi) {
            this.props.data.storeSelectorStateManager.result?.loadMapApi({
                key: channel?.BingMapsApiKey,
                lang: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode,
                market: this.props.context?.actionContext?.requestContext?.channel?.DefaultLanguageId
            }).then().catch();
        }

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.loadMapApi,
            () => {
                this.props.data.storeSelectorStateManager.result?.loadMapApi({
                    key: channel?.BingMapsApiKey,
                    lang: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode,
                    market: this.props.context?.actionContext?.requestContext?.channel?.DefaultLanguageId
                });
            }
        );

        if (autoSuggestionEnabled) {
            reaction(
                () => (!!(this.props.data.storeSelectorStateManager.result?.isMapApiLoaded && this.props.data.storeSelectorStateManager.result?.isDialogOpen)),
                async () => {
                    setTimeout(async () => {
                        await this._attachMapAutoSuggest();
                    },         0);
                }
            );
        }
    }

    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity
    public render(): JSX.Element {
        const {
            config: {
                termsOfServiceLink,
                className,
                heading,
                mode,
                style,
                setAsPreferredStore,
                showAllStores,
                lookupRadius
            },
            context: {
                telemetry,
                app: {
                    config: appConfig
                },
                actionContext: {
                    requestContext: {
                        channel,
                        cookies
                    }
                }
            },
            resources,
            data: {
                availabilitiesWithHours: { result: availabilitiesWithHours },
                storeSelectorStateManager: { result: storeSelectorStateManager },
                storeLocations: { result: storeLocations }
            }
        } = this.props;

        const isMapDisabled = (channel && channel.BingMapsApiKey && channel.BingMapsEnabled) ? false : true;
        const context = storeSelectorStateManager ? storeSelectorStateManager.context : undefined;
        const isDialogOpen: boolean = storeSelectorStateManager ? storeSelectorStateManager.isDialogOpen : false;
        const styleDefault = style !== undefined ? style : stylyEnum.dialog;
        const modeDefault = mode !== undefined ? mode : modeEnum.pickupInStore;
        const inlineView = styleDefault === stylyEnum.inline;
        const locatorView = modeDefault === modeEnum.findStores;
        const hideInventory = locatorView;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;
        const preferredStoreLocationId = storeSelectorStateManager?.preferredStoreLocationId || (Msdyn365.msdyn365Commerce.isBrowser ? window?.localStorage?.getItem('_msdyn365__preferredStore_') : '');
        const displayList = storeSelectorStateManager?.listMapViewState?.displayList;
        const isPreferredStoreEnabled = setAsPreferredStore && cookies?.isConsentGiven();

        const StoreSelectorActions = {
            toggleListMapViewState(): void {
                storeSelectorStateManager?.toggleListMapViewState();
            }
        };

        if (!(channel && channel.BingMapsApiKey)) {
            telemetry.error('BingMapsApiKey is missing.');
        }

        const configHeading = heading ? heading : locatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText;
        const preferredDistanceUnit = this.props.config.searchRadiusUnit === searchRadiusUnit.kilometers ? resources.kilometersShortText : resources.milesShortText;

        const viewProps = {
            ...(this.props as IStoreSelectorProps<IStoreSelectorData>),
            state: this.state,

            ModuleProps: {
                tag: inlineView ? 'div' as NodeTag : Modal,
                moduleProps: this.props,
                className: classname(`ms-store-${inlineView ? 'locate' : 'select'}`, className),
                autoFocus: true,
                fade: true,
                isOpen: isDialogOpen,
                onClosed: this._closeDialog,
                horizontalPosition: 'center',
                verticalPosition: 'center'
            },
            HeaderContainerProps: {
                tag: inlineView ? 'div' as NodeTag : ModalHeader,
                className: `ms-store-select__${inlineView ? 'header' : 'modal-header'}`,
                toggle: this._closeDialog
            },
            HeaderProps: configHeading && (
                <Msdyn365.Text
                    className='msc-modal__title'
                    {...configHeading}
                    tag={'h2'}
                    text={configHeading}
                    editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
                />
            ),
            FooterContainerProps: {
                tag: inlineView ? 'div' as NodeTag : ModalFooter,
                className: `ms-store-select__${inlineView ? 'footer' : 'modal-footer'} ${!displayList ? 'map-only-view' : ''}`
            },
            BodyContainerProps: {
                tag: inlineView ? 'div' as NodeTag : ModalBody,
                className: `ms-store-select__${inlineView ? 'body' : 'modal-body'}`
            },
            locationsMessage: !this.state.isLocationDisabled && (
                <StoreSelectorFoundLocationsMessage
                    resources={resources}
                    locations={hideInventory ? storeLocations : availabilitiesWithHours}
                    searchRadius={lookupRadius || 50}
                    preferredDistanceUnit={preferredDistanceUnit}
                    isSeeAllStore={this.state.isSeeAllStoreValue}
                />
            ),
            search: (
                <StoreSelectorSearchForm
                    value={this.state.searchTerm || ''}
                    resources={resources}
                    performSearch={this._performSearch}
                    searchTermChanged={this._searchTermChanged}
                    isMapDisabled={isMapDisabled}
                    showAllStores={showAllStores}
                    // tslint:disable-next-line:react-this-binding-issue jsx-no-lambda
                    onShowAllStores={() => this._getAndUpdateStoreLocation(true)}
                    onToggleListMapViewState={StoreSelectorActions.toggleListMapViewState}
                    displayList={displayList}
                    locatorView={locatorView}
                    telemetryContent={this.telemetryContent}
                />
            ),
            spinner: <StoreSelectorWaiting />,
            locationsList: ((availabilitiesWithHours && availabilitiesWithHours.length) || (storeLocations && storeLocations.length)) && (
                <StoreSelectorLocationLines
                    locations={hideInventory ? storeLocations : availabilitiesWithHours}
                    resources={resources}
                    preferredDistanceUnit={preferredDistanceUnit}
                    alreadySelectedLocation={context ? context.alreadySelectedLocation : undefined}
                    outOfStockThreshold={appConfig.outOfStockThreshold || 0}
                    enableOutOfStockCheck={appConfig.enableStockCheck || false}
                    onLocationSelected={this._onOrgUnitLocationSelected}
                    storeLocatorView={locatorView}
                    selectedStoreLocationId={selectedStoreLocationId}
                    onClick={this._setSelectedStore}
                    preferredStoreLocationId={preferredStoreLocationId}
                    onSetAsPreferredStore={this._setPreferredStore}
                    onRemovePreferredStore={this._removePreferredStore}
                    isPreferredStoreEnabled={isPreferredStoreEnabled}
                    displayList={displayList}
                    telemetryContent={this.telemetryContent}
                    isLocationDisabled={this.state.isLocationDisabled}
                />
            ),
            noLocationsMessage: <StoreSelectorEmptyMessage resources={resources} />,
            terms: <StoreSelectorTermsOfService link={termsOfServiceLink} onTextChange={this.handleLinkTextChange} requestContext={this.props.context.request} />,
            // Not being used in current context, we can use it here to pass more props.
            headerText: <span>{heading ? heading : locatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText}</span>,

            callbacks: {
                searchTermChanged: this._searchTermChanged,
                performSearch: this._performSearch,
                closeDialog: this._closeDialog,
                selectedLocation: this._onOrgUnitLocationSelected,
                getAndUpdateUserLocation: () => { this._getAndUpdateStoreLocation(); return Promise.resolve(); },
                attachMapAutoSuggest: this._attachMapAutoSuggest,
                onSuggestionSelected: this._onOrgUnitLocationSelected,
                setPreferredStore: this._setPreferredStore,
                removePreferredStore: this._removePreferredStore,
                setSelectedStore: this._setSelectedStore,
                setOrgUnitStoreInformation: this._setOrgUnitStoreInformation
            }
        } as IStoreSelectorViewProps;

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public handleLinkTextChange = (event: Msdyn365.ContentEditableEvent) => {
        if (this.props.config.termsOfServiceLink) {
            this.props.config.termsOfServiceLink.linkText = event.target.value;
        }
    };
    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent) => this.props.config.heading = event.target.value;

    private _attachMapAutoSuggest = async (): Promise<void> => {
        const {
            config: {
                autoSuggestOptions
            },
            context: {
                telemetry,
                actionContext: {
                    requestContext: {
                        channel
                    }
                }
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager?.isMapApiLoaded && !this.autoSuggestManager) {
            Microsoft.Maps.loadModule('Microsoft.Maps.AutoSuggest', {
                callback: () => {
                    const options = { ...autoSuggestOptions, countryCode: channel?.ChannelCountryRegionISOCode };
                    this.autoSuggestManager = new Microsoft.Maps.AutosuggestManager(options);
                    this.autoSuggestManager.attachAutosuggest('#ms-store-select__search-box', '#ms-store-select__search-box-container', this._onSuggestionSelected);
                },
                errorCallback: () => {
                    if (telemetry) {
                        telemetry.debug('Unable to attach map auto suggest.');
                    }
                },
                credentials: channel?.BingMapsApiKey
            });
        }
    }

    private _onSuggestionSelected = async (result: Microsoft.Maps.ISuggestionResult): Promise<void> => {
        await this._searchTermChanged(result.formattedSuggestion);
        await this._performSearch(result.formattedSuggestion);
    }

    private _setPreferredStore = async (storeId: string | undefined): Promise<void> => {
        const localStorage = Msdyn365.msdyn365Commerce.isBrowser ? window?.localStorage:  undefined;

        if (!storeId || !localStorage) {
            return;
        }

        const {
            context: {
                actionContext: {
                    requestContext: {
                        cookies
                    }
                }
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager || !cookies?.isConsentGiven()) { return; }

        localStorage.setItem(this.preferredStoreLocalStorageKey, storeId);
        await storeSelectorStateManager.setPreferredStoreLocationId(storeId);
    }

    private _removePreferredStore = async (): Promise<void> => {
        const localStorage = Msdyn365.msdyn365Commerce.isBrowser ? window?.localStorage:  undefined;

        if (!localStorage) {
            return;
        }

        const {
            context: {
                actionContext: {
                    requestContext: {
                        cookies
                    }
                }
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager || !cookies?.isConsentGiven()) { return; }

        localStorage.removeItem(this.preferredStoreLocalStorageKey);
        await storeSelectorStateManager.setPreferredStoreLocationId(undefined);
    }

    private _setSelectedStore = async (storeId: string | undefined): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!storeSelectorStateManager) { return; }

        await storeSelectorStateManager.setSelectedStoreLocationId(storeId);
    }

    private _performSearch = async (searchTerm: string): Promise<void> => {
        const {
            context: {
                actionContext
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (!searchTerm || !storeSelectorStateManager) {
            return;
        }

        this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });

        const location = await storeSelectorStateManager.geoLocate(searchTerm.trim() !== '' ? searchTerm : '0', actionContext);

        if (location) {
            await this._updateLocations(location.latitude, location.longitude);
        }

        this.setState({ isSearchInProgress: false });
    }

    private _searchTermChanged = async (searchTerm: string): Promise<void> => {
        this.setState({ searchTerm: searchTerm });
    }

    private _getAndUpdateStoreLocation = (showAllStores?: boolean): void => {
        const {
            config: {
                style
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        const styleDefault = style !== undefined ? style : stylyEnum.dialog;

        if (styleDefault !== stylyEnum.inline && (!storeSelectorStateManager || !storeSelectorStateManager.isDialogOpen)) {
            // Store selector dialog isn't open yet, so don't try and update anything
            return;
        }

        this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });

        if (navigator && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                async position => {
                    if (showAllStores) {
                        this.setState({ isSeeAllStoreValue: true });
                        await this._searchTermChanged('');
                        await this._updateLocations(position.coords.latitude, position.coords.longitude, 0);
                    } else {
                        await this._updateLocations(position.coords.latitude, position.coords.longitude);
                    }

                    this.setState({ isSearchInProgress: false });
                },
                async error => {
                    // If the location setting is turned off
                    if (error.PERMISSION_DENIED) {
                        this.setState({ isLocationDisabled: true });
                        if (showAllStores) {
                            this.setState({ isSeeAllStoreValue: true });
                            await this._searchTermChanged('');
                            await this._updateLocations(void 0, void 0, 0);
                        } else {
                            await this._updateLocations();
                        }
                    }

                    this.setState({ isSearchInProgress: false });
                },
                { timeout: 2000 }
            );
        } else {
            this.setState({ isSearchInProgress: false });
        }
    }

    private _closeDialog = async (): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        this.setState({ searchTerm: '' });

        if (storeSelectorStateManager) {
            return storeSelectorStateManager.closeDialog();
        }
    }

    private _setOrgUnitStoreInformation = async (orgUnitStoreInformation: IFullOrgUnitAvailability[]): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            },
            telemetry
        } = this.props;

        if (!storeSelectorStateManager) { return; }

        await storeSelectorStateManager.setOrgUnitStoreInformation({
            orgUnitStoreInformation,
            onLocationSelected: orgUnitLocation => {
                // TO-DO handle event for when location in selected
                return Promise.resolve();
            }
        })
            .catch((error: Error) => {
                if (telemetry) {
                    telemetry.error(error.message);
                    telemetry.debug('Unable to Update store location state');
                }
                return;
            });
        return;
    }

    private _updateLocations = async (latitude?: number, longitude?: number, radius?: number): Promise<void> => {
        const {
            telemetry,
            config: {
                mode,
                lookupRadius
            },
            context: {
                actionContext
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        const calRadius = (radius || radius === 0) ? radius : (lookupRadius || 50);
        const distanceUnitValue = this.props.config.searchRadiusUnit === searchRadiusUnit.kilometers ? 1 : 0;
        const modeDefault = mode !== undefined ? mode : modeEnum.pickupInStore;

        if (modeDefault === modeEnum.findStores) {
            const orgUnitLocationsInput = new GetOrgUnitLocationsByAreaInput(
                latitude,
                longitude,
                calRadius,
                distanceUnitValue,
                this.state.isLocationDisabled
            );

            const orgUnitLocations = await getOrgUnitLocationsByArea(orgUnitLocationsInput, actionContext);
            if (orgUnitLocations) {
                await this._setOrgUnitStoreInformation(orgUnitLocations);
                await this._setSelectedStore(undefined);
            }
            return;
        }

        if (!storeSelectorStateManager || !storeSelectorStateManager.context) {
            // Store selector dialog isn't open yet, so don't try and update anything
            return;
        }

        if (!storeSelectorStateManager.context.product) {
            // TODO: Use alternative search method here to not make inventory check
            return;
        }

        const input = new GetFullAvailableInventoryNearbyInput(
            storeSelectorStateManager.context.product.RecordId,
            latitude || 0,
            longitude || 0,
            calRadius,
            distanceUnitValue,
            this.state.isLocationDisabled
        );

        await getFullAvailableInventoryNearby(input, actionContext).catch((error) => {
            telemetry.warning(error);
            telemetry.error(error.message);
            telemetry.debug(`Unable to get full available inventory near by`);
        });
    }

    private _onOrgUnitLocationSelected = async (location: OrgUnitLocation | undefined): Promise<void> => {
        const {
            telemetry,
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager) {
            if (location && storeSelectorStateManager.context) {
                // Want to eat exceptions here so that the dialog still closes even if the onLocationSelected call goes wrong
                await storeSelectorStateManager.context.onLocationSelected(location).catch(error => {
                    telemetry.warning(error);
                    telemetry.error(error.message);
                    telemetry.debug(`Unable to get on org unit location selected`);
                });
            }

            await storeSelectorStateManager.closeDialog();
        }
    };
}

export default StoreSelector;

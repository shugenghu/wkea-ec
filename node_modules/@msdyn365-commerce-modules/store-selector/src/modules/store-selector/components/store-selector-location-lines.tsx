/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { IFullOrgUnitAvailability } from '@msdyn365-commerce-modules/retail-actions';
import { ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import { ItemAvailability, OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import { observable } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { IStoreSelectorResources } from '../store-selector.props.autogenerated';
import { IStoreSelectorLocationLineItemResources, StoreSelectorLocationLineItemComponent } from './store-selector-location-line-item';

export interface IStoreSelectorLocationLinesProps {
    locations?: IFullOrgUnitAvailability[];
    resources: IStoreSelectorResources;
    preferredDistanceUnit?: string;

    alreadySelectedLocation?: OrgUnitLocation;
    outOfStockThreshold: number;
    enableOutOfStockCheck: boolean;
    storeLocatorView?: boolean;
    selectedStoreLocationId?: string;
    isPreferredStoreEnabled?: boolean;
    displayList?: boolean;
    isLocationDisabled?: boolean;
    onClick: ((locationId: string | undefined) => void);
    preferredStoreLocationId: string | null;
    onSetAsPreferredStore: ((locationId: string | undefined) => void);
    onRemovePreferredStore: (() => void);
    /** The telemetry content */
    telemetryContent?: ITelemetryContent;
    onLocationSelected(location: OrgUnitLocation | undefined): void;
}

/**
 * Displays all the location line items, or null if none exists
 */
@observer
export class StoreSelectorLocationLines extends React.PureComponent<IStoreSelectorLocationLinesProps> {
    private selectedLocationRef: React.RefObject<HTMLDivElement>;

    @observable private _stores: IFullOrgUnitAvailability[] | undefined;

    constructor(props: IStoreSelectorLocationLinesProps) {
        super(props);
        this.selectedLocationRef = React.createRef();
    }

    public componentDidUpdate(prevProps: IStoreSelectorLocationLinesProps): void {
        if (this.props.selectedStoreLocationId !== prevProps.selectedStoreLocationId) {
            this._scrollIntoView();
        }
    }

    public componentDidMount(): void {
        if (this.props.locations) {
            this._stores = this._sortStores(this.props.locations);
        }
    }

    public render(): JSX.Element | null {
        if (!this._stores || this._stores.length === 0) {
            return null;
        }

        return (
            <div className={classnames('ms-store-select__locations', { show: this.props.displayList })} role='tablist'>
                {
                    this._stores.map((store, index) => {
                        return this._renderStoreLocation(store, index);
                    })
                }
            </div>
        );
    }

    private _renderStoreLocation(store: IFullOrgUnitAvailability, index: number): JSX.Element | undefined {
        const orgUnitLocation = store?.OrgUnitAvailability?.OrgUnitLocation;
        const selectedStoreLocationId = this.props.selectedStoreLocationId;
        return orgUnitLocation && (
            <div
                className={classnames('ms-store-select__location', { selected: selectedStoreLocationId === orgUnitLocation.OrgUnitNumber })}
                key={index}
                role='tab'
                // tslint:disable-next-line:jsx-no-lambda react-this-binding-issue
                onClick={() => this.props.onClick(orgUnitLocation.OrgUnitNumber)}
                ref={selectedStoreLocationId === orgUnitLocation.OrgUnitNumber ? this.selectedLocationRef : undefined}
            >
                <StoreSelectorLocationLineItemComponent
                    location={orgUnitLocation}
                    storeHours={store.StoreHours}
                    resources={this._mapResources(this.props.resources)}
                    preferredDistanceUnit= {this.props.preferredDistanceUnit!}
                    isCurrentLocation={this._isCurrentLocation(orgUnitLocation)}
                    isInStock={this._isProductInStock(store?.OrgUnitAvailability?.ItemAvailabilities)}
                    handlers={{ onSelected: this.props.onLocationSelected, onSetAsPreferredStore: this.props.onSetAsPreferredStore, onRemovePreferredStore:  this.props.onRemovePreferredStore}}
                    stockStatusLabel={this._stockInventoryLabel(store)}
                    storeLocatorView={this.props.storeLocatorView}
                    index={(index + 1).toString()}
                    preferredStoreLocationId={this.props.preferredStoreLocationId}
                    isPreferredStoreEnabled={this.props.isPreferredStoreEnabled}
                    telemetryContent={this.props.telemetryContent}
                    isLocationDisabled={this.props.isLocationDisabled}
                />
            </div>
        );
    }

    private _sortStores(stores: IFullOrgUnitAvailability[]): IFullOrgUnitAvailability[] {
        const isPreferredStore = (value: IFullOrgUnitAvailability) => this.props.isPreferredStoreEnabled && this.props.preferredStoreLocationId &&
            value?.OrgUnitAvailability?.OrgUnitLocation?.OrgUnitNumber === this.props.preferredStoreLocationId;

        return [
            ...stores.filter(isPreferredStore),
            ...stores.filter(store => !isPreferredStore(store))
        ];
    }

    private _scrollIntoView = () => {
        const selectedLocationDiv = this.selectedLocationRef.current;
        const parent = selectedLocationDiv?.parentElement;
        if (selectedLocationDiv && parent) {
            if (parent.scrollTop > selectedLocationDiv.offsetTop) {
                parent.scrollTop = selectedLocationDiv.offsetTop;
            } else if (selectedLocationDiv.offsetTop + selectedLocationDiv.clientHeight > parent.scrollTop + parent.clientHeight) {
                parent.scrollTop = selectedLocationDiv.offsetTop + selectedLocationDiv.clientHeight - parent.clientHeight;
            }
        }
    }

    private _isCurrentLocation = (location: OrgUnitLocation | undefined): boolean =>
        (this.props.alreadySelectedLocation && location && this.props.alreadySelectedLocation.OrgUnitNumber === location.OrgUnitNumber) || false;

    private _isProductInStock = (ItemAvailabilities: ItemAvailability[] | undefined): boolean => {
        if (!this.props.enableOutOfStockCheck) {
            return true;
        }

        if (ItemAvailabilities && ItemAvailabilities.length > 0) {
            return ItemAvailabilities[0].AvailableQuantity ? ItemAvailabilities[0].AvailableQuantity > 0 : false;
        }

        return false;
    };

    private _stockInventoryLabel = (availabilityWithHours: IFullOrgUnitAvailability | undefined): string | undefined => {
        if (availabilityWithHours?.ProductInventoryInformation
            && availabilityWithHours?.ProductInventoryInformation.length > 0) {
            for(let i=0; i<availabilityWithHours.ProductInventoryInformation.length; i++) {
                if(availabilityWithHours.OrgUnitAvailability?.OrgUnitLocation?.InventoryLocationId === availabilityWithHours.ProductInventoryInformation[i].InventLocationId) {
                    return availabilityWithHours.ProductInventoryInformation[i].StockLevelLabel;
                }

            }
        }

        return undefined;
    };

    private _mapResources = (resources: IStoreSelectorResources): IStoreSelectorLocationLineItemResources => {
        return {
            contactInfoHeader: resources.contactText,
            storeHoursHeader: resources.timeText,
            availabilityInfoHeader: resources.availabilityText,

            closedText: resources.storeHoursClosedText,
            outOfStock: resources.outOfStockText,
            inStock: resources.inStockText,

            currentLocation: resources.selectedStoreLocationText,
            selectLocation: resources.selectStoreText,
            selectLocationAriaLabelFormat: resources.selectStoreAriaFormatText,
            setAsPreferredStoreText: resources.setAsPreferredStoreText,
            setAsPreferredStoreTextAriaLabel: resources.setAsPreferredStoreTextAriaLabel,
            preferredStoreText: resources.preferredStoreText,
            preferredStoreAriaLabel: resources.preferredStoreAriaLabel,

            days: {
                monday: resources.storeHoursMondayText,
                tuesday: resources.storeHoursTuesdayText,
                wednesday: resources.storeHoursWednesdayText,
                thursday: resources.storeHoursThursdayText,
                friday: resources.storeHoursFridayText,
                saturday: resources.storeHoursSaturdayText,
                sunday: resources.storeHoursSundayText,
                mondayFull: resources.storeHoursMondayFullText,
                tuesdayFull: resources.storeHoursTuesdayFullText,
                wednesdayFull: resources.storeHoursWednesdayFullText,
                thursdayFull: resources.storeHoursThursdayFullText,
                fridayFull: resources.storeHoursFridayFullText,
                saturdayFull: resources.storeHoursSaturdayFullText,
                sundayFull: resources.storeHoursSundayFullText
            }
        };
    }
}
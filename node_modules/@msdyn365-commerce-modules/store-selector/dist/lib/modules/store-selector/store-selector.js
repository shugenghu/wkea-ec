import { __decorate } from "tslib";
import * as Msdyn365 from '@msdyn365-commerce/core';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { StoreSelectorEmptyMessage, StoreSelectorFoundLocationsMessage, StoreSelectorLocationLines, StoreSelectorSearchForm, StoreSelectorTermsOfService, StoreSelectorWaiting } from './components';
import { getFullAvailableInventoryNearby, GetFullAvailableInventoryNearbyInput, getOrgUnitLocationsByArea, GetOrgUnitLocationsByAreaInput } from '@msdyn365-commerce-modules/retail-actions';
import { getTelemetryObject, Modal, ModalBody, ModalFooter, ModalHeader } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
let StoreSelector = class StoreSelector extends React.Component {
    constructor(props) {
        super(props);
        this.preferredStoreLocalStorageKey = '_msdyn365__preferredStore_';
        this.handleLinkTextChange = (event) => {
            if (this.props.config.termsOfServiceLink) {
                this.props.config.termsOfServiceLink.linkText = event.target.value;
            }
        };
        this.handleHeadingChange = (event) => this.props.config.heading = event.target.value;
        this._attachMapAutoSuggest = async () => {
            const { config: { autoSuggestOptions }, context: { telemetry, actionContext: { requestContext: { channel } } }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (storeSelectorStateManager?.isMapApiLoaded && !this.autoSuggestManager) {
                Microsoft.Maps.loadModule('Microsoft.Maps.AutoSuggest', {
                    callback: () => {
                        const options = { ...autoSuggestOptions, countryCode: channel?.ChannelCountryRegionISOCode };
                        this.autoSuggestManager = new Microsoft.Maps.AutosuggestManager(options);
                        this.autoSuggestManager.attachAutosuggest('#ms-store-select__search-box', '#ms-store-select__search-box-container', this._onSuggestionSelected);
                    },
                    errorCallback: () => {
                        if (telemetry) {
                            telemetry.debug('Unable to attach map auto suggest.');
                        }
                    },
                    credentials: channel?.BingMapsApiKey
                });
            }
        };
        this._onSuggestionSelected = async (result) => {
            await this._searchTermChanged(result.formattedSuggestion);
            await this._performSearch(result.formattedSuggestion);
        };
        this._setPreferredStore = async (storeId) => {
            const localStorage = window?.localStorage;
            if (!storeId || !localStorage) {
                return;
            }
            const { context: { actionContext: { requestContext: { cookies } } }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (!storeSelectorStateManager || !cookies?.isConsentGiven()) {
                return;
            }
            localStorage.setItem(this.preferredStoreLocalStorageKey, storeId);
            await storeSelectorStateManager.setPreferredStoreLocationId(storeId);
        };
        this._removePreferredStore = async () => {
            const localStorage = window?.localStorage;
            if (!localStorage) {
                return;
            }
            const { context: { actionContext: { requestContext: { cookies } } }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (!storeSelectorStateManager || !cookies?.isConsentGiven()) {
                return;
            }
            localStorage.removeItem(this.preferredStoreLocalStorageKey);
            await storeSelectorStateManager.setPreferredStoreLocationId(undefined);
        };
        this._setSelectedStore = async (storeId) => {
            const { data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (!storeSelectorStateManager) {
                return;
            }
            await storeSelectorStateManager.setSelectedStoreLocationId(storeId);
        };
        this._performSearch = async (searchTerm) => {
            const { context: { actionContext }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (!searchTerm || !storeSelectorStateManager) {
                return;
            }
            this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });
            const location = await storeSelectorStateManager.geoLocate(searchTerm.trim() !== '' ? searchTerm : '0', actionContext);
            if (location) {
                await this._updateLocations(location.latitude, location.longitude);
            }
            this.setState({ isSearchInProgress: false });
        };
        this._searchTermChanged = async (searchTerm) => {
            this.setState({ searchTerm: searchTerm });
        };
        this._getAndUpdateStoreLocation = (showAllStores) => {
            const { config: { style }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            const styleDefault = style !== undefined ? style : "dialog";
            if (styleDefault !== "inline" && (!storeSelectorStateManager || !storeSelectorStateManager.isDialogOpen)) {
                return;
            }
            this.setState({ isSearchInProgress: true, isSeeAllStoreValue: false });
            if (navigator && navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async (position) => {
                    if (showAllStores) {
                        this.setState({ isSeeAllStoreValue: true });
                        await this._searchTermChanged('');
                        await this._updateLocations(position.coords.latitude, position.coords.longitude, 0);
                    }
                    else {
                        await this._updateLocations(position.coords.latitude, position.coords.longitude);
                    }
                    this.setState({ isSearchInProgress: false });
                }, async (error) => {
                    if (error.PERMISSION_DENIED) {
                        this.setState({ isLocationDisabled: true });
                        if (showAllStores) {
                            this.setState({ isSeeAllStoreValue: true });
                            await this._searchTermChanged('');
                            await this._updateLocations(void 0, void 0, 0);
                        }
                        else {
                            await this._updateLocations();
                        }
                    }
                    this.setState({ isSearchInProgress: false });
                }, { timeout: 2000 });
            }
            else {
                this.setState({ isSearchInProgress: false });
            }
        };
        this._closeDialog = async () => {
            const { data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            this.setState({ searchTerm: '' });
            if (storeSelectorStateManager) {
                return storeSelectorStateManager.closeDialog();
            }
        };
        this._setOrgUnitStoreInformation = async (orgUnitStoreInformation) => {
            const { data: { storeSelectorStateManager: { result: storeSelectorStateManager } }, telemetry } = this.props;
            if (!storeSelectorStateManager) {
                return;
            }
            await storeSelectorStateManager.setOrgUnitStoreInformation({
                orgUnitStoreInformation,
                onLocationSelected: orgUnitLocation => {
                    return Promise.resolve();
                }
            })
                .catch((error) => {
                if (telemetry) {
                    telemetry.error(error.message);
                    telemetry.debug('Unable to Update store location state');
                }
                return;
            });
            return;
        };
        this._updateLocations = async (latitude, longitude, radius) => {
            const { telemetry, config: { mode, lookupRadius }, context: { actionContext }, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            const calRadius = (radius || radius === 0) ? radius : (lookupRadius || 50);
            const distanceUnitValue = this.props.config.searchRadiusUnit === "kilometers" ? 1 : 0;
            const modeDefault = mode !== undefined ? mode : "pickupInStore";
            if (modeDefault === "findStores") {
                const orgUnitLocationsInput = new GetOrgUnitLocationsByAreaInput(latitude, longitude, calRadius, distanceUnitValue, this.state.isLocationDisabled);
                const orgUnitLocations = await getOrgUnitLocationsByArea(orgUnitLocationsInput, actionContext);
                if (orgUnitLocations) {
                    await this._setOrgUnitStoreInformation(orgUnitLocations);
                    await this._setSelectedStore(undefined);
                }
                return;
            }
            if (!storeSelectorStateManager || !storeSelectorStateManager.context) {
                return;
            }
            if (!storeSelectorStateManager.context.product) {
                return;
            }
            const input = new GetFullAvailableInventoryNearbyInput(storeSelectorStateManager.context.product.RecordId, latitude || 0, longitude || 0, calRadius, distanceUnitValue, this.state.isLocationDisabled);
            await getFullAvailableInventoryNearby(input, actionContext).catch((error) => {
                telemetry.warning(error);
                telemetry.error(error.message);
                telemetry.debug(`Unable to get full available inventory near by`);
            });
        };
        this._onOrgUnitLocationSelected = async (location) => {
            const { telemetry, data: { storeSelectorStateManager: { result: storeSelectorStateManager } } } = this.props;
            if (storeSelectorStateManager) {
                if (location && storeSelectorStateManager.context) {
                    await storeSelectorStateManager.context.onLocationSelected(location).catch(error => {
                        telemetry.warning(error);
                        telemetry.error(error.message);
                        telemetry.debug(`Unable to get on org unit location selected`);
                    });
                }
                await storeSelectorStateManager.closeDialog();
            }
        };
        this.state = { isSearchInProgress: true, searchTerm: '', isSeeAllStoreValue: false };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    componentDidMount() {
        const { context: { telemetry, actionContext: { requestContext: { channel } } }, config: { autoSuggestionEnabled } } = this.props;
        this._getAndUpdateStoreLocation();
        reaction(() => this.props.data.storeSelectorStateManager.result && this.props.data.storeSelectorStateManager.result.isDialogOpen, () => {
            this._getAndUpdateStoreLocation();
        });
        if (channel && !channel.BingMapsApiKey) {
            telemetry.error('BingMapsApiKey is missing.');
            return;
        }
        if (channel && !channel.BingMapsEnabled) {
            telemetry.error('Map is disabled from HQ.');
            return;
        }
        reaction(() => this.props.data.storeSelectorStateManager.result?.loadMapApi, () => {
            this.props.data.storeSelectorStateManager.result?.loadMapApi({
                key: channel?.BingMapsApiKey,
                lang: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode,
                market: this.props.context?.actionContext?.requestContext?.channel?.DefaultLanguageId
            });
        });
        if (autoSuggestionEnabled) {
            reaction(() => this.props.data.storeSelectorStateManager.result?.isMapApiLoaded, async () => {
                await this._attachMapAutoSuggest();
            });
        }
    }
    render() {
        const { config: { termsOfServiceLink, className, heading, mode, style, setAsPreferredStore, showAllStores, lookupRadius }, context: { telemetry, app: { config: appConfig }, actionContext: { requestContext: { channel, cookies } } }, resources, data: { availabilitiesWithHours: { result: availabilitiesWithHours }, storeSelectorStateManager: { result: storeSelectorStateManager }, storeLocations: { result: storeLocations } } } = this.props;
        const isMapDisabled = (channel && channel.BingMapsApiKey && channel.BingMapsEnabled) ? false : true;
        const context = storeSelectorStateManager ? storeSelectorStateManager.context : undefined;
        const isDialogOpen = storeSelectorStateManager ? storeSelectorStateManager.isDialogOpen : false;
        const styleDefault = style !== undefined ? style : "dialog";
        const modeDefault = mode !== undefined ? mode : "pickupInStore";
        const inlineView = styleDefault === "inline";
        const locatorView = modeDefault === "findStores";
        const hideInventory = locatorView;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;
        const preferredStoreLocationId = storeSelectorStateManager?.preferredStoreLocationId || window?.localStorage?.getItem('_msdyn365__preferredStore_');
        const displayList = storeSelectorStateManager?.listMapViewState?.displayList;
        const isPreferredStoreEnabled = setAsPreferredStore && cookies?.isConsentGiven();
        const StoreSelectorActions = {
            toggleListMapViewState() {
                storeSelectorStateManager?.toggleListMapViewState();
            }
        };
        if (!(channel && channel.BingMapsApiKey)) {
            telemetry.error('BingMapsApiKey is missing.');
        }
        const configHeading = heading ? heading : locatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText;
        const preferredDistanceUnit = this.props.config.searchRadiusUnit === "kilometers" ? resources.kilometersShortText : resources.milesShortText;
        const viewProps = {
            ...this.props,
            state: this.state,
            ModuleProps: {
                tag: inlineView ? 'div' : Modal,
                moduleProps: this.props,
                className: classname(`ms-store-${inlineView ? 'locate' : 'select'}`, className),
                autoFocus: true,
                fade: true,
                isOpen: isDialogOpen,
                onClosed: this._closeDialog,
                horizontalPosition: 'center',
                verticalPosition: 'center'
            },
            HeaderContainerProps: {
                tag: inlineView ? 'div' : ModalHeader,
                className: `ms-store-select__${inlineView ? 'header' : 'modal-header'}`,
                toggle: this._closeDialog
            },
            HeaderProps: configHeading && (React.createElement(Msdyn365.Text, Object.assign({ className: 'msc-modal__title' }, configHeading, { tag: 'h2', text: configHeading, editProps: { onEdit: this.handleHeadingChange, requestContext: this.props.context.request } }))),
            FooterContainerProps: {
                tag: inlineView ? 'div' : ModalFooter,
                className: `ms-store-select__${inlineView ? 'footer' : 'modal-footer'} ${!displayList ? 'map-only-view' : ''}`
            },
            BodyContainerProps: {
                tag: inlineView ? 'div' : ModalBody,
                className: `ms-store-select__${inlineView ? 'body' : 'modal-body'}`
            },
            locationsMessage: !this.state.isLocationDisabled && (React.createElement(StoreSelectorFoundLocationsMessage, { resources: resources, locations: hideInventory ? storeLocations : availabilitiesWithHours, searchRadius: lookupRadius || 50, preferredDistanceUnit: preferredDistanceUnit, isSeeAllStore: this.state.isSeeAllStoreValue })),
            search: (React.createElement(StoreSelectorSearchForm, { value: this.state.searchTerm || '', resources: resources, performSearch: this._performSearch, searchTermChanged: this._searchTermChanged, isMapDisabled: isMapDisabled, showAllStores: showAllStores, onShowAllStores: () => this._getAndUpdateStoreLocation(true), onToggleListMapViewState: StoreSelectorActions.toggleListMapViewState, displayList: displayList, locatorView: locatorView, telemetryContent: this.telemetryContent })),
            spinner: React.createElement(StoreSelectorWaiting, null),
            locationsList: ((availabilitiesWithHours && availabilitiesWithHours.length) || (storeLocations && storeLocations.length)) && (React.createElement(StoreSelectorLocationLines, { locations: hideInventory ? storeLocations : availabilitiesWithHours, resources: resources, preferredDistanceUnit: preferredDistanceUnit, alreadySelectedLocation: context ? context.alreadySelectedLocation : undefined, outOfStockThreshold: appConfig.outOfStockThreshold || 0, enableOutOfStockCheck: appConfig.enableStockCheck || false, onLocationSelected: this._onOrgUnitLocationSelected, storeLocatorView: locatorView, selectedStoreLocationId: selectedStoreLocationId, onClick: this._setSelectedStore, preferredStoreLocationId: preferredStoreLocationId, onSetAsPreferredStore: this._setPreferredStore, onRemovePreferredStore: this._removePreferredStore, isPreferredStoreEnabled: isPreferredStoreEnabled, displayList: displayList, telemetryContent: this.telemetryContent, isLocationDisabled: this.state.isLocationDisabled })),
            noLocationsMessage: React.createElement(StoreSelectorEmptyMessage, { resources: resources }),
            terms: React.createElement(StoreSelectorTermsOfService, { link: termsOfServiceLink, onTextChange: this.handleLinkTextChange, requestContext: this.props.context.request }),
            headerText: React.createElement("span", null, heading ? heading : locatorView ? resources.storeLocatorHeaderText : resources.storeSelectorHeaderText),
            callbacks: {
                searchTermChanged: this._searchTermChanged,
                performSearch: this._performSearch,
                closeDialog: this._closeDialog,
                selectedLocation: this._onOrgUnitLocationSelected,
                getAndUpdateUserLocation: () => { this._getAndUpdateStoreLocation(); return Promise.resolve(); },
                attachMapAutoSuggest: this._attachMapAutoSuggest,
                onSuggestionSelected: this._onOrgUnitLocationSelected,
                setPreferredStore: this._setPreferredStore,
                removePreferredStore: this._removePreferredStore,
                setSelectedStore: this._setSelectedStore,
                setOrgUnitStoreInformation: this._setOrgUnitStoreInformation
            }
        };
        return this.props.renderView(viewProps);
    }
};
StoreSelector = __decorate([
    observer
], StoreSelector);
export default StoreSelector;
//# sourceMappingURL=store-selector.js.map
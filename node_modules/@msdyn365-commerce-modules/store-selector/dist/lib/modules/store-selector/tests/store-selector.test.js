import { buildMockCoreContext, buildMockModuleProps } from '@msdyn365-commerce/core';
import { mount } from 'enzyme';
import { observable } from 'mobx';
import * as React from 'react';
import * as RetailActions from '../../../../../retail-actions';
import StoreSelector from '../store-selector';
const mockContext = buildMockCoreContext({
    app: {
        config: {
            outOfStockThreshold: 5,
            enableStockCheck: true
        }
    },
    actionContext: {
        requestContext: {
            channel: {
                BingMapsApiKey: '1001',
                BingMapsEnabled: true
            }
        }
    }
});
const mockData = {
    storeSelectorStateManager: {
        status: 'SUCCESS',
        result: {}
    },
    availabilitiesWithHours: {},
    storeLocations: {}
};
const mockConfig = {
    lookupRadius: 100,
    searchRadiusUnit: "kilometers"
};
const mockResources = {
    emptyLocationsText: 'No Nearby Locations',
    selectStoreText: 'Pick Up Here',
    selectStoreAriaFormatText: 'Pick Up At {StoreName}',
    timeText: 'Store Hours',
    captionText: 'Weâ€™re expanding our pick-up-in-store service to more Microsoft Store locations every day.',
    milesShortText: 'mi',
    kilometersShortText: 'mi',
    outOfStockText: 'Out of stock',
    inStockText: 'In Stock',
    selectedStoreLocationText: 'Selected store location',
    contactText: 'Contact',
    availabilityText: 'Availability',
    productDimensionTypeColor: 'Color',
    productDimensionTypeConfiguration: 'Configuration',
    productDimensionTypeSize: 'Size',
    productDimensionTypeStyle: 'Style',
    storeHoursClosedText: 'Closed',
    storeHoursMondayText: 'Mon',
    storeHoursTuesdayText: 'Tue',
    storeHoursWednesdayText: 'Wed',
    storeHoursThursdayText: 'Thur',
    storeHoursFridayText: 'Fri',
    storeHoursSaturdayText: 'Sat',
    storeHoursSundayText: 'Sun',
    storeHoursMondayFullText: 'Monday',
    storeHoursTuesdayFullText: 'Tuesday',
    storeHoursWednesdayFullText: 'Wednesday',
    storeHoursThursdayFullText: 'Thursday',
    storeHoursFridayFullText: 'Friday',
    storeHoursSaturdayFullText: 'Saturday',
    storeHoursSundayFullText: 'Sunday',
    storeAddressAriaLabel: 'Store address',
    storePhoneAriaLabel: 'Store phone',
    storeCountMessage: 'We found {count} stores within {radius} miles of you.',
    storeAllCountMessage: 'We found {count} stores.',
    storeCountMessageInKm: 'We found {count} stores within {radius} kilometers of you.',
    searchPlaceholderText: 'Search',
    searchInputAriaLabel: 'Search input',
    searchButtonAriaLabel: 'Search',
    storeSelectorHeaderText: 'Pick a store',
    storeLocatorHeaderText: 'Store Locator',
    seeAllStoresText: 'See all stores',
    setAsPreferredStoreText: 'Set as preferred store',
    setAsPreferredStoreTextAriaLabel: 'Set as preferred store',
    preferredStoreText: 'Preferred store',
    preferredStoreAriaLabel: 'Set as preferred store',
    viewMapText: 'View Map',
    viewListText: 'View List'
};
const stateManager = {
    listMapViewState: {
        displayList: true,
        displayMap: false
    },
    isMapApiLoaded: true,
    isDialogOpen: true,
    loadMapApi: jest.fn().mockResolvedValue(() => (input) => { return new Promise((resolve, reject) => { resolve(); }); })
};
describe('searchForm tests', () => {
    let moduleProps;
    beforeEach(() => {
        jest.clearAllMocks();
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockResolvedValue(undefined);
    });
    it('doesnt do search if dialog not open', () => {
        const mockDataNoStoreSelectorStateManager = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('does search when getAndUpdateUserLocation callback fired', async () => {
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };
        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        };
        jest.clearAllMocks();
        expect(viewProps.callbacks.getAndUpdateUserLocation());
        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalled();
    });
    it('does search if dialog open property changes', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        });
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        };
        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalled();
    });
    it('doesn\'t search if can\'t get location due to navigator not being found', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        });
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                failure('Error');
            })
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        };
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('doesn\'t search if getting location errors out', () => {
        const mockDataNoStoreSelectorStateManager = observable({
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        });
        window.navigator.geolocation = undefined;
        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        moduleProps.data.storeSelectorStateManager = {
            status: 'SUCCESS',
            result: {
                isDialogOpen: true,
                context: {
                    product: {
                        RecordId: 10
                    }
                }
            }
        };
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
});
describe('onDialogClosed tests', () => {
    let moduleProps;
    it('no-ops if no state manager', async () => {
        const mockDataNoStoreSelectorStateManager = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataNoStoreSelectorStateManager, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        await expect(viewProps.callbacks.closeDialog()).resolves.toBeUndefined();
    });
    it('calls closeDialog on state manager', async () => {
        const mockDataLocal = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    closeDialog: jest.fn()
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataLocal, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        await expect(viewProps.callbacks.closeDialog()).resolves.toBeUndefined();
        expect(mockDataLocal.storeSelectorStateManager.result.closeDialog).toBeCalled();
    });
});
describe('searchForm tests', () => {
    let moduleProps;
    beforeEach(() => {
        jest.clearAllMocks();
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockResolvedValue(undefined);
    });
    it('searchTermChanged callback updates state', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    geoLocate: jest.fn()
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        expect(result.state('searchTerm')).toEqual('');
        await expect(viewProps.callbacks.searchTermChanged('Seattle')).resolves.toBeUndefined();
        expect(result.state('searchTerm')).toEqual('Seattle');
    });
    it('search callback no-ops if no search term passed', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    geoLocate: jest.fn()
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('search callback no-ops if no state manager', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('search is disabled if missing BingMapsApiKey', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    geoLocate: jest.fn().mockResolvedValue(undefined)
                }
            },
        };
        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true
                }
            },
            actionContext: {
                requestContext: {
                    channel: {
                        BingMapsApiKey: undefined,
                        BingMapsEnabled: true
                    }
                }
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        expect(searchFormProps.isMapDisabled).toBe(true);
    });
    it('search callback skips future steps if no location returned by geoLocate', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    geoLocate: jest.fn().mockResolvedValue(undefined)
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        expect(searchFormProps.isMapDisabled).toBe(false);
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('search callback calls getFullAvailableInventoryNearby if location returned by geoLocate', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: 10, longitude: 15 })
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('   ')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(expect.objectContaining({
            latitude: 10,
            longitude: 15,
            radius: 100,
            productId: 25
        }), expect.anything());
    });
    it('search callback cleanly handles if getFullAvailableInventoryNearby throws', async () => {
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValueOnce('Fail');
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: 10, longitude: 15 })
                }
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(expect.objectContaining({
            latitude: 10,
            longitude: 15,
            radius: 100,
            productId: 25
        }), expect.anything());
    });
    it('search callback calls getFullAvailableInventoryNearby if location returned by geoLocate has expected default values', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    context: {
                        product: {
                            RecordId: 25
                        }
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                }
            },
        };
        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).toBeCalledWith(expect.objectContaining({
            latitude: 0,
            longitude: 0,
            radius: 50,
            productId: 25
        }), expect.anything());
    });
    it('search callback calls doesnt call getFullAvailableInventoryNearby if no product found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    context: {
                        product: undefined
                    },
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                }
            },
        };
        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
    });
    it('cleanly handles getFullAvailableInventoryNearby failure', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    geoLocate: jest.fn().mockResolvedValue({ latitude: undefined, longitude: undefined })
                }
            },
        };
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValueOnce('Fail');
        const localMockContext = buildMockCoreContext({
            app: {
                config: {
                    outOfStockThreshold: 5,
                    enableStockCheck: true,
                    lookupRadius: undefined
                }
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, {}, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.search).toBeDefined();
        const searchFormProps = viewProps.search.props;
        expect(searchFormProps).toBeDefined();
        await expect(searchFormProps.performSearch('sample')).resolves.toBeUndefined();
    });
});
describe('locationsList tests', () => {
    let moduleProps;
    it('locationsList is empty if no availabilitiesWithHours', async () => {
        const mockDataNoLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'FAILED',
                result: undefined
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataNoLocations, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).toBe(undefined);
    });
    it('locationsList is empty if availabilitiesWithHours is empty', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: []
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).toBe(undefined);
    });
    it('locationsList is not empty if availabilitiesWithHours is not empty', async () => {
        const mockDataValidLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataValidLocations, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        expect(locationLinesProps.outOfStockThreshold).toEqual(5);
        expect(locationLinesProps.enableOutOfStockCheck).toEqual(true);
        expect(locationLinesProps.alreadySelectedLocation).toBeUndefined();
    });
    it('Passes already selected location if present', async () => {
        const orgUnitLocation = {};
        const mockDataValidLocations = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    context: {
                        alreadySelectedLocation: orgUnitLocation
                    }
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataValidLocations, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        expect(locationLinesProps.alreadySelectedLocation).toEqual(orgUnitLocation);
    });
    it('locationsList is gets default values if not present in config', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        expect(locationLinesProps.outOfStockThreshold).toEqual(0);
        expect(locationLinesProps.enableOutOfStockCheck).toEqual(false);
    });
    it('locationsList onLocationSelected callback cleanly no-ops if no state found', async () => {
        const mockDataEmptyLocations = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'FAILED',
                result: undefined
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };
        moduleProps = {
            ...buildMockModuleProps(mockDataEmptyLocations, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await expect(locationLinesProps.onLocationSelected(undefined)).resolves.toBeUndefined();
    });
    it('locationsList onLocationSelected skips onLocationSelected but closes dialog if no context found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    closeDialog: jest.fn(),
                    context: undefined
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();
        expect(localMockData.storeSelectorStateManager.result.closeDialog).toBeCalled();
    });
    it('locationsList onLocationSelected calls onLocationSelected and closes dialog if context found', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    closeDialog: jest.fn(),
                    context: {
                        onLocationSelected: jest.fn().mockResolvedValue(undefined)
                    }
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();
        expect(localMockData.storeSelectorStateManager.result.closeDialog).toBeCalled();
        expect(localMockData.storeSelectorStateManager.result.context.onLocationSelected).toBeCalled();
    });
    it('locationsList onLocationSelected closes dialog even if onLocationSelected throws', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    closeDialog: jest.fn(),
                    context: {
                        onLocationSelected: jest.fn().mockRejectedValue('Fail')
                    }
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const localMockContext = {
            ...mockContext,
            app: {
                config: {}
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await expect(locationLinesProps.onLocationSelected('search')).resolves.toBeUndefined();
        expect(localMockData.storeSelectorStateManager.result.closeDialog).toBeCalled();
        expect(localMockData.storeSelectorStateManager.result.context.onLocationSelected).toBeCalled();
    });
});
describe('Map tests', () => {
    let moduleProps;
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('Doesn\'t load map script if BingMapsApiKey is missing', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    loadMapApi: jest.fn().mockResolvedValue(undefined)
                }
            },
        };
        const localMockContext = buildMockCoreContext({
            actionContext: {
                requestContext: {
                    channel: {
                        BingMapsApiKey: undefined,
                        BingMapsEnabled: true
                    }
                }
            },
            app: {
                config: {}
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(localMockData.storeSelectorStateManager.result?.loadMapApi).not.toBeCalled();
    });
    it('Doesn\'t load map script if Map in disabled in HQ', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    loadMapApi: jest.fn().mockResolvedValue(undefined)
                }
            },
        };
        const localMockContext = buildMockCoreContext({
            actionContext: {
                requestContext: {
                    channel: {
                        BingMapsApiKey: 'A1001',
                        BingMapsEnabled: false
                    }
                }
            },
            app: {
                config: {}
            }
        });
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(localMockData.storeSelectorStateManager.result?.loadMapApi).not.toBeCalled();
    });
    it('Attaches map autosuggest', async () => {
        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.callbacks.attachMapAutoSuggest());
        expect(result.exists('#ms-store-select__search-box'));
        expect(result.exists('#ms-store-select__search-box-container'));
    });
});
describe('Find stores test', () => {
    let moduleProps;
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('doesn\'t do inventory check but checks store locations only if findStore is passed in config', () => {
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValue(undefined);
        RetailActions.getOrgUnitLocationsByArea = jest.fn().mockResolvedValue(undefined);
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };
        const mockConfigFindStores = {
            mode: "findStores",
            style: "inline",
            lookupRadius: 100
        };
        moduleProps = {
            ...buildMockModuleProps(mockData, {}, mockConfigFindStores, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const mockLocation = {};
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.callbacks.getAndUpdateUserLocation());
        expect(RetailActions.getOrgUnitLocationsByArea).toBeCalled();
        expect(RetailActions.getFullAvailableInventoryNearby).not.toBeCalled();
        expect(viewProps.callbacks.setOrgUnitStoreInformation(mockLocation));
    });
    it('Sets preferred store', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setPreferredStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const mockConfigPreferredStore = {
            setAsPreferredStore: true,
            lookupRadius: 100
        };
        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    cookies: {
                        isConsentGiven: () => true
                    }
                }
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onSetAsPreferredStore('SEATTLE');
        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));
        expect(localMockData.storeSelectorStateManager.result.setPreferredStoreLocationId).toBeCalled();
    });
    it('Doesn\'t set preferred store if store id is undefined', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setPreferredStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const mockConfigPreferredStore = {
            setAsPreferredStore: true,
            lookupRadius: 100
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onSetAsPreferredStore(undefined);
        expect(viewProps.callbacks.setPreferredStore(undefined));
        expect(localMockData.storeSelectorStateManager.result.setPreferredStoreLocationId).not.toBeCalled();
    });
    it('Sets selected store', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setSelectedStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfig, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onClick('SEATTLE');
        expect(viewProps.callbacks.setSelectedStore('SEATTLE'));
        expect(localMockData.storeSelectorStateManager.result.setSelectedStoreLocationId).toBeCalled();
    });
    it('Sets preferred store', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setPreferredStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const mockConfigPreferredStore = {
            setAsPreferredStore: true,
            lookupRadius: 100
        };
        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    cookies: {
                        isConsentGiven: () => true
                    }
                }
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onSetAsPreferredStore('SEATTLE');
        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));
        expect(localMockData.storeSelectorStateManager.result.setPreferredStoreLocationId).toBeCalled();
    });
    it('Doesn\'t set preferred store if store id is undefined', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setPreferredStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const mockConfigPreferredStore = {
            setAsPreferredStore: true,
            lookupRadius: 100
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onSetAsPreferredStore(undefined);
        expect(viewProps.callbacks.setPreferredStore(undefined));
        expect(localMockData.storeSelectorStateManager.result.setPreferredStoreLocationId).not.toBeCalled();
    });
    it('Doesn\'t set preferred store if no cookie concent given', async () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: {
                    setPreferredStoreLocationId: jest.fn()
                }
            },
            availabilitiesWithHours: {
                status: 'SUCCESS',
                result: [{}]
            },
        };
        const mockConfigPreferredStore = {
            setAsPreferredStore: true,
            lookupRadius: 100
        };
        const localMockContext = {
            ...mockContext,
            actionContext: {
                requestContext: {
                    cookies: {
                        isConsentGiven: () => false
                    }
                }
            }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigPreferredStore, localMockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.locationsList).not.toBe(false);
        const locationLinesProps = viewProps.locationsList.props;
        expect(locationLinesProps).toBeDefined();
        await locationLinesProps.onSetAsPreferredStore('SEATTLE');
        expect(viewProps.callbacks.setPreferredStore('SEATTLE'));
        expect(localMockData.storeSelectorStateManager.result.setPreferredStoreLocationId).not.toBeCalled();
    });
});
describe('autosuggest enabled test cases', () => {
    let moduleProps;
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('should render correctly when autosuggest is enabled & store selector object is returned at server side.', () => {
        const localMockData = {
            ...mockData,
            storeSelectorStateManager: {
                status: 'SUCCESS',
                result: { ...stateManager }
            },
        };
        debugger;
        RetailActions.getFullAvailableInventoryNearby = jest.fn().mockRejectedValue(undefined);
        RetailActions.getOrgUnitLocationsByArea = jest.fn().mockResolvedValue(undefined);
        window.navigator.geolocation = {
            getCurrentPosition: jest.fn().mockImplementation((success, failure) => {
                success({
                    coords: {
                        latitude: 20,
                        longitude: 25
                    }
                });
            })
        };
        const mockConfigFindStores = {
            mode: "findStores",
            style: "inline",
            lookupRadius: 100,
            autoSuggestionEnabled: true,
            autoSuggestOptions: { maxResults: 5 }
        };
        moduleProps = {
            ...buildMockModuleProps(localMockData, {}, mockConfigFindStores, mockContext),
            resources: mockResources,
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); })
        };
        const result = mount(React.createElement(StoreSelector, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
    });
});
//# sourceMappingURL=store-selector.test.js.map
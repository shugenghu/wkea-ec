/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// tslint:disable:no-reference
/// <reference path="types/MicrosoftMaps/Microsoft.Maps.All.d.ts" />

import { IFullOrgUnitAvailability } from '@msdyn365-commerce-modules/retail-actions/dist/types/utilities/full-org-unit-availability';
import { IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import * as Msdyn365 from '@msdyn365-commerce/core';
import { OrgUnitLocation } from '@msdyn365-commerce/retail-proxy';
import classname from 'classnames';
import { observable, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { IMapData } from './map.data';
import { IMapProps, IPushpinOptionsData } from './map.props.autogenerated';

export interface IHeader {
    headerProps: INodeProps;
    heading: React.ReactNode;
}

export interface IMapViewProps extends IMapProps<IMapData> {
    ModuleProps: IModuleProps;
    Header: IHeader;
    MapProps: INodeProps;
    Map: Microsoft.Maps.Map | undefined;
}

/**
 *
 * Map component
 * @extends {React.Component<IMapProps<IMapData>>}
 */
@observer
class Map extends React.Component<IMapProps<IMapData>> {
    @observable public map: Microsoft.Maps.Map | undefined;
    private mapRef: React.RefObject<HTMLElement> = React.createRef<HTMLElement>();

    constructor(props: IMapProps<IMapData>) {
        super(props);
    }

    public componentDidMount(): void {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: {
                        channel
                    }
                }
            }
        } = this.props;

        if (channel && !channel.BingMapsApiKey) {
            telemetry.error('BingMapsApiKey is missing.');
            return;
        }

        if (channel && !channel.BingMapsEnabled) {
            telemetry.error('Map is disabled from HQ.');
            return;
        }

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.loadMapApi,
            () => {
                this.props.data.storeSelectorStateManager.result?.loadMapApi({
                    key: channel?.BingMapsApiKey,
                    lang: this.props.context?.actionContext?.requestContext?.channel?.ChannelCountryRegionISOCode,
                    market: this.props.context?.actionContext?.requestContext?.channel?.DefaultLanguageId
                });
            }
        );

        reaction(
            () => this.props.data.storeSelectorStateManager.result?.isMapApiLoaded,
            () => {
                this._initMap();
            }
        );

        reaction(
            () => {
                return [this.props.data.storeSelectorStateManager.result?.context?.orgUnitStoreInformation,
                this.props.data.storeSelectorStateManager.result?.selectedStoreLocationId,
                this.map];
            },
            async () => {
                this._updateMap();
            }
        );
    }

    public render(): JSX.Element | null {

        const {
            config: {
                heading,
                className
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        const displayMap = storeSelectorStateManager?.listMapViewState?.displayMap;

        const viewProps: IMapViewProps = {
            ...this.props,
            ModuleProps: {
                tag: 'div',
                moduleProps: this.props,
                className: classname('ms-map', { show: displayMap }, className)
            },
            Header: {
                headerProps: { className: 'ms-map__header' },
                heading: heading && heading.text && (
                    <Msdyn365.Text
                        className='ms-map__heading'
                        {...heading}
                        tag={heading.tag || 'h2'}
                        text={heading.text}
                        editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
                    />
                )
            },
            MapProps: {
                tag: 'div',
                className: 'ms-map__body',
                ref: this.mapRef
            },
            Map: this.map
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent) => this.props.config.heading!.text = event.target.value;

    private _initMap = () => {
        const {
            context: {
                actionContext: {
                    requestContext: {
                        channel
                    }
                }
            },
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;
        if (storeSelectorStateManager?.isMapApiLoaded) {

            this.map = new Microsoft.Maps.Map(this.mapRef.current as HTMLElement, {
                credentials: channel?.BingMapsApiKey,
                pushpinAccessible: true
            });
        }
    }

    private _updateMap = () => {
        const pushpinOptions = this.props.config.pushpinOptions;
        const storeSelectorStateManager = this.props.data.storeSelectorStateManager?.result;
        const orgUnitStoreInformation = storeSelectorStateManager?.context?.orgUnitStoreInformation;
        const selectedStoreLocationId = storeSelectorStateManager?.selectedStoreLocationId;

        if (this.map && orgUnitStoreInformation) {
            let mapLocation: OrgUnitLocation | undefined;
            this.map.entities.clear();
            const pushpins: Microsoft.Maps.IPrimitive[] = [];

            orgUnitStoreInformation.map((unitStoreInfo: IFullOrgUnitAvailability, index: number) => {
                const storeLocation = unitStoreInfo?.OrgUnitAvailability?.OrgUnitLocation;

                if (storeLocation?.Latitude && storeLocation.Longitude) {
                    const isSelectedLocation = selectedStoreLocationId === storeLocation.OrgUnitNumber;
                    const options = this._getPushpinOptions(isSelectedLocation, index, pushpinOptions);
                    const pushpin = new Microsoft.Maps.Pushpin(new Microsoft.Maps.Location(storeLocation.Latitude, storeLocation.Longitude), options);

                    Microsoft.Maps.Events.addHandler(pushpin, 'click', () => storeLocation.OrgUnitNumber && storeSelectorStateManager?.setSelectedStoreLocationId(storeLocation.OrgUnitNumber));

                    isSelectedLocation ? pushpins.unshift(pushpin) : pushpins.push(pushpin);

                    if (isSelectedLocation) {
                        mapLocation = storeLocation;
                    }
                }
            });

            if (mapLocation) {
                const currLocation = new Microsoft.Maps.Location(mapLocation.Latitude, mapLocation.Longitude);
                this.map.setView({ center: currLocation });
            } else {
                // Create a LocationRect from array of pushpins and set the map view.
                this.map.setView({
                    bounds: Microsoft.Maps.LocationRect.fromShapes(pushpins)
                });
            }

            this.map.setOptions({ pushpinAccessible: true });
            this.map?.entities.push(pushpins);
        }
    }

    private _getPushpinOptions = (isSelectedLocation: boolean, index: number, pushpinOptions?: IPushpinOptionsData) => {
        const text = pushpinOptions?.showIndex ? (index + 1).toString() : undefined;

        const size = pushpinOptions?.size || 1;
        const color = isSelectedLocation ? pushpinOptions?.selectionColor || pushpinOptions?.color : pushpinOptions?.color;
        const icon = this._getSvgIcon(size, color, text);

        return {
            // fallback if icon doesn't render properly
            color: isSelectedLocation ? pushpinOptions?.selectionColor : pushpinOptions?.color,
            icon: icon
        };
    }

    private _getSvgIcon = (size: number, color?: string, text?: string) => {
        const baseValue: number = 32;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${baseValue * size}" height="${baseValue * size}" viewBox="0 0 365 560">
                    <path fill="${color}" d="M182.9,551.7c0,0.1,0.2,0.3,0.2,0.3S358.3,283,358.3,194.6c0-130.1-88.8-186.7-175.4-186.9 C96.3,7.9,7.5,64.5,7.5,194.6c0,88.4,175.3,357.4,175.3,357.4S182.9,551.7,182.9,551.7z" />
                    ${text ? `<text x="185" y="280" style="font-size:220px;fill:#ffffff;" text-anchor="middle">${text}</text>` : ''}
                </svg>`;
    }
}

export default Map;

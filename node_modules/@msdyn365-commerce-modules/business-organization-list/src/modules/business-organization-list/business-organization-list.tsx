/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import * as React from 'react';

import { addOrganizationUser, AddOrganizationUserInput, deleteOrganizationUser, DeleteOrganizationUserInput, editOrganizationUser, EditOrganizationUserInput } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, Heading, IDataTableProps, IHeadingsProperty, IModuleProps, INodeProps, IPayLoad,
     ITableItemProps, ITableRowProps, ITelemetryContent, Table, TableDataType, TelemetryConstant } from '@msdyn365-commerce-modules/utilities';
import MsDyn365, { IRequestContext } from '@msdyn365-commerce/core';
import { BusinessPartnerUser } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import { computed, observable } from 'mobx';
import { observer } from 'mobx-react';
import { IBusinessOrganizationListData } from './business-organization-list.data';
import { IBusinessOrganizationListProps, IBusinessOrganizationListResources } from './business-organization-list.props.autogenerated';
import { FormButton, FormFieldError, FormInput, FormLabel, IBusinessFormItem, IUserFormItem } from './components';

export interface IBusinessOrganizationListViewProps extends IBusinessOrganizationListProps<IBusinessOrganizationListData> {
    OrganizationUserList: IModuleProps;
    moduleContainer: INodeProps;
    heading: React.ReactNode;
    noUsersText?: string;
    addUserButton?: React.ReactNode;
    search?: React.ReactNode;
    organizationListTable: React.ReactNode;
    form?: IFormViewProps;
    formItems?: IUserFormItem[];
    formType: FormType;
    deleteUserForm?: React.ReactNode;
    viewUserDetails?: React.ReactNode;
    modalHeading?: React.ReactNode;
    modalState?: boolean;
    toggleModal?(): void;
}

export interface IBusinessOrganizationListState {
    isReady: boolean;
    formItems: IUserFormItem[];
    isFormActive: boolean;
    formType: FormType;
    selectedUserData: BusinessPartnerUser;
    refresh: boolean;
    isModalOpen: boolean;
    hasFormError: boolean;
    hasActionError: boolean;
}

type GridSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

export enum FormType {
    None = 'NONE',
    Edit = 'EDIT',
    Remove = 'REMOVE',
    View = 'VIEW',
    Add = 'ADD'
}

export enum InputType {
    Text = 'text',
    Email = 'email'
}

export enum InputID {
    FirstName = 'FirstName',
    LastName = 'LastName',
    Email = 'Email',
    SpendingLimit = 'SpendingLimit',
    Status = 'Status',
    FullName = 'Name'
}

export interface IFormViewProps {
    modalClassName: string;
    FormWrapper: INodeProps;
    modalHeading?: string;
    modalDescription?: React.ReactNode;
    inputs?: IBusinessFormItem[];
    selectedUser?: BusinessPartnerUser;
    buttons?: React.ReactNode[];
    errorMessage?: React.ReactNode[];
    resources: IBusinessOrganizationListResources;
    toggle?(): void;
}

export const renderInputSection = (inputs: IUserFormItem[], className: string, onInputChange: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void): IBusinessFormItem[] => {
    return inputs.map((element) => {
        const { customClass, id, type, label, maxChars, isRequired, pattern, value, isDisabled } = element;

        return {
            wrapper: {
                className: classnames(className, id, customClass)
            },
            key: id,
            label: <FormLabel { ...{ id, forId: id, className, text: label }} />,
            errorMessage: <FormFieldError { ...{ className: className, type: 'item' }} />,
            input: (
                <FormInput
                    {
                    ...{
                            id: id,
                            type: type,
                            maxLength: maxChars,
                            pattern: pattern,
                            value: value,
                            className: className,
                            isRequired: isRequired === undefined ? false : isRequired,
                            onChange: onInputChange,
                            isDisabled: isDisabled
                        }
                    }
                />
            )
        };
    });
};

/**
 *
 * BusinessOrganizationList component
 * @extends {React.PureComponent<IBusinessOrganizationListProps<IBusinessOrganizationListData>>}
 */
@observer
class BusinessOrganizationList extends React.Component<IBusinessOrganizationListProps<IBusinessOrganizationListData>,IBusinessOrganizationListState> {
    public BusinessFormDefaultInputs: IUserFormItem[] = [
        {
            id: InputID.FirstName,
            type: InputType.Text,
            label: this.props.resources.firstNameLabelText,
            value: '',
            isRequired: true,
            customClass: 'width-50'
        },
        {
            id: InputID.LastName,
            type: InputType.Text,
            label: this.props.resources.lastNameLabelText,
            value: '',
            isRequired: true,
            customClass: 'width-50'
        },
        {
            id: InputID.Email,
            type: InputType.Email,
            label: this.props.resources.emailAddressLabelText,
            value: '',
            isRequired: true,
            pattern: '^[a-zA-Z0-9.!#$%&\'^_`{}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$',
            customClass: 'width-100'
        },
        {
            id: InputID.SpendingLimit,
            type: InputType.Text,
            label: this.props.resources.spendingLimitLabelText,
            value: '',
            isRequired: true,
            customClass: 'width-50'
        },
    ];

    private moduleClassName: string = 'ms-business-organization-list';
    private mobileExcludedColumns: string[];

    @observable
    private _viewport: GridSize;
    @computed get isMobile(): boolean {
        return (this._viewport === 'xs' || this._viewport === 'sm');
    }
    private telemetryContent?: ITelemetryContent;
    private payLoad: IPayLoad;

    constructor(props: IBusinessOrganizationListProps<IBusinessOrganizationListData>) {
        super(props);
        this._toggleModal = this._toggleModal.bind(this);
        this._onInputChange = this._onInputChange.bind(this);
        this._handleRemoveUserButton = this._handleRemoveUserButton.bind(this);

        this.mobileExcludedColumns = [InputID.Email, InputID.Status, InputID.SpendingLimit];
        this._viewport = props.context.request && props.context.request.device && props.context.request.device.Type === 'Mobile' ? 'xs' : 'lg';
        this._updateViewport = this._updateViewport.bind(this);

        this.state = {
            isReady: false,
            formItems: this.BusinessFormDefaultInputs,
            isFormActive: false,
            formType: FormType.None,
            selectedUserData: {Email: ''},
            refresh: true,
            isModalOpen: false,
            hasFormError: false,
            hasActionError: false
        };

        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
        this.payLoad = getPayloadObject('click', this.telemetryContent, '');
        this._updateViewport();
    }

    public componentDidMount(): void {
        if (MsDyn365.isBrowser && window.addEventListener) {
            window.addEventListener('resize', this._updateViewport);
            this._updateViewport();
        }
    }

    public componentWillUnmount(): void {
        if (MsDyn365.isBrowser && window.removeEventListener) {
            window.removeEventListener('resize', this._updateViewport);
        }
    }

    public render(): JSX.Element | null {
        const { config, resources, data: { users } } = this.props;
        const { className, heading } = config;
        const { addUserButtonText, loadingMessage, emptyListMessage, errorGettingUsersMessage } = resources;
        const { formItems, isFormActive, formType, isModalOpen } = this.state;

        const hasUsers = users && users.result && users.result.length > 0;
        this.payLoad.contentAction.etext = TelemetryConstant.AddUser;
        const addUserAttributes = getTelemetryAttributes(this.telemetryContent!, this.payLoad);

        if (!hasUsers) {
            let errorMessage = '';
            if (users.status === 'LOADING') {
                errorMessage = loadingMessage;
            } else if (users.status === 'FAILED') {
                errorMessage = errorGettingUsersMessage;
            } else if (users.result && users.result.length === 0) {
                errorMessage = emptyListMessage;
            }

            const errorProps = {
                ...this.props,
                className: className,
                OrganizationUserList: {
                    moduleProps: this.props,
                    className: classnames(this.moduleClassName, className)
                },
                moduleContainer: {
                    className: `${this.moduleClassName}__container`
                },
                heading: heading && <Heading className={`${this.moduleClassName}__heading`} headingTag={heading.tag} text={heading.text} />,
                addUserButton: <Button className={`${this.moduleClassName}__add-user-button`} onClick={this._handleAddUserButtonClicked} {...addUserAttributes} >{addUserButtonText}</Button>,
                noUsersText: <p className={`${this.moduleClassName}__error-message`}>{errorMessage}</p>
            };

            return this.props.renderView(errorProps) as React.ReactElement;
        }

        const viewProps = {
            ...this.props,
            className: className,
            OrganizationUserList: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, className)
            },
            moduleContainer: {
                className: `${this.moduleClassName}__container`
            },
            heading: heading && <Heading className={`${this.moduleClassName}__heading`} headingTag={heading.tag} text={heading.text} />,
            modalState: isModalOpen,
            addUserButton: <Button className={`${this.moduleClassName}__add-user-button`} onClick={this._handleAddUserButtonClicked} {...addUserAttributes} >{addUserButtonText}</Button>,
            organizationListTable: <Table {...this._createTableProps()} />,
            toggleModal: this._toggleModal,
            formType: formType,
            form: isFormActive && isModalOpen && (formType === FormType.Add || formType === FormType.Edit) ? this._renderUserForm() : this._renderUserDetails(),
            formItems: formItems
        } as IBusinessOrganizationListViewProps;

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    // _createTableProps: creates the props for the organization list table
    private _createTableProps(): IDataTableProps {
        const { config, resources, context } = this.props;
        const { tableSort, showPagination, paginationItemPerPage } = config;
        const { paginationNextButtonText, paginationPreviousButtonText, editButtonText, deleteButtonText, actionButtonText, paginationAriaLabel  } = resources;

        const tableData = this._createTableItems();
        const tableHeading = tableData.length > 0 && tableData[0].row.map((item) => {
            if (this.isMobile && this.mobileExcludedColumns.includes(item.id)) {
                return;
            } else {
                return {
                    name: item.id,
                    sortable: tableSort && tableSort || false
                } as IHeadingsProperty;
            }
        }) || [];

        return {
            resources: resources,
            headings: tableHeading,
            rows: tableData,
            className: `${this.moduleClassName}__table`,
            editLinkText: this.isMobile ? editButtonText : '', // '' === showing just icon
            deleteLinkText: this.isMobile ? deleteButtonText : '', // '' === showing just icon
            viewLinkText: 'View details',
            enableToModify: true,
            actionLinkText: actionButtonText,
            showCheckBoxes: false,
            isSortable: tableSort,
            showPagination: showPagination,
            minifyActions: this.isMobile,
            excludedColumns: this.isMobile ? this.mobileExcludedColumns : [],
            paginationProperty: {
                skipCount: context && context.request && context.request.query && context.request.query.skip && !isNaN(parseInt(context.request.query.skip, 10)) ? parseInt(context.request.query.skip, 10) : 0,
                itemPerPage: paginationItemPerPage || 10,
                prevText: paginationPreviousButtonText,
                nextText: paginationNextButtonText,
                paginationText: paginationAriaLabel,
                url: context && this._getCurrentUrl(context.request).href || ''
            },
            actions: {
                onDelete: this._handleDeleteIcon,
                onEdit: this._handleEditIcon,
                onView: this.isMobile && this._handleViewDetails || undefined
            },
            formatPrice: this._formatPrice
        };
    }

    // _createTableItems: converts users recieved from the data-action(IBusinessParterUser[]) to tableRows(ITableItemProps[])
    private _createTableItems(): ITableRowProps[] {
        const { resources, data: { users } } = this.props;
        const { activeStatusText, pendingStatusText, removedStatusText } = resources;
        const usersList = users && users.result;

        if (!usersList || usersList.length === 0) {
            return [];
        }

        return usersList.map((user) => {
            let statusString = '';

            switch(user.StatusValue) {
                case 0:
                    statusString = pendingStatusText;
                    break;
                case 1:
                    statusString = activeStatusText;
                    break;
                case 2:
                default:
                    statusString = removedStatusText;
            }

            return {
                row: [
                    {
                        id: InputID.FullName,
                        type: TableDataType.Text,
                        value: `${user.FirstName} ${user.LastName}`
                    },
                    {
                        id: InputID.Email,
                        type: TableDataType.Text,
                        value: user.Email
                    },
                    {
                        id: InputID.Status,
                        type: TableDataType.Text,
                        value: statusString
                    },
                    {
                        id: InputID.SpendingLimit,
                        type: TableDataType.Price,
                        value: user.SpendingLimit || 0
                    }
                ]
            };
        });
    }

    // _toggleModal: closes the modal and resets the form states
    private _toggleModal():void {
        this.setState({
            isModalOpen: false,
            isFormActive: false,
            formType: FormType.None
        });
    }

    // _handleAddUserButtonClicked: resets input fields, opens the modal, and sets the form states
    private _handleAddUserButtonClicked = () => {
        // reset form
        const newForm = this.state.formItems;
        newForm.forEach((input) => {
            if (input.id === InputID.Email) {
                // make sure email input is re enabled (it gets disabled when admin is editing user)
                input.isDisabled = false;
            }

            input.value = '';
        });

        this.setState({
            formItems: newForm,
            isFormActive: true,
            formType: FormType.Add,
            isModalOpen: true,
            hasFormError: false,
            hasActionError: false
        });
    }

    // _handleAddEditFormSaveButton: triggered on the save button for both add/edit forms. Calls the appropriate data-action and reloads the page when successful
    private _handleAddEditFormSaveButton = async () => {
        const { context } = this.props;
        const { formType, formItems } = this.state;

        const updatedUser = this._createBusinessPartner(formItems);

        if (formType === FormType.Edit) {
            editOrganizationUser(new EditOrganizationUserInput(updatedUser), context.actionContext)
                .then(() => {
                    window.location.reload(false);
                })
                .catch(error => {
                    context.telemetry.trace(error);
                    this.setState({
                        hasActionError: true
                    });
                });
        } else {
            addOrganizationUser(new AddOrganizationUserInput(updatedUser), context.actionContext)
                .then(() => {
                    window.location.reload(false);
                })
                .catch(error => {
                    context.telemetry.trace(error);
                    this.setState({
                        hasActionError: true
                    });
                });
        }
    }

    // _createBusinessPartner: attempts to convert input values(IUserFormItem) to a new user(BusinessPartnerUser)
    private _createBusinessPartner = (inputs: IUserFormItem[]): BusinessPartnerUser => {
        const newUser: BusinessPartnerUser = {
            Email: ''  // email is required field
        };

        inputs.forEach((input) => {
            // deals with input values need need to be converted into numbers
            if (input.id === InputID.SpendingLimit) {
                newUser[input.id] = parseFloat(input.value) || 0;
            } else {
                newUser[input.id] = input.value;
            }
        });

        return newUser;
    }

    // _handleFormCancelButton: closes the modal when clicking the Cancel button
    private _handleFormCancelButton = () => {
        this.setState({
            isFormActive: false,
            isModalOpen: false,
            formType: FormType.None
        });
    }

    // _handleEditIcon: converts the table row data(ITableItemProps[]) to input fields(IUserFormItem) and opens the edit form
    private _handleEditIcon = (userData: ITableItemProps[]) => {
        // split full name into first and last
        const possibleName = userData.find(cell => {return cell.id === 'Name';});
        const fullName = possibleName && possibleName.value as string || '';
        const lastSpaceIndex = fullName.lastIndexOf(' ');
        const firstName = fullName.substring(0, lastSpaceIndex);
        // tslint:disable-next-line:restrict-plus-operands
        const lastName = fullName.substring(lastSpaceIndex + 1);

        // create clone of formItems, map users information, update state
        const { formItems } = this.state;
        const newForm = formItems;

        newForm.forEach(input => {
            switch (input.id) {
                case InputID.FirstName:
                    input.value = firstName;
                    break;
                case InputID.LastName:
                    input.value = lastName;
                    break;
                case InputID.Email: // email can never be null/undefined as it is a required field
                    input.isDisabled = true;
                    const possibleCell = userData.find(cell => {return input.id === cell.id;});
                    input.value = possibleCell && possibleCell.value as string || '';
                    break;
                default:
                    const dataCell = userData.find(cell => {return input.id === cell.id;});
                    input.value = dataCell && dataCell.value as string || '';
            }
        });

        this.setState({
            formItems: newForm,
            isFormActive: true,
            formType: FormType.Edit,
            isModalOpen: true,
            hasFormError: false,
            hasActionError: false
        });
    }

    // _handleDeleteIcon: opens removeUser confirmation window
    private _handleDeleteIcon = (userData: ITableItemProps[]) => {
        const newUser: BusinessPartnerUser = {
            Email: ''
        };

        userData.forEach((cell: ITableItemProps) => {
            if (cell.id === 'Name') {
                // split full name into first and last
                const fullName = cell.value as string;
                const lastSpaceIndex = fullName.lastIndexOf(' ');
                newUser.FirstName = fullName.substring(0, lastSpaceIndex);
                // tslint:disable-next-line
                newUser.LastName = fullName.substring(lastSpaceIndex + 1);
            } else if (cell.type === TableDataType.Price) {
                newUser[cell.id] = this.props.context.cultureFormatter.formatCurrency(cell.value as string);
            } else {
                newUser[cell.id] = cell.value;
            }
        });

        this.setState({
            selectedUserData: newUser,
            formType: FormType.Remove,
            isModalOpen: true,
            isFormActive: false
        });
    }

    // _handleViewDetails: opens user details window
    private _handleViewDetails = (userData: ITableItemProps[]) => {
        const newUser: BusinessPartnerUser = {
            Email: ''
        };

        userData.forEach((cell: ITableItemProps) => {
            if (cell.id === 'Name') {
                // split full name into first and last
                const fullName = cell.value as string;
                const lastSpaceIndex = fullName.lastIndexOf(' ');
                newUser.FirstName = fullName.substring(0, lastSpaceIndex);
                // tslint:disable-next-line
                newUser.LastName = fullName.substring(lastSpaceIndex + 1);
            } else if (cell.type === TableDataType.Price) {
                newUser[cell.id] = this.props.context.cultureFormatter.formatCurrency(cell.value as string);
            } else {
                newUser[cell.id] = cell.value;
            }
        });

        this.setState({
            selectedUserData: newUser,
            formType: FormType.View,
            isModalOpen: true,
            isFormActive: false
        });
    }

    // _handleRemoveUserButton: triggered on confirmation of removing a user.
    private _handleRemoveUserButton = (records: BusinessPartnerUser) => {
        // TODO
        const { context } = this.props;
        const { selectedUserData: deleteUserData } = this.state;

        if (deleteUserData) {
            deleteOrganizationUser(new DeleteOrganizationUserInput(deleteUserData), context.actionContext)
                .then(() => {
                    window.location.reload(false);
                })
                .catch((error) => {
                    context.telemetry.trace(error);
                });
        }
        this.setState({
            formType: FormType.None,
            isModalOpen: false
        });
    }

    // _renderUserDetails: creates the remove/view form props
    private _renderUserDetails(): IFormViewProps {
        const { resources } = this.props;
        const { formType, selectedUserData } = this.state;
        const { removeModalHeaderText, removeModalDescription, viewModalHeaderText, cancelButtonText, cancelRemoveUserButtonText, removeUserButtonText, errorUpdatingUsersMessage } = resources;

        const formClassName = `${this.moduleClassName}__form`;
        const typeClassName = formType === FormType.Remove ? 'type-remove' : 'type-view';
        const handleRemoveButton = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => { this._handleRemoveUserButton(selectedUserData); };

        return {
            modalClassName: classnames(`${this.moduleClassName}__modal`, typeClassName),
            FormWrapper: {
                className: formClassName
            },
            modalHeading: formType === FormType.Remove ? removeModalHeaderText : viewModalHeaderText,
            modalDescription: formType === FormType.Remove && <p className={`${formClassName}-description`}>{removeModalDescription}</p>,
            selectedUser: selectedUserData,
            buttons: [
                // tslint:disable-next-line:react-this-binding-issue
                formType === FormType.Remove && <Button key={'action-remove'} className={`${formClassName}-remove-user-button`} onClick={handleRemoveButton}>{removeUserButtonText}</Button>,
                <Button key={'action-cancel'} className={`${formClassName}-cancel`} onClick={this._handleFormCancelButton}>{formType === FormType.Remove ? cancelRemoveUserButtonText : cancelButtonText}</Button>
            ],
            errorMessage: [
                <FormFieldError key='fieldIncorrect' id='fieldIncorrect' className={`${formClassName}-error`} message={errorUpdatingUsersMessage}/>,
            ],
            resources: resources
        };
    }

    // _renderUserForm: creates the add/edit form props
    private _renderUserForm(): IFormViewProps {
        const { resources } = this.props;
        const { formType, formItems, hasFormError, hasActionError, isReady } = this.state;
        const { editUserFormHeadingText, addUserFormHeadingText, saveButtonArialabel, saveButtonText, cancelButtonArialabel, cancelButtonText, fieldIncorrectErrorText, actionErrorText, allFieldsRequiredMessage } = resources;

        const formClassName = `${this.moduleClassName}__form`;
        const typeClassName = formType === FormType.Add ? 'type-add' : 'type-edit';

        return {
            modalClassName: classnames(`${this.moduleClassName}__modal`, typeClassName),
            FormWrapper: {
                className: formClassName
            },
            modalHeading: formType === FormType.Add ? addUserFormHeadingText : editUserFormHeadingText,
            modalDescription: formType === FormType.Add && <p className={`${formClassName}-all-required-msg`}>{allFieldsRequiredMessage}</p>,
            inputs: renderInputSection(formItems, `${formClassName}-item`, this._onInputChange),
            buttons: [
                (
                    <FormButton
                        key='continue'
                        id='continue'
                        className={`${formClassName}-save`}
                        ariaLabel={saveButtonArialabel}
                        text={saveButtonText}
                        onClick={this._handleAddEditFormSaveButton}
                        disabled={!isReady}
                        telemetryContent={this.telemetryContent}
                    />),
                <FormButton key='cancel' id='cancel' className={`${formClassName}-cancel`} ariaLabel={cancelButtonArialabel} text={cancelButtonText} onClick={this._handleFormCancelButton} telemetryContent={this.telemetryContent}/>
            ],
            errorMessage: [
                hasFormError && <FormFieldError key='fieldIncorrect' id='fieldIncorrect' className={this.moduleClassName} message={fieldIncorrectErrorText}/>,
                hasActionError && <FormFieldError key='fieldIncorrect' id='fieldIncorrect' className={this.moduleClassName} message={actionErrorText}/>
            ],
            resources: resources
        };
    }

    // _onInputChange: updates the fomrItems state on every input change
    private _onInputChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
        const newForm = this.state.formItems;

        newForm.forEach(item => {
            if (item.id === event.target.id) {
                item.value = event.target.value;
            }
        });

        // update state object with latest values and check if form is ready
        // TODO: remove !refresh
        this.setState((prev) => ({
            refresh: !prev.refresh,
            isReady: this._isFormReady(),
            formItems: newForm,
            hasFormError: false,
            hasActionError: false
        }));
    }

    // _isFormReady: checks whether the current values in the input fields are valid for submission, this will also disable/enable the submit button.
    private _isFormReady = (): boolean => {
        const { formItems } = this.state;

        for (let i = 0; i < formItems.length; i++) {
            // will return TRUE if:
            //  - input field is required and EMPTY
            //  OR
            //  - pattern provided and value does not match pattern
            //  OR
            //  - if spendingLimit input --> make sure value can be parsed into an NUMBER
            if ((formItems[i].isRequired && formItems[i].value.length < 1)) {
                return false;
            } else if (formItems[i].pattern !== undefined && formItems[i].value.match(formItems[i].pattern as string) === null) {
                return false;
            } else if (formItems[i].id === InputID.SpendingLimit && isNaN(parseFloat(formItems[i].value))) {
                this.setState({
                    hasFormError: true
                });
                return false;
            }
        }

        return true;
    }

    private _formatPrice = (price: number): string => {
        return this.props.context.cultureFormatter ? this.props.context.cultureFormatter.formatCurrency(price) : price.toString();
    }

    private _getCurrentUrl = (reqContext: IRequestContext): URL=> {
        if (MsDyn365.isBrowser) {
            return new URL(window.location.href);
        } else {
            // NOTE: Typing on requestURL is incorrect
            if (reqContext.url.requestUrl.href) {
                return new URL(reqContext.url.requestUrl.href);
            } else {
                return new URL(reqContext.url.requestUrl.href);
            }
        }
    }

    private _updateViewport(): void {
        this._viewport = this._getViewport();
    }

    private _getViewport = (): GridSize => {
        const { context } = this.props;

        // always render in mobile viewport on a mobile device
        if (context.request && context.request.device && context.request.device.Type === 'Mobile') {
            return 'xs';
        }

        if (typeof window !== undefined && window.innerWidth) {
            const gridSettings = context.request.gridSettings;
            if (gridSettings) {
                if (gridSettings.xs && window.innerWidth <= gridSettings.xs.w) {
                    return 'xs';
                } else if (gridSettings.sm && window.innerWidth <= gridSettings.sm.w) {
                    return 'sm';
                } else if (gridSettings.md && window.innerWidth <= gridSettings.md.w) {
                    return 'md';
                } else if (gridSettings.lg && window.innerWidth <= gridSettings.lg.w) {
                    return 'lg';
                } else {
                    return 'xl';
                }
            }
        }

        return 'xs';
    }
}

export default BusinessOrganizationList;

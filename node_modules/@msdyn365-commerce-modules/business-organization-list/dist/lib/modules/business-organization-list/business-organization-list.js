import { __decorate } from "tslib";
import * as React from 'react';
import { addOrganizationUser, AddOrganizationUserInput, deleteOrganizationUser, DeleteOrganizationUserInput, editOrganizationUser, EditOrganizationUserInput } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, Heading, Table, TableDataType, TelemetryConstant } from '@msdyn365-commerce-modules/utilities';
import MsDyn365 from '@msdyn365-commerce/core';
import classnames from 'classnames';
import { computed, observable } from 'mobx';
import { observer } from 'mobx-react';
import { FormButton, FormFieldError, FormInput, FormLabel } from './components';
export var FormType;
(function (FormType) {
    FormType["None"] = "NONE";
    FormType["Edit"] = "EDIT";
    FormType["Remove"] = "REMOVE";
    FormType["View"] = "VIEW";
    FormType["Add"] = "ADD";
})(FormType || (FormType = {}));
export var InputType;
(function (InputType) {
    InputType["Text"] = "text";
    InputType["Email"] = "email";
})(InputType || (InputType = {}));
export var InputID;
(function (InputID) {
    InputID["FirstName"] = "FirstName";
    InputID["LastName"] = "LastName";
    InputID["Email"] = "Email";
    InputID["SpendingLimit"] = "SpendingLimit";
    InputID["Status"] = "Status";
    InputID["FullName"] = "Name";
})(InputID || (InputID = {}));
export const renderInputSection = (inputs, className, onInputChange) => {
    return inputs.map((element) => {
        const { customClass, id, type, label, maxChars, isRequired, pattern, value, isDisabled } = element;
        return {
            wrapper: {
                className: classnames(className, id, customClass)
            },
            key: id,
            label: React.createElement(FormLabel, Object.assign({}, { id, forId: id, className, text: label })),
            errorMessage: React.createElement(FormFieldError, Object.assign({}, { className: className, type: 'item' })),
            input: (React.createElement(FormInput, Object.assign({}, {
                id: id,
                type: type,
                maxLength: maxChars,
                pattern: pattern,
                value: value,
                className: className,
                isRequired: isRequired === undefined ? false : isRequired,
                onChange: onInputChange,
                isDisabled: isDisabled
            })))
        };
    });
};
let BusinessOrganizationList = class BusinessOrganizationList extends React.Component {
    constructor(props) {
        super(props);
        this.BusinessFormDefaultInputs = [
            {
                id: InputID.FirstName,
                type: InputType.Text,
                label: this.props.resources.firstNameLabelText,
                value: '',
                isRequired: true,
                customClass: 'width-50'
            },
            {
                id: InputID.LastName,
                type: InputType.Text,
                label: this.props.resources.lastNameLabelText,
                value: '',
                isRequired: true,
                customClass: 'width-50'
            },
            {
                id: InputID.Email,
                type: InputType.Email,
                label: this.props.resources.emailAddressLabelText,
                value: '',
                isRequired: true,
                pattern: '^[a-zA-Z0-9.!#$%&\'^_`{}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$',
                customClass: 'width-100'
            },
            {
                id: InputID.SpendingLimit,
                type: InputType.Text,
                label: this.props.resources.spendingLimitLabelText,
                value: '',
                isRequired: true,
                customClass: 'width-50'
            },
        ];
        this.moduleClassName = 'ms-business-organization-list';
        this._handleAddUserButtonClicked = () => {
            const newForm = this.state.formItems;
            newForm.forEach((input) => {
                if (input.id === InputID.Email) {
                    input.isDisabled = false;
                }
                input.value = '';
            });
            this.setState({
                formItems: newForm,
                isFormActive: true,
                formType: FormType.Add,
                isModalOpen: true,
                hasFormError: false,
                hasActionError: false
            });
        };
        this._handleAddEditFormSaveButton = async () => {
            const { context } = this.props;
            const { formType, formItems } = this.state;
            const updatedUser = this._createBusinessPartner(formItems);
            if (formType === FormType.Edit) {
                editOrganizationUser(new EditOrganizationUserInput(updatedUser), context.actionContext)
                    .then(() => {
                    window.location.reload(false);
                })
                    .catch(error => {
                    context.telemetry.trace(error);
                    this.setState({
                        hasActionError: true
                    });
                });
            }
            else {
                addOrganizationUser(new AddOrganizationUserInput(updatedUser), context.actionContext)
                    .then(() => {
                    window.location.reload(false);
                })
                    .catch(error => {
                    context.telemetry.trace(error);
                    this.setState({
                        hasActionError: true
                    });
                });
            }
        };
        this._createBusinessPartner = (inputs) => {
            const newUser = {
                Email: ''
            };
            inputs.forEach((input) => {
                if (input.id === InputID.SpendingLimit) {
                    newUser[input.id] = parseFloat(input.value) || 0;
                }
                else {
                    newUser[input.id] = input.value;
                }
            });
            return newUser;
        };
        this._handleFormCancelButton = () => {
            this.setState({
                isFormActive: false,
                isModalOpen: false,
                formType: FormType.None
            });
        };
        this._handleEditIcon = (userData) => {
            const possibleName = userData.find(cell => { return cell.id === 'Name'; });
            const fullName = possibleName && possibleName.value || '';
            const lastSpaceIndex = fullName.lastIndexOf(' ');
            const firstName = fullName.substring(0, lastSpaceIndex);
            const lastName = fullName.substring(lastSpaceIndex + 1);
            const { formItems } = this.state;
            const newForm = formItems;
            newForm.forEach(input => {
                switch (input.id) {
                    case InputID.FirstName:
                        input.value = firstName;
                        break;
                    case InputID.LastName:
                        input.value = lastName;
                        break;
                    case InputID.Email:
                        input.isDisabled = true;
                        const possibleCell = userData.find(cell => { return input.id === cell.id; });
                        input.value = possibleCell && possibleCell.value || '';
                        break;
                    default:
                        const dataCell = userData.find(cell => { return input.id === cell.id; });
                        input.value = dataCell && dataCell.value || '';
                }
            });
            this.setState({
                formItems: newForm,
                isFormActive: true,
                formType: FormType.Edit,
                isModalOpen: true,
                hasFormError: false,
                hasActionError: false
            });
        };
        this._handleDeleteIcon = (userData) => {
            const newUser = {
                Email: ''
            };
            userData.forEach((cell) => {
                if (cell.id === 'Name') {
                    const fullName = cell.value;
                    const lastSpaceIndex = fullName.lastIndexOf(' ');
                    newUser.FirstName = fullName.substring(0, lastSpaceIndex);
                    newUser.LastName = fullName.substring(lastSpaceIndex + 1);
                }
                else if (cell.type === TableDataType.Price) {
                    newUser[cell.id] = this.props.context.cultureFormatter.formatCurrency(cell.value);
                }
                else {
                    newUser[cell.id] = cell.value;
                }
            });
            this.setState({
                selectedUserData: newUser,
                formType: FormType.Remove,
                isModalOpen: true,
                isFormActive: false
            });
        };
        this._handleViewDetails = (userData) => {
            const newUser = {
                Email: ''
            };
            userData.forEach((cell) => {
                if (cell.id === 'Name') {
                    const fullName = cell.value;
                    const lastSpaceIndex = fullName.lastIndexOf(' ');
                    newUser.FirstName = fullName.substring(0, lastSpaceIndex);
                    newUser.LastName = fullName.substring(lastSpaceIndex + 1);
                }
                else if (cell.type === TableDataType.Price) {
                    newUser[cell.id] = this.props.context.cultureFormatter.formatCurrency(cell.value);
                }
                else {
                    newUser[cell.id] = cell.value;
                }
            });
            this.setState({
                selectedUserData: newUser,
                formType: FormType.View,
                isModalOpen: true,
                isFormActive: false
            });
        };
        this._handleRemoveUserButton = (records) => {
            const { context } = this.props;
            const { selectedUserData: deleteUserData } = this.state;
            if (deleteUserData) {
                deleteOrganizationUser(new DeleteOrganizationUserInput(deleteUserData), context.actionContext)
                    .then(() => {
                    window.location.reload(false);
                })
                    .catch((error) => {
                    context.telemetry.trace(error);
                });
            }
            this.setState({
                formType: FormType.None,
                isModalOpen: false
            });
        };
        this._onInputChange = (event) => {
            const newForm = this.state.formItems;
            newForm.forEach(item => {
                if (item.id === event.target.id) {
                    item.value = event.target.value;
                }
            });
            this.setState((prev) => ({
                refresh: !prev.refresh,
                isReady: this._isFormReady(),
                formItems: newForm,
                hasFormError: false,
                hasActionError: false
            }));
        };
        this._isFormReady = () => {
            const { formItems } = this.state;
            for (let i = 0; i < formItems.length; i++) {
                if ((formItems[i].isRequired && formItems[i].value.length < 1)) {
                    return false;
                }
                else if (formItems[i].pattern !== undefined && formItems[i].value.match(formItems[i].pattern) === null) {
                    return false;
                }
                else if (formItems[i].id === InputID.SpendingLimit && isNaN(parseFloat(formItems[i].value))) {
                    this.setState({
                        hasFormError: true
                    });
                    return false;
                }
            }
            return true;
        };
        this._formatPrice = (price) => {
            return this.props.context.cultureFormatter ? this.props.context.cultureFormatter.formatCurrency(price) : price.toString();
        };
        this._getCurrentUrl = (reqContext) => {
            if (MsDyn365.isBrowser) {
                return new URL(window.location.href);
            }
            else {
                if (reqContext.url.requestUrl.href) {
                    return new URL(reqContext.url.requestUrl.href);
                }
                else {
                    return new URL(reqContext.url.requestUrl.href);
                }
            }
        };
        this._getViewport = () => {
            const { context } = this.props;
            if (context.request && context.request.device && context.request.device.Type === 'Mobile') {
                return 'xs';
            }
            if (typeof window !== undefined && window.innerWidth) {
                const gridSettings = context.request.gridSettings;
                if (gridSettings) {
                    if (gridSettings.xs && window.innerWidth <= gridSettings.xs.w) {
                        return 'xs';
                    }
                    else if (gridSettings.sm && window.innerWidth <= gridSettings.sm.w) {
                        return 'sm';
                    }
                    else if (gridSettings.md && window.innerWidth <= gridSettings.md.w) {
                        return 'md';
                    }
                    else if (gridSettings.lg && window.innerWidth <= gridSettings.lg.w) {
                        return 'lg';
                    }
                    else {
                        return 'xl';
                    }
                }
            }
            return 'xs';
        };
        this._toggleModal = this._toggleModal.bind(this);
        this._onInputChange = this._onInputChange.bind(this);
        this._handleRemoveUserButton = this._handleRemoveUserButton.bind(this);
        this.mobileExcludedColumns = [InputID.Email, InputID.Status, InputID.SpendingLimit];
        this._viewport = props.context.request && props.context.request.device && props.context.request.device.Type === 'Mobile' ? 'xs' : 'lg';
        this._updateViewport = this._updateViewport.bind(this);
        this.state = {
            isReady: false,
            formItems: this.BusinessFormDefaultInputs,
            isFormActive: false,
            formType: FormType.None,
            selectedUserData: { Email: '' },
            refresh: true,
            isModalOpen: false,
            hasFormError: false,
            hasActionError: false
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
        this.payLoad = getPayloadObject('click', this.telemetryContent, '');
        this._updateViewport();
    }
    get isMobile() {
        return (this._viewport === 'xs' || this._viewport === 'sm');
    }
    componentDidMount() {
        if (MsDyn365.isBrowser && window.addEventListener) {
            window.addEventListener('resize', this._updateViewport);
            this._updateViewport();
        }
    }
    componentWillUnmount() {
        if (MsDyn365.isBrowser && window.removeEventListener) {
            window.removeEventListener('resize', this._updateViewport);
        }
    }
    render() {
        const { config, resources, data: { users } } = this.props;
        const { className, heading } = config;
        const { addUserButtonText, loadingMessage, emptyListMessage, errorGettingUsersMessage } = resources;
        const { formItems, isFormActive, formType, isModalOpen } = this.state;
        const hasUsers = users && users.result && users.result.length > 0;
        this.payLoad.contentAction.etext = TelemetryConstant.AddUser;
        const addUserAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        if (!hasUsers) {
            let errorMessage = '';
            if (users.status === 'LOADING') {
                errorMessage = loadingMessage;
            }
            else if (users.status === 'FAILED') {
                errorMessage = errorGettingUsersMessage;
            }
            else if (users.result && users.result.length === 0) {
                errorMessage = emptyListMessage;
            }
            const errorProps = {
                ...this.props,
                className: className,
                OrganizationUserList: {
                    moduleProps: this.props,
                    className: classnames(this.moduleClassName, className)
                },
                moduleContainer: {
                    className: `${this.moduleClassName}__container`
                },
                heading: heading && React.createElement(Heading, { className: `${this.moduleClassName}__heading`, headingTag: heading.tag, text: heading.text }),
                addUserButton: React.createElement(Button, Object.assign({ className: `${this.moduleClassName}__add-user-button`, onClick: this._handleAddUserButtonClicked }, addUserAttributes), addUserButtonText),
                noUsersText: React.createElement("p", { className: `${this.moduleClassName}__error-message` }, errorMessage)
            };
            return this.props.renderView(errorProps);
        }
        const viewProps = {
            ...this.props,
            className: className,
            OrganizationUserList: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, className)
            },
            moduleContainer: {
                className: `${this.moduleClassName}__container`
            },
            heading: heading && React.createElement(Heading, { className: `${this.moduleClassName}__heading`, headingTag: heading.tag, text: heading.text }),
            modalState: isModalOpen,
            addUserButton: React.createElement(Button, Object.assign({ className: `${this.moduleClassName}__add-user-button`, onClick: this._handleAddUserButtonClicked }, addUserAttributes), addUserButtonText),
            organizationListTable: React.createElement(Table, Object.assign({}, this._createTableProps())),
            toggleModal: this._toggleModal,
            formType: formType,
            form: isFormActive && isModalOpen && (formType === FormType.Add || formType === FormType.Edit) ? this._renderUserForm() : this._renderUserDetails(),
            formItems: formItems
        };
        return this.props.renderView(viewProps);
    }
    _createTableProps() {
        const { config, resources, context } = this.props;
        const { tableSort, showPagination, paginationItemPerPage } = config;
        const { paginationNextButtonText, paginationPreviousButtonText, editButtonText, deleteButtonText, actionButtonText, paginationAriaLabel } = resources;
        const tableData = this._createTableItems();
        const tableHeading = tableData.length > 0 && tableData[0].row.map((item) => {
            if (this.isMobile && this.mobileExcludedColumns.includes(item.id)) {
                return;
            }
            else {
                return {
                    name: item.id,
                    sortable: tableSort && tableSort || false
                };
            }
        }) || [];
        return {
            resources: resources,
            headings: tableHeading,
            rows: tableData,
            className: `${this.moduleClassName}__table`,
            editLinkText: this.isMobile ? editButtonText : '',
            deleteLinkText: this.isMobile ? deleteButtonText : '',
            viewLinkText: 'View details',
            enableToModify: true,
            actionLinkText: actionButtonText,
            showCheckBoxes: false,
            isSortable: tableSort,
            showPagination: showPagination,
            minifyActions: this.isMobile,
            excludedColumns: this.isMobile ? this.mobileExcludedColumns : [],
            paginationProperty: {
                skipCount: context && context.request && context.request.query && context.request.query.skip && !isNaN(parseInt(context.request.query.skip, 10)) ? parseInt(context.request.query.skip, 10) : 0,
                itemPerPage: paginationItemPerPage || 10,
                prevText: paginationPreviousButtonText,
                nextText: paginationNextButtonText,
                paginationText: paginationAriaLabel,
                url: context && this._getCurrentUrl(context.request).href || ''
            },
            actions: {
                onDelete: this._handleDeleteIcon,
                onEdit: this._handleEditIcon,
                onView: this.isMobile && this._handleViewDetails || undefined
            },
            formatPrice: this._formatPrice
        };
    }
    _createTableItems() {
        const { resources, data: { users } } = this.props;
        const { activeStatusText, pendingStatusText, removedStatusText } = resources;
        const usersList = users && users.result;
        if (!usersList || usersList.length === 0) {
            return [];
        }
        return usersList.map((user) => {
            let statusString = '';
            switch (user.StatusValue) {
                case 0:
                    statusString = pendingStatusText;
                    break;
                case 1:
                    statusString = activeStatusText;
                    break;
                case 2:
                default:
                    statusString = removedStatusText;
            }
            return {
                row: [
                    {
                        id: InputID.FullName,
                        type: TableDataType.Text,
                        value: `${user.FirstName} ${user.LastName}`
                    },
                    {
                        id: InputID.Email,
                        type: TableDataType.Text,
                        value: user.Email
                    },
                    {
                        id: InputID.Status,
                        type: TableDataType.Text,
                        value: statusString
                    },
                    {
                        id: InputID.SpendingLimit,
                        type: TableDataType.Price,
                        value: user.SpendingLimit || 0
                    }
                ]
            };
        });
    }
    _toggleModal() {
        this.setState({
            isModalOpen: false,
            isFormActive: false,
            formType: FormType.None
        });
    }
    _renderUserDetails() {
        const { resources } = this.props;
        const { formType, selectedUserData } = this.state;
        const { removeModalHeaderText, removeModalDescription, viewModalHeaderText, cancelButtonText, cancelRemoveUserButtonText, removeUserButtonText, errorUpdatingUsersMessage } = resources;
        const formClassName = `${this.moduleClassName}__form`;
        const typeClassName = formType === FormType.Remove ? 'type-remove' : 'type-view';
        const handleRemoveButton = (event) => { this._handleRemoveUserButton(selectedUserData); };
        return {
            modalClassName: classnames(`${this.moduleClassName}__modal`, typeClassName),
            FormWrapper: {
                className: formClassName
            },
            modalHeading: formType === FormType.Remove ? removeModalHeaderText : viewModalHeaderText,
            modalDescription: formType === FormType.Remove && React.createElement("p", { className: `${formClassName}-description` }, removeModalDescription),
            selectedUser: selectedUserData,
            buttons: [
                formType === FormType.Remove && React.createElement(Button, { key: 'action-remove', className: `${formClassName}-remove-user-button`, onClick: handleRemoveButton }, removeUserButtonText),
                React.createElement(Button, { key: 'action-cancel', className: `${formClassName}-cancel`, onClick: this._handleFormCancelButton }, formType === FormType.Remove ? cancelRemoveUserButtonText : cancelButtonText)
            ],
            errorMessage: [
                React.createElement(FormFieldError, { key: 'fieldIncorrect', id: 'fieldIncorrect', className: `${formClassName}-error`, message: errorUpdatingUsersMessage }),
            ],
            resources: resources
        };
    }
    _renderUserForm() {
        const { resources } = this.props;
        const { formType, formItems, hasFormError, hasActionError, isReady } = this.state;
        const { editUserFormHeadingText, addUserFormHeadingText, saveButtonArialabel, saveButtonText, cancelButtonArialabel, cancelButtonText, fieldIncorrectErrorText, actionErrorText, allFieldsRequiredMessage } = resources;
        const formClassName = `${this.moduleClassName}__form`;
        const typeClassName = formType === FormType.Add ? 'type-add' : 'type-edit';
        return {
            modalClassName: classnames(`${this.moduleClassName}__modal`, typeClassName),
            FormWrapper: {
                className: formClassName
            },
            modalHeading: formType === FormType.Add ? addUserFormHeadingText : editUserFormHeadingText,
            modalDescription: formType === FormType.Add && React.createElement("p", { className: `${formClassName}-all-required-msg` }, allFieldsRequiredMessage),
            inputs: renderInputSection(formItems, `${formClassName}-item`, this._onInputChange),
            buttons: [
                (React.createElement(FormButton, { key: 'continue', id: 'continue', className: `${formClassName}-save`, ariaLabel: saveButtonArialabel, text: saveButtonText, onClick: this._handleAddEditFormSaveButton, disabled: !isReady, telemetryContent: this.telemetryContent })),
                React.createElement(FormButton, { key: 'cancel', id: 'cancel', className: `${formClassName}-cancel`, ariaLabel: cancelButtonArialabel, text: cancelButtonText, onClick: this._handleFormCancelButton, telemetryContent: this.telemetryContent })
            ],
            errorMessage: [
                hasFormError && React.createElement(FormFieldError, { key: 'fieldIncorrect', id: 'fieldIncorrect', className: this.moduleClassName, message: fieldIncorrectErrorText }),
                hasActionError && React.createElement(FormFieldError, { key: 'fieldIncorrect', id: 'fieldIncorrect', className: this.moduleClassName, message: actionErrorText })
            ],
            resources: resources
        };
    }
    _updateViewport() {
        this._viewport = this._getViewport();
    }
};
__decorate([
    observable
], BusinessOrganizationList.prototype, "_viewport", void 0);
__decorate([
    computed
], BusinessOrganizationList.prototype, "isMobile", null);
BusinessOrganizationList = __decorate([
    observer
], BusinessOrganizationList);
export default BusinessOrganizationList;
//# sourceMappingURL=business-organization-list.js.map
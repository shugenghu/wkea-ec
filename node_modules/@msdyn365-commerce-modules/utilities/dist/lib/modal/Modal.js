"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var React = tslib_1.__importStar(require("react"));
var utilities_1 = require("../common/utilities");
var Fade_1 = tslib_1.__importDefault(require("../fade/Fade"));
var Portal_1 = tslib_1.__importDefault(require("./Portal"));
var Modal = (function (_super) {
    tslib_1.__extends(Modal, _super);
    function Modal(props) {
        var _this = _super.call(this, props) || this;
        _this.element = null;
        _this.ref = React.createRef();
        _this.mounted = false;
        _this._getFocusableChildren = _this._getFocusableChildren.bind(_this);
        _this._handleBackdropClick = _this._handleBackdropClick.bind(_this);
        _this._handleBackdropMouseDown = _this._handleBackdropMouseDown.bind(_this);
        _this._handleEscape = _this._handleEscape.bind(_this);
        _this._handleTab = _this._handleTab.bind(_this);
        _this._onOpened = _this._onOpened.bind(_this);
        _this._onClosed = _this._onClosed.bind(_this);
        _this.state = {
            wasOpen: false,
            isOpen: props.isOpen || false,
            mouseDownElement: null
        };
        if (props.isOpen) {
            _this._open();
        }
        return _this;
    }
    Modal.prototype.componentDidMount = function () {
        if (this.props.onEnter) {
            this.props.onEnter();
        }
        this.mounted = true;
        var element = document.createElement('div');
        element.setAttribute('tabindex', '-1');
        element.style.visibility = 'hidden';
        element.style.position = 'position';
        this.element = element;
        document.body.appendChild(element);
        this.applicationNode = (this.props.applicationNode instanceof HTMLElement) ?
            this.props.applicationNode : document.querySelector("#" + this.props.applicationNode);
        if (this.state.isOpen && !this.state.wasOpen) {
            this._open();
        }
    };
    Modal.prototype.componentWillUnmount = function () {
        if (this.props.onExit) {
            this.props.onExit();
        }
        if (this.state.isOpen) {
            this._close();
        }
        this.mounted = false;
        if (this.element) {
            document.body.removeChild(this.element);
        }
    };
    Modal.prototype.componentDidUpdate = function (_prevProps, prevState) {
        var _this = this;
        if (this.state.isOpen && !prevState.isOpen) {
            setTimeout(function () {
                var focusableElementArr = _this._getFocusableChildren();
                if (focusableElementArr && focusableElementArr.length > 0 && focusableElementArr[0]) {
                    var firstFocusableElement = focusableElementArr[0];
                    firstFocusableElement.focus();
                }
            }, 100);
        }
    };
    Modal.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.isOpen && !this.props.isOpen) {
            this.setState({ isOpen: nextProps.isOpen });
        }
    };
    Modal.prototype.render = function () {
        if (this.state.isOpen && !this.state.wasOpen) {
            this._open();
        }
        if (this.element !== null) {
            var _a = this.props, wrapClassName = _a.wrapClassName, modalClassName = _a.modalClassName, backdropClassName = _a.backdropClassName, contentClassName = _a.contentClassName, className = _a.className, cssModule = _a.cssModule, modalTransition = _a.modalTransition, backdropTransition = _a.backdropTransition, backdrop = _a.backdrop, isOpen = _a.isOpen, onOpened = _a.onOpened, onClosed = _a.onClosed, role = _a.role, size = _a.size, tabIndex = _a.tabIndex, external_1 = _a.external, verticalPosition = _a.verticalPosition, horizontalPosition = _a.horizontalPosition, keyboard = _a.keyboard, zIndex = _a.zIndex, fade = _a.fade, toggle = _a.toggle, children = _a.children, applicationNode = _a.applicationNode, returnFocusRef = _a.returnFocusRef, ariaLabelledbyId = _a["aria-labelledby"], dialogAttributes = tslib_1.__rest(_a, ["wrapClassName", "modalClassName", "backdropClassName", "contentClassName", "className", "cssModule", "modalTransition", "backdropTransition", "backdrop", "isOpen", "onOpened", "onClosed", "role", "size", "tabIndex", "external", "verticalPosition", "horizontalPosition", "keyboard", "zIndex", "fade", "toggle", "children", "applicationNode", "returnFocusRef", 'aria-labelledby']);
            var modalAttributes = {
                onClick: this._handleBackdropClick,
                onMouseDown: this._handleBackdropMouseDown,
                onKeyUp: this._handleEscape,
                onKeyDown: this._handleTab,
                style: { display: 'block' }
            };
            var modalTransitions = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, Fade_1.default.defaultProps), modalTransition), { baseClass: fade && modalTransition ? modalTransition.baseClass : '', timeout: fade && modalTransition ? modalTransition.timeout : 0 });
            var backdropTransitions = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, Fade_1.default.defaultProps), backdropTransition), { baseClass: fade && backdropTransition ? backdropTransition.baseClass : '', timeout: fade && backdropTransition ? backdropTransition.timeout : 0 });
            var Backdrop = fade ?
                (React.createElement(Fade_1.default, tslib_1.__assign({}, backdropTransitions, { in: this.state.isOpen && !!backdrop, cssModule: cssModule, className: classnames_1.default('msc-modal__backdrop', backdropClassName) })))
                : React.createElement("div", { className: classnames_1.default('msc-modal__backdrop', 'show', backdropClassName) });
            var dialogBaseClass = 'msc-modal__dialog';
            var dialogClasses = classnames_1.default([
                dialogBaseClass,
                className,
                size ? "msc-modal__" + size : null
            ]);
            var dialog = (React.createElement("div", tslib_1.__assign({ ref: this.ref }, dialogAttributes, { className: dialogClasses, role: role, "aria-modal": this.state.isOpen, "aria-labelledby": this.props['aria-labelledby'], tabIndex: tabIndex }),
                React.createElement("div", { className: classnames_1.default('msc-modal__content', contentClassName), role: 'document' }, children)));
            return (React.createElement(Portal_1.default, { node: this.element },
                React.createElement("div", { className: wrapClassName },
                    React.createElement(Fade_1.default, tslib_1.__assign({}, modalAttributes, modalTransitions, { in: isOpen, onEntered: this._onOpened, onExited: this._onClosed, cssModule: cssModule, appear: fade, className: classnames_1.default('msc-modal', modalClassName) }),
                        external_1,
                        dialog),
                    Backdrop)));
        }
        return null;
    };
    Modal.prototype._open = function () {
        if (this.element) {
            this.element.style.zIndex = "" + (this.props.zIndex || 1000);
            this.element.style.display = 'block';
            this.element.style.visibility = 'visible';
            if (Modal.openCount === 0) {
                if (window) {
                    var scrollY_1 = window.scrollY;
                    var scrollbarWidth = window.innerWidth - document.body.clientWidth;
                    document.body.style.position = "fixed";
                    document.body.style.top = "-" + scrollY_1 + "px";
                    document.body.style.right = scrollbarWidth + "px";
                    document.body.style.left = "0px";
                }
                document.body.className = classnames_1.default(document.body.className, 'modal-open');
            }
            Modal.openCount += 1;
            if (this.applicationNode) {
                this.applicationNode.setAttribute('aria-hidden', 'true');
            }
            this.setState(tslib_1.__assign(tslib_1.__assign({}, this.state), { wasOpen: true }));
        }
    };
    Modal.prototype._close = function () {
        var _this = this;
        if (!this.state.isOpen) {
            return;
        }
        if (this.element) {
            this.element.style.display = 'none';
            setTimeout(function () {
                if (_this.element) {
                    _this.element.style.visibility = 'hidden';
                    _this.element.style.removeProperty('display');
                }
            }, 0);
        }
        if (Modal.openCount <= 1) {
            var modalOpenClassName = 'modal-open';
            var modalOpenClassNameRegex = new RegExp("(^| )" + modalOpenClassName + "( |$)");
            document.body.className = document.body.className.replace(modalOpenClassNameRegex, ' ').trim();
            if (window) {
                var scrollY_2 = document.body.style.top;
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.right = '';
                document.body.style.left = '';
                window.scrollTo(0, -parseInt(scrollY_2 || '0', 10));
            }
        }
        Modal.openCount -= 1;
        if (this.applicationNode) {
            this.applicationNode.setAttribute('aria-hidden', 'false');
        }
        if (this.props.returnFocusRef && this.props.returnFocusRef.current) {
            this.props.returnFocusRef.current.focus();
        }
        this.setState(tslib_1.__assign(tslib_1.__assign({}, this.state), { wasOpen: false }));
    };
    Modal.prototype._getFocusableChildren = function () {
        if (this.element === null) {
            return null;
        }
        return this.element.querySelectorAll(utilities_1.focusableElements.join(', '));
    };
    Modal.prototype._getFocusedChild = function () {
        var focusableChildren = this._getFocusableChildren();
        try {
            return document.activeElement;
        }
        catch (err) {
            return focusableChildren === null ? null : focusableChildren[0];
        }
    };
    Modal.prototype._handleBackdropClick = function (e) {
        if (e.target === this.state.mouseDownElement) {
            e.stopPropagation();
            if (!this.props.isOpen || this.props.backdrop !== true) {
                return;
            }
            var container = this.ref.current;
            if (e.target && container && !container.contains(e.target) && this.props.toggle) {
                this.props.toggle();
            }
        }
    };
    Modal.prototype._handleTab = function (e) {
        if (e.which !== 9) {
            return;
        }
        var focusableChildren = this._getFocusableChildren();
        if (focusableChildren === null) {
            return;
        }
        var totalFocusable = focusableChildren.length;
        var currentFocus = this._getFocusedChild();
        var focusedIndex = 0;
        for (var i = 0; i < totalFocusable; i += 1) {
            if (focusableChildren[i] === currentFocus) {
                focusedIndex = i;
                break;
            }
        }
        var el = null;
        if (e.shiftKey && focusedIndex === 0) {
            e.preventDefault();
            el = focusableChildren[totalFocusable - 1];
        }
        else if (!e.shiftKey && focusedIndex === totalFocusable - 1) {
            e.preventDefault();
            el = focusableChildren[0];
        }
        if (el) {
            el.focus();
        }
    };
    Modal.prototype._handleBackdropMouseDown = function (e) {
        this.setState({
            mouseDownElement: e.target
        });
    };
    Modal.prototype._handleEscape = function (e) {
        if (this.props.isOpen && this.props.keyboard && e.keyCode === 27 && this.props.toggle) {
            this.props.toggle();
        }
    };
    Modal.prototype._onOpened = function (node, isAppearing) {
        if (this.props.onOpened !== undefined) {
            this.props.onOpened();
        }
        if (this.props.modalTransition !== undefined && this.props.modalTransition.onEntered !== undefined) {
            this.props.modalTransition.onEntered(node, isAppearing);
        }
    };
    Modal.prototype._onClosed = function (node) {
        if (this.props.onClosed !== undefined) {
            this.props.onClosed();
        }
        this._close();
        if (this.props.modalTransition !== undefined && this.props.modalTransition.onExited !== undefined) {
            this.props.modalTransition.onExited(node);
        }
        if (this.mounted) {
            this.setState({ isOpen: false });
        }
    };
    Modal.defaultProps = {
        isOpen: false,
        autoFocus: true,
        verticalPosition: 'top',
        horizontalPosition: 'center',
        role: 'dialog',
        backdrop: true,
        keyboard: true,
        zIndex: 1000,
        tabIndex: 0,
        fade: true,
        modalTransition: {
            timeout: utilities_1.TransitionTimeouts.Modal
        },
        backdropTransition: {
            mountOnEnter: true,
            timeout: utilities_1.TransitionTimeouts.Fade
        }
    };
    Modal.openCount = 0;
    return Modal;
}(React.Component));
exports.default = Modal;
//# sourceMappingURL=Modal.js.map
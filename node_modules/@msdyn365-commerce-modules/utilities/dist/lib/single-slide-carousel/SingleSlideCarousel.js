"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var utilities_1 = require("../common/utilities");
var Flipper_1 = tslib_1.__importDefault(require("../flipper/Flipper"));
var SingleSlideCarousel = (function (_super) {
    tslib_1.__extends(SingleSlideCarousel, _super);
    function SingleSlideCarousel(props) {
        var _this = _super.call(this, props) || this;
        _this.carouselSize = 0;
        _this.slideSize = 0;
        _this.itemSize = 0;
        _this.flipperNextLabel = 'next';
        _this.flipperPrevLabel = 'prev';
        _this._onResized = function () {
            _this._onCarouselResized();
        };
        _this._nextSlide = _this._nextSlide.bind(_this);
        _this._previousSlide = _this._previousSlide.bind(_this);
        _this._handleTouchStart = _this._handleTouchStart.bind(_this);
        _this._handleTouchEnd = _this._handleTouchEnd.bind(_this);
        _this._onFocus = _this._onFocus.bind(_this);
        _this._onResized = _this._onResized.bind(_this);
        _this.state = { showPrevious: false, showNext: false, offset: 0 };
        _this.ref = React.createRef();
        _this.slideRef = React.createRef();
        _this.itemRef = React.createRef();
        _this.direction = 'left';
        _this.id = props.parentId || '';
        _this.scrollThreshold = _this.props.touchScrollThreshold !== undefined ? _this.props.touchScrollThreshold : 100;
        return _this;
    }
    SingleSlideCarousel.prototype.componentDidUpdate = function () {
        this.carousel = this.ref.current;
        this.slide = this.slideRef.current;
        this.item = this.itemRef.current;
        this._setSizes();
        this._updateFlippers(this.state.offset);
    };
    SingleSlideCarousel.prototype.componentDidMount = function () {
        this.direction = this.props.vertical ? 'top' : 'left';
        this.carousel = this.ref.current;
        this.slide = this.slideRef.current;
        this.item = this.itemRef.current;
        this._setSizes();
        this.resizeThrottledEventHandler =
            window && utilities_1.addThrottledEvent(window, 'resize', this._onResized);
        this._updateFlippers(0);
    };
    SingleSlideCarousel.prototype.componentWillUnmount = function () {
        window && window.removeEventListener('resize', this.resizeThrottledEventHandler, false);
    };
    SingleSlideCarousel.prototype.render = function () {
        var isVert = this.props.vertical === true;
        var slidePositionStyle = {};
        var modifiedChildren = this._getClonedChildren(isVert);
        slidePositionStyle[this.direction] = this.state.offset + "px";
        var carouselClass = (isVert) ? 'msc-ss-carousel-vert' : 'msc-ss-carousel';
        var carouselSlideClass = (isVert) ? 'msc-ss-carousel-vert-slide' : 'msc-ss-carousel-slide';
        var overflowClass = (isVert) ? 'msc-ss-carousel-vert-strip' : 'msc-ss-carousel-strip';
        var previousFlipperGlyph = (isVert) ? 'msi-chevron-up' : 'msi-chevron-left';
        var nextFlipperGlyph = (isVert) ? 'msi-chevron-down' : 'msi-chevron-right';
        var previousFlipperClassName = (isVert) ? 'msc-ss-carousel-vert__flipper' : 'msc-ss-carousel__flipper';
        var nextFlipperClassName = (isVert) ? 'msc-ss-carousel-vert__flipper msc-ss-carousel-vert__flipper--next' : 'msc-ss-carousel__flipper msc-ss-carousel__flipper--next';
        var disableClassName = !this.state.showPrevious || !this.state.showNext ? 'disabled' : null;
        return (React.createElement("div", { className: carouselClass, onTouchStart: this._handleTouchStart, onTouchEnd: this._handleTouchEnd },
            React.createElement(Flipper_1.default, { id: "flipperPreviousButton_" + this.id, glyphProps: { className: previousFlipperGlyph }, onClick: this._previousSlide, className: !this.state.showPrevious ? previousFlipperClassName + " " + disableClassName : "" + previousFlipperClassName, "aria-hidden": !this.state.showPrevious, "aria-label": this.props.flipperPrevLabel, disabled: !this.state.showPrevious ? true : false, displayTooltip: this.props.flipperPrevLabel && this.props.flipperPrevLabel.length > 0 ? true : false, telemetryContent: this.props.telemetryContent, telemetryLabel: this.flipperPrevLabel }),
            React.createElement(Flipper_1.default, { id: "flipperNextButton_" + this.id, glyphProps: { className: nextFlipperGlyph }, onClick: this._nextSlide, className: !this.state.showNext ? nextFlipperClassName + " " + disableClassName : "" + nextFlipperClassName, "aria-hidden": !this.state.showNext, "aria-label": this.props.flipperNextLabel, disabled: !this.state.showNext ? true : false, displayTooltip: this.props.flipperNextLabel && this.props.flipperNextLabel.length > 0 ? true : false, telemetryContent: this.props.telemetryContent, telemetryLabel: this.flipperNextLabel }),
            React.createElement("div", { ref: this.ref, className: "" + overflowClass },
                React.createElement("ul", { className: carouselSlideClass, style: slidePositionStyle, ref: this.slideRef, role: this.props.useTabList ? 'tablist' : 'list' }, modifiedChildren))));
    };
    SingleSlideCarousel.prototype._getClonedChildren = function (isVert) {
        var _this = this;
        return React.Children.map(this.props.children, function (child, index) {
            var castChild = child;
            if (index === 1) {
                return React.cloneElement(castChild, {
                    className: (isVert ? SingleSlideCarousel.verticalItemsSelector : SingleSlideCarousel.itemsSelector) + " " + castChild.props.className,
                    ref: _this.itemRef,
                    onFocus: _this._onFocus
                });
            }
            return React.cloneElement(castChild, {
                className: (isVert ? SingleSlideCarousel.verticalItemsSelector : SingleSlideCarousel.itemsSelector) + " " + castChild.props.className,
                onFocus: _this._onFocus
            });
        });
    };
    SingleSlideCarousel.prototype._nextSlide = function () {
        this._moveSingleSlide(true);
    };
    SingleSlideCarousel.prototype._previousSlide = function () {
        this._moveSingleSlide(false);
    };
    SingleSlideCarousel.prototype._handleTouchStart = function (evt) {
        if (evt.touches.length === 0) {
            this.scrollStart = undefined;
        }
        else {
            this.scrollStart = this.props.vertical === true ? evt.touches[0].screenY : evt.touches[0].screenX;
        }
    };
    SingleSlideCarousel.prototype._handleTouchEnd = function (evt) {
        if (evt.changedTouches.length > 0 && this.scrollStart !== undefined) {
            var newTarget = this.props.vertical === true ? evt.changedTouches[0].screenY : evt.changedTouches[0].screenX;
            var delta = newTarget - this.scrollStart;
            if (delta > this.scrollThreshold) {
                this._previousSlide();
            }
            if (delta < -this.scrollThreshold) {
                this._nextSlide();
            }
        }
        this.scrollStart = undefined;
        return;
    };
    SingleSlideCarousel.prototype._moveSingleSlide = function (next) {
        var currentOffset = parseInt(utilities_1.getCSS(this.slide, this.direction), 10);
        var carouselSize = this.carouselSize;
        var maxScrollCount = Math.floor(carouselSize / (this.itemSize));
        var directionModifier = next ? -1 : 1;
        currentOffset = !isNaN(currentOffset) && typeof currentOffset === 'number' ? currentOffset : 0;
        if (maxScrollCount === 0) {
            maxScrollCount = 1;
        }
        maxScrollCount = carouselSize % (this.itemSize) === 0 ? maxScrollCount - 1 : maxScrollCount;
        maxScrollCount = Math.max(maxScrollCount, 1);
        var maxScrollDistance = maxScrollCount * (this.itemSize);
        var distanceToEdge = next ? this.slideSize - carouselSize + currentOffset : Math.abs(currentOffset);
        distanceToEdge = Math.max(0, distanceToEdge);
        var offset = maxScrollDistance <= distanceToEdge
            ? maxScrollDistance * directionModifier + currentOffset
            : distanceToEdge * directionModifier + currentOffset;
        this._updateFlippers(offset);
    };
    SingleSlideCarousel.prototype._setSizes = function () {
        var item = this.item;
        if (!!item) {
            this.itemSize = this.props.vertical ? item.scrollHeight : item.scrollWidth;
        }
        else {
            this.itemSize = 0;
        }
        this.carouselSize = this._calculateCarouselSize();
        this.slideSize = this.slide ? (this.props.vertical ? this.slide.scrollHeight : this.slide.scrollWidth) : 0;
    };
    SingleSlideCarousel.prototype._calculateCarouselSize = function () {
        if (!this.carousel) {
            return 0;
        }
        var carouselStyle = getComputedStyle(this.carousel);
        var padding = this.props.vertical ? parseFloat(carouselStyle.paddingTop || '') + parseFloat(carouselStyle.paddingBottom || '')
            : parseFloat(carouselStyle.paddingLeft || '') + parseFloat(carouselStyle.paddingRight || '');
        return this.props.vertical ? this.carousel.clientHeight - padding : this.carousel.clientWidth - padding;
    };
    SingleSlideCarousel.prototype._canScrollPrevious = function (offset) {
        return !isNaN(offset) && offset !== 0;
    };
    SingleSlideCarousel.prototype._canScrollNext = function (offset) {
        if (this.carouselSize + Math.abs(offset) >= this.slideSize) {
            return false;
        }
        return true;
    };
    SingleSlideCarousel.prototype._updateFlippers = function (offset) {
        this.setState({
            showPrevious: this._canScrollPrevious(offset),
            showNext: this._canScrollNext(offset),
            offset: offset
        });
    };
    SingleSlideCarousel.prototype._scrollItemIntoView = function (item) {
        var _this = this;
        var carouselSize = this.carouselSize;
        var offset = (this.props.vertical) ? item.offsetTop : item.offsetLeft;
        var updateOffset = false;
        var left = parseInt(utilities_1.getCSS(this.slide, 'left'), 10) || 0;
        var top = parseInt(utilities_1.getCSS(this.slide, 'top'), 10) || 0;
        if (this.props.vertical) {
            if (top < 0 && -top > offset) {
                if (offset !== 0) {
                    offset = -offset + 1;
                }
                updateOffset = true;
            }
            else if (top + offset > carouselSize - this.itemSize) {
                offset = carouselSize - this.itemSize - offset - 1;
                updateOffset = true;
            }
        }
        else if (this.direction === 'left') {
            if (left < 0 && -left > offset) {
                if (offset !== 0) {
                    offset = -offset + 1;
                }
                updateOffset = true;
            }
            else if (left + offset > carouselSize - this.itemSize) {
                offset = carouselSize - this.itemSize - offset + 19;
                updateOffset = true;
            }
        }
        if (updateOffset) {
            this._updateFlippers(offset);
            if (this.props.vertical) {
                setTimeout(function () {
                    _this.slide.parentElement.scrollTop = 0;
                }, 0);
            }
            else {
                setTimeout(function () {
                    _this.slide.parentElement.scrollLeft = 0;
                }, 0);
            }
        }
    };
    SingleSlideCarousel.prototype._onFocus = function (event) {
        var target = event.currentTarget;
        this._scrollItemIntoView(target);
    };
    SingleSlideCarousel.prototype._onCarouselResized = function () {
        this._setSizes();
        var offset = parseInt(utilities_1.getCSS(this.slide, this.direction), 10);
        if (!isNaN(offset) && offset < 0 && this.slideSize + offset < this.carouselSize) {
            offset = Math.min(0, this.carouselSize - this.slideSize);
        }
        this._updateFlippers(offset);
    };
    SingleSlideCarousel.itemsSelector = 'msc-ss-carousel-item';
    SingleSlideCarousel.verticalItemsSelector = 'msc-ss-carousel-vert-item';
    return SingleSlideCarousel;
}(React.PureComponent));
exports.default = SingleSlideCarousel;
//# sourceMappingURL=SingleSlideCarousel.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = tslib_1.__importDefault(require("@msdyn365-commerce/core"));
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var React = tslib_1.__importStar(require("react"));
var __1 = require("../");
var utilities_1 = require("./../common/utilities");
var SliderThumb_1 = tslib_1.__importDefault(require("./SliderThumb"));
var orientations = {
    horizontal: {
        dimension: 'width',
        direction: 'left',
        coordinate: 'x'
    },
    vertical: {
        dimension: 'height',
        direction: 'top',
        coordinate: 'y'
    }
};
var EventType;
(function (EventType) {
    EventType[EventType["Start"] = 0] = "Start";
    EventType[EventType["End"] = 1] = "End";
    EventType[EventType["Change"] = 2] = "Change";
})(EventType || (EventType = {}));
var Slider = (function (_super) {
    tslib_1.__extends(Slider, _super);
    function Slider(props) {
        var _this = _super.call(this, props) || this;
        _this.ref = React.createRef();
        _this.thumb1Ref = React.createRef();
        _this.thumb2Ref = React.createRef();
        _this._renderLabels = function (labels) {
            return (React.createElement("div", { className: 'slider__labels p-0' }, labels.map(function (label) {
                return (React.createElement("div", { key: label.labelId, role: 'presentation', className: "slider__labels-item " + label.labelPositioning }, label.labelString));
            })));
        };
        _this._renderSliderThumbs = function (thumbStyles) {
            return (React.createElement(React.Fragment, null,
                React.createElement("input", { type: 'range', id: _this.props.sliderThumbs[0].id + "range", className: "slider__thumb__range sr-only", min: _this.props.min, max: _this.isRangeSlider ? _this.state.sliderThumbs[1].value - _this.props.step : _this.props.max, value: _this.state.sliderThumbs[0].value, role: 'slider', "aria-live": 'polite', "aria-valuemin": _this.props.min, "aria-valuemax": _this.isRangeSlider ? _this.state.sliderThumbs[1].value - _this.props.step : _this.props.max, "aria-label": _this.props.sliderThumbs[0].ariaLabel, "aria-valuenow": _this.state.sliderThumbs[0].value, "aria-orientation": _this.props.orientation, onChange: _this._handleOnChange, onBlur: _this.props.onBlur }),
                React.createElement(SliderThumb_1.default, { id: _this.props.sliderThumbs[0].id, ref: _this.thumb1Ref, handleStart: _this._handleStart, handleDrag: _this._handleDrag, handleEnd: _this._handleEnd, handleFocus: _this.props.onFocus, handleBlur: _this.props.onBlur, handleTooltipText: _this.props.handleTooltipText, showTooltip: _this.props.showTooltip, style: thumbStyles[0], trackThumbClass: _this.props.trackThumbClass, sliderValue: _this.state.sliderThumbs[0].value }),
                ' ',
                _this.isRangeSlider && (React.createElement(React.Fragment, null,
                    React.createElement("input", { type: 'range', id: _this.props.sliderThumbs[1].id + "range", className: "slider__thumb__range sr-only", min: _this.state.sliderThumbs[0].value + _this.props.step, max: _this.props.max, value: _this.state.sliderThumbs[1].value, role: 'slider', "aria-live": 'polite', "aria-valuemin": _this.state.sliderThumbs[0].value + _this.props.step, "aria-valuemax": _this.props.max, "aria-label": _this.props.sliderThumbs[1].ariaLabel, "aria-valuenow": _this.state.sliderThumbs[1].value, "aria-orientation": _this.props.orientation, onChange: _this._handleOnChange, onBlur: _this.props.onBlur, onFocus: _this.props.onFocus }),
                    React.createElement(SliderThumb_1.default, { id: _this.props.sliderThumbs[1].id, ref: _this.thumb2Ref, sliderValue: _this.state.sliderThumbs[1].value, handleStart: _this._handleStart, handleDrag: _this._handleDrag, handleEnd: _this._handleEnd, handleFocus: _this.props.onFocus, handleBlur: _this.props.onBlur, handleTooltipText: _this.props.handleTooltipText, showTooltip: _this.props.showTooltip, style: thumbStyles[1], trackThumbClass: _this.props.trackThumbClass, ariaValueText: _this.props.sliderThumbs[1].ariaValueText })))));
        };
        _this._handleUpdate = function () {
            var orientation = _this.props.orientation;
            var dimensionStr = utilities_1.toUpperCaseFirstChar(orientations[orientation].dimension);
            var sliderPos = _this.ref.current["offset" + dimensionStr];
            var handlePos = _this.thumb1Ref.current.sliderButtonRef.current["offset" + dimensionStr];
            _this.setState({
                limit: sliderPos - handlePos,
                grab: orientations.horizontal.direction === 'right' ? -handlePos / 2 : handlePos / 2
            });
        };
        _this._handleStart = function (e) {
            e.stopPropagation();
            var eventType = e.type;
            document.addEventListener('mousemove', _this._handleDrag);
            document.addEventListener('mouseup', _this._handleEnd);
            var castTarget = e.target;
            var thumbid = castTarget && castTarget.id;
            _this.setState(function (_prevState) {
                return { active: true, id: thumbid };
            }, function () {
                _this._getThumbAndPublishEvent(castTarget, 0, eventType);
            });
        };
        _this._position = function (e) {
            var grab = _this.state.grab;
            var orientation = _this.props.orientation;
            var castEvent = e;
            var node = _this.ref;
            var coordinateStyle = utilities_1.toUpperCaseFirstChar(orientations[orientation].coordinate);
            var directionStyle = orientations[orientation].direction;
            var clientCoordinateStyle = "client" + coordinateStyle;
            var coordinate = !castEvent.touches ? e[clientCoordinateStyle] : castEvent.touches[0][clientCoordinateStyle];
            var direction = node.current.getBoundingClientRect()[directionStyle];
            var pos = orientations.horizontal.direction === 'right' ? direction - coordinate - grab : coordinate - direction - grab;
            return _this._getValueFromPosition(pos);
        };
        _this._getPositionFromValue = function (value) {
            var limit = _this.state.limit;
            var _a = _this.props, min = _a.min, max = _a.max;
            var diffMaxMin = max - min;
            var diffValMin = value - min;
            var percentage = diffValMin / diffMaxMin;
            return Math.round(percentage * limit);
        };
        _this._getValueFromPosition = function (pos) {
            var limit = _this.state.limit;
            var _a = _this.props, orientation = _a.orientation, min = _a.min, max = _a.max, step = _a.step;
            var percentage = utilities_1.clamp(pos, 0, limit) / (limit || 1);
            var baseVal = step * Math.round((percentage * (max - min)) / step);
            var value = orientation === 'horizontal' ? baseVal + min : max - baseVal;
            return utilities_1.clamp(value, min, max);
        };
        _this._coordinates = function (pos) {
            var _a = _this.state, limit = _a.limit, grab = _a.grab;
            var orientation = _this.props.orientation;
            var value = _this._getValueFromPosition(pos);
            var position = _this._getPositionFromValue(value);
            var handlePos = orientation === 'horizontal' ? position + grab : position;
            var fillPos = orientation === 'horizontal' ? handlePos : limit - handlePos;
            return {
                fill: fillPos,
                handle: handlePos,
                label: handlePos
            };
        };
        _this._setSliderValue = function (sliderThumb, castTarget, eventType) {
            if (_this.isRangeSlider) {
                _this.setState(function (_prevState) {
                    return {
                        sliderThumbs: tslib_1.__assign({}, _this.props.sliderThumbs)
                    };
                }, function () {
                    _this._getThumbAndPublishEvent(castTarget, 2, eventType);
                });
            }
            else {
                _this.setState(function (_prevState) {
                    return {
                        sliderThumbs: sliderThumb
                    };
                }, function () {
                    _this._getThumbAndPublishEvent(castTarget, 2, eventType);
                });
            }
        };
        _this._publishNotification = function (thumb, delegate, eventType) {
            delegate({
                id: (thumb && thumb.id) || '',
                slider: _this,
                firstThumbValue: _this.state.sliderThumbs[0].value,
                secondThumbValue: (_this.state.sliderThumbs[1] && _this.state.sliderThumbs[1].value) || NaN,
                eventType: eventType
            });
        };
        _this._getThumbAndPublishEvent = function (element, eventType, nativeEventType) {
            var elmenentId = '';
            if (element && element.id && eventType === 2) {
                elmenentId = element.id.replace('range', '');
            }
            var thumb = element && _this._getThumbFromProps(elmenentId);
            if (eventType === 1) {
                if (_this.props.onChangeEnd) {
                    _this._publishNotification(thumb && thumb[0], _this.props.onChangeEnd, nativeEventType);
                }
            }
            if (eventType === 0) {
                if (_this.props.onChangeStart) {
                    _this._publishNotification(thumb && thumb[0], _this.props.onChangeStart, nativeEventType);
                }
            }
            if (eventType === 2) {
                if (_this.props.onChange) {
                    _this._publishNotification(thumb && thumb[0], _this.props.onChange, nativeEventType);
                }
            }
        };
        _this.isRangeSlider = _this.props.sliderThumbs.length === 2;
        _this.state = {
            sliderThumbs: _this.props.sliderThumbs,
            grab: 0,
            limit: 0,
            active: false,
            id: ''
        };
        _this._handleUpdate = _this._handleUpdate.bind(_this);
        _this._handleDrag = _this._handleDrag.bind(_this);
        _this._handleEnd = _this._handleEnd.bind(_this);
        _this._handleStart = _this._handleStart.bind(_this);
        _this._handleOnChange = _this._handleOnChange.bind(_this);
        _this._setSliderValue = _this._setSliderValue.bind(_this);
        _this._getThumbFromProps = _this._getThumbFromProps.bind(_this);
        _this._publishNotification = _this._publishNotification.bind(_this);
        _this._getThumbAndPublishEvent = _this._getThumbAndPublishEvent.bind(_this);
        _this._willThumbsCrossOver = _this._willThumbsCrossOver.bind(_this);
        _this._handleOnClick = _this._handleOnClick.bind(_this);
        if (core_1.default.isBrowser && document.body.parentElement && document.body.parentElement.getAttribute('dir') === 'rtl') {
            orientations.horizontal.direction = 'right';
        }
        return _this;
    }
    Slider.getDerivedStateFromProps = function (props, state) {
        if ((props.sliderThumbs.length && props.sliderThumbs[0].value !== state.sliderThumbs[0].value) ||
            (props.sliderThumbs.length > 1 && props.sliderThumbs[1].value !== state.sliderThumbs[1].value)) {
            var nextState = tslib_1.__assign({}, state);
            nextState.sliderThumbs[0].value = props.sliderThumbs[0].value;
            if (props.sliderThumbs.length > 1) {
                nextState.sliderThumbs[1].value = props.sliderThumbs[1].value;
            }
            return nextState;
        }
        return null;
    };
    Slider.prototype.componentDidMount = function () {
        this._handleUpdate();
        core_1.default.isBrowser && window.addEventListener('resize', this._handleUpdate);
    };
    Slider.prototype.shouldComponentUpdate = function (nextProps, _nextState) {
        var shouldRender = true;
        if (this.isRangeSlider) {
            var thumb1Position = this._getPositionFromValue(nextProps.sliderThumbs[0].value);
            var thumb2Position = this._getPositionFromValue(nextProps.sliderThumbs[1].value);
            shouldRender = thumb2Position > 0 ? thumb2Position >= thumb1Position + nextProps.step : true;
        }
        return shouldRender;
    };
    Slider.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this._handleUpdate);
    };
    Slider.prototype.render = function () {
        var _a, _b, _c, _d, _e;
        var orientation = this.props.orientation;
        var sliderClass = this.props.className
            ? Slider.sliderBaseClass + " slider-" + orientation + " " + this.props.className
            : Slider.sliderBaseClass + " slider-" + orientation;
        var sliderId = this.props.id;
        var dimension = orientations[orientation].dimension;
        var direction = orientations[orientation].direction;
        var camelCasedDirection = utilities_1.toUpperCaseFirstChar(direction);
        var positionThumb1 = this._getPositionFromValue(this.props.sliderThumbs[0].value);
        var coordsThumb1 = this._coordinates(positionThumb1);
        var fillStyle = (_a = {}, _a[dimension] = coordsThumb1.fill + "px", _a);
        var handleStyle = [];
        handleStyle.push((_b = {}, _b[direction] = coordsThumb1.handle + "px", _b));
        var trackProgressClass = classnames_1.default('progress-bar', this.props.trackProgressClass ? this.props.trackProgressClass : '');
        if (this.isRangeSlider) {
            var positionThumb2 = this._getPositionFromValue(this.props.sliderThumbs[1].value);
            var coordsThumb2 = this._coordinates(positionThumb2);
            handleStyle.push((_c = {}, _c[direction] = coordsThumb2.handle + "px", _c));
            if (orientation === 'vertical') {
                fillStyle = (_d = {},
                    _d["marginBottom"] = coordsThumb1.fill + "px",
                    _d[dimension] = coordsThumb2.fill - coordsThumb1.fill + "px",
                    _d);
            }
            else {
                fillStyle = (_e = {},
                    _e["margin" + camelCasedDirection] = (orientations.horizontal.direction === "right" ? coordsThumb1.fill - this.state.grab : coordsThumb1.fill) + "px",
                    _e[dimension] = coordsThumb2.handle - coordsThumb1.handle + "px",
                    _e);
            }
        }
        return (React.createElement("div", { className: sliderClass, ref: this.ref, onClick: this._handleOnClick, role: 'none' },
            this.props.showProgressBar && (React.createElement(__1.Progress, tslib_1.__assign({ id: "progress_" + sliderId, ariaLabel: this.props.ariaLabel, className: trackProgressClass, min: this.props.min, max: this.props.max, value: this.props.fillTrackValue ? this.props.fillTrackValue : 0 }, (this.props.fillTrackValue ? { 'aria-valuetext': this.props.fillTrackValue } : {})))),
            React.createElement("div", { className: 'slider__track', id: "" + sliderId, style: fillStyle }),
            this._renderSliderThumbs(handleStyle),
            this.props.showLabels ? this._renderLabels(this.props.labels) : null));
    };
    Slider.prototype._handleEnd = function (e) {
        var _this = this;
        e.stopPropagation();
        var eventType = e.type;
        var castTarget = e.target;
        this.setState(function (_prevState) {
            return { active: false, id: '' };
        }, function () {
            _this._getThumbAndPublishEvent(castTarget, 1, eventType);
        });
        document.removeEventListener('mousemove', this._handleDrag);
        document.removeEventListener('mouseup', this._handleEnd);
    };
    Slider.prototype._handleDrag = function (e) {
        e.stopPropagation();
        var value = this._position(e);
        var eventType = e.type;
        var castThumb = e.target;
        var thumbId = this.state.id || (castThumb && castThumb.id);
        var thumbPressed = this._getThumbFromProps(thumbId);
        if (thumbPressed && !this._willThumbsCrossOver(thumbPressed[0], e)) {
            thumbPressed[0].value = value;
            this._setSliderValue(thumbPressed, castThumb, eventType);
        }
    };
    Slider.prototype._handleOnClick = function (e) {
        var _this = this;
        e.stopPropagation();
        var position = this._position(e);
        var castThumb = e.target;
        var thumb1 = this._getThumbFromProps(this.props.sliderThumbs[0].id);
        var eventType = e.type;
        if (this.isRangeSlider) {
            var thumb2_1 = this._getThumbFromProps(this.props.sliderThumbs[1].id);
            if (thumb1 && thumb2_1) {
                var thumb2Value = thumb2_1[0].value;
                if (position >= thumb2Value) {
                    thumb2_1[0].value = position;
                }
                else {
                    thumb1[0].value = position;
                }
                this.setState(function (_prevState) {
                    return ({ sliderThumbs: [thumb1[0], thumb2_1[0]] });
                }, function () {
                    _this._getThumbAndPublishEvent(castThumb, 2, eventType);
                });
            }
        }
        else if (thumb1) {
            thumb1[0].value = position;
            this.setState(function (_prevState) {
                return ({ sliderThumbs: thumb1 });
            }, function () {
                _this._getThumbAndPublishEvent(castThumb, 2, eventType);
            });
        }
    };
    Slider.prototype._handleOnChange = function (e) {
        e.stopPropagation();
        var castTarget = e.target;
        var thumbInteractedWith = castTarget && this._getThumbFromProps(castTarget.id.replace('range', ''));
        var eventType = e.type;
        thumbInteractedWith[0].value = parseInt(e.target.value, 10);
        this._setSliderValue(thumbInteractedWith, castTarget, eventType);
    };
    Slider.prototype._getThumbFromProps = function (thumbId) {
        var thumbFound;
        thumbFound = this.props.sliderThumbs.filter(function (thumb) {
            return thumb.id === thumbId;
        });
        return thumbFound.length > 0 ? thumbFound : null;
    };
    Slider.prototype._willThumbsCrossOver = function (thumbPressed, event) {
        if (!this.isRangeSlider) {
            return false;
        }
        else {
            var keycode = 0;
            var checkCondition = false;
            if (event.type === 'keydown') {
                var castEvent = event;
                keycode = castEvent.keyCode;
                if ((thumbPressed === this.props.sliderThumbs[1] && (keycode === 38 || keycode === 39)) ||
                    (thumbPressed === this.props.sliderThumbs[0] && (keycode === 37 || keycode === 40))) {
                    return false;
                }
                else {
                    checkCondition = true;
                }
            }
            if (event.type === 'touchmove' || event.type === 'mousemove' || event.type === 'click') {
                var value = this._position(event);
                if ((this.state.sliderThumbs[1].value < value && thumbPressed.id === this.props.sliderThumbs[1].id) ||
                    (this.state.sliderThumbs[0].value > value && thumbPressed.id === this.props.sliderThumbs[0].id)) {
                    return false;
                }
                else {
                    checkCondition = true;
                }
            }
            return checkCondition && this.props.sliderThumbs[1].value - this.props.step * 2 >= this.props.sliderThumbs[0].value
                ? false
                : true;
        }
    };
    Slider.defaultProps = {
        showTooltip: true,
        inForm: false,
        orientation: 'horizontal',
        min: 0,
        max: 100,
        step: 1,
        sliderThumbs: [{ id: 'slider_thumb_id', value: 50 }]
    };
    Slider.sliderBaseClass = 'slider';
    return Slider;
}(React.Component));
exports.default = Slider;
//# sourceMappingURL=Slider.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var React = tslib_1.__importStar(require("react"));
var utilities_1 = require("../common/utilities");
var PopperContent_1 = tslib_1.__importDefault(require("../popper-content/PopperContent"));
var DEFAULT_DELAYS = {
    show: 0,
    hide: 250
};
var Tooltip = (function (_super) {
    tslib_1.__extends(Tooltip, _super);
    function Tooltip(props) {
        var _this = _super.call(this, props) || this;
        _this.ref = React.createRef();
        _this.addTargetEvents = _this.addTargetEvents.bind(_this);
        _this.handleDocumentClick = _this.handleDocumentClick.bind(_this);
        _this.removeTargetEvents = _this.removeTargetEvents.bind(_this);
        _this.toggle = _this.toggle.bind(_this);
        _this.onMouseOverTooltip = _this.onMouseOverTooltip.bind(_this);
        _this.onMouseLeaveTooltip = _this.onMouseLeaveTooltip.bind(_this);
        _this.onMouseOverTooltipContent = _this.onMouseOverTooltipContent.bind(_this);
        _this.onMouseLeaveTooltipContent = _this.onMouseLeaveTooltipContent.bind(_this);
        _this.show = _this.show.bind(_this);
        _this.hide = _this.hide.bind(_this);
        _this.onFocusOutTarget = _this.onFocusOutTarget.bind(_this);
        _this.onEscKeyDown = _this.onEscKeyDown.bind(_this);
        _this.onEscKeyDownNative = _this.onEscKeyDownNative.bind(_this);
        _this.target = null;
        _this.isMobile = false;
        _this.tabPressed = false;
        _this.state = {
            tooltipOpen: props.isOpen
        };
        return _this;
    }
    Tooltip.prototype.componentDidMount = function () {
        this.target = utilities_1.getTargetElement(this.props.target);
        this.addTargetEvents();
        var body = document.getElementsByTagName('body').item(0);
        if (body) {
            var bodyClasses = body.getAttribute('class');
            if (bodyClasses && bodyClasses.indexOf('mobile') > -1) {
                this.isMobile = true;
            }
        }
        if (this.target !== null && this.target.attributes.getNamedItem('aria-describedby') !== null) {
            this.target.attributes.removeNamedItem('aria-describedby');
        }
    };
    Tooltip.prototype.componentWillUnmount = function () {
        this.clearHideTimeout();
        this.clearShowTimeout();
        this.removeTargetEvents();
    };
    Tooltip.prototype.onMouseOverTooltip = function (e) {
        if (this.hideTimeout) {
            this.clearHideTimeout();
        }
        this.showTimeout = window.setTimeout(this.show.bind(this, e), this.getDelay('show'));
    };
    Tooltip.prototype.onMouseLeaveTooltip = function (e) {
        if (this.showTimeout) {
            this.clearShowTimeout();
        }
        this.hideTimeout = window.setTimeout(this.hide.bind(this, e), this.getDelay('hide'));
    };
    Tooltip.prototype.onMouseOverTooltipContent = function () {
        if (this.props.autohide) {
            return;
        }
        if (this.hideTimeout) {
            this.clearHideTimeout();
        }
    };
    Tooltip.prototype.onMouseLeaveTooltipContent = function (e) {
        if (this.props.autohide) {
            return;
        }
        if (this.showTimeout) {
            this.clearShowTimeout();
        }
        this.hideTimeout = window.setTimeout(this.hide.bind(this, e.nativeEvent), this.getDelay('hide'));
    };
    Tooltip.prototype.onFocusOutTarget = function (e) {
        var _this = this;
        if (!this.props.isOpen) {
            return;
        }
        if (this.tabPressed) {
            this.tabPressed = false;
            setTimeout(function () {
                var nextFocus = document.activeElement;
                if (!_this.ref || !_this.ref.current || !_this.ref.current.contains(nextFocus)) {
                    _this.hide(e);
                }
            }, 1);
        }
        else {
            this.hide(e);
        }
    };
    Tooltip.prototype.onEscKeyDown = function (e) {
        if (e.keyCode === 9) {
            this.tabPressed = true;
        }
        else if (e.key === 'Escape') {
            this.hide(e.nativeEvent);
        }
    };
    Tooltip.prototype.onEscKeyDownNative = function (e) {
        if (e.keyCode === 9) {
            this.tabPressed = true;
        }
        else if (e.key === 'Escape') {
            this.hide(e);
        }
    };
    Tooltip.prototype.getDelay = function (key) {
        var delay = this.props.delay;
        if (typeof delay === 'object') {
            return isNaN(delay[key]) ? DEFAULT_DELAYS[key] : delay[key];
        }
        return delay || 0;
    };
    Tooltip.prototype.show = function (e) {
        if (!this.props.isOpen) {
            this.clearShowTimeout();
            this.toggle(e);
            if (this.target !== null) {
                var ariaAttr = document.createAttribute('aria-describedby');
                ariaAttr.value = this.props.id;
                this.target.attributes.setNamedItem(ariaAttr);
            }
        }
    };
    Tooltip.prototype.hide = function (e) {
        if (this.props.isOpen) {
            this.clearHideTimeout();
            this.toggle(e);
            if (this.target !== null && this.target.attributes.getNamedItem('aria-describedby') !== null) {
                this.target.attributes.removeNamedItem('aria-describedby');
            }
        }
    };
    Tooltip.prototype.clearShowTimeout = function () {
        clearTimeout(this.showTimeout);
        this.showTimeout = undefined;
    };
    Tooltip.prototype.clearHideTimeout = function () {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = undefined;
    };
    Tooltip.prototype.handleDocumentClick = function (e) {
        if (!this.target) {
            return;
        }
        var target = e.target;
        if (e.target === this.target || this.target.contains(target)) {
            if (this.hideTimeout) {
                this.clearHideTimeout();
            }
            if (!this.props.isOpen) {
                this.toggle(e);
            }
        }
        else if (this.props.isOpen && target.getAttribute('role') !== 'tooltip') {
            if (this.showTimeout) {
                this.clearShowTimeout();
            }
            this.hideTimeout = window.setTimeout(this.hide.bind(this, e), this.getDelay('hide'));
        }
    };
    Tooltip.prototype.addTargetEvents = function () {
        var _this = this;
        if (!this.target) {
            return;
        }
        if (this.props.trigger) {
            var triggers = this.props.trigger.split(' ');
            if (triggers.indexOf('manual') === -1) {
                if (triggers.indexOf('click') > -1) {
                    ['click', 'touchstart'].forEach(function (event) {
                        document.addEventListener(event, _this.handleDocumentClick, true);
                    });
                }
                if (triggers.indexOf('hover') > -1) {
                    this.target.addEventListener('mouseover', this.onMouseOverTooltip, true);
                    this.target.addEventListener('mouseout', this.onMouseLeaveTooltip, true);
                }
                if (triggers.indexOf('focus') > -1) {
                    this.target.addEventListener('focusin', this.show, true);
                    if (this.props.displayMode === 'FLYOUT') {
                        this.target.addEventListener('focusout', this.onFocusOutTarget, true);
                    }
                    else {
                        this.target.addEventListener('focusout', this.hide, true);
                    }
                }
                this.target.addEventListener('keydown', this.onEscKeyDownNative, true);
            }
        }
        else {
            this.target.addEventListener('mouseover', this.onMouseOverTooltip, true);
            this.target.addEventListener('mouseout', this.onMouseLeaveTooltip, true);
            this.target.addEventListener('keydown', this.onEscKeyDownNative, true);
            this.target.addEventListener('focusin', this.show, true);
            if (this.props.displayMode === 'FLYOUT') {
                this.target.addEventListener('focusout', this.onFocusOutTarget, true);
            }
            else {
                this.target.addEventListener('focusout', this.hide, true);
            }
            ['click', 'touchstart'].forEach(function (event) {
                document.addEventListener(event, _this.handleDocumentClick, true);
            });
        }
    };
    Tooltip.prototype.removeTargetEvents = function () {
        var _this = this;
        if (!this.target) {
            return;
        }
        this.target.removeEventListener('mouseover', this.onMouseOverTooltip, true);
        this.target.removeEventListener('mouseout', this.onMouseLeaveTooltip, true);
        this.target.removeEventListener('keydown', this.onEscKeyDownNative, true);
        this.target.removeEventListener('focusin', this.show, true);
        this.target.removeEventListener('focusout', this.onFocusOutTarget, true);
        this.target.removeEventListener('focusout', this.hide, true);
        ['click', 'touchstart'].forEach(function (event) {
            document.removeEventListener(event, _this.handleDocumentClick, true);
        });
    };
    Tooltip.prototype.toggle = function (e) {
        if (e) {
            if (this.props.disabled) {
                e.preventDefault();
            }
            if (this.props.toggle) {
                this.props.toggle();
            }
        }
    };
    Tooltip.prototype.render = function () {
        if (!this.props.isOpen || this.isMobile) {
            return null;
        }
        var _a = this.props, cssModule = _a.cssModule, isOpen = _a.isOpen, target = _a.target, placementPrefix = _a.placementPrefix, hideArrow = _a.hideArrow, className = _a.className, innerClassName = _a.innerClassName, innerRef = _a.innerRef, modifiers = _a.modifiers, toggle = _a.toggle, autohide = _a.autohide, delay = _a.delay, placement = _a.placement, disabled = _a.disabled, trigger = _a.trigger, boundariesElement = _a.boundariesElement, offset = _a.offset, arrowClassName = _a.arrowClassName, displayMode = _a.displayMode, id = _a.id, attributes = tslib_1.__rest(_a, ["cssModule", "isOpen", "target", "placementPrefix", "hideArrow", "className", "innerClassName", "innerRef", "modifiers", "toggle", "autohide", "delay", "placement", "disabled", "trigger", "boundariesElement", "offset", "arrowClassName", "displayMode", "id"]);
        var classes = utilities_1.mapToCssModules(classnames_1.default(displayMode === 'FLYOUT' ? 'msc-flyout-inner' : 'msc-tooltip-inner', this.props.innerClassName), this.props.cssModule);
        var popperClasses = utilities_1.mapToCssModules(classnames_1.default(displayMode === 'FLYOUT' ? 'msc-flyout' : 'msc-tooltip', 'show', this.props.className), this.props.cssModule);
        return (React.createElement("div", { ref: this.ref },
            React.createElement(PopperContent_1.default, { placement: placement, isOpen: isOpen || false, target: target, className: popperClasses, hideArrow: hideArrow, placementPrefix: placementPrefix, boundariesElement: boundariesElement, arrowClassName: arrowClassName, offset: offset, modifiers: modifiers, cssModule: cssModule },
                React.createElement("div", tslib_1.__assign({}, attributes, { className: classes, role: displayMode === undefined || displayMode === 'TOOLTIP' ? 'tooltip' : undefined, ref: innerRef, id: this.props.id, "aria-hidden": isOpen, onMouseOver: this.onMouseOverTooltipContent, onMouseLeave: this.onMouseLeaveTooltipContent, onKeyDown: this.onEscKeyDown })))));
    };
    Tooltip.defaultProps = {
        isOpen: false,
        hideArrow: false,
        placement: 'top',
        placementPrefix: 'msc-bs-tooltip',
        delay: DEFAULT_DELAYS,
        autohide: true,
        toggle: function () { return; }
    };
    return Tooltip;
}(React.Component));
exports.default = Tooltip;
//# sourceMappingURL=Tooltip.js.map
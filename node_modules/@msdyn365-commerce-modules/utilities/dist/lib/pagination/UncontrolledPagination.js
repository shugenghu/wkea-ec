"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classnames_1 = tslib_1.__importDefault(require("classnames"));
var React = tslib_1.__importStar(require("react"));
var __1 = require("..");
var utilities_1 = require("../common/utilities");
var PaginationItem_1 = tslib_1.__importDefault(require("./PaginationItem"));
var PaginationLink_1 = tslib_1.__importDefault(require("./PaginationLink"));
var UncontrolledPagination = (function (_super) {
    tslib_1.__extends(UncontrolledPagination, _super);
    function UncontrolledPagination(props) {
        var _this = _super.call(this, props) || this;
        _this.activePage = 0;
        _this.maxPages = _this.props.items ? Math.ceil(_this.props.items / _this.props.itemsPerPage) : 0;
        _this.activePage = Math.floor((_this.props.startingItem || 0) / _this.props.itemsPerPage);
        _this.qsps = {};
        var splitUrl = _this.props.url.split('?');
        if (splitUrl[1]) {
            _this.url = splitUrl[0];
            var secondSplit = splitUrl[1].split('#');
            _this.hash = secondSplit[1] ? "#" + secondSplit[1] : '';
            var parsedQsps = secondSplit[0].split('&');
            for (var _i = 0, parsedQsps_1 = parsedQsps; _i < parsedQsps_1.length; _i++) {
                var qsp = parsedQsps_1[_i];
                var qspPair = qsp.split('=');
                if (_this.props.qsp !== qspPair[0]) {
                    _this.qsps[qspPair[0]] = qspPair[1];
                }
            }
        }
        else {
            var secondSplit = splitUrl[0].split('#');
            _this.url = secondSplit[0];
            _this.hash = secondSplit[1] ? "#" + secondSplit[1] : '';
        }
        return _this;
    }
    UncontrolledPagination.prototype.render = function () {
        var _a;
        var _b = this.props, className = _b.className, baseUrl = _b.baseUrl, qsp = _b.qsp, items = _b.items, itemsPerPage = _b.itemsPerPage, startingItem = _b.startingItem, previousText = _b.previousText, nextText = _b.nextText, previousAriaLabel = _b.previousAriaLabel, nextAriaLabel = _b.nextAriaLabel, listClassName = _b.listClassName, cssModule = _b.cssModule, children = _b.children, size = _b.size, Tag = _b.tag, ListTag = _b.listTag, label = _b["aria-label"], role = _b.role, props = tslib_1.__rest(_b, ["className", "baseUrl", "qsp", "items", "itemsPerPage", "startingItem", "previousText", "nextText", "previousAriaLabel", "nextAriaLabel", "listClassName", "cssModule", "children", "size", "tag", "listTag", 'aria-label', "role"]);
        this.maxPages = this.props.items ? Math.ceil(this.props.items / this.props.itemsPerPage) : 0;
        this.activePage = Math.floor((this.props.startingItem || 0) / this.props.itemsPerPage);
        this.qsps = {};
        var splitUrl = this.props.url.split('?');
        if (splitUrl[1]) {
            this.url = splitUrl[0];
            var secondSplit = splitUrl[1].split('#');
            this.hash = secondSplit[1] ? "#" + secondSplit[1] : '';
            var parsedQsps = secondSplit[0].split('&');
            for (var _i = 0, parsedQsps_2 = parsedQsps; _i < parsedQsps_2.length; _i++) {
                var activeQsp = parsedQsps_2[_i];
                var qspPair = activeQsp.split('=');
                if (this.props.qsp !== qspPair[0]) {
                    this.qsps[qspPair[0]] = qspPair[1];
                }
            }
        }
        else {
            var secondSplit = splitUrl[0].split('#');
            this.url = secondSplit[0];
            this.hash = secondSplit[1] ? "#" + secondSplit[1] : '';
        }
        var paginationClasses = utilities_1.mapToCssModules(classnames_1.default(className), cssModule);
        var listpaginationClasses = utilities_1.mapToCssModules(classnames_1.default(listClassName, 'msc-pagination', (_a = {},
            _a["msc-pagination-" + size] = !!size,
            _a)), cssModule);
        return (React.createElement(Tag, { className: paginationClasses, role: 'navigation', "aria-label": label },
            React.createElement(ListTag, tslib_1.__assign({}, props, { className: listpaginationClasses }), this._generatePageLinks())));
    };
    UncontrolledPagination.prototype._generateUrl = function (page) {
        var _this = this;
        var items = this.props.itemsPerPage * page;
        var keys = Object.keys(this.qsps);
        var qspUrl = page > 0 ? "?" + this.props.qsp + "=" + items : '';
        keys.forEach(function (key) {
            qspUrl = qspUrl ? qspUrl + "&" + key + "=" + _this.qsps[key] : "?" + key + "=" + _this.qsps[key];
        });
        return this.url + qspUrl + this.hash;
    };
    UncontrolledPagination.prototype._generatePaginationArrow = function (next, disable, className) {
        var url = disable ? undefined : this._generateUrl(this.activePage + (next ? 1 : -1));
        var tooltipId = next ? this.props.nextId : this.props.prevId;
        var ariaDescribedBy = next ? this.props.nextAreaDescribed : this.props.prevAreaDescribed;
        var placement = next ? 'right' : 'left';
        var tag = disable ? 'span' : 'a';
        return (React.createElement(PaginationItem_1.default, { disabled: disable, className: className },
            React.createElement(PaginationLink_1.default, { id: tooltipId, href: url, next: next, previous: !next, "aria-describedby": ariaDescribedBy, tag: tag, role: 'link', "aria-label": next ? this.props.nextAriaLabel : this.props.previousAriaLabel, "aria-disabled": disable, telemetryContent: this.props.telemetryContent }, next ? this.props.nextText : this.props.previousText),
            tooltipId && (React.createElement(__1.UncontrolledTooltip, { placement: placement, id: ariaDescribedBy, target: tooltipId }, next ? 'next' : 'previous'))));
    };
    UncontrolledPagination.prototype._generatePaginationItem = function (page) {
        var active = this.activePage === page;
        var url = this._generateUrl(page);
        page = page + 1;
        return (React.createElement(PaginationItem_1.default, { active: active },
            React.createElement(PaginationLink_1.default, { href: active ? undefined : url, telemetryContent: this.props.telemetryContent }, page)));
    };
    UncontrolledPagination.prototype._generateEllipse = function () {
        return (React.createElement(PaginationItem_1.default, null,
            React.createElement(PaginationLink_1.default, { tag: 'span' }, "...")));
    };
    UncontrolledPagination.prototype._generatePageLinks = function () {
        var displayCountSide = 3;
        var leftDistance = this.activePage;
        var rightDistance = this.maxPages - this.activePage - 1;
        var leftEllipse = this.maxPages > UncontrolledPagination.pagesDisplayed && leftDistance > 3;
        var rightEllipse = this.maxPages > UncontrolledPagination.pagesDisplayed && rightDistance > 3;
        leftDistance = Math.min(leftDistance, displayCountSide);
        rightDistance = Math.min(rightDistance, displayCountSide);
        var pages = [];
        var ellipseOffset = leftEllipse ? -1 : 0;
        var displayedPagesOnLeft = leftDistance + (displayCountSide - rightDistance) + ellipseOffset;
        var startingIndex = Math.max(this.activePage - displayedPagesOnLeft, 0);
        var endIndex = Math.min((startingIndex + 5 + (rightEllipse ? 0 : 1) + (leftEllipse ? 0 : 1)), (rightEllipse ? this.maxPages - 1 : this.maxPages));
        if (leftEllipse) {
            pages.push(this._generatePaginationItem(0));
            pages.push(this._generateEllipse());
        }
        for (var i = startingIndex; i < endIndex; i++) {
            pages.push(this._generatePaginationItem(i));
        }
        if (rightEllipse) {
            pages.push(this._generateEllipse());
            pages.push(this._generatePaginationItem(this.maxPages - 1));
        }
        return (React.createElement(React.Fragment, null,
            this._generatePaginationArrow(false, (this.activePage === 0), 'previous'),
            pages,
            this._generatePaginationArrow(true, (this.activePage === this.maxPages - 1), 'next')));
    };
    UncontrolledPagination.defaultProps = {
        tag: 'nav',
        listTag: 'ul',
        'aria-label': 'pagination',
        items: 0,
        itemsPerPage: 25,
        startingItem: 0,
    };
    UncontrolledPagination.pagesDisplayed = 7;
    return UncontrolledPagination;
}(React.Component));
exports.default = UncontrolledPagination;
//# sourceMappingURL=UncontrolledPagination.js.map
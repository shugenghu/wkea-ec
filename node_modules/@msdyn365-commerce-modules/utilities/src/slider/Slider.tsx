import MsDyn365 from '@msdyn365-commerce/core';
import classnames from 'classnames';
import * as React from 'react';
import { Progress } from '../';
import { clamp, toUpperCaseFirstChar } from './../common/utilities';
import { ISliderChangeNotification, ISliderLabel, ISliderProps, ISliderThumbProps } from './Slider.props';
import SliderThumb from './SliderThumb';

// This maintains the min and max values for the 2 thumbs
export interface ISliderState {
    sliderThumbs: ISliderThumbProps[];
    limit: number;
    grab: number;
    active: boolean;
    id: string;
}

const orientations = {
    horizontal: {
        dimension: 'width',
        direction: 'left',
        coordinate: 'x'
    },
    vertical: {
        dimension: 'height',
        direction: 'top',
        coordinate: 'y'
    }
};

interface IFillCoordinates {
    fill: number;
    handle: number;
    label: number;
}

const enum EventType {
    Start,
    End,
    Change
}

/**
 * Slider - This is a slider component this component morphs into a range slider
 * based on flags
 */

export default class Slider extends React.Component<ISliderProps, ISliderState> {
    public static defaultProps: Partial<ISliderProps> = {
        showTooltip: true,
        inForm: false,
        orientation: 'horizontal',
        min: 0,
        max: 100,
        step: 1,
        sliderThumbs: [{ id: 'slider_thumb_id', value: 50 }]
    };
    private static sliderBaseClass: string = 'slider';

    public isRangeSlider: boolean;
    private ref: React.RefObject<HTMLDivElement> = React.createRef<HTMLDivElement>();
    private thumb1Ref: React.RefObject<SliderThumb> = React.createRef<SliderThumb>();
    private thumb2Ref: React.RefObject<SliderThumb> = React.createRef<SliderThumb>();

    public static getDerivedStateFromProps(props: ISliderProps, state: ISliderState): ISliderState | null {
        if ((props.sliderThumbs.length && props.sliderThumbs[0].value !== state.sliderThumbs[0].value) ||
                (props.sliderThumbs.length > 1 && props.sliderThumbs[1].value !== state.sliderThumbs[1].value)) {
                const nextState = { ...state };
                nextState.sliderThumbs[0].value = props.sliderThumbs[0].value;
                if (props.sliderThumbs.length > 1) {
                    nextState.sliderThumbs[1].value = props.sliderThumbs[1].value;
                }
                return nextState;
            }
        return null;
    }

    constructor(props: ISliderProps) {
        super(props);
        this.isRangeSlider = this.props.sliderThumbs.length === 2;
        this.state = {
            sliderThumbs: this.props.sliderThumbs,
            grab: 0,
            limit: 0,
            active: false,
            id: ''
        };
        this._handleUpdate = this._handleUpdate.bind(this);
        this._handleDrag = this._handleDrag.bind(this);
        this._handleEnd = this._handleEnd.bind(this);
        this._handleStart = this._handleStart.bind(this);
        this._handleOnChange = this._handleOnChange.bind(this);
        this._setSliderValue = this._setSliderValue.bind(this);
        this._getThumbFromProps = this._getThumbFromProps.bind(this);
        this._publishNotification = this._publishNotification.bind(this);
        this._getThumbAndPublishEvent = this._getThumbAndPublishEvent.bind(this);
        this._willThumbsCrossOver = this._willThumbsCrossOver.bind(this);
        this._handleOnClick = this._handleOnClick.bind(this);
        if (MsDyn365.isBrowser && document.body.parentElement && document.body.parentElement.getAttribute('dir') === 'rtl') {
            orientations.horizontal.direction ='right';
        }
    }

    public componentDidMount(): void {
        this._handleUpdate();
        MsDyn365.isBrowser && window.addEventListener('resize', this._handleUpdate);
    }

    public shouldComponentUpdate(nextProps: ISliderProps, _nextState: ISliderState): boolean {
        let shouldRender = true;
        if (this.isRangeSlider) {
            const thumb1Position = this._getPositionFromValue(nextProps.sliderThumbs[0].value);
            const thumb2Position = this._getPositionFromValue(nextProps.sliderThumbs[1].value);
            /**
             * During first render the second thumb isn't positioned since handleUpdate positions it after it's mounted
             * in the componentDidMount method. This check is to make sure that the first render happens correctly and then
             * for all subsequent renders and updates, the thumb2 position cannot be 0 thanks to this condition.
             */
            shouldRender = thumb2Position > 0 ? thumb2Position >= thumb1Position + nextProps.step : true;
        }
        return shouldRender;
    }

    public componentWillUnmount(): void {
        window.removeEventListener('resize', this._handleUpdate);
    }

    public render(): JSX.Element {
        const { orientation } = this.props;
        const sliderClass = this.props.className
            ? `${Slider.sliderBaseClass} slider-${orientation} ${this.props.className}`
            : `${Slider.sliderBaseClass} slider-${orientation}`;

        const sliderId = this.props.id;
        const dimension = orientations[orientation].dimension;
        const direction = orientations[orientation].direction;
        const camelCasedDirection = toUpperCaseFirstChar(direction);
        const positionThumb1 = this._getPositionFromValue(this.props.sliderThumbs[0].value);
        const coordsThumb1 = this._coordinates(positionThumb1);
        let fillStyle = { [dimension]: `${coordsThumb1.fill}px` };
        const handleStyle: React.CSSProperties[] = [];
        handleStyle.push({ [direction]: `${coordsThumb1.handle}px` });
        const trackProgressClass = classnames('progress-bar', this.props.trackProgressClass ? this.props.trackProgressClass : '');

        if (this.isRangeSlider) {
            const positionThumb2 = this._getPositionFromValue(this.props.sliderThumbs[1].value);
            const coordsThumb2 = this._coordinates(positionThumb2);
            handleStyle.push({ [direction]: `${coordsThumb2.handle}px` });
            if (orientation === 'vertical') {
                fillStyle = {
                    [`marginBottom`]: `${coordsThumb1.fill}px`,
                    [dimension]: `${coordsThumb2.fill - coordsThumb1.fill}px`
                };
            } else {
                fillStyle = {
                    [`margin${camelCasedDirection}`]: `${orientations.horizontal.direction === `right` ? coordsThumb1.fill - this.state.grab : coordsThumb1.fill }px`,
                    [dimension]: `${coordsThumb2.handle - coordsThumb1.handle}px`
                };
            }
        }

        return (
            <div className={sliderClass} ref={this.ref} onClick={this._handleOnClick} role='none'>
                {this.props.showProgressBar && (
                    <Progress
                        id={`progress_${sliderId}`}
                        ariaLabel={this.props.ariaLabel}
                        className={trackProgressClass}
                        min={this.props.min}
                        max={this.props.max}
                        value={this.props.fillTrackValue ? this.props.fillTrackValue : 0 }
                        {...(this.props.fillTrackValue ? { 'aria-valuetext': this.props.fillTrackValue } : {})}
                    />
                )}
                <div className='slider__track' id={`${sliderId}`} style={fillStyle} />
                {this._renderSliderThumbs(handleStyle)}
                {this.props.showLabels ? this._renderLabels(this.props.labels!) : null}
            </div>
        );
    }

    private _renderLabels = (labels: ISliderLabel[]): JSX.Element => {
        return (
            <div className={'slider__labels p-0'}>
                {labels.map((label: ISliderLabel) => {
                    return (
                        <div key={label.labelId} role='presentation' className={`slider__labels-item ${label.labelPositioning}`}>
                            {label.labelString}
                        </div>
                    );
                })}
            </div>
        );
    };

    private _renderSliderThumbs = (thumbStyles: React.CSSProperties[]): React.ReactFragment | JSX.Element | null => {
        return (
            <React.Fragment>
                <input
                    type={'range'}
                    id={`${this.props.sliderThumbs[0].id}range`}
                    className={`slider__thumb__range sr-only`}
                    min={this.props.min}
                    max={this.isRangeSlider ? this.state.sliderThumbs[1].value - this.props.step : this.props.max}
                    value={this.state.sliderThumbs[0].value}
                    role='slider'
                    aria-live='polite'
                    aria-valuemin={this.props.min}
                    aria-valuemax={this.isRangeSlider ? this.state.sliderThumbs[1].value - this.props.step : this.props.max}
                    aria-label={this.props.sliderThumbs[0].ariaLabel}
                    aria-valuenow={this.state.sliderThumbs[0].value}
                    aria-orientation={this.props.orientation}
                    onChange={this._handleOnChange}
                    onBlur={this.props.onBlur}
                />
                <SliderThumb
                    id={this.props.sliderThumbs[0].id}
                    ref={this.thumb1Ref}
                    handleStart={this._handleStart}
                    handleDrag={this._handleDrag}
                    handleEnd={this._handleEnd}
                    handleFocus={this.props.onFocus}
                    handleBlur={this.props.onBlur}
                    handleTooltipText={this.props.handleTooltipText}
                    showTooltip={this.props.showTooltip}
                    style={thumbStyles[0]}
                    trackThumbClass={this.props.trackThumbClass}
                    sliderValue={this.state.sliderThumbs[0].value}
                />{' '}
                {this.isRangeSlider && (
                    <>
                        <input
                            type={'range'}
                            id={`${this.props.sliderThumbs[1].id}range`}
                            className={`slider__thumb__range sr-only`}
                            min={this.state.sliderThumbs[0].value + this.props.step}
                            max={this.props.max}
                            value={this.state.sliderThumbs[1].value}
                            role='slider'
                            aria-live='polite'
                            aria-valuemin={this.state.sliderThumbs[0].value + this.props.step}
                            aria-valuemax={this.props.max}
                            aria-label={this.props.sliderThumbs[1].ariaLabel}
                            aria-valuenow={this.state.sliderThumbs[1].value}
                            aria-orientation={this.props.orientation}
                            onChange={this._handleOnChange}
                            onBlur={this.props.onBlur}
                            onFocus={this.props.onFocus}
                        />
                        <SliderThumb
                            id={this.props.sliderThumbs[1].id}
                            ref={this.thumb2Ref}
                            sliderValue={this.state.sliderThumbs[1].value}
                            handleStart={this._handleStart}
                            handleDrag={this._handleDrag}
                            handleEnd={this._handleEnd}
                            handleFocus={this.props.onFocus}
                            handleBlur={this.props.onBlur}
                            handleTooltipText={this.props.handleTooltipText}
                            showTooltip={this.props.showTooltip}
                            style={thumbStyles[1]}
                            trackThumbClass={this.props.trackThumbClass}
                            ariaValueText={this.props.sliderThumbs[1].ariaValueText}
                        />
                    </>
                )}
            </React.Fragment>
        );
    };

    private _handleUpdate = (): void => {
        const { orientation } = this.props;
        const dimensionStr = toUpperCaseFirstChar(orientations[orientation].dimension);

        // To get the offsetWidth and offsetHeight of the slider element
        const sliderPos = this.ref.current![`offset${dimensionStr}`];
        const handlePos = this.thumb1Ref.current!.sliderButtonRef.current![`offset${dimensionStr}`];

        this.setState({
            limit: sliderPos - handlePos,
            grab : orientations.horizontal.direction === 'right' ? - handlePos / 2 : handlePos / 2
        });
    };

    private _handleStart = (e: React.TouchEvent | React.KeyboardEvent | React.MouseEvent): void => {
        e.stopPropagation();
        const eventType = e.type;
        document.addEventListener('mousemove', (this._handleDrag as unknown) as EventListener);
        document.addEventListener('mouseup', (this._handleEnd as unknown) as EventListener);
        const castTarget = e.target as HTMLElement;
        const thumbid = castTarget && castTarget.id;
        this.setState(
            (_prevState: ISliderState) => {
                return { active: true, id: thumbid };
            },
            () => {
                this._getThumbAndPublishEvent(castTarget, EventType.Start, eventType);
            }
        );
    };

    private _handleEnd(e: React.KeyboardEvent | React.MouseEvent | React.TouchEvent): void {
        e.stopPropagation();
        const eventType = e.type;
        const castTarget = e.target as HTMLElement;
        this.setState(
            (_prevState: ISliderState) => {
                return { active: false, id: '' };
            },
            () => {
                this._getThumbAndPublishEvent(castTarget, EventType.End, eventType);
            }
        );
        document.removeEventListener('mousemove', (this._handleDrag as unknown) as EventListener);
        document.removeEventListener('mouseup', (this._handleEnd as unknown) as EventListener);
    }

    private _handleDrag(e: React.MouseEvent | React.TouchEvent): void {
        e.stopPropagation();
        const value = this._position(e);
        const eventType = e.type;
        const castThumb = e.target as HTMLElement;
        const thumbId = this.state.id || (castThumb && castThumb.id);
        const thumbPressed = this._getThumbFromProps(thumbId);

        if (thumbPressed && !this._willThumbsCrossOver(thumbPressed[0], e)) {
            thumbPressed[0].value = value;
            this._setSliderValue(thumbPressed, castThumb, eventType);
        }
    }

    private _handleOnClick(e: React.MouseEvent | React.TouchEvent): void {
        e.stopPropagation();
        const position =  this._position(e);
        const castThumb = e.target as HTMLElement;
        const thumb1 = this._getThumbFromProps(this.props.sliderThumbs[0].id);
        const eventType = e.type;

        if (this.isRangeSlider) {
            const thumb2 = this._getThumbFromProps(this.props.sliderThumbs[1].id);

            if (thumb1 && thumb2) {
                const thumb2Value = thumb2[0].value;

                if (position >= thumb2Value) {
                    thumb2[0].value = position;
                } else {
                    thumb1[0].value = position;
                }

                this.setState(
                    (_prevState: ISliderState) => {
                        return ({ sliderThumbs: [thumb1[0], thumb2[0]] });
                    },
                    () => {
                        this._getThumbAndPublishEvent(castThumb, EventType.Change, eventType);
                    }
                );
            }

        } else if (thumb1) {
            thumb1[0].value = position;
            this.setState(
                (_prevState: ISliderState) => {
                    return ({ sliderThumbs: thumb1 });
                },
                () => {
                    this._getThumbAndPublishEvent(castThumb, EventType.Change, eventType);
                }
            );
        }
    }

    private _position = (e: React.KeyboardEvent | React.MouseEvent | React.TouchEvent): number => {
        const { grab } = this.state;
        const { orientation } = this.props;
        const castEvent = (e as unknown) as TouchEvent;
        const node = this.ref;
        const coordinateStyle = toUpperCaseFirstChar(orientations[orientation].coordinate);
        const directionStyle = orientations[orientation].direction;
        // string conversion to the right property value
        const clientCoordinateStyle = `client${coordinateStyle}`;
        const coordinate = !castEvent.touches ? e[clientCoordinateStyle] : castEvent.touches[0][clientCoordinateStyle];
        const direction = node.current!.getBoundingClientRect()[directionStyle];
        const pos = orientations.horizontal.direction === 'right' ? direction - coordinate - grab : coordinate - direction - grab;
        return this._getValueFromPosition(pos);
    };

    private _getPositionFromValue = (value: number): number => {
        const { limit } = this.state;
        const { min, max } = this.props;
        const diffMaxMin = max - min;
        const diffValMin = value - min;
        const percentage = diffValMin / diffMaxMin;
        return Math.round(percentage * limit);
    };

    /**
     * Translate position of slider to slider value
     * @param  {number} pos - Current position/coordinates of slider
     * @return {number} value - Slider value
     */
    private _getValueFromPosition = (pos: number): number => {
        const { limit } = this.state;
        const { orientation, min, max, step } = this.props;

        const percentage = clamp(pos, 0, limit) / (limit || 1);
        const baseVal = step * Math.round((percentage * (max - min)) / step);
        const value = orientation === 'horizontal' ? baseVal + min : max - baseVal;

        return clamp(value, min, max);
    };

    /**
     * Grab coordinates of slider
     * @param  {Object} pos - Position object
     * @return {Object} - Slider fill/handle coordinates
     */
    private _coordinates = (pos: number): IFillCoordinates => {
        const { limit, grab } = this.state;
        const { orientation } = this.props;
        const value = this._getValueFromPosition(pos);
        const position = this._getPositionFromValue(value);
        const handlePos = orientation === 'horizontal' ? position + grab : position;
        const fillPos = orientation === 'horizontal' ? handlePos : limit - handlePos;

        return {
            fill: fillPos,
            handle: handlePos,
            label: handlePos
        };
    };

    private _handleOnChange(e: React.ChangeEvent<HTMLInputElement>): void {
        e.stopPropagation();
        const castTarget = e.target as HTMLInputElement;
        const thumbInteractedWith = castTarget && this._getThumbFromProps(castTarget.id.replace('range',''));
        const eventType = e.type;
        thumbInteractedWith![0].value = parseInt(e.target.value, 10);
        this._setSliderValue(thumbInteractedWith!, castTarget, eventType);
    }

    private _setSliderValue = (sliderThumb: ISliderThumbProps[], castTarget: HTMLElement, eventType: string): void => {
        if (this.isRangeSlider) {
            this.setState((_prevState: ISliderState) => {
                return {
                    sliderThumbs: { ...this.props.sliderThumbs }
                };
            },            () => {
                this._getThumbAndPublishEvent(castTarget, EventType.Change, eventType);
            });
        } else {
            this.setState((_prevState: ISliderState) => {
                return {
                    sliderThumbs: sliderThumb
                };
            },            () => {
                this._getThumbAndPublishEvent(castTarget, EventType.Change, eventType);
            });
        }
    };

    private _getThumbFromProps(thumbId: string): ISliderThumbProps[] | null {
        let thumbFound;

        thumbFound = this.props.sliderThumbs.filter((thumb: ISliderThumbProps) => {
            return thumb.id === thumbId;
        });

        return thumbFound.length > 0 ? thumbFound : null;
    }

    private _publishNotification = (
        thumb: ISliderThumbProps | null,
        delegate: (sliderNotification: Readonly<ISliderChangeNotification>) => void,
        eventType: string
    ): void => {
        delegate({
            id: (thumb && thumb.id) || '',
            slider: this,
            firstThumbValue: this.state.sliderThumbs[0].value,
            secondThumbValue: (this.state.sliderThumbs[1] && this.state.sliderThumbs[1].value) || NaN,
            eventType: eventType
        });
    };

    private _getThumbAndPublishEvent = (element: HTMLElement, eventType: EventType, nativeEventType: string): void => {
        let elmenentId = '';
        if (element && element.id && eventType === EventType.Change) {
            elmenentId = element.id.replace('range','');
        }
        const thumb = element && this._getThumbFromProps(elmenentId);

        if (eventType === EventType.End) {
            if (this.props.onChangeEnd) {
                this._publishNotification(thumb && thumb[0], this.props.onChangeEnd, nativeEventType);
            }
        }
        if (eventType === EventType.Start) {
            if (this.props.onChangeStart) {
                this._publishNotification(thumb && thumb[0], this.props.onChangeStart, nativeEventType);
            }
        }
        if (eventType === EventType.Change) {
            if (this.props.onChange) {
                this._publishNotification(thumb && thumb[0], this.props.onChange, nativeEventType);
            }
        }
    };

    private _willThumbsCrossOver(
        thumbPressed: ISliderThumbProps,
        event: React.KeyboardEvent | React.MouseEvent | React.TouchEvent
    ): boolean {
        if (!this.isRangeSlider) {
            return false;
        } else {
            let keycode = 0;
            let checkCondition = false;

            if (event.type === 'keydown') {
                const castEvent = (event as unknown) as KeyboardEvent;
                keycode = castEvent.keyCode;
                if (
                    (thumbPressed === this.props.sliderThumbs[1] && (keycode === 38 || keycode === 39)) ||
                    (thumbPressed === this.props.sliderThumbs[0] && (keycode === 37 || keycode === 40))
                ) {
                    return false;
                } else {
                    checkCondition = true;
                }
            }
            if (event.type === 'touchmove' || event.type === 'mousemove' || event.type === 'click') {
                const value = this._position(event);
                if (
                    (this.state.sliderThumbs[1].value < value && thumbPressed.id === this.props.sliderThumbs[1].id) ||
                    (this.state.sliderThumbs[0].value > value && thumbPressed.id === this.props.sliderThumbs[0].id)
                ) {
                    return false;
                } else {
                    checkCondition = true;
                }
            }

            return checkCondition && this.props.sliderThumbs[1].value - this.props.step * 2 >= this.props.sliderThumbs[0].value
                ? false
                : true;
        }
    }
}

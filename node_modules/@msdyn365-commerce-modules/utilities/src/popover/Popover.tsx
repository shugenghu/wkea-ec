import classNames from 'classnames';
import * as React from 'react';
import { canUseDOM, getTargetElement, mapToCssModules } from '../common/utilities';
import PopperContent from '../popper-content/PopperContent';
import { IPopoverProps } from './Popover.props';

/**
 * Popover component
 */
export default class Popover extends React.Component<IPopoverProps> {
    public static defaultProps: Partial<IPopoverProps> = {
        isOpen: false,
        placement: 'right',
        toggle: () => { return; },
    };

    public props: IPopoverProps;
    private target: HTMLElement | null;
    private popover: HTMLDivElement | null;
    private tabPressed: boolean = false;

    constructor(props: IPopoverProps) {
        super(props);
        this.props = props;

        this.popover = null;
        this._addTargetEvents = this._addTargetEvents.bind(this);
        this._handleDocumentClick = this._handleDocumentClick.bind(this);
        this._removeTargetEvents = this._removeTargetEvents.bind(this);
        this.getRef = this.getRef.bind(this);
        this._toggle = this._toggle.bind(this);
        this._focusOutTarget = this._focusOutTarget.bind(this);
        this._focusOutPopover = this._focusOutPopover.bind(this);
        this._keyDown = this._keyDown.bind(this);
        this._show = this._show.bind(this);
        this._hide = this._hide.bind(this);
        this.target = null;
    }

    public componentDidMount(): void {
        this.target = getTargetElement(this.props.target);
        this._handleProps();
    }

    public componentDidUpdate(): void {
        this._handleProps();
    }

    public componentWillUnmount(): void {
        this._removeTargetEvents();
    }

    public getRef(ref: HTMLDivElement | null): void {
        this.popover = ref;
    }

    public render(): JSX.Element | null {
        if (!this.props.isOpen) {
            return null;
        }

        const {
            cssModule,
            isOpen,
            target,
            placementPrefix,
            hideArrow,
            className,
            innerClassName,
            modifiers,
            placement,
            container,
            offset,
            toggle,
            boundariesElement,
            role,
            ...attributes
        } = this.props;

        const classes = mapToCssModules(
            classNames(
                'msc-popover-inner',
                this.props.innerClassName
            ),
            this.props.cssModule
        );

        const popperClasses = mapToCssModules(
            classNames(
                'msc-popover',
                'show',
                this.props.className
            ),
            this.props.cssModule
        );

        return (
            <PopperContent
                className={popperClasses}
                target={target}
                isOpen={isOpen}
                hideArrow={hideArrow}
                placement={placement}
                placementPrefix={placementPrefix}
                container={container}
                modifiers={modifiers}
                focusOut={this._focusOutPopover}
                offset={offset}
                boundariesElement={boundariesElement}
            >
                <div {...attributes} role={role} className={classes} ref={this.getRef} />
            </PopperContent>
        );
    }

    private _handleProps(): void {
        if (this.props.isOpen) {
            this._show();
        } else {
            this._hide();
        }
    }

    private _show(): void {
        this.tabPressed = false;
        this._addTargetEvents();
        if (!this.props.isOpen) {
            this._toggle();
        }
    }

    private _hide(): void {
        this._removeTargetEvents();
        if (this.props.isOpen) {
            this._toggle();
        }
    }

    private _handleDocumentClick(e: Event): void {
        if (!this.target) { return; }

        const target = e.target as HTMLElement;

        if (e.target !== this.target
            && !this.target.contains(target)
            && e.target !== this.popover
            && !(this.popover && this.popover.contains(target))
        ) {
            if (this.props.isOpen) {
                this._toggle();
            }
        }
    }

    private _addTargetEvents(): void {
        if (!this.target) { return; }
        if (canUseDOM) {
            ['click', 'touchstart'].forEach((event: string) => {
                document.addEventListener(event, this._handleDocumentClick, true);
            });
            this.target.addEventListener('focusout', this._focusOutTarget, true);
            this.target.addEventListener('keydown', this._keyDown, true);
        }
    }

    private _removeTargetEvents(): void {
        if (!this.target) { return; }
        if (canUseDOM) {
            ['click', 'touchstart'].forEach((event: string) => {
                document.removeEventListener(event, this._handleDocumentClick, true);
            });
            this.target.removeEventListener('focusout', this._focusOutTarget, true);
            this.target.removeEventListener('keydown', this._keyDown, true);
        }
    }

    private _focusOutPopover(): void {
        setTimeout(() => {
            const nextFocus = document.activeElement;
            if (this.popover && !this.popover.contains(nextFocus)) {
              this._hide();
            }
        },         1);
    }

    private _focusOutTarget(): void {
        if (this.tabPressed) {
            this.tabPressed = false;
            setTimeout(() => {
                const nextFocus = document.activeElement;
                if (this.popover && !this.popover.contains(nextFocus)) {
                   this._hide();
                }
            },         1);
        }
    }

    private _keyDown(e: KeyboardEvent): void {
        if (e.keyCode === 9) {
            this.tabPressed = true;
        } else if (this.props.isOpen && e.keyCode === 27 && this.props.toggle) {
            this.props.toggle();
        }
    }

    private _toggle(): void {
        if (this.props.disabled) {
            return;
        }

        if (this.props.toggle) {
            this.props.toggle();
        }
    }
}

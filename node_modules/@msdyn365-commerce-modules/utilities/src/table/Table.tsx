import React from 'react';

import classnames from 'classnames';
import { Button, Node, UncontrolledPagination } from '..';
import CheckBoxButton from './checkbox';

// tslint:disable-next-line:no-empty-interface
export interface ITableResources {

}

export interface IDataTableProps {
    resources: ITableResources;
    headings: (IHeadingsProperty | undefined)[];
    rows: ITableRowProps[];
    className?: string;
    editLinkText?: string;
    actionLinkText?: string;
    deleteLinkText?: string;
    viewLinkText?: string;
    enableToModify: boolean;
    showCheckBoxes?: boolean;
    isSortable?: boolean;
    showPagination?: boolean;
    paginationProperty: IPaginationProperty;
    minifyActions?: boolean;
    minifiedButtonText?: string;
    excludedColumns?: string[]; // filled with ITableItemProps.id of columns not to show
    actions: {
        onDelete?(userData: ITableItemProps[]): void | undefined;
        onEdit?(userData: ITableItemProps[]): void | undefined;
        onView?(userData: ITableItemProps[]): void | undefined;
    };
    checkBoxCallback?(records: ITableRowProps[]): void;
    formatPrice?(price: number): string;
}

export interface IPaginationProperty {
    itemPerPage: number;
    skipCount: number;
    prevText: string;
    nextText: string;
    paginationText: string;
    url: string;
}

export interface ITableItemProps {
    id: string;
    type: TableDataType;
    value: boolean | number | string;
}

export interface ITableRowProps {
    row: ITableItemProps[];
}

interface IDataTableCells {
    header: boolean;
    className: string;
    content: string | number | React.ReactNode;
    cellIndex: number;
    scope: 'col'|'row';
    colSpan?: number;
    records?: ITableRowProps;
}

export interface IHeadingsProperty {
   name: string;
   sortable: boolean;
}

export interface ITableState {
    sortingKey: string;
    ascendingOrder: boolean;
    showActions: boolean;
    selectedIndex: string;
}

export enum TableDataType {
    Number = 'Number',
    Text = 'Text',
    Price = 'Price'
}

// tslint:disable-next-line:completed-docs
export default class Table extends React.Component<IDataTableProps,ITableState> {
    public componentClassName: string = 'ms-table';
    private headingPrefix: string = 'table';

    constructor(props: IDataTableProps) {
        super(props);
        this.state = {
            ascendingOrder: true,
            sortingKey: props.headings[0] && props.headings[0].name || '',
            showActions: props.minifyActions !== undefined ? !props.minifyActions : true,
            selectedIndex: ''
        };
    }

    public render(): JSX.Element {
        const { className, headings, rows, isSortable, showPagination, paginationProperty } = this.props;
        const { sortingKey, ascendingOrder } = this.state;

        const classname = classnames(this.componentClassName, className);
        let tableRows = isSortable && sortingKey ? this._sortTableRow(rows, sortingKey, ascendingOrder) : rows;
        let paginationLinks = null;

        if (showPagination) {
            const { skipCount, itemPerPage, nextText, prevText, paginationText, url } = paginationProperty;

            paginationLinks = (
                <UncontrolledPagination
                    className='ms-table-business-org__pagination'
                    role='navigation'
                    aria-label={paginationText}
                    url={url}
                    qsp={'skip'}
                    items={tableRows.length}
                    itemsPerPage={itemPerPage}
                    startingItem={skipCount}
                    previousText={<div className='msc-pagination__prev'><span className='ms-table-business-org__pagination-left' aria-hidden='true'/><span className='prev-text'>{prevText}</span></div>}
                    nextText={<div className='msc-pagination__next'><span className='next-text'>{nextText}</span><span className='ms-table-business-org__pagination-right' aria-hidden='true'/></div>}
                    previousAriaLabel={prevText}
                    nextAriaLabel={nextText}
                />
            );

            // tslint:disable-next-line
            tableRows = this._getCurrentPageData(tableRows, skipCount, skipCount + itemPerPage);
        }

        // console.log(tableRows);
        const tableBody = this._renderRow(tableRows);
        const tableHead = this._renderHeadingRow(headings);

        return (
            <div className={`${this.componentClassName}__container`}>
                <table className={classname}>
                    <thead>{tableHead}</thead>
                    <tbody>{tableBody}</tbody>
                </table>
                {paginationLinks}
            </div>
        );
    }

    private _selectSortingKey = (columnName: string)=> {
        const { sortingKey, ascendingOrder } = this.state;
        let newOrder = true;

        if (sortingKey === columnName) {
            newOrder = !ascendingOrder;
        }

        this.setState({
            sortingKey: columnName,
            ascendingOrder: newOrder,
            showActions: false
        });
    }

    private _renderHeadingRow = (columnData: (IHeadingsProperty | undefined)[]) => {
        const { resources, showCheckBoxes, enableToModify, minifyActions, rows, actionLinkText, isSortable, checkBoxCallback } = this.props;
        const { sortingKey, ascendingOrder } = this.state;

        const sortingClassName = ascendingOrder ? 'asc' : 'dsc';

        const columns = columnData.map((data, cellIndex)=> {
            if (!data) {
                return;
            }

            const heading = resources[`${this.headingPrefix}${data.name}HeadingText`] || resources[`${data.name}HeadingText`] || data.name;
            const content = isSortable && data.sortable && (
                // tslint:disable-next-line:react-this-binding-issue
                <div className={classnames(`${this.componentClassName}__heading-sorting`, sortingKey === data.name && sortingClassName)} onClick={this._selectSortingKey.bind(this, data.name)} role='button'>
                    {heading}
                </div>
            ) || heading;

            return (
                this.tableCell({
                    header: true,
                    className: classnames(`${this.componentClassName}__heading-row-data`, data.name === 'SpendingLimit' && 'num-type'),
                    content: content,
                    cellIndex: cellIndex,
                    scope: 'col',
                })
            );
        });

        const radioCheckBox = showCheckBoxes && checkBoxCallback && (
            <CheckBoxButton
                {
                ...{
                        onChange:() => { checkBoxCallback(rows);},
                        name: 'All'
                    }
                }
            />
        );

        return (
            <tr className={`${this.componentClassName}__heading-row`}>
                { showCheckBoxes && this.tableCell({ header: true, className: `${this.componentClassName}__heading-row-data checkbox`, content: radioCheckBox, cellIndex: 1, scope: 'col' }) }
                { columns }
                { enableToModify && this.tableCell({ header: true, className: `${this.componentClassName}__heading-row-data action-links`, content: minifyActions ? '' : actionLinkText, cellIndex: 1, scope: 'col' }) }
            </tr>
        );
    }

    private _renderRow = (rows: ITableRowProps[]) => {
        const { enableToModify, showCheckBoxes, excludedColumns, actions, checkBoxCallback, formatPrice } = this.props;

        const tableRows = rows.map((rowsData, index)=> {
                let className = index % 2 ? `${this.componentClassName}__row even-row` : `${this.componentClassName}__row odd-row`;
                let showActions = false;

                const columnData = rowsData.row.map(cell => {
                    if (excludedColumns && excludedColumns.includes(cell.id)) {
                        return;
                    }
                    // numbers/price data types will always be right-aligned per design standards
                    const extraClass = cell.type === TableDataType.Number || cell.type === TableDataType.Price ? 'num-type' : '';
                    const cellContent = cell.type === TableDataType.Price && formatPrice ? formatPrice(cell.value as number) : cell.value;
                    return this.tableCell({ header: false, className: classnames(`${this.componentClassName}__row-data`, extraClass), content: cellContent, cellIndex: index, scope: 'row' });
                });

                const radioCheckBox = showCheckBoxes && checkBoxCallback && (
                    <CheckBoxButton
                        {
                        ...{
                                onChange:() => { checkBoxCallback(rows);},
                                name:'actionOptions'
                            }
                        }
                    />
                );
                const rowKey = `row-${index}`;

                if (rowKey === this.state.selectedIndex && this.state.showActions) {
                    className += ' selected';
                    showActions = true;
                }

                const actionButtons = actions && this._renderActions(rowsData.row, showActions, rowKey);

                return (
                    <tr key={rowKey} className={className}>
                        { showCheckBoxes && this.tableCell({ header: false, className: `${this.componentClassName}__row-data`, content: radioCheckBox, cellIndex: index, scope: 'row', records: rowsData}) }
                        { columnData }
                        { enableToModify &&  this.tableCell({ header: false, className: `${this.componentClassName}__row-data`, content: actionButtons, cellIndex: index, scope: 'row', records: rowsData}) }
                    </tr>
                );
            });

        return  tableRows;
    };

    private _renderActions = (data: ITableItemProps[], showActions: boolean, key: string): React.ReactNode => {
        const { editLinkText, deleteLinkText, viewLinkText, minifyActions, minifiedButtonText, actions: { onEdit, onDelete, onView} } = this.props;
        const handleClickEdit = onEdit !== undefined ? () => { onEdit(data); } : undefined;
        const handleClickDelete = onDelete !== undefined ? () => { onDelete(data); } : undefined;
        const handleClickView = onView !== undefined ? () => { onView(data); } : undefined;

        const actionButtons = (
            <Node className={`${this.componentClassName}__row-links`}>
                { handleClickView && <Button className={`${this.componentClassName}__row-links-view`} onClick={handleClickView}>{viewLinkText}</Button> }
                { handleClickEdit && <Button className={`${this.componentClassName}__row-links-edit`} onClick={handleClickEdit}>{editLinkText}</Button> }
                { handleClickDelete  && <Button className={`${this.componentClassName}__row-links-delete`} onClick={handleClickDelete}>{deleteLinkText}</Button> }
            </Node>
        );

        if (minifyActions) {
            return (
                <Node className={`${this.componentClassName}__row-links-minified`}>
                    <Button className={`${this.componentClassName}__row-links-toggle`} data-type={key} onClick={this._toggleActions}>{minifiedButtonText ? minifiedButtonText : ''}</Button>
                    { showActions && actionButtons }
                </Node>
            );
        } else {
            return actionButtons;
        }
    }

    private _toggleActions = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        const target = event && event.target as HTMLElement;
        const newKey = target &&  target.getAttribute('data-type') ? target.getAttribute('data-type') as string : '';
        this.setState({
            showActions: !this.state.showActions,
            selectedIndex: newKey
        });
    }

    private _sortTableRow = (table: ITableRowProps[], sortingkey: string, ascendingOrder: boolean): ITableRowProps[] => {
        return table.sort((userOne: ITableRowProps, userTwo: ITableRowProps) => {
            const userOneData = userOne.row.find(cell => { return cell.id === sortingkey;});
            const userTwoData = userTwo.row.find(cell => { return cell.id === sortingkey;});

            if (!userOneData || !userTwoData) {
                return -1;
            }

            if (typeof userOneData.value === 'number' && typeof userTwoData.value === 'number') {
                return  ascendingOrder ? (userOneData.value - userTwoData.value) : (userTwoData.value - userOneData.value);
            }

            const cleanFirst = userOneData.value as string && userOneData.value.toString().toLowerCase().trim();
            const cleanSecond = userOneData.value as string && userTwoData.value.toString().toLowerCase().trim();

            if (!cleanFirst || !cleanSecond) {
                return -1;
            }
            if (ascendingOrder) {
                return cleanFirst < cleanSecond ? -1 : 1;
            } else {
                return cleanFirst > cleanSecond ? -1 : 1;
            }
        });
    }

    private _getCurrentPageData = (tableRows: ITableRowProps[], start: number, end: number): ITableRowProps[] => {
        if (start >= end) {
            return tableRows;
        }

        const result = [];
        for(let i = start; i < end; i++) {
            tableRows[i] && result.push(tableRows[i]);
        }

        return result;
    };

    private tableCell = (props: IDataTableCells) => {
        const { className, header, cellIndex, scope, colSpan, content } = props;

        return header ? (
            <th className={className} key={`heading-${cellIndex}`} scope={scope} colSpan={colSpan}>
                {content}
            </th>
        ) : (
            <td className={className} scope={scope} colSpan={colSpan}>
                {content}
            </td>
        );
    }
}

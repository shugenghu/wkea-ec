export function onMouseMoveLensContainer(event: React.MouseEvent<HTMLDivElement>): void {
    if (event.type === 'touchmove' || event.type === 'touchstart' || event.type === 'touchend') {
        return;
    }
    const img = event.currentTarget.nextElementSibling?.querySelector('img') || undefined;
    const lens = event.currentTarget;

    if (!document.body.querySelector('.ms-containerZoom__result')) {
        const containerDiv = document.createElement('div');
        containerDiv.setAttribute('class', 'ms-containerZoom__result');
        document.body.appendChild(containerDiv);
    }
    const zoomPic = document.body.querySelector('.ms-containerZoom__result') || undefined;
    containerZoomMouseMoveHandler(event, img, lens, zoomPic);
}

function containerZoomMouseMoveHandler(event: React.MouseEvent<HTMLDivElement>, img: HTMLImageElement | undefined, lens: EventTarget & HTMLDivElement, zoomPic: Element | undefined): void {
    const cx = zoomPic!.clientWidth / lens.offsetWidth;
    const cy = zoomPic!.clientHeight / lens.offsetHeight;
    const pos = getCursorPos(event, img);
    const xy = getXY(pos.x, pos.y, lens.offsetWidth, lens.offsetHeight, lens!.parentElement!.parentElement!.offsetWidth, lens!.parentElement!.parentElement!.offsetHeight);
    const lensStyle = `; left:` + `${xy.x}px` + ` ` + `; top:` + `${xy.y}px` + ` `;
    lens?.setAttribute('style', lensStyle);

    const src = img!.getAttribute('src');

    const picStyleValues = `; background-position:` + `-` + `${xy.x * cx}px` + ` -` + `${xy.y * cy}px`
        + `; background-size:` + `${img!.width * cx}px` + ` ` + `${img!.height * cy}px`
        + `; background-image:url('` + `${src}` + ` ')` + `; top:` + `${pos.z}px` + ` `;

    zoomPic!.setAttribute('style', picStyleValues);
}

export function onMouseOutLensContainer(event: React.MouseEvent<HTMLDivElement>): void {
    event.currentTarget.removeAttribute('style');
    event.currentTarget?.setAttribute('style', 'left: -200px; top: -200px');
    event.currentTarget.classList.remove('ms-containerZoom__zoom-lens__opacity');

    const img = event.currentTarget.nextElementSibling?.querySelector('img');
    img!.removeAttribute('style');

    const resultEle = document.body.querySelector('.ms-containerZoom__result');
    if (document.body.querySelector('.ms-containerZoom__result')) {
        document.body.removeChild(resultEle!);
    }
}

export function onMouseOverImageContainer(event: React.MouseEvent<HTMLDivElement>): void {
    const lens = event.currentTarget.parentElement?.previousElementSibling;
    lens!.classList.add('ms-containerZoom__zoom-lens__opacity');

    if (!document.body.querySelector('.ms-containerZoom__result')) {
        const containerDiv = document.createElement('div');
        containerDiv.setAttribute('class', 'ms-containerZoom__result');
        document.body.appendChild(containerDiv);
    }
    const pos = getCursorPosOfLens(event);
    const xy = getXY(pos.x, pos.y, lens!.clientWidth, lens!.clientWidth, lens?.parentElement?.parentElement!.offsetWidth, lens?.parentElement?.parentElement!.offsetHeight);

    const lensStyle = `left:` + `${xy.x}px` + ` ` + `; top:` + `${xy.y}px` + ` `;
    lens?.setAttribute('style', lensStyle);
}

export function onContainerZoomInit(event: React.MouseEvent<HTMLImageElement>): void {
    const lens = event.currentTarget.parentElement?.parentElement?.querySelector('.ms-containerZoom__zoom-lens') || undefined;

    if (!document.body.querySelector('.ms-containerZoom__result')) {
        const containerDiv = document.createElement('div');
        containerDiv.setAttribute('class', 'ms-containerZoom__result');
        document.body.appendChild(containerDiv);
    }
    const resultEle = document.body.querySelector('.ms-containerZoom__result') || undefined;
    lens!.classList.add('ms-containerZoom__zoom-lens__opacity');
    onMouseOverImageContainer(event);
    containerZoomMouseMoveHandler(event, event.currentTarget, lens as EventTarget & HTMLDivElement, resultEle);
}

export function inlineZoomImageOnHover(event: React.MouseEvent<HTMLImageElement>, scale?: string): void {
    if (event.type === 'touchmove' || event.type === 'touchstart' || event.type === 'touchend') {
        return;
    }
    const zoomImg = event.currentTarget.parentElement?.nextElementSibling?.querySelector('img');
    const width = event.currentTarget.width;
    const height = event.currentTarget.height;

    const inlineStyle = `; width:` + `${width * Number(scale)}` + `px` + `; height:` + `${height * Number(scale)}` + `px` + `; opacity: 1`;
    zoomImg!.setAttribute('style', inlineStyle);
}

export function inlineZoomImageOnMouseMove(event: React.MouseEvent<HTMLImageElement>): void {
    if (event.type === 'touchmove' || event.type === 'touchstart' || event.type === 'touchend') {
        return;
    }
    const parentElement = event.currentTarget.parentElement!.parentElement;
    const zoomImg = event.currentTarget;

    const dataScale = parentElement && parentElement.getAttribute('data-scale') || '';
    const inlineStyle = getInlineStyleOnMouseMove(zoomImg, dataScale, event);

    zoomImg.removeAttribute('style');
    zoomImg.setAttribute('style', inlineStyle);
}

function getInlineStyleOnMouseMove(zoomImg: EventTarget & HTMLImageElement, dataScale: string, event: React.MouseEvent<HTMLImageElement>): string {
    zoomImg.removeAttribute('style');
    const picImg = zoomImg.parentElement && zoomImg.parentElement.previousElementSibling && zoomImg.parentElement.previousElementSibling.querySelector('img');
    const inlineStyle = `; width:` + `${picImg!.width * Number(dataScale)}` + `px`
        + `; height:` + `${picImg!.height * Number(dataScale)}` + `px` + `; opacity: 1`;
    zoomImg!.setAttribute('style', inlineStyle);

    const targetWidth = picImg!.offsetWidth;
    const targetHeight = picImg!.offsetHeight;
    const sourceWidth = picImg!.offsetWidth;
    const sourceHeight = picImg!.offsetHeight;
    const xRatio = (zoomImg.width - targetWidth) / sourceWidth;
    const yRatio = (zoomImg.height - targetHeight) / sourceHeight;

    const imgArea = picImg!.getBoundingClientRect();

    let left = 0;
    let top = 0;

    left = event.pageX - imgArea.left;
    top = event.pageY - imgArea.top;
    left = left - window.pageXOffset;
    top = top - window.pageYOffset;
    top = Math.max(Math.min(top, sourceHeight), 0);
    left = Math.max(Math.min(left, sourceWidth), 0);
    return `${inlineStyle}` + `; left:` + `${left * -xRatio}` + `px` + `; top:` + `${top * -yRatio}` + `px`;
}

export function inlineZoomImageOnMouseOut(event: React.MouseEvent<HTMLImageElement>): void {
    if (event.type === 'touchmove' || event.type === 'touchstart' || event.type === 'touchend') {
        return;
    }
    event.currentTarget.removeAttribute('style');
    event.currentTarget.style.height = '0';
    event.currentTarget.style.width = '0';
}

export function inlineZoomInit(event: React.MouseEvent<HTMLImageElement>, dataScale?: string): void {
    if (event.type === 'touchmove' || event.type === 'touchstart' || event.type === 'touchend') {
        return;
    }

    const zoomImg = event.currentTarget.parentElement?.nextElementSibling?.querySelector('img');
    if (!zoomImg) {
        return;
    }

    const inlineStyle = getInlineStyleOnMouseMove(zoomImg, dataScale || '1', event);
    zoomImg.removeAttribute('style');
    zoomImg.setAttribute('style', inlineStyle);
}

// tslint:disable-next-line:typedef
function getXY(positionX: number, positionY: number, clientWidth: number, clientheight: number, eleOffsetWidth: number, eleOffsetHeight: number) {
    let x = 0;
    let y = 0;

    x = positionX - (clientWidth / 2);
    y = positionY - (clientheight / 2);

    if (x > eleOffsetWidth - clientWidth) {
        x = eleOffsetWidth - clientWidth;
    }

    if (x < 0) {
        x = 0;
    }
    if (y > eleOffsetHeight - clientheight) {
        y = eleOffsetHeight - clientheight;
    }
    if (y < 0) {
        y = 0;
    }
    return {
        x: x,
        y: y
    };
}

// tslint:disable-next-line:typedef
function getCursorPosOfLens(event: React.MouseEvent) {
    const img = event.currentTarget;
    let x = 0;
    let y = 0;
    event = event || window.event;
    const a = img!.getBoundingClientRect();
    x = event.pageX - a.left;
    y = event.pageY - a.top;
    x = x - window.pageXOffset;
    y = y - window.pageYOffset;
    return {
        x: x,
        y: y
    };
}

// tslint:disable-next-line:typedef
function getCursorPos(event: React.MouseEvent, img?: HTMLImageElement) {
    let x = 0;
    let y = 0;
    let z = 0;
    event = event || window.event;
    const a = img!.getBoundingClientRect();
    x = event.pageX - a.left;
    y = event.pageY - a.top;
    z = a.top;
    x = x - window.pageXOffset;
    y = y - window.pageYOffset;
    return {
        x: x,
        y: y,
        z: z
    };
}

export function removeInlineZoomStyle(): void {
    const imgTag: HTMLImageElement | null  = document.body.querySelector('.ms-inline-zoom__zoomedImg');
    const hasStyleAttr = imgTag && imgTag.hasAttribute('style');
    if(hasStyleAttr) {
        imgTag!.removeAttribute('style');
        imgTag!.setAttribute('style','width: 0; height: 0;');
    }
}
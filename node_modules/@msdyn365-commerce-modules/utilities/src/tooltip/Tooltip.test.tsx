/* tslint:disable:no-unused-variable */
import { setupMaster } from 'cluster';
import { mount,render,shallow } from 'enzyme';
import * as React from 'react';
/* tslint:enable:no-unused-variable */
import * as renderer from 'react-test-renderer';
import Tooltip from '../tooltip/Tooltip';

const testRef: React.RefObject<HTMLAnchorElement> = React.createRef();
const spyOnToggle = jest.fn();
describe('Tooltip', () => {

    let wrapper;
    // tslint:disable-next-line: no-function-expression
    beforeEach(function():void {
        document.body.className='mobile';
        document.body.appendChild(document.createElement('div'));
    });
    it('renders a tooltip', () => {
        const input = renderer.create(
        <div>
            <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
            <Tooltip
                placement='right'
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
            Test content
            </Tooltip>
        </div>);
        expect(input.toJSON()).toMatchSnapshot();
    });
    it('Mobile view test case.',()=> {
      wrapper = mount(
                <Tooltip
                    placement='right'
                    disabled={true}
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                    Test content
                </Tooltip>,
                { attachTo: document.body.firstElementChild as HTMLElement }
            );
      expect(document.body.className).toBe('mobile');
    });
    it('tooltip text should be equal',()=> {

        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>
            </div>,
            );
        wrapper.find('.msc-tooltip-inner').simulate('mouseleave');
        wrapper.find('.msc-tooltip-inner').simulate('mouseover');
        expect(wrapper.find('.msc-tooltip-inner').text()).toEqual('Test content');
    });
    it('tooltip should be open',()=> {
        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>
            </div>,
            { attachTo: document.body.firstElementChild as HTMLElement }
            );
        const toggleLink= document.querySelector('.msc-tooltip-inner') as HTMLElement;
        expect(toggleLink).toBeDefined();
    });
    it('tooltip should be close',()=> {
        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={false}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>
             </div>,
            { attachTo: document.body.firstElementChild as HTMLElement }
            );
        const toggleLink= document.querySelector('.msc-tooltip-inner') as HTMLElement;
        expect(toggleLink).toBe(null);
    });
    it('tooltip should be open on click',()=> {
        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={false}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>
            </div>,
            { attachTo: document.body.firstElementChild as HTMLElement }
            );
        const toggleLink= document.querySelector('#TooltipExample') as HTMLElement;
        toggleLink.click();
        const tooltipHtml= document.querySelector('.msc-tooltip-inner') as HTMLElement;
        expect(tooltipHtml).toBeDefined();
    });
    it('tooltip bind event without target.',()=> {
        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    autohide={false}
                    isOpen={true}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                    Test content
                </Tooltip>
            </div>,
            { attachTo: document.body.firstElementChild as HTMLElement }
            );
        const tooltipWrapper = document.querySelector('.msc-tooltip-inner') as HTMLElement;
        expect(tooltipWrapper.getAttribute('onMouseOver')).toBeDefined();
        expect(tooltipWrapper.getAttribute('onMouseLeave')).toBeDefined();
        expect(tooltipWrapper.getAttribute('onKeyDown')).toBeDefined();
     });
    it('tooltip click without target',()=> {
        wrapper = mount(
            <div>
                <a href='#tooltip' id='TooltipExample' ref={testRef}>tooltip</a>
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={null}
                    toggle={spyOnToggle}
                >
                    Test content
                </Tooltip>
            </div>,
            { attachTo: document.body.firstElementChild as HTMLElement }
            );
        const clickableLink = document.querySelector('#TooltipExample') as HTMLElement;
        clickableLink.click();
        const tooltipHtml= document.querySelector('.msc-tooltip-inner') as HTMLElement;
        expect(tooltipHtml).toBe(null);
    });
    it('Event callback should be undefined without target',()=> {
        wrapper = shallow(
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={null}
                    toggle={spyOnToggle}
                >
                 Test content
                </Tooltip>
               );
        const instance = wrapper.instance();
        instance.showTimeout=99;
        expect(instance.handleDocumentClick()).toBe(undefined);
        expect(instance.onMouseOverTooltipContent()).toBe(undefined);
        expect(instance.addTargetEvents()).toBe(undefined);
        expect(instance.removeTargetEvents()).toBe(undefined);
        expect(instance.show()).toBe(undefined);
       });
    it('Toggle show methed called.',()=> {
        wrapper = mount(
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={false}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>,
                );
        const instance = wrapper.instance();
        instance.show(testRef);
        expect(spyOnToggle).toBeCalled();

       });
    it('Toggle hide methed called.',()=> {
        wrapper = mount(
                <Tooltip
                    trigger='click hover focus'
                    autohide={false}
                    isOpen={true}
                    target={testRef}
                    toggle={spyOnToggle}
                >
                Test content
                </Tooltip>,
               );
        const instance = wrapper.instance();
        instance.hide(testRef);
        expect(spyOnToggle).toBeCalled();

       });

    it('Toggle hide methed called withot target.',()=> {
        wrapper = mount(
            <Tooltip
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={null}
                toggle={spyOnToggle}
            >
                 Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        instance.hide(testRef);
        expect(spyOnToggle).toBeCalled();

       });

    it('tooltip auto hide event and method should be called.',()=> {
        wrapper = mount(
            <Tooltip
                trigger='click hover focus'
                autohide={true}
                isOpen={true}
                target={null}
                toggle={spyOnToggle}
            >
                    Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        instance.showTimeout=90000;
        expect(instance.onMouseOverTooltipContent()).toBe(undefined);
        expect(instance.onMouseLeaveTooltipContent()).toBe(undefined);
        expect(instance.onMouseLeaveTooltip()).toBe(undefined);
        expect(instance.showTimeout).toBe(undefined);
        instance.hideTimeout=90000;
        expect(instance.onMouseOverTooltip()).toBe(undefined);
        expect(instance.hideTimeout).toBe(undefined);

       });

    it('should be reset time on onMouseLeaveTooltipContent method called',()=> {
        wrapper = mount(
            <Tooltip
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        instance.showTimeout=90000;
        expect(instance.onMouseLeaveTooltipContent(testRef)).toBe(undefined);
        expect(instance.showTimeout).toBe(undefined);
       });
    it('should be called getDelay method',()=> {
        wrapper = mount(
            <Tooltip
                delay={0}
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        // default time
        expect(instance.getDelay('show')).toBe(0);
       });
    it('preventDefault method should be called.',()=> {
        wrapper = mount(
            <Tooltip
                disabled={true}
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                 Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        const event = { preventDefault: spyOnToggle };
        instance.toggle(event);
        expect(spyOnToggle).toBeCalled();
           // key test.
       });
    it('onEscKeyDown method test case.',()=> {
        wrapper = mount(
            <Tooltip
                disabled={true}
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                Test content
            </Tooltip>,
            );
        const instance = wrapper.instance();
        const event = { preventDefault: spyOnToggle,key:'Escape'};
        instance.onEscKeyDown(event);
        expect(spyOnToggle).toBeCalled();
           // key test.
       });
    it('onEscKeyDownNative method test case.',()=> {
        wrapper = mount(
            <Tooltip
                disabled={true}
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >Test content
            </Tooltip>
            );
        const instance = wrapper.instance();
        const event = { preventDefault: spyOnToggle,key:'Escape'};
        instance.onEscKeyDownNative(event);
        expect(spyOnToggle).toBeCalled();
           // key test.
       });
    it('Default toggle props method.',()=> {
        wrapper = mount(
            <Tooltip
                disabled={true}
                trigger='click hover focus'
                autohide={false}
                isOpen={true}
                target={testRef}
            >
                Test content
            </Tooltip>
            );
        wrapper.props().toggle();
        expect(wrapper.props().toggle).toBeDefined();
        // key test.
       });
    it('Toggle hide methed target remove attr.',()=> {
        const div = document.createElement('div');
        div.setAttribute('aria-describedby','test');
        wrapper = mount(
            <Tooltip
                trigger='click hover focus'
                autohide={false}
                id='topPopoverExample'
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                Test content
            </Tooltip>
            );
        const instance = wrapper.instance();
        instance.target = div;
        instance.hide({});
        expect(instance.target.attributes.getNamedItem('aria-describedby')).toBe(null);

    });

    it('handleDocumentClick method test cases..',()=> {
        const div = document.createElement('div');
        div.setAttribute('role','tooltip');
        wrapper = mount(
            <Tooltip
                trigger='click hover focus'
                autohide={false}
                id='topPopoverExample'
                isOpen={true}
                target={testRef}
                toggle={spyOnToggle}
            >
                    Test content
            </Tooltip>
            );
        const instance = wrapper.instance();
        instance.target = div;
        instance.handleDocumentClick({target:instance.target});
        instance.hideTimeout=10;
        instance.handleDocumentClick({target:instance.target});
        expect(instance.hideTimeout).toBe(undefined);
    });

});
import * as Msdyn365 from '@msdyn365-commerce/core';
import classnames from 'classnames';
import * as React from 'react';
import { Button, getPayloadObject, getTelemetryAttributes, IPayLoad, TelemetryConstant } from '../';
import Collapse from '../collapse/Collapse';
import { ICollapseProps } from '../collapse/Collapse.props';
import { IDrawerProps } from './Drawer.props';

export interface IControlledDrawerState {
    isOpen: boolean;
}

export type GlyphPlacement = 'start' | 'end';

/**
 * ControlledDrawer - This is a full width controlled collapse where the button glyph changes
 * when the drawer is open and closed. The toggle function can be managed by the parent.
 */

export default class ControlledDrawer extends React.Component<IDrawerProps, IControlledDrawerState> {
    private drawerOpenGlyph: string;
    private drawerCloseGlyph: string;
    private drawerGlyphClass: string;
    private isManuallyToggled: boolean;
    private isExpanded: boolean;
    private payLoad: IPayLoad;
    constructor(props: IDrawerProps) {
        super(props);
        const { openGlyph, closeGlyph } = this.props;
        this._toggle = this._toggle.bind(this);
        this.isManuallyToggled = false;
        this.state = { isOpen: (props.collapseProps && props.collapseProps.isOpen) || false };
        this.isExpanded = this.state.isOpen;
        this.drawerGlyphClass = classnames('drawer__glyph', this.props.toggleGlyphClassName || '');
        this.payLoad = getPayloadObject('click', props.telemetryContent!, '');

        if (this.props.animateGlyph) {
            this.drawerOpenGlyph = classnames([this.drawerGlyphClass, openGlyph || closeGlyph || '']);
            this.drawerCloseGlyph = this.drawerOpenGlyph;
        } else {
            this.drawerOpenGlyph = classnames([this.drawerGlyphClass, openGlyph || '']);
            this.drawerCloseGlyph = classnames([this.drawerGlyphClass, closeGlyph || '']);
        }
    }

    public render(): JSX.Element {
        const collapseProps = {...this.props.collapseProps} as ICollapseProps;
        collapseProps.isOpen = this.isManuallyToggled ? this.state.isOpen : collapseProps.isOpen || false;
        collapseProps.children = this.props.children;
        const drawerClass = classnames('drawer', this.props.className || '');
        this.isManuallyToggled = false;
        this.isExpanded = collapseProps.isOpen;
        this.state = {isOpen: collapseProps.isOpen};
        this.payLoad.contentAction.etext = collapseProps.isOpen ? TelemetryConstant.Collapse : TelemetryConstant.Expand;
        const attributes = getTelemetryAttributes(this.props.telemetryContent!, this.payLoad);
        return (
            <div className={drawerClass}>
                <Button
                    {...this.props.toggleButtonProps}
                    onClick={this._toggle}
                    aria-expanded={collapseProps.isOpen}
                    block
                    disabled={this.props.disabled}
                    className={'drawer__button'}
                    {...attributes}
                >
                    {this._generateDrawerButtonInnerMarkup(collapseProps.isOpen)}
                </Button>
                <Collapse {...collapseProps} />
            </div>
        );
    }

    private _generateDrawerButtonInnerMarkup(collapseState: boolean): JSX.Element {
        const {toggleButtonText} = this.props;
        const drawerButtonTextClass = classnames('drawer__buttontext', this.props.toggleButtonClassName || '');
        if (this.props.glyphPlacement === 'end') {
            return (
                <>
                    {this._generateTitle(classnames(drawerButtonTextClass, '__start'), toggleButtonText.toString())}
                    {this._generateGlyphMarkup('drawer__glyph__end', collapseState)}
                </>
            );
        }

        const isStart = this.props.glyphPlacement === 'start';
        const additionalClassName = `__${isStart ? 'end' : 'start'}`;
        return (
            <>
                {isStart && this._generateGlyphMarkup('drawer__glyph__start', collapseState)}
                {this._generateTitle(classnames(drawerButtonTextClass, additionalClassName), this.props.toggleButtonText.toString())}
            </>
        );
    }

    private _generateTitle(titleLClassName: string, title: string): JSX.Element {
        if(this.props.onTextChange && this.props.requestContext) {
            return(
                <Msdyn365.Text
                    tag='span'
                    text={title}
                    className={titleLClassName}
                    editProps={{onEdit: this.props.onTextChange, requestContext: this.props.requestContext}}
                />
            );
        } else {
            return(
                <span className={titleLClassName}>{title}</span>
            );
        }
    }
    private _generateGlyphMarkup(location: string, collapseState:boolean): JSX.Element {
        const glyphClass = `${collapseState? this.drawerOpenGlyph: this.drawerCloseGlyph} ${location}`;
        return (
            <span className={glyphClass} />
        );
    }

    private _toggle(e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void {
        e.preventDefault();
        this.isExpanded = !this.isExpanded;
        this.setState({ isOpen: this.isExpanded });
        this.isManuallyToggled = true;
        if (this.props.onToggle) {
            this.props.onToggle(this.state);
        }
    }
}

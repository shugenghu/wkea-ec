import classNames from 'classnames';
import * as React from 'react';
import { focusableElements, TransitionTimeouts } from '../common/utilities';
import Fade from '../fade/Fade';
import IModalProps from './Modal.props';
import Portal from './Portal';

export interface IModalState {
    wasOpen: boolean;
    isOpen: boolean;
    mouseDownElement: EventTarget | null;
}

export type ModalVerticalPosition = 'top' | 'center' | 'bottom';
export type ModalHorizontalPosition = 'left' | 'center' | 'right';

/**
 * Modal component
 */
export default class Modal extends React.Component<IModalProps, IModalState> {
    public static defaultProps: Partial<IModalProps> = {
        isOpen: false,
        autoFocus: true,
        verticalPosition: 'top', // needs to be non-null since we use non-null assertion in getVerticalPositionClass
        horizontalPosition: 'center', // needs to be non-null since we use non-null assertion in getHorizontalPositionClass
        role: 'dialog',
        backdrop: true,
        keyboard: true,
        zIndex: 1000,
        tabIndex: 0,
        fade: true,
        modalTransition: {
            timeout: TransitionTimeouts.Modal
        },
        backdropTransition: {
            mountOnEnter: true,
            timeout: TransitionTimeouts.Fade // uses standard fade transition
        }
    };

    private static openCount: number = 0;

    private element: HTMLElement | null;
    private mounted: boolean;
    private ref: React.RefObject<HTMLDivElement>;
    /** this property is initialized in componentDidMount rather than constructor in case the dialog needs to be pre-rendered. */
    private applicationNode!: HTMLElement | null;

    constructor(props: IModalProps) {
        super(props);
        this.element = null;
        this.ref = React.createRef();
        this.mounted = false;

        this._getFocusableChildren = this._getFocusableChildren.bind(this);
        this._handleBackdropClick = this._handleBackdropClick.bind(this);
        this._handleBackdropMouseDown = this._handleBackdropMouseDown.bind(this);
        this._handleEscape = this._handleEscape.bind(this);
        this._handleTab = this._handleTab.bind(this);
        this._onOpened = this._onOpened.bind(this);
        this._onClosed = this._onClosed.bind(this);

        this.state = {
            wasOpen: false,
            isOpen: props.isOpen || false,
            mouseDownElement: null
        };

        if (props.isOpen) {
            this._open();
        }
    }

    public componentDidMount(): void {
        if (this.props.onEnter) {
            this.props.onEnter();
        }
        this.mounted = true;

        const element = document.createElement('div');
        element.setAttribute('tabindex', '-1');
        element.style.visibility = 'hidden';
        element.style.position = 'position';
        this.element = element;
        document.body.appendChild(element);

        this.applicationNode = (this.props.applicationNode instanceof HTMLElement) ?
            this.props.applicationNode : document.querySelector(`#${this.props.applicationNode}`);

        if (this.state.isOpen && !this.state.wasOpen) {
            this._open();
        }
    }

    public componentWillUnmount(): void {
        if (this.props.onExit) {
            this.props.onExit();
        }
        if (this.state.isOpen) {
            this._close();
        }
        this.mounted = false;

        if (this.element) {
            document.body.removeChild(this.element);
        }
    }

    public componentDidUpdate(_prevProps: IModalProps, prevState: IModalState): void {
        if (this.state.isOpen && !prevState.isOpen) {
            setTimeout(() => {
                const focusableElementArr = this._getFocusableChildren();
                if (focusableElementArr && focusableElementArr.length > 0 && focusableElementArr[0]) {
                    const firstFocusableElement = focusableElementArr[0] as HTMLElement;
                    firstFocusableElement.focus();
                }
            },         100);
        }
    }

    public componentWillReceiveProps(nextProps: IModalProps): void {
        if (nextProps.isOpen && !this.props.isOpen) {
            this.setState({ isOpen: nextProps.isOpen });
        }
    }

    public render(): JSX.Element | null {
        if (this.state.isOpen && !this.state.wasOpen) {
            this._open();
        }
        if (this.element !== null) {
            const {
                wrapClassName, modalClassName, backdropClassName, contentClassName, className, cssModule,
                modalTransition, backdropTransition, backdrop, isOpen, onOpened, onClosed,
                role, size, tabIndex, external, verticalPosition, horizontalPosition, keyboard, zIndex, fade, toggle,
                children, applicationNode, returnFocusRef, 'aria-labelledby': ariaLabelledbyId,
                ...dialogAttributes
            } = this.props;

            const modalAttributes = {
                onClick: this._handleBackdropClick,
                onMouseDown: this._handleBackdropMouseDown,
                onKeyUp: this._handleEscape,
                onKeyDown: this._handleTab,
                style: { display: 'block' }
            };

            const modalTransitions = {
                ...Fade.defaultProps,
                ...modalTransition,
                baseClass: fade && modalTransition ? modalTransition.baseClass : '',
                timeout: fade && modalTransition ? modalTransition.timeout : 0
            };
            const backdropTransitions = {
                ...Fade.defaultProps,
                ...backdropTransition,
                baseClass: fade && backdropTransition ? backdropTransition.baseClass : '',
                timeout: fade && backdropTransition ? backdropTransition.timeout : 0
            };

            const Backdrop = fade ?
                (
                    <Fade
                        {...backdropTransitions}
                        in={this.state.isOpen && !!backdrop}
                        cssModule={cssModule}
                        className={classNames('msc-modal__backdrop', backdropClassName)}
                    />
                )
                : <div className={classNames('msc-modal__backdrop', 'show', backdropClassName)} />;

            const dialogBaseClass = 'msc-modal__dialog';
            const dialogClasses =
                classNames([
                    dialogBaseClass,
                    className,
                    size ? `msc-modal__${size}` : null
                ]);

            const dialog = (
                <div
                    ref={this.ref}
                    {...dialogAttributes}
                    className={dialogClasses}
                    role={role}
                    aria-modal={this.state.isOpen}
                    aria-labelledby={this.props['aria-labelledby']}
                    tabIndex={tabIndex}
                >
                    <div
                        className={classNames('msc-modal__content', contentClassName)}
                        role='document'
                    >
                        {children}
                    </div>
                </div>
            );

            return (
                <Portal node={this.element}>
                    <div className={wrapClassName}>
                        <Fade
                            {...modalAttributes}
                            {...modalTransitions}
                            in={isOpen}
                            onEntered={this._onOpened}
                            onExited={this._onClosed}
                            cssModule={cssModule}
                            appear={fade}
                            className={classNames('msc-modal', modalClassName)}
                        >
                            {external}
                            {dialog}
                        </Fade>
                        {Backdrop}
                    </div>
                </Portal>
            );
        }

        return null;
    }

    private _open(): void {
        if (this.element) {
            this.element.style.zIndex = `${this.props.zIndex || 1000}`;
            this.element.style.display = 'block';
            this.element.style.visibility = 'visible';
            if (Modal.openCount === 0) {
                if (window) {
                    const scrollY = window.scrollY;
                    const scrollbarWidth = window.innerWidth - document.body.clientWidth;
                    document.body.style.position = `fixed`;
                    document.body.style.top = `-${scrollY}px`;
                    document.body.style.right = `${scrollbarWidth}px`;
                    document.body.style.left = `0px`;
                }

                document.body.className = classNames(
                    document.body.className,
                    'modal-open'
                );
            }
            Modal.openCount += 1;

            if (this.applicationNode) {
                this.applicationNode.setAttribute('aria-hidden', 'true');
            }

            this.setState({ ...this.state, wasOpen: true });
        }
    }

    private _close(): void {
        if (!this.state.isOpen) {
            return;
        }

        if (this.element) {
            this.element.style.display = 'none';
            setTimeout(() => {
                if(this.element) {
                    this.element.style.visibility = 'hidden';
                    this.element.style.removeProperty('display');
                }
            },         0);

        }

        if (Modal.openCount <= 1) {
            const modalOpenClassName = 'modal-open';
            // Use regex to prevent matching `modal-open` as part of a different class, e.g. `my-modal-opened`
            const modalOpenClassNameRegex = new RegExp(`(^| )${modalOpenClassName}( |$)`);
            document.body.className = document.body.className.replace(modalOpenClassNameRegex, ' ').trim();

            if (window) {
                const scrollY = document.body.style.top;
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.right = '';
                document.body.style.left = '';
                window.scrollTo(0, -parseInt(scrollY || '0', 10));
            }
        }
        Modal.openCount -= 1;

        if (this.applicationNode) {
            this.applicationNode.setAttribute('aria-hidden', 'false');
        }

        if (this.props.returnFocusRef && this.props.returnFocusRef.current) {
            this.props.returnFocusRef.current.focus();
        }

        this.setState({ ...this.state, wasOpen: false });
    }

    private _getFocusableChildren(): NodeListOf<Element> | null {
        if (this.element === null) {
            return null;
        }

        return this.element.querySelectorAll(focusableElements.join(', '));
    }

    private _getFocusedChild(): Element | null {
        const focusableChildren = this._getFocusableChildren();

        try {
            return document.activeElement;
        } catch (err) {
            return focusableChildren === null ? null : focusableChildren[0];
        }
    }

    private _handleBackdropClick(e: React.MouseEvent): void {
        if (e.target === this.state.mouseDownElement) {
            e.stopPropagation();
            if (!this.props.isOpen || this.props.backdrop !== true) {
                return;
            }

            const container = this.ref.current;

            if (e.target && container && !container.contains(e.target as Node) && this.props.toggle) {
                this.props.toggle();
            }
        }
    }

    private _handleTab(e: React.KeyboardEvent): void {
        if (e.which !== 9) {
            return;
        }

        const focusableChildren = this._getFocusableChildren();
        if (focusableChildren === null) {
            return;
        }

        const totalFocusable = focusableChildren.length;
        const currentFocus = this._getFocusedChild();

        let focusedIndex = 0;

        for (let i = 0; i < totalFocusable; i += 1) {
            if (focusableChildren[i] === currentFocus) {
                focusedIndex = i;
                break;
            }
        }

        let el: HTMLElement | null = null;
        if (e.shiftKey && focusedIndex === 0) {
            e.preventDefault();
            el = focusableChildren[totalFocusable - 1] as HTMLElement;
        } else if (!e.shiftKey && focusedIndex === totalFocusable - 1) {
            e.preventDefault();
            el = focusableChildren[0] as HTMLElement;
        }
        if (el) {
            el.focus();
        }
    }

    private _handleBackdropMouseDown(e: React.MouseEvent): void {
        this.setState({
            mouseDownElement: e.target
        });
    }

    private _handleEscape(e: React.KeyboardEvent): void {
        if (this.props.isOpen && this.props.keyboard && e.keyCode === 27 && this.props.toggle) {
            this.props.toggle();
        }
    }

    private _onOpened(node: HTMLElement, isAppearing: boolean): void {
        if (this.props.onOpened !== undefined) {
            this.props.onOpened();
        }
        if (this.props.modalTransition !== undefined && this.props.modalTransition.onEntered !== undefined) {
            this.props.modalTransition.onEntered(node, isAppearing);
        }
    }

    private _onClosed(node: HTMLElement): void {
        if (this.props.onClosed !== undefined) {
            this.props.onClosed();
        }
        this._close();
        if (this.props.modalTransition !== undefined && this.props.modalTransition.onExited !== undefined) {
            this.props.modalTransition.onExited(node);
        }
        if (this.mounted) {
            this.setState({ isOpen: false });
        }
    }
}

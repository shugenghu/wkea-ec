import { debounce } from 'lodash';
import * as React from 'react';
import { IQuantityProps } from './Quantity.props';

interface IQuantityState {
    currentInput: number;
}
/**
 * Quantity Component - This component is used to allow input of quantity between a
 * range of values
 */

export default class Quantity extends React.PureComponent<IQuantityProps, IQuantityState> {
    public static defaultProps: Partial<IQuantityProps> = {
        min: 1
    };

    private inputRef: React.RefObject<HTMLInputElement> = React.createRef<HTMLInputElement>();

    constructor(props: IQuantityProps) {
        super(props);
        this.state = { currentInput: props.currentCount || 1 };
        this._handleChange = this._handleChange.bind(this);
    }

    public render(): JSX.Element {
        const currentValue = this.state.currentInput;

        return (
            <input
                type='number'
                min={this.props.min}
                className='msc-quantity-input'
                pattern='[0-9]*'
                value={this.state.currentInput}
                onChange={this._handleChange}
                onBlur={this._validateMin}
                aria-live='polite'
                aria-label={`${this.props.inputQuantityAriaLabel}`}
                role='spinbutton'
                aria-valuemin={this.props.min}
                aria-valuemax={this.props.max}
                aria-valuenow={currentValue}
                id={this.props.id}
                ref={this.inputRef}
            />
        );
    }

    private _handleChange(e: React.ChangeEvent<HTMLInputElement>): void {
        const currentValue = parseInt((e.target.value), 10);
        const minValue = this.props.min === undefined ? 1 : this.props.min;
        const inputElement = this.inputRef && this.inputRef.current && this.inputRef.current instanceof HTMLInputElement && this.inputRef.current;

        if (currentValue > this.props.max) {
            this.setState(
                { currentInput: this.props.max },
                () => {
                    debounce(
                        () => {
                            this.props.onChange && this.props.onChange(this.state.currentInput);
                        },
                        200)();
                }
            );
        } else {
                this.setState(
                    { currentInput: currentValue },
                    () => {
                        debounce(
                            () => {
                                if(!isNaN(this.state.currentInput) && !(this.state.currentInput < minValue)) {
                                    this.props.onChange && this.props.onChange(this.state.currentInput);

                                    if (inputElement) {
                                        inputElement.setAttribute('aria-valuenow', currentValue.toString());
                                        inputElement.setAttribute('value', currentValue.toString());
                                    }
                                }
                            },
                            200)();
                    }
                );
        }
    }

    private _validateMin = (): void => {
        const minValue = this.props.min === undefined ? 1 : this.props.min;
        if(isNaN(this.state.currentInput) || (this.state.currentInput < minValue)) {
            this.setState({ currentInput: minValue }, () => { this.props.onChange && this.props.onChange(this.state.currentInput); });
        } else {
            this.props.onChange && this.props.onChange(this.state.currentInput);
        }
    }
}
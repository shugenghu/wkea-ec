import { __decorate } from "tslib";
import { addItemToOrderTemplate, AddItemToOrderTemplateInput, getDimensionsForSelectedVariant, GetDimensionsForSelectedVariantInput, getSelectedVariant, SelectedVariantInput } from '@msdyn365-commerce-modules/retail-actions';
import { Button, Modal, ModalBody } from '@msdyn365-commerce-modules/utilities';
import { searchByCriteriaAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import { get } from 'lodash';
import { computed } from 'mobx';
import React from 'react';
import { NotFoundComponent, ProductConfiguration, ProductList } from './';
var CONTENT;
(function (CONTENT) {
    CONTENT[CONTENT["Search"] = 0] = "Search";
    CONTENT[CONTENT["ProductList"] = 1] = "ProductList";
    CONTENT[CONTENT["ProductConfiguration"] = 2] = "ProductConfiguration";
    CONTENT[CONTENT["NotFound"] = 3] = "NotFound";
    CONTENT[CONTENT["Error"] = 4] = "Error";
    CONTENT[CONTENT["Loading"] = 5] = "Loading";
})(CONTENT || (CONTENT = {}));
export class AddLineToTemplate extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            isOpen: false,
            query: '',
            products: [],
            content: CONTENT.Search,
            selectedProduct: null,
        };
        this.defaultImageSettings = {
            viewports: {
                xs: { q: `w=64&h=64&m=6`, w: 0, h: 0 },
                lg: { q: `w=64&h=64&m=6`, w: 0, h: 0 },
                xl: { q: `w=64&h=64&m=6`, w: 0, h: 0 }
            },
            lazyload: true
        };
        this.searchTextInput = React.createRef();
        this._onSearchSubmit = (event) => {
            event.preventDefault();
            const query = get(this, 'searchTextInput.current.value', null);
            if (!query) {
                return;
            }
            this.setState({
                content: CONTENT.Loading,
            });
            this._getSearchResults(query)
                .then(result => {
                if (result.length === 0) {
                    this.setState({
                        content: CONTENT.NotFound,
                    });
                }
                else {
                    this.setState({
                        products: result,
                        content: CONTENT.ProductList,
                    });
                }
            })
                .catch(error => {
                this.setState({
                    content: CONTENT.Error,
                });
            });
        };
        this._onQuantityChangeHandler = (event) => {
            this.setState({
                selectedQuantity: +event.target.value
            });
        };
        this._onSelectItem = async (product) => {
            const { actionContext, request: { apiSettings: { channelId } } } = this.props.context;
            const varianteInput = new SelectedVariantInput(product.RecordId, channelId, []);
            const productVariant = await getSelectedVariant(varianteInput, actionContext);
            if (!productVariant) {
                this.props.context.telemetry.error('Error retrieving product variant');
                return;
            }
            const dimensions = await this._getProductDimensions(product);
            this.setState({
                selectedProductDimensions: dimensions,
                content: CONTENT.ProductConfiguration,
                selectedProduct: productVariant
            });
        };
        this._onInputChange = (event) => {
            this.setState({
                query: event.target.value
            });
        };
        this._onBackButtonClickHandler = () => {
            console.log('on back button');
            this.setState({
                content: CONTENT.ProductList
            });
        };
        this._highlightSearchTerm = (name) => {
            const parsedName = name && unescape(name.replace(new RegExp(this.state.query, 'i'), '<span>$&</span>'));
            return React.createElement("div", { className: 'msc-add-line-to-template__product__name', dangerouslySetInnerHTML: { __html: parsedName || '' } });
        };
        this._addItemToTemplateHandler = async (config) => {
            const { orderTemplateId, context: { actionContext } } = this.props;
            const input = new AddItemToOrderTemplateInput(orderTemplateId, config.product.RecordId, config.quantity, config.product.DefaultUnitOfMeasure || 'ea');
            const result = await addItemToOrderTemplate(input, actionContext);
            this.setState({
                reloadPage: true
            });
            return result;
        };
        this._toggleModalHandler = () => {
            this.setState({
                isOpen: !this.state.isOpen,
                content: CONTENT.Search
            });
            if (this.state.reloadPage) {
                window.location.reload();
                this.setState({
                    reloadPage: false
                });
            }
        };
    }
    onComponentDidMount() {
        this.searchTextInput.current?.focus();
    }
    onComponentDidUpdate() {
        this.searchTextInput.current?.focus();
    }
    get showBackArrow() {
        return this.state.content === CONTENT.ProductConfiguration;
    }
    render() {
        const { resources: { addLineModalLinkText, searchButtonAriaLabel, searchInputAriaLabel, searchModalPlaceholderText } } = this.props;
        const modalProps = {
            ...this.props,
            className: 'msc-add-line-to-template',
            toggle: this._toggleModalHandler,
            isOpen: this.state.isOpen
        };
        return (React.createElement(React.Fragment, null,
            React.createElement(Modal, Object.assign({}, modalProps),
                React.createElement("div", { className: 'msc-modal__header' },
                    this.showBackArrow && React.createElement("button", { type: 'button', className: 'msc-modal__back-button', "aria-label": 'Back to search results', onClick: this._onBackButtonClickHandler }),
                    React.createElement("h5", { className: 'msc-modal__title' }, addLineModalLinkText),
                    React.createElement("button", { type: 'button', className: 'msc-modal__close-button', "aria-label": 'Close', onClick: this._toggleModalHandler })),
                React.createElement(ModalBody, null,
                    React.createElement("form", { className: 'msc-add-line-to-template__search-form', "aria-label": searchButtonAriaLabel, name: 'add-line-to-template-search-form', role: 'form', autoComplete: 'off', onSubmit: this._onSearchSubmit },
                        React.createElement("input", { type: 'text', autoFocus: true, "aria-label": searchInputAriaLabel, className: 'msc-form-control msc-add-line-to-template__search-input', placeholder: searchModalPlaceholderText, value: this.state.query, onChange: this._onInputChange, ref: this.searchTextInput }),
                        React.createElement("button", { className: 'msc-add-line-to-template__search-button', "aria-label": 'Add To Template Search Button', color: 'primary' })),
                    this._renderContent())),
            React.createElement(Button, { className: 'msc-add-line-to-template__button', "aria-label": addLineModalLinkText, onClick: this._toggleModalHandler },
                React.createElement("span", null),
                addLineModalLinkText)));
    }
    _renderContent() {
        switch (this.state.content) {
            case CONTENT.ProductConfiguration:
                const { selectedProduct, selectedProductDimensions } = this.state;
                const viewProps = {
                    ...this.props,
                    imageSettings: this.props.imageSettings || this.defaultImageSettings,
                    product: selectedProduct,
                    dimensions: selectedProductDimensions,
                    addToTemplateHandler: this._addItemToTemplateHandler,
                    onQuantityChangeHandler: this._onQuantityChangeHandler,
                    highlightSearchTerm: this._highlightSearchTerm
                };
                return React.createElement(ProductConfiguration, Object.assign({}, viewProps));
            case CONTENT.ProductList:
                const productProps = {
                    ...this.props,
                    imageSettings: this.props.imageSettings || this.defaultImageSettings,
                    clickHandler: this._onSelectItem,
                    products: this.state.products,
                    highlightSearchTerm: this._highlightSearchTerm
                };
                return React.createElement(ProductList, Object.assign({}, productProps));
            case CONTENT.Loading:
                return React.createElement(Loader, { msg: this.props.resources.progressNotificationText });
            case CONTENT.NotFound:
                const { notFoundSearchErrorNotice, notFoundSearchErrorRedediation } = this.props.resources;
                return React.createElement(NotFoundComponent, { error: notFoundSearchErrorNotice, msg: notFoundSearchErrorRedediation });
            case CONTENT.Error:
                return React.createElement("div", { className: 'msc-alert-danger' }, this.props.resources.searchErrorMessage);
            default:
                return null;
        }
    }
    _getSearchResults(searchText) {
        const { context: { actionContext, request: { apiSettings: { channelId, catalogId } } } } = this.props;
        const searchCriteriaInput = {};
        searchCriteriaInput.Context = {
            ChannelId: channelId,
            CatalogId: catalogId
        };
        searchCriteriaInput.IncludeAttributes = true;
        searchCriteriaInput.SearchCondition = searchText;
        return searchByCriteriaAsync({ callerContext: actionContext }, searchCriteriaInput);
    }
    async _getProductDimensions(product) {
        const { context: { actionContext, request: { apiSettings: { channelId } } } } = this.props;
        const id = product.MasterProductId ? product.MasterProductId : product.RecordId;
        return getDimensionsForSelectedVariant(new GetDimensionsForSelectedVariantInput(id, channelId, []), actionContext);
    }
}
__decorate([
    computed
], AddLineToTemplate.prototype, "showBackArrow", null);
const Loader = (props) => (React.createElement(React.Fragment, null,
    React.createElement("div", { className: 'msc-add-line-to-template__loading__icon' }),
    React.createElement("div", { className: 'msc-add-line-to-template__loading__msg' }, props.msg)));
//# sourceMappingURL=add-line.js.map
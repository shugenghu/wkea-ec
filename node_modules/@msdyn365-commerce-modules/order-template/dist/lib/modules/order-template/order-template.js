import { __decorate } from "tslib";
import { getPriceForSelectedVariant, getProductUrlSync, PriceForSelectedVariantInput } from '@msdyn365-commerce-modules/retail-actions';
import { Alert, getTelemetryObject, Heading, UncontrolledPagination } from '@msdyn365-commerce-modules/utilities';
import { ItemAddedToCartDialog } from '@msdyn365-commerce/components';
import MsDyn365, { AsyncResult, getUrlSync } from '@msdyn365-commerce/core';
import { getCartState } from '@msdyn365-commerce/global-state';
import { addCartLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { deleteAsync, removeProductListLinesAsync, updateProductListLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductListsDataActions.g';
import classnames from 'classnames';
import debounce from 'lodash/debounce';
import { action } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { OrderTemplateActionsView, OrderTemplateBulkActions, OrderTemplateLinesStatusMessage, OrderTemplateLineView, OrderTemplateTableHeading } from '../../';
import { ActiveOrderTemplateLinesInput } from './actions/get-order-template';
let OrderTemplateLines = class OrderTemplateLines extends React.Component {
    constructor(props, state) {
        super(props);
        this._onRemoveSelection = (event) => {
            const { context, resources } = this.props;
            const { telemetry } = context;
            const { removeSelectedFailureMessage, removeSelectedSuccessMessage } = resources;
            const lines = this.state.productSelection;
            const productListLines = lines && lines.length && lines
                .filter(line => line.isChecked)
                .map(line => line.productListLine);
            if (productListLines && productListLines.length) {
                const productListId = productListLines[0].ProductListId;
                removeProductListLinesAsync({ callerContext: context.actionContext }, productListId, productListLines)
                    .then(() => {
                    this.setState({
                        userMessage: removeSelectedSuccessMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                    window.location.reload();
                })
                    .catch(error => {
                    telemetry.warning('[order-template-lines] Unable remove items from the order template lines');
                    telemetry.error(error);
                    this.setState({
                        userMessage: removeSelectedFailureMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                });
            }
        };
        this._onAddSelectionToBag = async (event) => {
            const { context, resources } = this.props;
            const { addedToCartFailureMessage, addedToCartSuccessMessage } = resources;
            const lines = this.state.productSelection;
            const cartState = await getCartState(context.actionContext);
            const selectedLines = lines.filter(line => line.isChecked);
            if (selectedLines.length) {
                const cartLines = selectedLines.map(productLine => {
                    return {
                        ItemId: productLine.fullProduct?.ProductDetails.ItemId,
                        ProductId: productLine.productListLine.ProductId,
                        Quantity: productLine.productListLine.Quantity || 1,
                        TrackingId: '',
                        UnitOfMeasureSymbol: productLine.productListLine.UnitOfMeasure || productLine.fullProduct?.ProductDetails.DefaultUnitOfMeasure
                    };
                }) || [];
                return addCartLinesAsync({ callerContext: context.actionContext }, cartState.cart.Id, cartLines, cartState.cart.Version)
                    .then(async (res) => {
                    context.telemetry.trace(`Order template; selected line items (${cartLines.map(line => line.ItemId).join(',')}) added to cart: ${cartState.cart.Id}`);
                    await cartState.refreshCart({});
                    this.setState({
                        userMessage: addedToCartSuccessMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                })
                    .catch(error => {
                    context.telemetry.trace('Unable to add order template to cart.');
                    this.setState({
                        userMessage: addedToCartFailureMessage,
                        statusCssString: 'danger',
                        messageGlyph: 'fas fa-exclamation-triangle',
                        isOpen: true
                    });
                });
            }
        };
        this._getCurrentUrl = (reqContext) => {
            if (MsDyn365.isBrowser) {
                return new URL(window.location.href);
            }
            return new URL(reqContext.url.requestUrl.href);
        };
        this._renderItemAddedToCartDialog = () => {
            if (!this.state.itemAddedToCartDialogData) {
                return null;
            }
            const onClose = () => {
                this.setState({
                    itemKey: this.state.itemKey,
                    userMessage: this.state.userMessage,
                    statusCssString: this.state.statusCssString,
                    messageGlyph: this.state.messageGlyph,
                    isOpen: this.state.isOpen,
                    isItemAddedToOrderTemplateOpen: false
                });
            };
            return (React.createElement(ItemAddedToCartDialog, { className: 'msc-item-added-to-cart-dialog', id: this.props.id, typeName: this.props.typeName, context: this.props.context, dialogStrings: this._generateItemAddedToCartDialogResources(), data: this.state.itemAddedToCartDialogData, modalOpen: this.state.isItemAddedToOrderTemplateOpen, onClose: onClose }));
        };
        this._renderPagination = () => {
            const { config, context, data, resources } = this.props;
            const orderTemplate = data && data.orderTemplate && data.orderTemplate.result;
            if (!orderTemplate) {
                return null;
            }
            const fullUrl = this._getCurrentUrl(context.request);
            const itemsPerPage = config.itemsPerPage || 50;
            const currentPageNumber = this.props.context.request.query && (+this.props.context.request.query.skip / itemsPerPage) || 0;
            const skipCount = currentPageNumber * itemsPerPage;
            const totalItems = orderTemplate && orderTemplate.totalLines;
            const previousText = resources.flipperPrevious;
            const nextText = resources.flipperNext;
            if (totalItems <= itemsPerPage) {
                return null;
            }
            return (React.createElement(UncontrolledPagination, { className: `${this.className}__pagination`, role: 'navigation', "aria-label": resources.paginationAriaLabel, url: fullUrl.href, qsp: 'skip', items: totalItems, itemsPerPage: itemsPerPage, startingItem: skipCount, previousText: React.createElement("div", { className: 'msc-pagination__prev' },
                    React.createElement("span", { className: `${this.props.config.className}__pagination-left`, "aria-hidden": 'true' }),
                    React.createElement("span", { className: 'prev-text' }, previousText)), nextText: React.createElement("div", { className: 'msc-pagination__next' },
                    React.createElement("span", { className: 'next-text' }, nextText),
                    React.createElement("span", { className: `${this.props.config.className}__pagination-right`, "aria-hidden": 'true' })), previousAriaLabel: previousText, nextAriaLabel: nextText }));
        };
        this._onDismiss = () => {
            this.setState({
                isOpen: false
            });
        };
        this._changeQuantity = (itemKey, quantity) => {
            const { context, data, telemetry, config } = this.props;
            const { orderTemplate } = data;
            if (context) {
                if (orderTemplate.result) {
                    const orderTemplateLinesData = orderTemplate && orderTemplate.result && orderTemplate.result.orderTemplateLines;
                    if (orderTemplateLinesData) {
                        const orderLineIndex = orderTemplateLinesData.findIndex(lines => lines.productListLine.LineId === itemKey);
                        const newProductListLine = { ...orderTemplateLinesData[orderLineIndex] };
                        if (orderTemplateLinesData[orderLineIndex].productListLine.Quantity === quantity) {
                            return;
                        }
                        newProductListLine.productListLine.Quantity = quantity;
                        const { fullProduct, ...line } = newProductListLine;
                        updateProductListLinesAsync({ callerContext: context.actionContext }, orderTemplate.result.productList.Id, [line.productListLine])
                            .then(list => {
                            this.setState({
                                itemKey: itemKey,
                                userMessage: '',
                                statusCssString: 'success',
                                messageGlyph: 'fas fa-check',
                                isOpen: false
                            });
                            if (list) {
                                const newLine = list.find(lines => lines.LineId === itemKey);
                                orderTemplateLinesData[orderLineIndex].productListLine = newLine;
                                const updatedLines = [...orderTemplateLinesData];
                                updatedLines[orderLineIndex] = { fullProduct, productListLine: newLine };
                                const updatedOrderTemplate = { ...orderTemplate.result, ProductListLines: updatedLines };
                                context.actionContext.update(new ActiveOrderTemplateLinesInput(context.actionContext.requestContext, config), updatedOrderTemplate);
                            }
                        })
                            .catch(error => {
                            telemetry.warning('[order-template-lines] Unable to update product quantity.');
                            telemetry.error(error);
                            this.setState({
                                itemKey: itemKey,
                                userMessage: 'Failed to update quantity value.',
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        });
                    }
                }
            }
        };
        this._addItemToBag = (product, quantity, itemKey) => {
            const { context, data, resources, telemetry } = this.props;
            const { cart } = data;
            const { maxQuantityLimitText, addedToCartFailureMessage } = resources;
            if (context) {
                if (cart.result) {
                    const addProductToCartInput = {
                        product: product,
                        count: quantity
                    };
                    cart.result
                        .addProductToCart(addProductToCartInput)
                        .then(result => {
                        if (result.status === 'SUCCESS') {
                            return getPriceForSelectedVariant(new PriceForSelectedVariantInput(product.RecordId, this.props.context.actionContext.requestContext.apiSettings.channelId, product), this.props.context.actionContext).then(priceResult => {
                                if (!priceResult) {
                                    return AsyncResult.reject('Failed to retrieve product price');
                                }
                                this.setState({
                                    itemKey: itemKey,
                                    userMessage: '',
                                    statusCssString: 'success',
                                    messageGlyph: 'fas fa-check',
                                    isOpen: false,
                                    isItemAddedToOrderTemplateOpen: true,
                                    itemAddedToCartDialogData: {
                                        product: product,
                                        productPrice: priceResult,
                                        quantity: quantity
                                    }
                                });
                                return AsyncResult.resolve();
                            });
                        }
                        else if (result.substatus === 'MAXQUANTITY') {
                            this.setState({
                                itemKey: itemKey,
                                userMessage: maxQuantityLimitText
                                    .replace('{curQuantity}', quantity.toString())
                                    .replace('{maxQuantity}', context.app.config.maxQuantityForProductListLineItem.toString()) ||
                                    `You can only add ${context.app.config.maxQuantityForProductListLineItem} of this item to your shopping bag`,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                            return AsyncResult.resolve();
                        }
                        else {
                            telemetry.debug('[order-template-lines] Unable to Update Cart Line from the order template lines');
                            this.setState({
                                itemKey: itemKey,
                                userMessage: addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                            return AsyncResult.resolve();
                        }
                    })
                        .catch(error => {
                        telemetry.warning(error);
                        telemetry.debug('[order-template-lines] Error trying to Update Cart Line from the order template lines');
                        this.setState({
                            itemKey: itemKey,
                            userMessage: addedToCartFailureMessage,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                    });
                }
            }
        };
        this._removeItemFromOrderTemplateLines = (listLineId) => {
            const { context, data, telemetry } = this.props;
            const { orderTemplate } = data;
            if (context && context.actionContext) {
                const userToken = context.request.user.isAuthenticated && context.request.user.token;
                if (userToken && orderTemplate.result && orderTemplate.result && listLineId) {
                    const listLine = orderTemplate.result.orderTemplateLines.find(l => l.productListLine.LineId === listLineId);
                    if (listLine) {
                        const productListId = listLine.productListLine.ProductListId;
                        const { fullProduct, ...line } = listLine;
                        removeProductListLinesAsync({ callerContext: context.actionContext }, productListId, [line.productListLine])
                            .then(() => {
                            window.location.reload(false);
                        })
                            .catch(error => {
                            telemetry.warning('[order-template-lines] Unable remove items from the order template lines');
                            telemetry.error(error);
                        });
                    }
                }
                else {
                    telemetry.warning('[order-template-lines] Unable remove items from the order template lines user token or lineItemID was not found');
                }
            }
        };
        this._renameTemplate = async (_template) => {
            window.location.reload(false);
            return Promise.resolve();
        };
        this._removeTemplate = () => {
            const { context, data, telemetry, resources } = this.props;
            const { orderTemplate } = data;
            if (context && context.actionContext) {
                const userToken = context.request.user.isAuthenticated && context.request.user.token;
                if (userToken && orderTemplate && orderTemplate.result) {
                    deleteAsync({ callerContext: context.actionContext }, orderTemplate.result.productList)
                        .then()
                        .catch((error) => {
                        telemetry.warning('[order-template] Unable to delete order template.');
                        telemetry.error(error);
                        this.setState({
                            itemKey: orderTemplate.result?.productList.Id || '',
                            userMessage: resources.deleteOrderTemplateFailedText,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                    });
                    const newLink = getUrlSync('ordertemplatelist', this.props.context.actionContext);
                    if (newLink) {
                        window.location.assign(newLink);
                    }
                }
                else {
                    telemetry.warning('[order-template] Failed to delete order template. Order template was not found');
                }
            }
            else {
                telemetry.warning('[order-template] Failed to delete order template.');
            }
        };
        this.className = 'ms-order-template';
        this.state = {
            itemKey: '',
            userMessage: '',
            statusCssString: 'success',
            messageGlyph: 'fas fa-check',
            isOpen: false,
            isItemAddedToOrderTemplateOpen: false,
            productSelection: []
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    async componentDidMount() {
        this.setState({});
        const orderTemplate = await this.props.data.orderTemplate;
        this.props.config.heading.text = orderTemplate.productList.Name || '';
        this.setState({
            productSelection: orderTemplate.orderTemplateLines
        });
    }
    render() {
        const { heading, className } = this.props.config;
        const { emptyOrderTemplateLinesText, errorGettingOrderTemplateLines } = this.props.resources;
        const { orderTemplate, cart } = this.props.data;
        if (cart.status === 'LOADING' || orderTemplate.status === 'LOADING') {
            const errorProps = {
                ...this.props,
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(this.className, className)
                },
                status: 'LOADING',
                statusMessage: React.createElement(OrderTemplateLinesStatusMessage, { errorType: 'LOADING', text: 'Loading...' }),
                heading: heading && React.createElement(Heading, Object.assign({ className: `${this.className}__heading` }, heading)),
                resources: this.props.resources
            };
            return this.props.renderView(errorProps);
        }
        if (cart.status === 'FAILED' || orderTemplate.status === 'FAILED') {
            const errorProps = {
                ...this.props,
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(`${this.className}`, className)
                },
                status: 'FAILED',
                statusMessage: React.createElement(OrderTemplateLinesStatusMessage, { errorType: 'FAILED', text: errorGettingOrderTemplateLines }),
                heading: heading && React.createElement(Heading, Object.assign({ className: `${this.className}__heading` }, heading)),
                resources: this.props.resources
            };
            return this.props.renderView(errorProps);
        }
        const orderTemplateResult = orderTemplate && orderTemplate.result;
        const orderTemplateLines = orderTemplateResult && orderTemplateResult.orderTemplateLines;
        if (!orderTemplateResult || !orderTemplateLines || orderTemplateLines.length === 0) {
            const emptyViewProps = {
                ...this.props,
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(`${this.className}`, className)
                },
                status: 'EMPTY',
                statusMessage: React.createElement(OrderTemplateLinesStatusMessage, { errorType: 'EMPTY', text: emptyOrderTemplateLinesText }),
                heading: heading && React.createElement(Heading, Object.assign({ className: `${this.className}__heading` }, heading)),
                resources: this.props.resources
            };
            return this.props.renderView(emptyViewProps);
        }
        const viewProps = {
            ...this.props,
            OrderTemplateLines: {
                moduleProps: this.props,
                className: classnames(`${this.className}`, className)
            },
            resources: this.props.resources,
            status: 'SUCCESS',
            productsStatusMessage: this.state.isOpen && (React.createElement("div", { className: `${this.className}-products-status` },
                React.createElement(Alert, { color: this.state.statusCssString, isOpen: this.state.isOpen, toggle: this._onDismiss },
                    React.createElement("span", null, this.state.userMessage)))),
            heading: heading && React.createElement(Heading, Object.assign({ className: `${this.className}__heading` }, heading)),
            OrderTemplateActions: {
                className: `${this.className}-action-bar`,
                tag: 'div'
            },
            ProductsTable: {
                className: `${this.className}__table`,
                tag: 'table'
            },
            ProductsTableRow: {
                className: `${this.className}-table-line`,
                tag: 'tr'
            },
            ProductsTableHeading: this._renderProductListHeader(this.props.resources),
            ProductDetails: {
                className: `${this.className}-table-line__link`,
                tag: 'a'
            },
            orderLines: this._renderProductList(),
            callbacks: { updateQuantity: debounce(this._changeQuantity, 2000) },
            orderActions: this._renderOrderActions(orderTemplateResult),
            pagination: this._renderPagination(),
            itemAddedToCartDialog: this._renderItemAddedToCartDialog(),
            bulkOrderLineActions: this._getBulkActions(orderTemplateResult.productList.Id)
        };
        return this.props.renderView(viewProps);
    }
    onSelect(line, isChecked) {
        line.isChecked = isChecked;
        const updated = this.state.productSelection.map(product => {
            if (product.fullProduct?.ProductDetails.ItemId === line.fullProduct?.ProductDetails.ItemId) {
                line.isChecked = isChecked;
            }
            return product;
        }) || [];
        this.setState({
            productSelection: updated
        });
    }
    onSelectAll(isChecked) {
        const updated = this.state.productSelection.map(line => {
            line.isChecked = isChecked;
            return line;
        }) || [];
        this.setState({
            productSelection: updated
        });
    }
    _renderProductListHeader(resources) {
        const { productNumberText, productText, productUnitPriceText, productUOMText, productQuantityText, productActionsText } = resources;
        const headers = {
            productNumber: productNumberText,
            productName: productText,
            productUnitPrice: productUnitPriceText,
            productUOM: productUOMText,
            productQuantity: productQuantityText,
            productActions: productActionsText,
            clickHandler: (isChecked) => this.onSelectAll(isChecked)
        };
        return React.createElement(OrderTemplateTableHeading, Object.assign({}, headers));
    }
    _getBulkActions(orderTemplateId) {
        return OrderTemplateBulkActions({
            ...this.props,
            orderTemplateId: orderTemplateId,
            onAddSelectionToBag: this._onAddSelectionToBag,
            onRemoveSelection: this._onRemoveSelection
        });
    }
    _generateLinesAddedToCartDialogResources() {
        return {
            viewCartButtonText: this.props.resources.viewCartButtonText,
            orderTemplateCloseButtonText: this.props.resources.orderTemplateCloseButtonText,
            linesAddedToCartHeaderItemsOneText: this.props.resources.linesAddedToCartHeaderItemsOneText,
            linesAddedToCartHeaderLinesOneText: this.props.resources.linesAddedToCartHeaderLinesOneText,
            linesAddedToCartHeaderLinesFormatText: this.props.resources.linesAddedToCartHeaderLinesFormatText,
            linesAddedToCartHeaderMessageText: this.props.resources.linesAddedToCartHeaderMessageText
        };
    }
    _generateItemAddedToCartDialogResources() {
        return {
            viewCartButtonText: this.props.resources.viewCartButtonText,
            orderTemplateCloseButtonText: this.props.resources.orderTemplateCloseButtonText,
            itemAddedToCartHeaderItemOneText: this.props.resources.itemAddedToCartHeaderItemOneText,
            itemAddedToCartHeaderItemFormatText: this.props.resources.itemAddedToCartHeaderItemFormatText,
            itemAddedToCartHeaderMessageText: this.props.resources.itemAddedToCartHeaderMessageText,
            freePriceText: this.props.resources.freePriceText,
            originalPriceText: this.props.resources.originalPriceText,
            currentPriceText: this.props.resources.currentPriceText
        };
    }
    _renderOrderActions(orderTemplate) {
        const { id, typeName, context, resources } = this.props;
        const { addTemplateToBagButtonText, renameTemplateButtonText, deleteTemplateButtonText, closeWindowButtonText, addToCartFailureMessage, addToCartSuccessMessage, addToCartProcessMessage } = resources;
        const orderTemplateActions = {
            data: { orderTemplate },
            id: id,
            typeName: typeName,
            context: context,
            telemetryContent: this.telemetryContent,
            handlers: {
                onRenameTemplate: this._renameTemplate,
                onRemoveTemplate: this._removeTemplate
            },
            renameOrderTemplateDialogStrings: this._generateOrderTemplateNameDialogResources(resources),
            resources: {
                addTemplateToBagButtonText: addTemplateToBagButtonText,
                renameTemplateButtonText: renameTemplateButtonText,
                deleteTemplateButtonText: deleteTemplateButtonText,
                addToCartFailureMessage: addToCartFailureMessage,
                addToCartSuccessMessage: addToCartSuccessMessage,
                addToCartProcessMessage: addToCartProcessMessage,
                closeWindowButtonText: closeWindowButtonText,
                linesAddedToCartDialogResources: this._generateLinesAddedToCartDialogResources()
            }
        };
        return OrderTemplateActionsView(orderTemplateActions);
    }
    _generateOrderTemplateNameDialogResources(resources) {
        return {
            orderTemplateHeaderLabel: resources.renameOrderTemplateTitleText,
            orderTemplateTitleLabel: resources.orderTemplateTitle,
            orderTemplateNameAriaLabel: resources.orderTemplateTitle,
            orderTemplateDescription: '',
            defaultOrderTemplateName: resources.defaultOrderTemplateName,
            orderTemplateButtonLabel: resources.renameOrderTemplateButtonText,
            orderTemplateCancelButtonLabel: resources.cancelBtnLabel
        };
    }
    _renderProductList() {
        const { priceFree, originalPriceText, currentPriceText, addOrderTemplateItemToBagButtonText, removeItemFromOrderTemplateButtonText, productDimensionTypeColor, productDimensionTypeSize, productDimensionTypeStyle, inputQuantityAriaLabel } = this.props.resources;
        const { context, telemetry } = this.props;
        const { imageSettings } = this.props.config;
        return this.state.productSelection?.map((line, index) => {
            const currentProductProps = {
                orderTemplateLine: line,
                productListLine: line.productListLine,
                price: line.fullProduct?.ProductPrice,
                context: context,
                productUrl: getProductUrlSync(line.fullProduct.ProductDetails, context.actionContext, undefined),
                imageSettings: imageSettings,
                telemetry: telemetry,
                moduleId: this.props.id,
                moduleTypeName: this.props.typeName,
                quantity: line.productListLine.Quantity,
                handlers: {
                    onAddToBag: this._addItemToBag,
                    onRemoveItem: this._removeItemFromOrderTemplateLines,
                    onChangeQuantity: debounce(this._changeQuantity, 2000),
                    onSelect: this.onSelect.bind(this)
                },
                resources: {
                    productDimensionTypeColor: productDimensionTypeColor,
                    productDimensionTypeSize: productDimensionTypeSize,
                    productDimensionTypeStyle: productDimensionTypeStyle,
                    freePriceText: priceFree,
                    originalPriceText: originalPriceText,
                    currentPriceText: currentPriceText,
                    inputQuantityAriaLabel: inputQuantityAriaLabel,
                    removeFromOrderTemplateLinesText: removeItemFromOrderTemplateButtonText,
                    addToBagButtonText: addOrderTemplateItemToBagButtonText
                }
            };
            return OrderTemplateLineView(currentProductProps);
        });
    }
};
__decorate([
    action
], OrderTemplateLines.prototype, "componentDidMount", null);
OrderTemplateLines = __decorate([
    observer
], OrderTemplateLines);
export default OrderTemplateLines;
//# sourceMappingURL=order-template.js.map
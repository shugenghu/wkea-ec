/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { getPriceForSelectedVariant, getProductUrlSync, OrderTemplate, OrderTemplateLine, PriceForSelectedVariantInput } from '@msdyn365-commerce-modules/retail-actions';
import { Alert, getTelemetryObject, Heading, IModuleProps, INodeProps, ITelemetryContent, UncontrolledPagination } from '@msdyn365-commerce-modules/utilities';
import { IItemAddedToCartDialogData, IItemAddedToCartDialogResources, ILinesAddedToCartDialogResources, IOrderTemplateNameDialogResources, ItemAddedToCartDialog } from '@msdyn365-commerce/components';
import MsDyn365, { AsyncResult, getUrlSync, IRequestContext } from '@msdyn365-commerce/core';
import { getCartState } from '@msdyn365-commerce/global-state';
import { CartLine, ProductList, ProductListLine } from '@msdyn365-commerce/retail-proxy';
import { addCartLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import {
    deleteAsync,
    removeProductListLinesAsync,
    updateProductListLinesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductListsDataActions.g';
import { SimpleProduct } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import classnames from 'classnames';
import debounce from 'lodash/debounce';
import { action } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import {
    IOrderTemplateActionsProps,
    IOrderTemplateActionsViewProps,
    IOrderTemplateData,
    IOrderTemplateLineProps,
    IOrderTemplateLineViewProps,
    IOrderTemplateProps,
    IOrderTemplateResources,
    IOrderTemplateTableHeading,
    OrderTemplateActionsView,
    OrderTemplateBulkActions,
    OrderTemplateLinesStatusMessage,
    OrderTemplateLineView,
    OrderTemplateTableHeading
} from '../../';
import { ActiveOrderTemplateLinesInput } from './actions/get-order-template';

export interface IOrderTemplateLineActionMessageState {
    itemKey: string;
    userMessage: string;
    statusCssString: string;
    messageGlyph: string;
    isOpen: boolean;
    isItemAddedToOrderTemplateOpen: boolean;
    itemAddedToCartDialogData?: IItemAddedToCartDialogData;
    productSelection: IOrderTemplateLineViewModel[];
}

export type orderTemplateLinesStatus = 'LOADING' | 'SUCCESS' | 'FAILED' | 'EMPTY';

export interface IOrderTemplateViewProps extends IOrderTemplateProps<IOrderTemplateData> {
    OrderTemplateLines: IModuleProps;
    callbacks?: IOrderTemplateLinesCallbacks;
    status?: orderTemplateLinesStatus;
    statusMessage?: React.ReactNode;
    heading?: React.ReactNode;
    OrderTemplateActions?: INodeProps;
    ProductsTable?: INodeProps;
    ProductsTableRow?: INodeProps;
    ProductsTableHeading?: React.ReactNode;
    ProductDetails?: INodeProps;
    orderLines?: IOrderTemplateLineViewProps[];
    productListLines?: ProductListLine[];
    productsStatusMessage?: React.ReactNode;
    orderActions?: IOrderTemplateActionsViewProps | null;
    resources: IOrderTemplateResources;
    pagination?: React.ReactNode;
    itemAddedToCartDialog?: React.ReactNode;
    bulkOrderLineActions?: React.ReactNode;
}

export interface IOrderTemplateLinesCallbacks {
    updateQuantity(itemKey: string, quantity: number): void;
}

export interface IOrderTemplateLineViewModel extends OrderTemplateLine {
    isChecked: boolean;
}

/**
 *
 * OrderTemplateLines component
 * @extends {React.PureComponent<IOrderTemplateProps<IOrderTemplateData>, IOrderTemplateLineActionMessageState>}
 */
@observer
class OrderTemplateLines extends React.Component<IOrderTemplateProps<IOrderTemplateData>, IOrderTemplateLineActionMessageState> {
    private readonly className: string;
    private telemetryContent?: ITelemetryContent;

    constructor(props: IOrderTemplateProps<IOrderTemplateData>, state: IOrderTemplateLineActionMessageState) {
        super(props);
        this.className = 'ms-order-template';
        this.state = {
            itemKey: '',
            userMessage: '',
            statusCssString: 'success',
            messageGlyph: 'fas fa-check',
            isOpen: false,
            isItemAddedToOrderTemplateOpen: false,
            productSelection: []
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
    }

    @action
    public async componentDidMount(): Promise<void> {
        this.setState({});
        const orderTemplate = await this.props.data.orderTemplate;
        this.props.config.heading!.text = orderTemplate.productList.Name || '';
        this.setState({
            productSelection: orderTemplate.orderTemplateLines as IOrderTemplateLineViewModel[]
        });
    }

    public render(): JSX.Element | null {
        const { heading, className } = this.props.config;
        const { emptyOrderTemplateLinesText, errorGettingOrderTemplateLines } = this.props.resources;
        const { orderTemplate, cart } = this.props.data;

        if (cart.status === 'LOADING' || orderTemplate.status === 'LOADING') {
            const errorProps: IOrderTemplateViewProps = {
                ...(this.props as IOrderTemplateProps<IOrderTemplateData>),
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(this.className, className)
                },
                status: 'LOADING',
                statusMessage: <OrderTemplateLinesStatusMessage errorType='LOADING' text='Loading...' />,
                heading: heading && <Heading className={`${this.className}__heading`} {...heading} />,
                resources: this.props.resources
            };
            return this.props.renderView(errorProps);
        }

        if (cart.status === 'FAILED' || orderTemplate.status === 'FAILED') {
            const errorProps: IOrderTemplateViewProps = {
                ...(this.props as IOrderTemplateProps<IOrderTemplateData>),
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(`${this.className}`, className)
                },
                status: 'FAILED',
                statusMessage: <OrderTemplateLinesStatusMessage errorType='FAILED' text={errorGettingOrderTemplateLines} />,
                heading: heading && <Heading className={`${this.className}__heading`} {...heading} />,
                resources: this.props.resources
            };

            return this.props.renderView(errorProps);
        }

        const orderTemplateResult = orderTemplate && orderTemplate.result;
        const orderTemplateLines= orderTemplateResult && orderTemplateResult.orderTemplateLines;

        if (!orderTemplateResult || !orderTemplateLines || orderTemplateLines.length === 0) {
            const emptyViewProps: IOrderTemplateViewProps = {
                ...(this.props as IOrderTemplateProps<IOrderTemplateData>),
                OrderTemplateLines: {
                    moduleProps: this.props,
                    className: classnames(`${this.className}`, className)
                },
                status: 'EMPTY',
                statusMessage: <OrderTemplateLinesStatusMessage errorType='EMPTY' text={emptyOrderTemplateLinesText} />,
                heading: heading && <Heading className={`${this.className}__heading`} {...heading} />,
                resources: this.props.resources
            };

            return this.props.renderView(emptyViewProps);
        }

        const viewProps: IOrderTemplateViewProps = {
            ...(this.props as IOrderTemplateProps<IOrderTemplateData>),
            OrderTemplateLines: {
                moduleProps: this.props,
                className: classnames(`${this.className}`, className)
            },
            resources: this.props.resources,
            status: 'SUCCESS',
            productsStatusMessage: this.state.isOpen && (
                <div className={`${this.className}-products-status`}>
                    <Alert color={this.state.statusCssString} isOpen={this.state.isOpen} toggle={this._onDismiss}>
                        <span>{this.state.userMessage}</span>
                    </Alert>
                </div>
            ),
            heading: heading && <Heading className={`${this.className}__heading`} {...heading} />,
            OrderTemplateActions: {
                className: `${this.className}-action-bar`,
                tag: 'div'
            },
            ProductsTable: {
                className: `${this.className}__table`,
                tag: 'table'
            },
            ProductsTableRow: {
                className: `${this.className}-table-line`,
                tag: 'tr'
            },
            ProductsTableHeading: this._renderProductListHeader(this.props.resources),
            ProductDetails: {
                className: `${this.className}-table-line__link`,
                tag: 'a'
            },
            orderLines: this._renderProductList(),
            callbacks: { updateQuantity: debounce(this._changeQuantity, 2000) },
            orderActions: this._renderOrderActions(orderTemplateResult),
            pagination: this._renderPagination(),
            itemAddedToCartDialog: this._renderItemAddedToCartDialog(),
            bulkOrderLineActions: this._getBulkActions(orderTemplateResult.productList.Id)
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public onSelect(line: IOrderTemplateLineViewModel, isChecked: boolean): void {
        line.isChecked = isChecked;

        const updated = this.state.productSelection.map(product => {
            if (product.fullProduct?.ProductDetails.ItemId === line.fullProduct?.ProductDetails.ItemId) {
                line.isChecked = isChecked;
            }
            return product;
        }) || [];

        this.setState({
            productSelection: updated
        });
    }

    public onSelectAll(isChecked: boolean): void {
        const updated = this.state.productSelection.map(line => {
            line.isChecked = isChecked;
            return line;
        }) || [];

        this.setState({
            productSelection: updated
        });
    }

    private _renderProductListHeader(resources: IOrderTemplateResources): React.ReactNode {
        const { productNumberText, productText, productUnitPriceText, productUOMText, productQuantityText, productActionsText } = resources;
        const headers: IOrderTemplateTableHeading = {
            productNumber: productNumberText,
            productName: productText,
            productUnitPrice: productUnitPriceText,
            productUOM: productUOMText,
            productQuantity: productQuantityText,
            productActions: productActionsText,
            clickHandler: (isChecked: boolean) => this.onSelectAll(isChecked)
        };

        return <OrderTemplateTableHeading {...headers}/>;
    }

    private _getBulkActions(orderTemplateId: string): React.ReactNode {
        return OrderTemplateBulkActions({
            ...this.props,
            orderTemplateId: orderTemplateId,
            onAddSelectionToBag: this._onAddSelectionToBag,
            onRemoveSelection: this._onRemoveSelection
        });
    }

    private _generateLinesAddedToCartDialogResources(): ILinesAddedToCartDialogResources {
        return {
            viewCartButtonText: this.props.resources.viewCartButtonText,
            orderTemplateCloseButtonText: this.props.resources.orderTemplateCloseButtonText,
            linesAddedToCartHeaderItemsOneText: this.props.resources.linesAddedToCartHeaderItemsOneText,
            linesAddedToCartHeaderLinesOneText: this.props.resources.linesAddedToCartHeaderLinesOneText,
            linesAddedToCartHeaderLinesFormatText: this.props.resources.linesAddedToCartHeaderLinesFormatText,
            linesAddedToCartHeaderMessageText: this.props.resources.linesAddedToCartHeaderMessageText
        };
    }

    private _generateItemAddedToCartDialogResources(): IItemAddedToCartDialogResources {
        return {
            viewCartButtonText: this.props.resources.viewCartButtonText,
            orderTemplateCloseButtonText: this.props.resources.orderTemplateCloseButtonText,
            itemAddedToCartHeaderItemOneText: this.props.resources.itemAddedToCartHeaderItemOneText,
            itemAddedToCartHeaderItemFormatText: this.props.resources.itemAddedToCartHeaderItemFormatText,
            itemAddedToCartHeaderMessageText: this.props.resources.itemAddedToCartHeaderMessageText,
            freePriceText: this.props.resources.freePriceText,
            originalPriceText: this.props.resources.originalPriceText,
            currentPriceText: this.props.resources.currentPriceText
        };
    }

    /**
     * @TODO user progress notification - current implementation is to refresh page upon XHR success
     * @param event React.MouseEvent
     */
    private _onRemoveSelection = (event: React.MouseEvent<HTMLElement>) => {
        const { context, resources } = this.props;
        const { telemetry } = context;
        const { removeSelectedFailureMessage, removeSelectedSuccessMessage } = resources;
        const lines = this.state.productSelection;
        const productListLines = lines && lines.length && lines
            .filter(line => line.isChecked)
            .map(line => line.productListLine);

        if (productListLines && productListLines.length) {
            const productListId = productListLines[0].ProductListId;

            removeProductListLinesAsync({ callerContext: context.actionContext }, productListId!, productListLines)
                .then(() => {
                    this.setState({
                        userMessage: removeSelectedSuccessMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                    window.location.reload();
                })
                .catch(error => {
                    telemetry.warning('[order-template-lines] Unable remove items from the order template lines');
                    telemetry.error(error);
                    this.setState({
                        userMessage: removeSelectedFailureMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                });
        }
    }

    private _onAddSelectionToBag = async (event: React.MouseEvent<HTMLElement>) => {
        const { context, resources } = this.props;
        const { addedToCartFailureMessage, addedToCartSuccessMessage } = resources;
        const lines = this.state.productSelection;
        const cartState = await getCartState(context.actionContext);
        const selectedLines = lines.filter(line => line.isChecked);

        if (selectedLines.length) {
            const cartLines = selectedLines.map(productLine => {
                return {
                    ItemId: productLine.fullProduct?.ProductDetails.ItemId,
                    ProductId: productLine.productListLine.ProductId,
                    Quantity: productLine.productListLine.Quantity || 1,
                    TrackingId: '',
                    UnitOfMeasureSymbol: productLine.productListLine.UnitOfMeasure || productLine.fullProduct?.ProductDetails.DefaultUnitOfMeasure
                } as CartLine ;
            }) || [];

            return addCartLinesAsync({ callerContext: context.actionContext }, cartState.cart.Id, cartLines, cartState.cart.Version!)
                .then(async res => {
                    context.telemetry.trace(`Order template; selected line items (${cartLines.map(line => line.ItemId).join(',')}) added to cart: ${cartState.cart.Id}`);
                    await cartState.refreshCart({});
                    this.setState({
                        userMessage: addedToCartSuccessMessage,
                        statusCssString: 'success',
                        messageGlyph: 'fas fa-check',
                        isOpen: true
                    });
                })
                .catch(error => {
                    context.telemetry.trace('Unable to add order template to cart.');
                    this.setState({
                        userMessage: addedToCartFailureMessage,
                        statusCssString: 'danger',
                        messageGlyph: 'fas fa-exclamation-triangle',
                        isOpen: true
                    });
                });
        }
    };

    private _renderOrderActions(orderTemplate: OrderTemplate): IOrderTemplateActionsViewProps {
        const { id, typeName, context, resources } = this.props;
        const {
            addTemplateToBagButtonText,
            renameTemplateButtonText,
            deleteTemplateButtonText,
            closeWindowButtonText,
            addToCartFailureMessage,
            addToCartSuccessMessage,
            addToCartProcessMessage
        } = resources;

        const orderTemplateActions: IOrderTemplateActionsProps = {
            data: { orderTemplate },
            id: id,
            typeName: typeName,
            context: context,
            telemetryContent: this.telemetryContent,
            handlers: {
                onRenameTemplate: this._renameTemplate,
                onRemoveTemplate: this._removeTemplate
            },
            renameOrderTemplateDialogStrings: this._generateOrderTemplateNameDialogResources(resources),
            resources: {
                addTemplateToBagButtonText: addTemplateToBagButtonText,
                renameTemplateButtonText: renameTemplateButtonText,
                deleteTemplateButtonText: deleteTemplateButtonText,
                addToCartFailureMessage: addToCartFailureMessage,
                addToCartSuccessMessage: addToCartSuccessMessage,
                addToCartProcessMessage: addToCartProcessMessage,
                closeWindowButtonText: closeWindowButtonText,
                linesAddedToCartDialogResources: this._generateLinesAddedToCartDialogResources()
            }
        };

        return OrderTemplateActionsView(orderTemplateActions);
    }

    private _generateOrderTemplateNameDialogResources(resources: IOrderTemplateResources): IOrderTemplateNameDialogResources {
        return {
            orderTemplateHeaderLabel: resources.renameOrderTemplateTitleText,
            orderTemplateTitleLabel: resources.orderTemplateTitle,
            orderTemplateNameAriaLabel: resources.orderTemplateTitle,
            orderTemplateDescription: '',
            defaultOrderTemplateName: resources.defaultOrderTemplateName,
            orderTemplateButtonLabel: resources.renameOrderTemplateButtonText,
            orderTemplateCancelButtonLabel: resources.cancelBtnLabel
        };
    }

    private _getCurrentUrl = (reqContext: IRequestContext): URL=> {
        if (MsDyn365.isBrowser) {
            return new URL(window.location.href);
        }
        return new URL(reqContext.url.requestUrl.href);
    }

    private _renderItemAddedToCartDialog = (): React.ReactNode | null => {
        if (!this.state.itemAddedToCartDialogData) {
            return null;
        }

        const onClose = () => {
            this.setState({
                itemKey: this.state.itemKey,
                userMessage: this.state.userMessage,
                statusCssString: this.state.statusCssString,
                messageGlyph: this.state.messageGlyph,
                isOpen: this.state.isOpen,
                isItemAddedToOrderTemplateOpen: false
            });
        };

        return (
            <ItemAddedToCartDialog
                className={'msc-item-added-to-cart-dialog'}
                id={this.props.id}
                typeName={this.props.typeName}
                context={this.props.context}
                dialogStrings={this._generateItemAddedToCartDialogResources()}
                data={this.state.itemAddedToCartDialogData}
                modalOpen={this.state.isItemAddedToOrderTemplateOpen}
                onClose={onClose}
            />
        );
    }

    private _renderPagination = (): React.ReactNode | null => {
        const { config, context, data, resources } = this.props;
        const orderTemplate = data && data.orderTemplate && data.orderTemplate.result;
        if (!orderTemplate) {
            return null;
        }

        const fullUrl = this._getCurrentUrl(context.request);
        const itemsPerPage = config.itemsPerPage || 50;
        const currentPageNumber = this.props.context.request.query && (+this.props.context.request.query.skip / itemsPerPage) || 0;
        const skipCount = currentPageNumber * itemsPerPage;
        const totalItems = orderTemplate && orderTemplate.totalLines;
        const previousText = resources.flipperPrevious;
        const nextText = resources.flipperNext;

        if (totalItems <= itemsPerPage) {
            return null;
        }

        return (
            <UncontrolledPagination
                className={`${this.className}__pagination`}
                role='navigation'
                aria-label={resources.paginationAriaLabel}
                url={fullUrl.href}
                qsp={'skip'}
                items={totalItems}
                itemsPerPage={itemsPerPage}
                startingItem={skipCount}
                previousText={<div className='msc-pagination__prev'><span className={`${this.props.config.className}__pagination-left`} aria-hidden='true'/><span className='prev-text'>{previousText}</span></div>}
                nextText={<div className='msc-pagination__next'><span className='next-text'>{nextText}</span><span className={`${this.props.config.className}__pagination-right`} aria-hidden='true'/></div>}
                previousAriaLabel={previousText}
                nextAriaLabel={nextText}
            />
        );
    }

    private _renderProductList(): IOrderTemplateLineViewProps[] {
        const {
            priceFree,
            originalPriceText,
            currentPriceText,
            addOrderTemplateItemToBagButtonText,
            removeItemFromOrderTemplateButtonText,
            productDimensionTypeColor,
            productDimensionTypeSize,
            productDimensionTypeStyle,
            inputQuantityAriaLabel
        } = this.props.resources;

        const { context, telemetry } = this.props;
        const { imageSettings } = this.props.config;

        return this.state.productSelection?.map((line, index) => {
            const currentProductProps: IOrderTemplateLineProps = {
                orderTemplateLine: line,
                productListLine: line.productListLine ,
                price: line.fullProduct?.ProductPrice,
                context: context,
                productUrl: getProductUrlSync(line.fullProduct!.ProductDetails, context.actionContext, undefined),
                imageSettings: imageSettings,
                telemetry: telemetry,
                moduleId: this.props.id,
                moduleTypeName: this.props.typeName,
                quantity: line.productListLine.Quantity!,
                handlers: {
                    onAddToBag: this._addItemToBag,
                    onRemoveItem: this._removeItemFromOrderTemplateLines,
                    onChangeQuantity: debounce(this._changeQuantity, 2000),
                    onSelect: this.onSelect.bind(this)
                },
                resources: {
                    productDimensionTypeColor: productDimensionTypeColor,
                    productDimensionTypeSize: productDimensionTypeSize,
                    productDimensionTypeStyle: productDimensionTypeStyle,
                    freePriceText: priceFree,
                    originalPriceText: originalPriceText,
                    currentPriceText: currentPriceText,
                    inputQuantityAriaLabel: inputQuantityAriaLabel,
                    removeFromOrderTemplateLinesText: removeItemFromOrderTemplateButtonText,
                    addToBagButtonText: addOrderTemplateItemToBagButtonText
                }
            };

            return OrderTemplateLineView(currentProductProps)!;
        });
    }

    // dismiss alert when addingToCart/removeItem
    private _onDismiss = () => {
        this.setState({
            isOpen: false
        });
    };

    private _changeQuantity = (itemKey: string, quantity: number) => {
        const { context, data, telemetry, config } = this.props;
        const { orderTemplate } = data;

        if (context) {
            if (orderTemplate.result) {
                const orderTemplateLinesData = orderTemplate && orderTemplate.result && orderTemplate.result.orderTemplateLines;
                if (orderTemplateLinesData) {
                    const orderLineIndex = orderTemplateLinesData.findIndex(lines => lines.productListLine.LineId === itemKey);
                    const newProductListLine = { ...orderTemplateLinesData[orderLineIndex] };
                    if (orderTemplateLinesData[orderLineIndex].productListLine.Quantity === quantity) {
                        return;
                    }

                    newProductListLine.productListLine.Quantity = quantity;
                    const { fullProduct, ...line } = newProductListLine;

                    updateProductListLinesAsync({ callerContext: context.actionContext }, orderTemplate.result.productList.Id, [line.productListLine])
                        .then(list => {
                            this.setState({
                                itemKey: itemKey,
                                userMessage: '',
                                statusCssString: 'success',
                                messageGlyph: 'fas fa-check',
                                isOpen: false
                            });
                            if (list) {
                                const newLine = list.find(lines => lines.LineId === itemKey);
                                orderTemplateLinesData[orderLineIndex].productListLine = newLine!;
                                const updatedLines = [...orderTemplateLinesData];
                                updatedLines[orderLineIndex] = { fullProduct, productListLine: newLine! };
                                const updatedOrderTemplate = { ...orderTemplate.result, ProductListLines: updatedLines };
                                context.actionContext.update(new ActiveOrderTemplateLinesInput(context.actionContext.requestContext, config), updatedOrderTemplate);
                            }
                        })
                        .catch(error => {
                            telemetry.warning('[order-template-lines] Unable to update product quantity.');
                            telemetry.error(error);
                            this.setState({
                                itemKey: itemKey,
                                userMessage: 'Failed to update quantity value.',
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        });
                }
            }
        }
    };

    private _addItemToBag = (product: SimpleProduct, quantity: number, itemKey: string): void => {
        const { context, data, resources, telemetry } = this.props;
        const { cart } = data;
        const { maxQuantityLimitText, addedToCartFailureMessage } = resources;

        if (context) {
            if (cart.result) {
                const addProductToCartInput = {
                    product: product,
                    count: quantity
                };

                cart.result
                    .addProductToCart(addProductToCartInput)
                    .then(result => {
                        if (result.status === 'SUCCESS') {
                            return getPriceForSelectedVariant(
                                new PriceForSelectedVariantInput(
                                    product.RecordId,
                                    this.props.context.actionContext.requestContext.apiSettings.channelId,
                                    product),
                                this.props.context.actionContext).then(priceResult => {
                                    if (!priceResult) {
                                        return AsyncResult.reject('Failed to retrieve product price');
                                    }
                                    this.setState({
                                        itemKey: itemKey,
                                        userMessage: '',
                                        statusCssString: 'success',
                                        messageGlyph: 'fas fa-check',
                                        isOpen: false,
                                        isItemAddedToOrderTemplateOpen: true,
                                        itemAddedToCartDialogData: {
                                            product: product,
                                            productPrice: priceResult,
                                            quantity: quantity
                                        }
                                    });
                                    return AsyncResult.resolve();
                                });
                        } else if (result.substatus === 'MAXQUANTITY') {
                            this.setState({
                                itemKey: itemKey,
                                userMessage:
                                    maxQuantityLimitText
                                        .replace('{curQuantity}', quantity.toString())
                                        .replace('{maxQuantity}', context.app.config.maxQuantityForProductListLineItem.toString()) ||
                                    `You can only add ${context.app.config.maxQuantityForProductListLineItem} of this item to your shopping bag`,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                            return AsyncResult.resolve();
                        } else {
                            telemetry.debug('[order-template-lines] Unable to Update Cart Line from the order template lines');
                            this.setState({
                                itemKey: itemKey,
                                userMessage: addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                            return AsyncResult.resolve();
                        }
                    })
                    .catch(error => {
                        telemetry.warning(error);
                        telemetry.debug('[order-template-lines] Error trying to Update Cart Line from the order template lines');
                        this.setState({
                            itemKey: itemKey,
                            userMessage: addedToCartFailureMessage,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                    });
            }
        }
    };

    private _removeItemFromOrderTemplateLines = (listLineId: string): void | undefined => {
        const { context, data, telemetry } = this.props;
        const { orderTemplate } = data;

        if (context && context.actionContext) {
            const userToken = context.request.user.isAuthenticated && context.request.user.token;
            if (userToken && orderTemplate.result && orderTemplate.result && listLineId) {
                const listLine = orderTemplate.result.orderTemplateLines.find(l => l.productListLine.LineId === listLineId);
                if (listLine) {
                    const productListId = listLine.productListLine.ProductListId;
                    const { fullProduct, ...line } = listLine;
                    removeProductListLinesAsync({ callerContext: context.actionContext }, productListId!, [line.productListLine])
                        .then(() => {
                            window.location.reload(false);
                        })
                        .catch(error => {
                            telemetry.warning('[order-template-lines] Unable remove items from the order template lines');
                            telemetry.error(error);
                        });
                }
            } else {
                telemetry.warning(
                    '[order-template-lines] Unable remove items from the order template lines user token or lineItemID was not found'
                );
            }
        }
    };

    private  _renameTemplate = async (_template: ProductList): Promise<void> => {
        window.location.reload(false);
        return Promise.resolve();
    };

    private _removeTemplate = () => {
        const { context, data, telemetry, resources } = this.props;
        const { orderTemplate } = data;

        if (context && context.actionContext) {
            const userToken = context.request.user.isAuthenticated && context.request.user.token;
            if (userToken && orderTemplate && orderTemplate.result) {
                deleteAsync({ callerContext: context.actionContext }, orderTemplate.result.productList)
                .then()
                .catch((error: string) => {
                        telemetry.warning('[order-template] Unable to delete order template.');
                        telemetry.error(error);
                        this.setState({
                            itemKey: orderTemplate.result?.productList.Id || '',
                            userMessage: resources.deleteOrderTemplateFailedText,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                });
                const newLink = getUrlSync('ordertemplatelist', this.props.context.actionContext);
                if (newLink) {
                    window.location.assign(newLink);
                }
            } else {
            telemetry.warning('[order-template] Failed to delete order template. Order template was not found');
            }
        } else {
                telemetry.warning('[order-template] Failed to delete order template.');
        }
    };
}

export default OrderTemplateLines;

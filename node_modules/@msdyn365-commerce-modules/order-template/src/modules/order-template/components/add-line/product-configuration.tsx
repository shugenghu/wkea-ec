import {
    getDimensionsForSelectedVariant,
    GetDimensionsForSelectedVariantInput,
    getFallbackImageUrl,
    getPriceForSelectedVariant,
    getProductAvailabilitiesForSelectedVariant,
    getSelectedVariant,
    IProductInventoryInformation,
    PriceForSelectedVariantInput,
    ProductAvailabilitiesForSelectedVariantInput,
    SelectedVariantInput
 } from '@msdyn365-commerce-modules/retail-actions';
import { Button, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import { ProductDimensionFull } from '@msdyn365-commerce/commerce-entities';
import { IImageSettings, Image } from '@msdyn365-commerce/core';
import { ProductDimensionValue, ProductListLine } from '@msdyn365-commerce/retail-proxy';
import { SimpleProduct } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import classnames from 'classnames';
import React from 'react';
import { Dropdown, IAddLineToTemplateProps, IAddLineToTemplateResources, IDropdownItemProps, IDropdownOnSelection } from '.';
import OrderTemplateQuantity from '../common/order-template-quantity';

export interface IProductCnnfigurationProps extends IAddLineToTemplateProps {
    product: SimpleProduct;
    dimensions: ProductDimensionFull[];
    imageSettings: IImageSettings;
    telemetryContent?: ITelemetryContent;
    addToTemplateHandler(params: IProductConfigurationState): Promise<ProductListLine>;
    highlightSearchTerm(name: string): React.ReactNode;
}

export interface IProductConfigurationState {
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    product: SimpleProduct;
    dimensions: ProductDimensionFull[];
    selectedDimensions: {};
    productAvailableQuantity?: IProductInventoryInformation;
    buttonDisabled: boolean;
    showAddConfirmation: boolean;
    showAddError: boolean;
    isBusy: boolean;
}

/**
 * Configure selected product for addition to order template
 */
export class ProductConfiguration extends React.Component<IProductCnnfigurationProps, IProductConfigurationState> {
    private selectedDimensions: {};

    constructor(props: IProductCnnfigurationProps) {
        super(props);

        this.state = {
            quantity: 1,
            unitPrice: props.product.Price,
            totalPrice: props.product.Price,
            product: props.product,
            dimensions: props.dimensions,
            selectedDimensions: {},
            buttonDisabled: false,
            showAddConfirmation: false,
            showAddError: false
        } as IProductConfigurationState;

        this.selectedDimensions = props.dimensions.reduce((result, d) => {
            result[`${d.DimensionTypeValue}`] = d.DimensionValues![0].Value;
            return result;
        },                                                {});
    }

    public render(): JSX.Element {
        const {
            context: {
                actionContext: {
                    requestContext: { apiSettings }
                },
                request: { gridSettings }
             },
             resources: {
                addItemToTemplateText,
                addLineProductUnitPricePrefix,
                decrementButtonAriaLabel,
                incrementButtonAriaLabel,
                quantitySelectLabel,
                addLineProductUnitOfMeasurePrefix,
                addToTemplateConfirmation,
                addToTemplateError,
                totalPriceLabel
            },
            imageSettings,
            highlightSearchTerm
        } = this.props;
        const { buttonDisabled, product, quantity, unitPrice, totalPrice, showAddConfirmation, showAddError } = this.state;

        const confirmationMessage = addToTemplateConfirmation
            .replace('{count}', this.state.quantity.toString())
            .replace('{productAndDimensions}', `${this.state.product.Name}, ${Object.values(this.selectedDimensions).join(', ')}`);

        return (
            <>
                <div className='msc-add-line-to-template__product-config'>
                    <Image
                        src={product?.PrimaryImageUrl || ''}
                        fallBackSrc={
                            getFallbackImageUrl(product?.ItemId, apiSettings) || ''
                        }
                        className={'thumbnail'}
                        imageSettings={imageSettings}
                        gridSettings={gridSettings!}
                        loadFailureBehavior='empty'
                    />
                    <div className='msc-add-line-to-template__product__attributes'>
                        <div>
                            <div className='msc-add-line-to-template__product__id'>{product?.RecordId}</div>
                            <div className='msc-add-line-to-template__product__name'>{highlightSearchTerm(product?.Name || '')}</div>
                            <div className='msc-add-line-to-template__product__unit-price'>{addLineProductUnitPricePrefix} {this._formatPrice(unitPrice)}</div>
                            <div className='msc-add-line-to-template__product__uom'>{addLineProductUnitOfMeasurePrefix} {product?.DefaultUnitOfMeasure}</div>
                        </div>
                        <div className='msc-add-line-to-template__product-config__dimensions'>
                            {this._getDimensionsNodes()}
                        </div>
                    </div>
                    <div>
                        <div className='quantity-container'>
                            <div>{quantitySelectLabel}</div>
                            <OrderTemplateQuantity
                                id={'msc-add-line-to-template__product-config__quantity'}
                                currentCount={quantity}
                                onChange={this._onQuantityChange}
                                inputQuantityAriaLabel='Press to increment quantity by 1'
                                max={Number.MAX_VALUE}
                                decrementButtonAriaLabel={decrementButtonAriaLabel}
                                incrementButtonAriaLabel={incrementButtonAriaLabel}
                            />
                        </div>
                        <div className='msc-add-line-to-template__product__total-price'>{totalPriceLabel} {this._formatPrice(totalPrice)}</div>
                    </div>
                </div>
                {showAddConfirmation && <div className='msc-add-line-to-template__add-success msc-alert-success msc-alert'><span aria-hidden='true'/>{confirmationMessage}</div>}
                {showAddError && <div className='msc-add-line-to-template__add-error msc-alert-danger msc-alert'><span className='msi-exclamation-triangle' aria-hidden='true'/>{addToTemplateError}</div>}
                    <Button
                        className={classnames('msc-add-line-to-template__add-configured-product-button', { 'is-busy': this.state.isBusy })}
                        aria-label={addItemToTemplateText}
                        onClick={this._addToTemplateHandler}
                        disabled={buttonDisabled}
                    >
                        {addItemToTemplateText}
                    </Button>
            </>
        );
    }

    private _getDimensionsNodes(): React.ReactElement[] {
        const { dimensions } = this.state;
        const { resources } = this.props;

        return dimensions?.map((dimension: ProductDimensionFull) => {
            const { DimensionValues, DimensionTypeValue } = dimension;
            const mapDimensions = (value: ProductDimensionValue): IDropdownItemProps => ({
                id: value.RecordId,
                value: value.Value || ''
            });
            const dropdownList: IDropdownItemProps[] = DimensionValues ? DimensionValues.map<IDropdownItemProps>(mapDimensions) : [];

            return (
                <div key={DimensionTypeValue}>
                    <div>{this._getDropdownName(DimensionTypeValue, resources)}</div>
                    <Dropdown
                        dropdownId={DimensionTypeValue}
                        dropdownName={this._getDropdownName(DimensionTypeValue, resources)}
                        dropdownList={dropdownList}
                        onChange={this._onDimensionChanged}
                    />
                </div>
            );
        });
    }

    private _addToTemplateHandler = async (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
        // hide confirmation when adding multiple items
        this.setState({
            isBusy: true,
            showAddConfirmation: false,
            showAddError: false
        });

        this.props.addToTemplateHandler({...this.state})
            .then(status => {
                // validate against the existance of a ProductListId
                if (status.ProductListId) {
                    this.setState({
                        isBusy: false,
                        showAddConfirmation: true
                    });
                }
            }).catch(error => {
                this.setState({
                    isBusy: false,
                    showAddError: true
                });
                this.props.context.telemetry.error('Error adding item to order template');
            });
    };

    private _onQuantityChange = (newValue: number) => {
        this.setState({
            quantity: newValue,
            totalPrice: newValue * this.props.product.Price
        });
    }

    // rehydrate the selected variants price, available dimensions & sizes
    private _onDimensionChanged = async (selection: IDropdownOnSelection): Promise<void> => {
        this.setState({
            isBusy: false,
            showAddConfirmation: false,
            showAddError: false,
            buttonDisabled: true
        });

        const { product, dimensions, context } = this.props;
        const {
            actionContext,
            request: { apiSettings: { channelId } }
        } = context;

        const mappedDimensions = dimensions?.map(dimension => {
            return {
                DimensionTypeValue: dimension.DimensionTypeValue,
                DimensionValue: dimension.DimensionValues?.find(value => value.RecordId === +selection.selectId),
                ExtensionProperties: dimension.ExtensionProperties
            };
        }).filter(dimension => {
            return dimension && dimension.DimensionValue;
        });

        mappedDimensions.forEach(dimension => {
            this.state.selectedDimensions[dimension.DimensionTypeValue] = dimension.DimensionValue;
        });

        const variantProduct = (await getSelectedVariant(
            new SelectedVariantInput(
                product.MasterProductId ? product.MasterProductId : product.RecordId,
                channelId,
                mappedDimensions
            ),
            actionContext
        ));

        if (!variantProduct) {
            this.props.context.telemetry.error(`Error retrieving variant product for product ${product.MasterProductId ? product.MasterProductId : product.RecordId}`);
            return;
        }

        const dimensionInput = new GetDimensionsForSelectedVariantInput(
            variantProduct.RecordId,
            channelId,
            mappedDimensions
        );
        const variantDimensions = await getDimensionsForSelectedVariant(dimensionInput, actionContext);

        if (!variantDimensions) {
            this.props.context.telemetry.error('Error retrieving dimensions for reconfigured product variant');
            this.setState({
                buttonDisabled: false
            });
            return;
        }

        const availabilityInput = new ProductAvailabilitiesForSelectedVariantInput(
            product.MasterProductId ? product.MasterProductId : product.RecordId,
            channelId
        );
        // @TODO sync UX quantity w/ actual availibility
        const newAvailableQuantity = await getProductAvailabilitiesForSelectedVariant(availabilityInput, actionContext);
        const priceInput = new PriceForSelectedVariantInput(product.RecordId, channelId);
        const productPrice = await getPriceForSelectedVariant(priceInput, actionContext);

        if (!productPrice) {
            this.props.context.telemetry.error('Error retrieving price for reconfigured product variant');
            this.setState({
                buttonDisabled: false
            });
            return;
        }

        this.setState({
            buttonDisabled: false,
            productAvailableQuantity: newAvailableQuantity && newAvailableQuantity[0] || undefined,
            unitPrice: +(productPrice.BasePrice || product.Price),
            dimensions: variantDimensions,
            product: variantProduct
        });
    }

    private _getDropdownName = (dimensionType: number, resources: IAddLineToTemplateResources): string => {
        switch (dimensionType) {
            case 1: // Color
                return resources.productDimensionTypeColor;
            case 2: // Configuration
                return resources.productDimensionTypeConfiguration;
            case 3: // Size
                return resources.productDimensionTypeSize;
            case 4: // Style
                return resources.productDimensionTypeStyle;
            default:
                return '';
        }
    };

    private _formatPrice(price: number): string {
        const {
            context: {
                cultureFormatter: {
                    formatCurrency,
                    // @ts-ignore
                    currencyCode
                }
            }
        } = this.props;

        return formatCurrency(price.toFixed(2), currencyCode);
    }
}
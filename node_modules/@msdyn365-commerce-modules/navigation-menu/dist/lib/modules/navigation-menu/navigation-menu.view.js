import { generateImageUrl } from '@msdyn365-commerce-modules/retail-actions';
import { getPayloadObject, getTelemetryAttributes, getTelemetryObject, Module, Node, onTelemetryClick } from '@msdyn365-commerce-modules/utilities';
import { Image } from '@msdyn365-commerce/core';
import classnames from 'classnames';
import * as React from 'react';
export class NavigationMenuView extends React.PureComponent {
    constructor(props) {
        super(props);
        this.supportedLevel = 3;
        this.currentLevel = 0;
        this._updateCategoryImage = (categoryImage) => () => {
            this.setState({
                categoryImage: categoryImage !== '' ? categoryImage : 'empty'
            });
        };
        this._handleDropdownToggle = (data, parentId) => () => {
            if (!this.props.isMobileView) {
                this.setState({
                    activeMenu: (this.state.activeMenu && this.state.activeMenu === data.id) ? undefined : data.id,
                    parentMenu: parentId
                });
                if (this.props.showCategoryImage) {
                    this._updateCategoryImage(data.imageSource)();
                }
            }
            else {
                NavigationMenuView.isBackTrack = false;
                this.setState({
                    activeMenu: data.id,
                    mobileViewLabelText: data.linkText,
                    parentMenu: parentId
                });
            }
            this._resetFocus();
        };
        this._handleGoBack = () => () => {
            NavigationMenuView.isBackTrack = true;
            this.setState({ activeMenu: this.state.parentMenu });
            this._resetFocus();
        };
        this._resetFocus = () => {
            if (this.props.isMobileView) {
                setTimeout(() => {
                    this.menuNode && this.menuNode.current && this.menuNode.current.focus();
                }, 0);
            }
        };
        this._handleClickOutside = (event) => {
            if (this.menuNode.current && !this.menuNode.current.contains(event.target)) {
                this.setState({ activeMenu: undefined, mobileViewLabelText: '' });
            }
        };
        this._getCategoryImage = (categoryImage) => {
            const categoryImageUrl = generateImageUrl(`${categoryImage}`, this.props.context.actionContext.requestContext.apiSettings);
            const defaultImageSettings = {
                viewports: {
                    xs: { q: 'w=300&h=250&m=8', w: 0, h: 0 },
                    sm: { q: 'w=300&h=250&m=8', w: 0, h: 0 },
                    md: { q: 'w=300&h=250&m=8', w: 0, h: 0 },
                    lg: { q: 'w=300&h=250&m=8', w: 0, h: 0 }
                },
                lazyload: true
            };
            if (categoryImageUrl !== undefined) {
                const ImageData = { src: categoryImageUrl };
                return (React.createElement(Image, Object.assign({ className: 'ms-nav-image__item' }, ImageData, { gridSettings: this.props.context.request.gridSettings, imageSettings: this.props.config.categoryImageSettings || defaultImageSettings, loadFailureBehavior: 'hide', role: 'tabpanel', id: `${categoryImage}__categoryImage` })));
            }
            return null;
        };
        this.menuNode = React.createRef();
        this.state = { activeMenu: undefined, mobileViewLabelText: '', parentMenu: undefined };
        this._closeSubmenu = this._closeSubmenu.bind(this);
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
        this.payLoad = getPayloadObject('click', this.telemetryContent, '', '');
    }
    componentDidMount() {
        document.body && document.body.addEventListener('mousedown', this._handleClickOutside);
    }
    componentWillUnmount() {
        document.body && document.body.removeEventListener('mousedown', this._handleClickOutside, false);
    }
    render() {
        const { isMobileView, MenuList, MobileBackButton, MobileDescriptionContainer, MobileDescriptionLabel, Navigation } = this.props;
        this.currentLevel = 1;
        return (React.createElement(Module, Object.assign({}, Navigation, { className: classnames(Navigation.className, isMobileView && this.state.activeMenu !== undefined ? 'child' : 'parent') }),
            React.createElement(Node, Object.assign({}, MenuList, { ref: this.menuNode, tabIndex: '-1' }),
                isMobileView && this.state.activeMenu !== undefined &&
                    React.createElement(Node, Object.assign({}, MobileDescriptionContainer),
                        React.createElement(Node, Object.assign({}, MobileBackButton, { onClick: this._handleGoBack() })),
                        React.createElement(Node, Object.assign({}, MobileDescriptionLabel), this.state.mobileViewLabelText)),
                this._renderDisplay())));
    }
    _renderDisplay() {
        const { ListItem, menuItemData, isMobileView } = this.props;
        const { activeMenu } = this.state;
        const menuItemList = [];
        if (isMobileView && activeMenu !== undefined && menuItemData.length > 0) {
            let menuItem = {};
            for (let i = 0; i < menuItemData.length; i++) {
                if (menuItemData[i] && menuItemData[i].id === activeMenu) {
                    menuItem = menuItemData[i];
                    !NavigationMenuView.isBackTrack ? this.setState({ parentMenu: undefined }) : this.setState({ parentMenu: undefined, mobileViewLabelText: menuItemData[i].linkText });
                    break;
                }
                menuItem = this._getFromSubMenu(menuItemData[i]);
                if (menuItem && menuItem.id === activeMenu) {
                    break;
                }
            }
            menuItem && menuItemList.push(React.createElement(Node, Object.assign({ key: menuItem.id }, ListItem),
                " ",
                this._createMenuItemList(menuItem),
                " "));
        }
        else {
            menuItemData.forEach((item, index) => {
                menuItemList.push(React.createElement(Node, Object.assign({ key: index }, ListItem), this._createMenuItemList(item)));
            });
        }
        return menuItemList;
    }
    _getFromSubMenu(item) {
        const subMenus = item && item.subMenu;
        if (subMenus && subMenus.length > 0) {
            for (let i = 0; i <= subMenus.length - 1; i++) {
                if (subMenus[i].id === this.state.activeMenu) {
                    !NavigationMenuView.isBackTrack ? this.setState({ parentMenu: item && item.id }) : this.setState({ parentMenu: item && item.id, mobileViewLabelText: subMenus[i].linkText });
                    return subMenus[i];
                }
                const found = this._getFromSubMenu(subMenus[i]);
                if (found) {
                    return found;
                }
            }
        }
        this.props.context.telemetry.error('Submenu content is empty, module wont render.');
        return null;
    }
    _createMenuItemList(menuItemData) {
        if (menuItemData && menuItemData.subMenu && menuItemData.subMenu.length > 0) {
            if (this.props.isMobileView && this.state.activeMenu !== undefined) {
                return (this._renderSubMenu(menuItemData.subMenu, menuItemData.id));
            }
            else {
                return (React.createElement(React.Fragment, null,
                    this._renderButtonMenuItem(menuItemData),
                    this._renderSubMenu(menuItemData.subMenu, menuItemData.id)));
            }
        }
        else if (menuItemData && menuItemData.linkText && menuItemData.linkURL && menuItemData.linkURL.length > 0) {
            return (this._renderLinkMenuItem(menuItemData));
        }
        else if (menuItemData && menuItemData.linkText && !menuItemData.linkURL) {
            return (this._renderSpanMenuItem(menuItemData));
        }
        this.props.context.telemetry.error('Navigation menu content is empty, module wont render.');
        return null;
    }
    _renderSubMenu(subMenus, activeMenu) {
        const { isMobileView, ListItem } = this.props;
        if (activeMenu && this.state.activeMenu !== activeMenu) {
            this.props.context.telemetry.error('Navigation Active menu content is empty, module wont render.');
            return null;
        }
        if (!subMenus || subMenus.length === 0) {
            this.props.context.telemetry.error('Navigation Submenu content is empty, module wont render.');
            return null;
        }
        let levelClassName = '';
        const menuOptions = subMenus && subMenus.map((option, idx) => {
            const hasOptions = (option.subMenu && option.subMenu.length > 0);
            let menuItem;
            if (hasOptions && isMobileView) {
                menuItem = this._renderButtonMenuItem(option, activeMenu, idx);
            }
            else {
                menuItem = (option.linkURL
                    ? this._renderLinkMenuItem(option, idx)
                    : this._renderSpanMenuItem(option));
            }
            let subMenu;
            if (hasOptions) {
                this.currentLevel++;
                if (this.currentLevel <= this.supportedLevel - 1) {
                    levelClassName = `level-${this.currentLevel.toString()}`;
                    subMenu = this._renderSubMenu(option.subMenu, isMobileView ? option.id : undefined);
                }
            }
            return (React.createElement(Node, Object.assign({}, ListItem, { key: option.id }),
                menuItem,
                subMenu));
        });
        return (this._renderMenu(levelClassName, menuOptions, activeMenu));
    }
    _renderButtonMenuItem(option, activeMenu, index) {
        const { Button } = this.props;
        return (React.createElement(Node, Object.assign({ key: index }, Button, { onClick: this._handleDropdownToggle(option, activeMenu), onFocus: this._closeSubmenu, "aria-haspopup": true, "aria-expanded": this.state.activeMenu && this.state.activeMenu === option.id ? true : false, "data-parent": activeMenu }), option.linkText));
    }
    _renderLinkMenuItem(option, index) {
        const { Link } = this.props;
        const linkText = option.linkText ? option.linkText : '';
        const imagesource = option.imageSource ? option.imageSource : '';
        this.payLoad.contentAction.etext = linkText;
        const attributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        return (React.createElement(Node, Object.assign({}, Link, { key: index, onMouseOver: this._updateCategoryImage(imagesource), href: option.linkURL }, attributes, { onClick: onTelemetryClick(this.telemetryContent, this.payLoad, linkText) }), option.linkText));
    }
    _renderSpanMenuItem(option, index) {
        const { Span } = this.props;
        return (React.createElement(Node, Object.assign({ key: index }, Span), option.linkText));
    }
    _renderMenu(level, menuOptions, currentItem) {
        const { DivContainer, MenuList, ImageDivContainer, showCategoryImage } = this.props;
        this.currentLevel = 1;
        if (showCategoryImage) {
            return (React.createElement(Node, Object.assign({}, DivContainer, { className: DivContainer.className }),
                React.createElement(Node, Object.assign({}, MenuList, { className: classnames(MenuList.className, level) }), menuOptions),
                React.createElement(Node, Object.assign({}, ImageDivContainer, { className: ImageDivContainer.className }), this.state.categoryImage !== undefined && this.state.categoryImage !== null && this._getCategoryImage(this.state.categoryImage))));
        }
        return (React.createElement(Node, Object.assign({}, MenuList, { className: classnames(MenuList.className, level) }), menuOptions));
    }
    _closeSubmenu() {
        if (!this.props.isMobileView) {
            this.setState({ activeMenu: undefined, mobileViewLabelText: '' });
        }
    }
}
NavigationMenuView.isBackTrack = false;
export default NavigationMenuView;
//# sourceMappingURL=navigation-menu.view.js.map
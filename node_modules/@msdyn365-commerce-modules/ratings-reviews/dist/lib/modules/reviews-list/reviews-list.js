import { __decorate } from "tslib";
import { getRnrAuthEndpointId, getRnrEndpointId, getRnrPartnerId, getSelectedProductIdFromActionInput } from '@msdyn365-commerce-modules/retail-actions';
import { format, getTelemetryObject, LabeledDropdown } from '@msdyn365-commerce-modules/utilities';
import { RatingComponent } from '@msdyn365-commerce/components';
import * as Msdyn365 from '@msdyn365-commerce/core';
import classname from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { getReviewsForGivenProduct } from '../../actions/get-product-reviews';
import { GetProductReviewsInput } from '../../actions/inputs/get-product-reviews-input';
import { ReportReviewConcernInput } from '../../actions/inputs/report-review-concern-input';
import { SubmitHelpfulnessVoteInput } from '../../actions/inputs/submit-helpfulness-vote-input';
import reportReviewConcern from '../../actions/report-review-concern';
import submitHelpfulnessVote from '../../actions/submit-helpfulness-vote';
import { ReviewModal, submitReview } from '../../common/review-modal';
import { PageControls, ReviewCount } from './components/components';
import { ReportReviewModal } from './components/report-review-modal';
import { ReviewCard } from './components/review-card';
let ReviewsList = class ReviewsList extends React.Component {
    constructor(props) {
        super(props);
        this.sortByDropdownOptions = [
            { key: 'MostHelpful', value: this.props.resources.mostHelpfulSortOptionText },
            { key: 'MostRecent', value: this.props.resources.mostRecentSortOptionText },
            { key: 'HighestRating', value: this.props.resources.highestRatedSortOptionText },
            { key: 'LowestRating', value: this.props.resources.lowestRatedSortOptionText }
        ];
        this.filterByDropdownOptions = [
            { key: '1;2;3;4;5', value: this.props.resources.allRatinsFilterByOptionText },
            { key: '5', value: this.props.resources.fiveStarFilterByOptionText },
            { key: '4', value: this.props.resources.fourStarFilterByOptionText },
            { key: '3', value: this.props.resources.threeStarFilterByOptionText },
            { key: '2', value: this.props.resources.twoStarFilterByOptionText },
            { key: '1', value: this.props.resources.oneStarFilterByOptionText }
        ];
        this.handleHeadingChange = (event) => this.props.config.heading.text = event.target.value;
        this._userReview = () => {
            const userReview = this.props.data.userReview.result;
            return userReview && this._reviewCard(userReview, true);
        };
        this._reviewCards = (reviewList) => {
            const userReview = this.props.data.userReview.result;
            const reviewElements = [];
            for (const review of reviewList) {
                if (!review.isTakenDown && review.isPublished && userReview ? review.reviewId !== userReview.reviewId : true) {
                    reviewElements.push(this._reviewCard(review, false));
                }
            }
            return reviewElements;
        };
        this._reviewCard = (review, userReview) => {
            return ReviewCard({
                review: review,
                resources: { ...this.props.resources },
                context: this.props.context,
                isUserReview: userReview,
                parentId: this.props.id,
                parentType: this.props.typeName,
                reportedReviews: this.state.reportedReviews,
                returnRef: this._userReportModalToggle,
                reportedReviewId: this.state.reportingReviewId,
                toggleWriteReviewModal: this._toggleReviewModal,
                toggleReportReviewModal: this._onReportModalOpen,
                updateReviewHelpfulness: this.updateReviewHelpfulnessVote,
                votedReviews: this.state.votedReviews
            });
        };
        this._userReviewModal = () => {
            return ReviewModal({
                userReview: this.props.data.userReview.result,
                product: this.props.data.product.result,
                resources: { ...this.props.resources },
                context: this.props.context,
                parentId: this.props.id,
                parentType: this.props.typeName,
                isOpen: this.state.isReviewModalOpen,
                rating: this.state.userReviewRating,
                reviewTitle: this.state.userReviewTitle,
                reviewText: this.state.userReviewText,
                onModalToggle: this._toggleReviewModal,
                onTitleChange: this._onTitleChange,
                onTextChange: this._onTextChange,
                onRatingChange: this._onRatingChange,
                onReviewComplete: this._onReviewComplete,
                renderContextId: 'writeReview-list',
                returnRef: this._userReviewModalToggle,
                hasError: this.state.hasReviewError
            });
        };
        this._onTitleChange = (event) => {
            this.reviewsListCallbacks.updateReviewTitle(event.target.value);
        };
        this._onTextChange = (event) => {
            this.reviewsListCallbacks.updateReviewText(event.target.value);
        };
        this._onRatingChange = (value) => {
            this.reviewsListCallbacks.updateRating(value);
        };
        this._toggleReviewModal = () => {
            const userReview = this.props.data.userReview.result;
            if (this.state.isReviewModalOpen) {
                this.setState({ isReviewModalOpen: false, hasReviewError: false });
            }
            else {
                this.setState({
                    isReviewModalOpen: true,
                    userReviewText: userReview.reviewText,
                    userReviewTitle: userReview.title,
                    userReviewRating: userReview.rating
                });
            }
        };
        this._onReviewComplete = (isSuccess) => {
            if (isSuccess) {
                this.setState({ isReviewModalOpen: false, hasReviewError: false });
            }
            else {
                this.setState({ hasReviewError: true });
            }
        };
        this._reportReviewModal = () => {
            return ReportReviewModal({
                resources: { ...this.props.resources },
                context: this.props.context,
                isOpen: this.state.isReportModalOpen,
                returnRef: this._userReportModalToggle,
                reportedKey: this.state.reportedKey,
                onModalToggle: this._onReportModalClose,
                onRadioChange: this._onRadioChange,
                reportReview: this._reportReview,
                hasError: this.state.hasReportError,
                telemetryContent: this.telemetryContent
            });
        };
        this._onReportModalOpen = (reviewId) => {
            this.setState({ isReportModalOpen: true, reportingReviewId: reviewId, reported: false, reportedKey: "8" });
        };
        this._onReportModalClose = () => {
            this.setState({ isReportModalOpen: false, hasReportError: false });
        };
        this._onRadioChange = (event) => {
            this.setState({ reportedKey: event.currentTarget.getAttribute('data-key') || '' });
        };
        this._reportReviewCallback = (reviewId, reportedKey) => {
            reportReviewConcern(new ReportReviewConcernInput(reviewId, getRnrPartnerId(this.props.context.actionContext), this.props.context.request.locale, reportedKey, this.getUserToken(this.props.context.request), getRnrAuthEndpointId(this.props.context.actionContext)), this.props.context.actionContext).then(_value => {
                const reportedReview = this.state.reportedReviews;
                reportedReview.push(reviewId);
                this.setState({ reported: true, reportedReviews: reportedReview, hasReportError: false });
            }).catch(_value => {
                this.setState({ hasReportError: true });
            });
        };
        this._reportReview = () => {
            this._reportReviewCallback(this.state.reportingReviewId, this.state.reportedKey);
        };
        this.updateSortByDropdown = async (notification) => {
            await this.updateReviews(0, notification.selectedOption, this.state.selectedFilterByOption, 1, this.state.isFilterApplied);
        };
        this.updateFilterByDropdown = async (notification) => {
            await this.updateReviews(0, this.state.selectedSortByOption, notification.selectedOption, 1, true);
        };
        this.updateReviews = async (skipItems, selectedSortByOption, selectedFilterByOption, currentPage, isFilterApplied) => {
            const productId = getSelectedProductIdFromActionInput(this.props.context.actionContext);
            if (productId === undefined) {
                return;
            }
            const result = await getReviewsForGivenProduct(new GetProductReviewsInput(productId, getRnrPartnerId(this.props.context.actionContext), this.props.context.request.locale, getRnrEndpointId(this.props.context.actionContext), selectedSortByOption.key, selectedFilterByOption.key, skipItems < 0 ? 0 : skipItems), this.props.context.actionContext);
            if (result && result.items && result.pagingInfo && result.pagingInfo.totalItems !== undefined) {
                this.setState({
                    currentPage: currentPage,
                    listOfReviews: result.items,
                    selectedSortByOption,
                    selectedFilterByOption,
                    reviewsCount: result.pagingInfo.totalItems,
                    isFilterApplied: isFilterApplied
                });
            }
        };
        this._updateVoteUi = (reviewId, isHelpful) => {
            let alreadyExists = false;
            let list = this.state.votedReviews.map((review) => {
                if (review.reviewId === reviewId) {
                    review.approved = isHelpful;
                    alreadyExists = true;
                }
                return review;
            });
            if (!alreadyExists) {
                list = list.concat({ reviewId: reviewId, approved: isHelpful });
            }
            this.setState({ votedReviews: list });
        };
        this.updateReviewHelpfulnessVote = (reviewId, isHelpful) => {
            submitHelpfulnessVote(new SubmitHelpfulnessVoteInput(reviewId, getRnrPartnerId(this.props.context.actionContext), this.props.context.request.locale, isHelpful, this.getUserToken(this.props.context.request), getRnrAuthEndpointId(this.props.context.actionContext)), this.props.context.actionContext).then(() => {
                this._updateVoteUi(reviewId, isHelpful);
            });
        };
        this.getUserToken = (context) => {
            return context && context.user && context.user.token;
        };
        this.reviewsListCallbacks = {
            updateReviewTitle: (title) => {
                this.setState({ userReviewTitle: title });
            },
            updateReviewText: (text) => {
                this.setState({ userReviewText: text });
            },
            updateRating: (rating) => {
                this.setState({ userReviewRating: rating });
            },
            onReviewSubmitted: (isSuccessful) => {
                if (isSuccessful) {
                    this.setState({ isReviewModalOpen: false, hasReviewError: false });
                }
                else {
                    this.setState({ hasReviewError: true });
                }
            },
            submitReview: submitReview,
            toggleModal: this._toggleReviewModal,
            updateReviewHelpfulnessVote: this.updateReviewHelpfulnessVote,
            toggleReportModal: (reviewId) => {
                this.state.isReportModalOpen ? this._onReportModalOpen(reviewId) : this._onReportModalClose();
            },
            reportReview: this._reportReviewCallback,
            updateFilterByDropdown: this.updateFilterByDropdown,
            updateSortByDropdown: this.updateSortByDropdown,
            updateReviews: this.updateReviews
        };
        const { userReview: { result: userReview } } = this.props.data;
        this.state = {
            skipItems: 0,
            reviewsCount: 0,
            listOfReviews: [],
            currentPage: 1,
            showSpinner: false,
            isFilterApplied: false,
            selectedSortByOption: this.sortByDropdownOptions[0],
            selectedFilterByOption: this.filterByDropdownOptions[0],
            userReviewRating: userReview ? userReview.rating : 0,
            userReviewText: userReview ? userReview.reviewText : '',
            userReviewTitle: userReview ? userReview.title : '',
            isReviewModalOpen: false,
            hasReviewError: false,
            isReportModalOpen: false,
            hasReportError: false,
            reported: false,
            reportedKey: "8",
            reportingReviewId: '',
            reportedReviews: [],
            votedReviews: []
        };
        this._userReviewModalToggle = React.createRef();
        this._userReportModalToggle = React.createRef();
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    componentDidMount() {
        this.props.data.reviewsList.then((reviewsList) => {
            if (reviewsList &&
                reviewsList.pagingInfo &&
                reviewsList.pagingInfo.totalItems &&
                reviewsList.items &&
                reviewsList.items.length > 0) {
                this.setState({
                    listOfReviews: reviewsList.items,
                    reviewsCount: reviewsList.pagingInfo.totalItems,
                });
            }
        });
        reaction(() => this.props.data.ratingsReviewsState.result && this.props.data.ratingsReviewsState.result.filterKey, async (filterKey) => {
            const filterKeyValue = Number(filterKey);
            const dropdownItemsCount = this.filterByDropdownOptions.length;
            if (!!filterKey &&
                !isNaN(filterKeyValue) &&
                filterKeyValue < dropdownItemsCount) {
                const filterByOption = this.filterByDropdownOptions.find((option) => option.key === filterKey);
                if (!filterByOption) {
                    this.props.telemetry.warning(`[reviews-list] cannot find filter with key ${filterKey}`);
                }
                else {
                    await this.updateReviews(0, this.state.selectedSortByOption, filterByOption, 1, true);
                    const selectedIndex = dropdownItemsCount - filterKeyValue;
                    this.setState({
                        selectedFilterByOption: this.filterByDropdownOptions[selectedIndex]
                    });
                }
            }
        });
    }
    render() {
        const { className, heading, reviewsShownOnEachPage } = this.props.config;
        const { currentPage, reviewsCount, selectedFilterByOption, selectedSortByOption } = this.state;
        const { ratingsSummary: { result: ratingsSummary } } = this.props.data;
        const resources = this.props.resources;
        const completeClass = classname('ms-reviews-list', className);
        const viewProps = {
            ...this.props,
            state: this.state,
            className: completeClass,
            moduleProps: {
                moduleProps: this.props,
                className: completeClass
            },
            callbacks: this.reviewsListCallbacks,
            reviewModal: this._userReviewModal(),
            reportReviewModal: this._reportReviewModal(),
            filterByDropdown: (React.createElement(LabeledDropdown, { labelText: resources.filterByDropdownText, dropdownId: 'reviewsListFilterBy', dropdownOptions: this.filterByDropdownOptions, selectedOption: selectedFilterByOption, onSelectOption: this.updateFilterByDropdown, controlledByParent: true })),
            sortByDropdown: React.createElement(LabeledDropdown, { labelText: resources.sortByDropdownText, dropdownId: 'reviewsListSortBy', dropdownOptions: this.sortByDropdownOptions, selectedOption: selectedSortByOption, onSelectOption: this.updateSortByDropdown }),
            averageRating: ratingsSummary && (React.createElement(RatingComponent, { avgRating: ratingsSummary.averageRating || 0, readOnly: true, ariaLabel: format(resources.averageRatingAriaLabel, ratingsSummary.averageRating, '5'), ratingCount: `${ratingsSummary.reviewsCount}`, data: {}, context: this.props.context, id: this.props.id, typeName: this.props.typeName })),
            reviewCount: React.createElement(ReviewCount, { resources: { ...this.props.resources }, currentPage: currentPage, reviewsCount: reviewsCount, reviewsShownOnEachPage: reviewsShownOnEachPage }),
            refineReviewsProps: { className: 'ms-reviews-list__refiners' },
            reviewsListProps: { className: 'ms-reviews-list__reviews' },
            reviewCards: this._reviewCards(this.state.listOfReviews),
            userReview: this._userReview(),
            pageControls: (React.createElement(PageControls, { resources: { ...this.props.resources }, currentPage: currentPage, reviewsShownOnEachPage: reviewsShownOnEachPage, selectedSortByOption: selectedSortByOption, selectedFilterByOption: selectedFilterByOption, updateReviews: this.updateReviews, reviewsCount: reviewsCount, telemetryContent: this.telemetryContent })),
            noReviewsMessage: React.createElement("span", { className: 'ms-reviews-list__empty-message', "aria-live": 'polite' }, resources.noReviewsMessage),
            noReviewsWithFilterMessage: React.createElement("span", { className: 'ms-reviews-list__filter-message', "aria-live": 'polite' }, resources.noReviewsWithSelectedFilterMessage),
            heading: heading && (React.createElement(Msdyn365.Text, { className: 'ms-reviews-list__heading', tag: heading.tag || 'h2', text: heading.text, editProps: { onEdit: this.handleHeadingChange, requestContext: this.props.context.request } })),
            sortByOptions: this.sortByDropdownOptions,
            filterByOptions: this.filterByDropdownOptions
        };
        return this.props.renderView(viewProps);
    }
};
ReviewsList = __decorate([
    observer
], ReviewsList);
export default ReviewsList;
//# sourceMappingURL=reviews-list.js.map
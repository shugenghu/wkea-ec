import { createObservableDataAction } from '@msdyn365-commerce/core';
import { getActivePricesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import { getSelectedProductIdFromActionInput, getSelectedVariant, SelectedVariantInput, getCustomer } from './index';
import * as semver from 'semver';
import { GetCustomerInput } from './get-customer';
/**
 * Input class for the GetPriceForSelectedVariant Data Action
 */
export class PriceForSelectedVariantInput {
    constructor(productId, channelId, selectedProduct, customerId) {
        this.getCacheKey = () => `PriceForSelectedVariant`;
        this.getCacheObjectType = () => 'Price';
        this.dataCacheType = () => 'none';
        this.productId = productId;
        this.channelId = channelId;
        this.selectedProduct = selectedProduct;
        this.customerId = customerId || '';
    }
}
/**
 * The createInput method for the GetPriceForSelectedVariantDataAction
 * @param inputData The input data for the createInput method
 */
export const createActivePriceForSelectedVariantInput = (inputData) => {
    const productId = getSelectedProductIdFromActionInput(inputData);
    if (productId) {
        return new PriceForSelectedVariantInput(+productId, +inputData.requestContext.apiSettings.channelId, undefined);
    }
    else {
        throw new Error('Unable to create PriceForSelectedVariantInput, no productId found on module config or query');
    }
};
/**
 * The Action Method for the GetPriceForSelectedVariant Data Action
 * Pulls the currently selected variant from the cache using the getSelectedVariant data action, and gets it's current contextual price
 * via the getActivePrice RetailServer API
 */
export async function getPriceForSelectedVariantAction(input, ctx) {
    let affliations = [];
    if (ctx.requestContext && ctx.requestContext.user && ctx.requestContext.user.isAuthenticated) {
        const customerInput = new GetCustomerInput(ctx.requestContext.apiSettings);
        const customer = await getCustomer(customerInput, ctx);
        if (customer && customer.CustomerAffiliations) {
            customer.CustomerAffiliations.forEach((affliation) => {
                var aff = { AffiliationId: affliation.RetailAffiliationId, CustomerId: customer.AccountNumber };
                affliations.push(aff);
            });
        }
    }
    return Promise.resolve()
        // @ts-ignore: Promise vs. ObservablePromise typing conflict
        .then(() => {
        const activeProduct = input.selectedProduct;
        if (!activeProduct) {
            const selectedVariantInput = new SelectedVariantInput(input.productId, input.channelId);
            return getSelectedVariant(selectedVariantInput, ctx);
        }
        return activeProduct;
    })
        .then((productResult) => {
        const projectDomain = { ChannelId: +ctx.requestContext.apiSettings.channelId, CatalogId: +ctx.requestContext.apiSettings.catalogId };
        const activeProduct = productResult;
        if (activeProduct) {
            return getActivePricesAsync({ callerContext: ctx, queryResultSettings: {} }, projectDomain, [activeProduct.RecordId], new Date(), input.customerId || null, affliations, true
            // @ts-ignore
            ).then(response => {
                if (response && response.length > 0) {
                    const productPrice = response[0];
                    // If RS Verison < 9.16.0 (aka 10.0.6), customer contextual price won't be
                    // included so instead just use AdjustedPrice
                    if (semver.lt(ctx.requestContext.apiSettings.retailServerProxyVersion, '9.16.0')) {
                        productPrice.CustomerContextualPrice = productPrice.AdjustedPrice;
                    }
                    return productPrice;
                }
                throw new Error('[getPriceForSelectedVariantAction]Invalid response recieved from calculateProductPrice');
            });
        }
        return null;
    })
        .catch((error) => {
        ctx.trace(error.message);
        ctx.telemetry.exception(error);
        ctx.telemetry.debug(`[getPriceForSelectedVariantAction]Error executing action`);
        throw new Error('[getPriceForSelectedVariantAction]Error executing action');
    });
}
export default createObservableDataAction({
    id: '@msdyn365-commerce-modules/retail-actions/get-price-for-selected-variant',
    action: getPriceForSelectedVariantAction,
    input: createActivePriceForSelectedVariantInput
});
//# sourceMappingURL=get-price-for-selected-variant.js.map
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createObservableDataAction, sendCommerceRequest } from '@msdyn365-commerce/core';
import getFullProducts, { FullProductInput } from './get-full-products';
import { buildCacheKey, getProductDetailsCriteriaFromActionInput } from './utilities/utils';
/**
 * GetRecommendations Input Action
 */
export class GetRecommendationsInput {
    constructor(customerAccountNumber, productIds, categoryIds, recommendationType, skipItems, maxItems, criteria, apiSettings) {
        this.getCacheKey = () => buildCacheKey(this.constructedCacheKey, this.apiSettings);
        this.getCacheObjectType = () => `GetRecommendations`;
        this.dataCacheType = () => 'request';
        this.constructedCacheKey = ``;
        if (Array.isArray(productIds) && productIds.length) {
            this.constructedCacheKey += `${productIds.toString()}|`;
        }
        else {
            this.constructedCacheKey += 'ProductIdsUnspecified|';
            productIds = [];
        }
        if (Array.isArray(categoryIds) && categoryIds.length) {
            this.constructedCacheKey += `${categoryIds.toString()}|`;
        }
        else {
            this.constructedCacheKey += 'categoryIdsUnspecified|';
            categoryIds = [];
        }
        if (recommendationType) {
            this.constructedCacheKey += `${recommendationType.toString()}|`;
        }
        else {
            throw new Error('Recommendation type is required input.');
        }
        if (customerAccountNumber) {
            this.constructedCacheKey += `${customerAccountNumber.toString()}|`;
        }
        else {
            this.constructedCacheKey += 'customerAccountNumberUnspecified|';
            customerAccountNumber = '';
        }
        this.constructedCacheKey += `skip-${skipItems || 0}|`;
        this.constructedCacheKey += `top-${maxItems || 100}`;
        this.apiSettings = apiSettings;
        this.channelId = apiSettings.channelId;
        this.customerAccountNumber = customerAccountNumber;
        this.productIds = productIds;
        this.catalogId = apiSettings.catalogId;
        this.categoryIds = categoryIds;
        this.recommendationType = recommendationType;
        this.maxItems = maxItems;
        this.skipItems = skipItems;
        this.ProductDetailsCriteria = criteria;
    }
}
/**
 * Creates the input required to make the retail api call to get recommendations
 */
export const createInput = (inputData) => {
    if (inputData && inputData.requestContext && inputData.config) {
        const customerAccountNumber = inputData.config.includeCustomerAccountNumber
            ? inputData.requestContext.user.customerAccountNumber
            : inputData.config.customerAccountNumber;
        const recommendationType = inputData.config.recommendationType;
        const skipItems = inputData.config.skipItems ? Number(inputData.config.skipItems) : 0;
        const maxItems = inputData.config.maxItems ? Number(inputData.config.maxItems) : 50;
        const channelId = Number(inputData.requestContext.apiSettings.channelId);
        const productDetailsCriteria = getProductDetailsCriteriaFromActionInput(inputData);
        if (Number.isNaN(channelId)) {
            throw new Error('Input channel id is not a number.');
        }
        if (!recommendationType) {
            throw new Error('Input recommendation type is invalid.');
        }
        // Get productids from input configuration and product id from query string.
        const productIdsAsString = inputData.config && inputData.config.productIds;
        const productIds = [];
        if (typeof productIdsAsString === 'string') {
            productIdsAsString.split(',').forEach(idString => {
                const id = Number(idString);
                if (Number.isNaN(id)) {
                    throw new Error('Product id in module configuration is not a number.');
                }
                else {
                    productIds.push(id);
                }
            });
        }
        // Get category ids from input
        const categoryIdsAsString = inputData.config && inputData.config.categoryIds;
        const categoryIds = [];
        if (typeof categoryIdsAsString === 'string') {
            categoryIdsAsString.split(',').forEach(idString => {
                const id = Number(idString);
                if (Number.isNaN(id)) {
                    throw new Error('Category id in module configuration is not a number.');
                }
                else {
                    categoryIds.push(id);
                }
            });
        }
        // if desired we can even add productId from query string to input configured product ids
        if (inputData.requestContext.query && inputData.requestContext.query.productId) {
            let productIdFromQueryString;
            productIdFromQueryString = Number(inputData.requestContext.query.productId);
            if (Number.isNaN(productIdFromQueryString)) {
                throw new Error('Product id in querystring is is not a number.');
            }
            else {
                productIds.push(productIdFromQueryString);
            }
        }
        return new GetRecommendationsInput(customerAccountNumber, productIds, categoryIds, recommendationType, skipItems, maxItems, productDetailsCriteria, inputData.requestContext.apiSettings);
    }
    throw new Error('Invalid input data or request context');
};
/**
 * Get recommended elements(products/contents) from RS
 */
export async function getRecommendationsAction(input, ctx) {
    const apiSettings = ctx.requestContext.apiSettings;
    // Start building the call components to get recommended elements from RS
    // {host}/Commerce/Recommendations('NEW')/GetElements?%24skip=0&%24top=1000&api-version=7.3
    const requestUrl = `${apiSettings.baseUrl}Commerce/Recommendations('${input.recommendationType.toUpperCase()}')/GetElements?$skip=${input.skipItems}&$top=${input.maxItems}&api-version=7.3`;
    const requestOptions = {
        headers: { oun: apiSettings.oun },
        timeout: 5000
    };
    // build the recommendation criteria object for request payload
    // NOTE: Update to RecommendationCriteria type once entities package is updated to include Reco types.
    // tslint:disable-next-line:no-any
    const recoCriteria = {};
    if (input.customerAccountNumber && input.customerAccountNumber !== '') {
        // tslint:disable-next-line:prefer-type-cast
        recoCriteria['@odata.type'] = '#Microsoft.Dynamics.Commerce.Runtime.DataModel.RecommendationCriteria';
        recoCriteria.CustomerAccountNumber = input.customerAccountNumber;
    }
    // Exclude catalog 0 from calls
    if (input.catalogId > 0) {
        recoCriteria.CatalogId = input.catalogId;
        // tslint:disable-next-line:prefer-type-cast
        recoCriteria['CatalogId@odata.type'] = '#Int64';
    }
    if (Array.isArray(input.categoryIds) && input.categoryIds.length) {
        recoCriteria.CategoryIds = input.categoryIds;
        // tslint:disable-next-line:prefer-type-cast
        recoCriteria['CategoryIds@odata.type'] = '#Collection(Int64)';
    }
    if (Array.isArray(input.productIds) && input.productIds.length) {
        recoCriteria.ProductIds = input.productIds;
        // tslint:disable-next-line:prefer-type-cast
        recoCriteria['ProductIds@odata.type'] = '#Collection(Int64)';
    }
    const requestBody = {
        recommendationCriteria: recoCriteria
    };
    // Get the recommended elements from RS
    const recommendedElements = await sendCommerceRequest(requestUrl, 'post', requestBody, requestOptions)
        .then((response) => {
        if (Array.isArray(response.data) && response.data.length > 0) {
            return response.data;
        }
        ctx.trace('[getRecommendedElementsAction] No recommended elements found.');
        return [];
    })
        .catch((error) => {
        ctx.telemetry.error(`[getRecommendedElementsAction] Unable to Fetch recommended elements.`);
        ctx.telemetry.exception(error);
        return [];
    });
    // If no results, exit early
    if (recommendedElements.length <= 0) {
        return [];
    }
    // Filter out product elements from recommended elements returned by RS
    const recommendedProductElements = [];
    recommendedElements.forEach((recommendedElement) => {
        // NOTE: Update to RecommendedElementType instead of '1' once entities package is updated to include Reco types.
        if (recommendedElement.ElementTypeValue === 1 && recommendedElement.ElementId) {
            recommendedProductElements.push(new FullProductInput(recommendedElement.ElementId, input.apiSettings, input.ProductDetailsCriteria));
        }
    });
    // Get product details for recommended products
    if (recommendedProductElements.length > 0) {
        return getFullProducts(recommendedProductElements, ctx);
    }
    else {
        ctx.trace(`[getRecommendedElementsAction] Unable to hydrate the recommended elements into simple products.`);
        return [];
    }
}
export default createObservableDataAction({
    id: '@msdyn365-commerce-modules/retail-actions/get-recommendations',
    action: getRecommendationsAction,
    input: createInput
});
//# sourceMappingURL=get-recommendations.js.map
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { createObservableDataAction } from '@msdyn365-commerce/core';
import { getRelatedProductsAsync, getRelationTypesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import getFullProducts, { FullProductInput } from './get-full-products';
import { QueryResultSettingsProxy } from './utilities/QueryResultSettingsProxy';
import { getProductDetailsCriteriaFromActionInput } from './utilities/utils';
/**
 * GetRelatedProducts Input Action
 */
export class GetRelatedProductsInput {
    constructor(productId, catalogId, relationType, queryResultSettingsProxy, criteria) {
        this.getCacheKey = () => `${this.productId}|${this.catalogId}|${this.relationType.toLowerCase()}|${this.queryResultSettingsProxy.cacheKeyHint}|${this.ProductDetailsCriteria.getPrice}`;
        this.getCacheObjectType = () => 'GetRelatedProducts';
        this.dataCacheType = () => 'none';
        this.productId = productId;
        this.catalogId = catalogId;
        this.relationType = relationType;
        this.queryResultSettingsProxy = queryResultSettingsProxy;
        this.ProductDetailsCriteria = criteria;
    }
}
/**
 * Creates the input required to make GetRelatedProducts retail api call
 */
export const createGetRelatedProductsInput = (inputData) => {
    if (inputData && inputData.requestContext && inputData.config) {
        const catalogId = inputData.requestContext.apiSettings.catalogId;
        const relationType = inputData.config.relationType;
        // @ts-ignore: URLTokens not properly types
        let productId = inputData.requestContext.urlTokens ? Number(inputData.requestContext.urlTokens.recordId) : 0;
        const productDetailsCriteria = getProductDetailsCriteriaFromActionInput(inputData);
        if (!relationType) {
            throw new Error('Input relation type is invalid.');
        }
        // Query string may override the product id from url
        if (inputData.requestContext.query && inputData.requestContext.query.productId) {
            productId = Number(inputData.requestContext.query.productId);
        }
        if (Number.isNaN(productId) || productId <= 0) {
            throw new Error('No valid product id available in url or query string.');
        }
        if (Number.isNaN(catalogId)) {
            throw new Error('Failed to cast catalog id into a number.');
        }
        const queryResultSettingsProxy = QueryResultSettingsProxy.fromInputData(inputData);
        return new GetRelatedProductsInput(productId, catalogId, relationType, queryResultSettingsProxy, productDetailsCriteria);
    }
    throw new Error('Invalid input data or request context');
};
export function searchProductRelationType(productRelationTypes, _productRelationType) {
    let foundProductRelationTypeId;
    _productRelationType = _productRelationType.toLowerCase();
    productRelationTypes.forEach((productRelationType) => {
        if (productRelationType.Name && productRelationType.Name.toLowerCase() === _productRelationType) {
            return (foundProductRelationTypeId = productRelationType.RecordId);
        }
    });
    return foundProductRelationTypeId;
}
async function getRelatedProductsAction(input, ctx) {
    const apiSettings = ctx.requestContext.apiSettings;
    const querySettings = input.queryResultSettingsProxy.QueryResultSettings;
    const productRelationTypes = await getRelationTypesAsync({ callerContext: ctx, queryResultSettings: querySettings }, input.productId, +apiSettings.channelId, input.catalogId);
    if (!productRelationTypes) {
        ctx.trace(`[getProductRelationType] Unable to get product relation types for product ${input.productId}`);
        return [];
    }
    const productRelationTypeId = searchProductRelationType(productRelationTypes, input.relationType);
    if (!productRelationTypeId) {
        ctx.trace(`[getRelatedProducts] Unable to find relation type ${input.relationType} for product ${input.productId}`);
        return [];
    }
    const productInputs = await getRelatedProductsAsync({ callerContext: ctx, queryResultSettings: querySettings }, input.productId, +apiSettings.channelId, input.catalogId, productRelationTypeId)
        .then(response => {
        if (response && response.length) {
            return response.map((product) => {
                return new FullProductInput(product.RecordId, apiSettings, input.ProductDetailsCriteria);
            });
        }
        ctx.trace('[getRelatedProductsAction] Invalid response from server');
        return [];
    })
        .catch((error) => {
        ctx.trace(error.message);
        ctx.trace(error.stack || '');
        ctx.telemetry.exception(error);
        ctx.telemetry.debug(`[getRelatedProductsAction] Unable to Fetch Products.`);
        ctx.trace(`[getRelatedProductsAction] Unable to Fetch Products.`);
        return [];
    });
    if (productInputs.length > 0) {
        return getFullProducts(productInputs, ctx);
    }
    else {
        return [];
    }
}
/**
 * The getRelatedProducts data action
 * Uses a productId URL Token and finds the relation types for said product
 * using the getRelationTypes RetailServer API, and then finds and retusn all products that
 * share that relation type via the getRelatedProducts RetailServer API
 */
export default createObservableDataAction({
    id: '@msdyn365-commerce-modules/retail-actions/get-related-products',
    action: getRelatedProductsAction,
    input: createGetRelatedProductsInput
});
//# sourceMappingURL=get-related-products.js.map
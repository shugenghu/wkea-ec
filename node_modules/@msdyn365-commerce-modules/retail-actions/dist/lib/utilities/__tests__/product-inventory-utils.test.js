import { buildHydratedMockActionContext, buildMockRequest } from '@msdyn365-commerce/core';
import 'jest';
import { mapProductInventoryInformation } from '../product-inventory-utils';
describe('Product inventory utils', () => {
    it('Enable stock check is disabled', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: false, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toEqual(0);
    });
    it('Total available in stock', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(1);
    });
    it('Total available low stock', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'Low stock', 'LOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(1);
        expect(target[0].StockLevelLabel).toEqual('Low stock');
    });
    it('Total available out of stock', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'Out of stock', 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 1 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual('Out of stock');
    });
    it('Total available out of stock and inventory is 0', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const inventoryLabel = 'item is out of stock';
        const productMock = getMockWarehouseInventory(0, 2, inventoryLabel, 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 1 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual(inventoryLabel);
    });
    it('Total available out of stock and inventory is negative', () => {
        const app = { config: { inventoryLevel: 'totalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const inventoryLabel = 'item is out of stock';
        const productMock = getMockWarehouseInventory(-1, 2, inventoryLabel, 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 1 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual(inventoryLabel);
    });
    it('Physical available in stock', () => {
        const app = { config: { inventoryLevel: 'physicalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        // should be 2 as physical available is 2
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(2);
        expect(target[0].StockLevelLabel).toEqual('In stock');
    });
    it('Physical available low stock', () => {
        const app = { config: { inventoryLevel: 'physicalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'Low stock', 'LOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(2);
        expect(target[0].StockLevelLabel).toEqual('Low stock');
    });
    it('Physical available out of stock', () => {
        const app = { config: { inventoryLevel: 'physicalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'Out of stock', 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 2 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual('Out of stock');
    });
    it('Physical available out of stock and inventory is 0', () => {
        const app = { config: { inventoryLevel: 'physicalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const inventoryLabel = 'item is out of stock';
        const productMock = getMockWarehouseInventory(1, 0, inventoryLabel, 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 2 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual(inventoryLabel);
    });
    it('Physical available out of stock and inventory is negative', () => {
        const app = { config: { inventoryLevel: 'physicalAvailable', enableStockCheck: true, inventoryRanges: 'all' } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const inventoryLabel = 'item is out of stock';
        const productMock = getMockWarehouseInventory(1, -1, inventoryLabel, 'OOS');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        // even when inventory is 2 it should be not available as inventory code is OOS
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
        expect(target[0].StockLevelLabel).toEqual(inventoryLabel);
    });
    it('Threshold (0) enabled and product is in stock', () => {
        const app = { config: { inventoryLevel: 'inventoryThreshold', enableStockCheck: true, inventoryRanges: 'all', outOfStockThreshold: 0 } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(1);
    });
    it('Threshold (50) enabled and product is in stock as product inventory is 65', () => {
        const app = { config: { inventoryLevel: 'inventoryThreshold', enableStockCheck: true, inventoryRanges: 'all', outOfStockThreshold: 50 } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(65, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(15);
    });
    it('Threshold (10) out of stock as product inventory is 1', () => {
        const app = { config: { inventoryLevel: 'inventoryThreshold', enableStockCheck: true, inventoryRanges: 'all', outOfStockThreshold: 10 } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(1, 2, 'In stock', 'AVAIL');
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
    });
    it('Threshold (0) out of stock as product inventory is 0', () => {
        const app = { config: { inventoryLevel: 'inventoryThreshold', enableStockCheck: true, inventoryRanges: 'all', outOfStockThreshold: 0 } };
        const mockRequest = buildMockRequest({ app: app });
        const mockActionContext = buildHydratedMockActionContext({ requestContext: mockRequest });
        const productMock = getMockWarehouseInventory(0, 2, 'In stock', 'AVAIL');
        debugger;
        const target = mapProductInventoryInformation(mockActionContext, productMock);
        expect(target).not.toBeUndefined();
        expect(target.length).toBeGreaterThan(0);
        expect(target[0].IsProductAvailable).not.toBeTruthy();
        expect(target[0].ProductAvailableQuantity.AvailableQuantity).toEqual(0);
    });
});
export const getMockWarehouseInventory = (totalAvailable, physicalAvailable, invLabel, invCode) => {
    let productWarehouseInventoryMock = {
        InventLocationId: '123',
        ProductId: 1,
        TotalAvailable: totalAvailable,
        PhysicalAvailable: physicalAvailable,
        TotalAvailableInventoryLevelLabel: invLabel,
        TotalAvailableInventoryLevelCode: invCode,
        PhysicalAvailableInventoryLevelCode: invCode,
        PhysicalAvailableInventoryLevelLabel: invLabel
    };
    return [productWarehouseInventoryMock];
};
//# sourceMappingURL=product-inventory-utils.test.js.map
import getFullProducts, { FullProductInput, ProductDetailsCriteria } from '../get-full-products';
/**
 * If refinement criteria is set, then gets refined products.
 * @param input refinable products input
 * @param ctx action context
 * @param getRefinedProducts callback function to get a promise (e.g. refineSearchByCategoryAsync, refineSearchByTextAsync)
 * that is executed to get refined products or full set of products.
 */
export async function getRefinedFullProducts(input, ctx, getRefinedProducts) {
    if (!input || !input.refinementCriteria) {
        ctx.trace('[getFullProductsByRefineSearchCategoryAction] Invalid input.');
        return {};
    }
    if (!input.refinementCriteria.length) {
        ctx.trace('[getFullProductsByRefineSearchCategoryAction] No refiners specified.');
        return {};
    }
    const { apiSettings } = ctx.requestContext;
    let fullProductInputs = [];
    const searchResults = await getRefinedProducts();
    if (!searchResults) {
        ctx.telemetry.error('[getFullProductsByRefineSearchCategoryAction] no searchResults returned');
    }
    else {
        fullProductInputs = searchResults.map((product) => {
            return new FullProductInput(product.RecordId, apiSettings, input.productDetailsCriteria || new ProductDetailsCriteria());
        });
    }
    if (fullProductInputs.length) {
        const productResult = await getFullProducts(fullProductInputs, ctx);
        return {
            productSearchResult: productResult,
            refinementCriteria: input.refinementCriteria
        };
    }
    else {
        return {
            productSearchResult: [],
            refinementCriteria: input.refinementCriteria
        };
    }
}
//# sourceMappingURL=refiner-utils.js.map
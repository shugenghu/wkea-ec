/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { render } from 'enzyme';
import * as React from 'react';

import { IProductInventoryInformation } from '@msdyn365-commerce-modules/retail-actions';
import { buildMockModuleProps } from '@msdyn365-commerce/core';
import { AsyncResult, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { IBuyboxData, IBuyboxProps } from '../../../../index';
import { mockResources } from '../../__mocks__/mock-resources';
import { IBuyboxCallbacks, IBuyboxState } from '../../buybox';
import {
    BuyboxErrorBlock,
    getBuyBoxInventoryLabel,
    getBuyboxProductDescription,
    getBuyboxProductQuantity,
    getBuyboxProductTitle,
    getBuyboxShopSimilarLook,
    IBuyboxErrorBlockProps,
    // IBuyboxShopSimilarItemViewProps
} from '../../components';

// @ts-ignore partial mock
const mockContext: ICoreContext<{}>  = {
    app: {
        config: {
            maxQuantityForCartLineItem: 5
        }
    }
};

describe('Buybox Inventory Level Label',()=> {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    it('returns null if no product quantity',()=> {
        moduleProps = buildMockModuleProps(
            {
            productAvailableQuantity: {
                    status: 'FAILED',
                    result: undefined,
                } as AsyncResult<IProductInventoryInformation[]>
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const inventoryLabel = getBuyBoxInventoryLabel(moduleProps);

        expect(inventoryLabel).toBe(undefined);
    });

    it('renders correctly with correct stock Labels', () => {
        moduleProps = buildMockModuleProps (
        {
            productAvailableQuantity:{
                status: 'SUCCESS',
                result: [{
                       StockLevelLabel:'Available'
                }]
            }as AsyncResult<IProductInventoryInformation[]>
        },
        {},
        {},
        mockContext
    ) as IBuyboxProps<IBuyboxData>;

        const inventoryLabel = getBuyBoxInventoryLabel(moduleProps);
        expect(inventoryLabel).toBeDefined();

        const component = render(inventoryLabel!);
        expect(component).toMatchSnapshot();
    });
});

describe('Buybox Product Title', () => {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    it('returns null if no product', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'FAILED',
                    result: undefined,
                } as AsyncResult<SimpleProduct>
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const title = getBuyboxProductTitle(moduleProps);

        expect(title).toBe(undefined);
    });

    it('renders correctly with default values', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'SUCCESS',
                    result: {
                        Name: undefined
                    },
                } as AsyncResult<SimpleProduct>
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const title = getBuyboxProductTitle(moduleProps);

        expect(title).toBeDefined();

        const component = render(title!);
        expect(component).toMatchSnapshot();
    });

    it('renders correctly with supplied values', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'SUCCESS',
                    result: {
                        Name: 'Toy'
                    },
                } as AsyncResult<SimpleProduct>,
            },
            {},
            {
                titleHeadingTag: 'h2'
            },
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const title = getBuyboxProductTitle(moduleProps);

        expect(title).toBeDefined();

        const component = render(title!);
        expect(component).toMatchSnapshot();
    });
});

describe('getBuyboxProductDescription', () => {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    it('returns null if no product', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'FAILED',
                    result: undefined,
                } as AsyncResult<SimpleProduct>
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const description = getBuyboxProductDescription(moduleProps);

        expect(description).toBe(undefined);
    });

    it('renders correctly with default values', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'SUCCESS',
                    result: {
                        Name: undefined
                    },
                } as AsyncResult<SimpleProduct>
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const description = getBuyboxProductDescription(moduleProps);

        expect(description).toBeDefined();

        const component = render(description!);
        expect(component).toMatchSnapshot();
    });

    it('renders correctly with supplied values', () => {
        moduleProps = buildMockModuleProps(
            {
                product: {
                    status: 'SUCCESS',
                    result: {
                        Description: 'This is a toy'
                    },
                } as AsyncResult<SimpleProduct>,
            },
            {},
            {},
            mockContext
        ) as IBuyboxProps<IBuyboxData>;

        const description = getBuyboxProductTitle(moduleProps);

        expect(description).toBeDefined();

        const component = render(description!);
        expect(component).toMatchSnapshot();
    });
});

describe('Buybox Product Quantity', () => {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    const mockState: IBuyboxState = {
        quantity: 0,
        errorState: {
            configureErrors: {}
        },
        selectedDimensions: {}
    };

    const mockCallbacks: IBuyboxCallbacks = {
        updateQuantity: jest.fn(),
        updateErrorState: jest.fn(),
        dimensionSelectedAsync: jest.fn(),
        updateSelectedProduct: jest.fn(),
        getDropdownName: jest.fn(),
        changeModalOpen:jest.fn(),
        changeUpdatingDimension: jest.fn()

    };

    it('does not include error block if no errors', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    product: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ),
            resources: mockResources
         } as IBuyboxProps<IBuyboxData>;

        const quantity = getBuyboxProductQuantity(moduleProps, mockState, mockCallbacks);

        expect(quantity.errors).toBeUndefined();
    });

    it('includes error block if no errors', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    product: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ),
            resources: mockResources
         } as IBuyboxProps<IBuyboxData>;
        const quantity = getBuyboxProductQuantity(moduleProps, mockState, mockCallbacks);

        expect(quantity.errors).toBeUndefined();
    });

    it('fires callback when input changes', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    product: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ),
            resources: mockResources
         } as IBuyboxProps<IBuyboxData>;

        const quantity = getBuyboxProductQuantity(moduleProps, mockState, mockCallbacks);

        // @ts-ignore
        const quantityProps: IQuantityProps = quantity.input.props;

        quantityProps.onChange(2);

        expect(mockCallbacks.updateQuantity).toBeCalledWith(2);
   });
});

describe('Buybox Shop Similar Item', () => {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    const mockState: IBuyboxState = {
        quantity: 0,
        errorState: {
            configureErrors: {}
        },
        selectedDimensions: {}
    };

    const mockCallbacks: IBuyboxCallbacks = {
        updateQuantity: jest.fn(),
        updateErrorState: jest.fn(),
        dimensionSelectedAsync: jest.fn(),
        updateSelectedProduct: jest.fn(),
        getDropdownName: jest.fn(),
        changeModalOpen:jest.fn(),
        changeUpdatingDimension: jest.fn()

    };

    it('render ShopSimilarLooks link if product available', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    product: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ),
            resources: mockResources
         } as IBuyboxProps<IBuyboxData>;

        const shopSimilarItem = getBuyboxShopSimilarLook(moduleProps, mockState, mockCallbacks);

        expect(shopSimilarItem.errors).toBeUndefined();
    });

    it('includes error block if product not available errors', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    product: {
                        status: 'FAILED',
                        result: {},
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ),
            resources: mockResources
         } as IBuyboxProps<IBuyboxData>;
        const shopSimilarItem = getBuyboxShopSimilarLook(moduleProps, mockState, mockCallbacks);

        expect(shopSimilarItem.errors).toBeUndefined();
    });
});

describe('Buybox Error Block', () => {
    it('renders correctly with no error messages', () => {
        const mockProps: IBuyboxErrorBlockProps = {
            resources: mockResources,
            configureErrors: {},
            otherError: undefined,
            quantityError: undefined,
            showError: true
        };
        const component = render(<BuyboxErrorBlock {...mockProps} />);
        expect(component).toMatchSnapshot();
    });

    it('renders correctly with errors', () => {
        const mockProps: IBuyboxErrorBlockProps = {
            resources: mockResources,
            configureErrors: {1: 'Missing 1', 2: 'Missing 2'},
            otherError: 'Other error',
            quantityError: 'Quantity error',
            showError: true
        };
        const component = render(<BuyboxErrorBlock {...mockProps} />);
        expect(component).toMatchSnapshot();
    });

    it('renders correctly with errors but showError=false', () => {
        const mockProps: IBuyboxErrorBlockProps = {
            resources: mockResources,
            configureErrors: {1: 'Missing 1', 2: 'Missing 2'},
            otherError: 'Other error',
            quantityError: 'Quantity error',
            showError: false
        };
        const component = render(<BuyboxErrorBlock {...mockProps} />);
        expect(component).toMatchSnapshot();
    });
});
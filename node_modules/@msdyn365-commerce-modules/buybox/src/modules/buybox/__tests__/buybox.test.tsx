/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { IStoreSelectorStateManager } from '@msdyn365-commerce-modules/bopis-utilities';
import * as RetailActions from '@msdyn365-commerce-modules/retail-actions';
import { ProductDimensionFull, RatingsSummary } from '@msdyn365-commerce/commerce-entities';
import { IAddToCartComponentProps } from '@msdyn365-commerce/components';
import { buildMockModuleProps, ICoreContext } from '@msdyn365-commerce/core';
import { ICartState } from '@msdyn365-commerce/global-state';
import { AsyncResult, CommerceList, Customer, ProductDeliveryOptions, ProductPrice, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { mount } from 'enzyme';
import * as React from 'react';
import { Buybox, IBuyboxData, IBuyboxProps } from '../../../index';
import { mockResources } from '../__mocks__/mock-resources';
import { IBuyboxCallbacks, IBuyboxState, IBuyboxViewProps } from '../buybox';
import { getBuyboxProductConfigure } from '../components';

const mockData: IBuyboxData = {
    deliveryOptions: {
        status: 'FAILED',
        result: undefined,
    } as AsyncResult<ProductDeliveryOptions | undefined>,
    product: {
        status: 'FAILED',
        result: undefined,
    } as AsyncResult<SimpleProduct>,
    productDimensions: {
        status: 'FAILED',
        result: undefined,
    } as AsyncResult<ProductDimensionFull[]>,
    storeSelectorStateManager: {
        status: 'FAILED',
        result: undefined,
    } as AsyncResult<IStoreSelectorStateManager>,
    productPrice: {
        status: 'FAILED',
        result: undefined
    } as AsyncResult<ProductPrice>,
    ratingsSummary: {
        status: 'SUCCESS',
        result: undefined
    } as AsyncResult<RatingsSummary>,
    cart: {
        status: 'SUCCESS',
        result: undefined
    } as AsyncResult<ICartState>,
    wishlists: {
        status: 'FAILED',
        result: undefined
    } as AsyncResult<CommerceList[]>,
    orderTemplates: {
        status: 'FAILED',
        result: undefined
    } as AsyncResult<RetailActions.OrderTemplate[]>,
    productAvailableQuantity: {
        status: 'SUCCESS',
        result: undefined
    } as AsyncResult<RetailActions.IProductInventoryInformation[]>,
    customerInformation: {
        status: 'SUCCESS',
        result: undefined
    } as AsyncResult<Customer>
};

const mockDimensions = [
    {
        DimensionTypeValue: 3,
        DimensionValues: [{
                RecordId:22565421223,
                Value:'32',
                ExtensionProperties:[]
              },{
                RecordId:22565421225,
                Value:'36',
                ExtensionProperties:[]
              },{
                RecordId:22565421226,
                Value:'38',
                ExtensionProperties:[]
              },{
                RecordId:22565421227,
                Value:'40',
                ExtensionProperties:[]
              },{
                RecordId:22565421228,
                Value:'42',
                ExtensionProperties:[]
              },{
                RecordId:22565421229,
                Value:'44',
                ExtensionProperties:[]
              },{
                RecordId:22565421230,
                Value:'46',
                ExtensionProperties:[]
              },{
                RecordId:22565421231,
                Value:'48',
                ExtensionProperties:[]
              }
        ]
    },
    {
        DimensionTypeValue: 1,
        DimensionValues: [
            {
                RecordId:22565421201,
                Value: 'Light Blue',
                ExtensionProperties:[]
            }
        ]
    },
    {
        DimensionTypeValue: 4,
        DimensionValues: [{
                RecordId:5637144584,
                Value: 'Big',
                ExtensionProperties:[]
            },{
                RecordId:5637144583,
                Value:'Regular',
                ExtensionProperties:[]
            }
        ]
    },
    {
        DimensionTypeValue: 2,
        DimensionValues: [{
            RecordId:56371445841,
            ExtensionProperties:[]
        },{
            RecordId:56371445831,
            ExtensionProperties:[]
        }
    ]
    },
    {
        DimensionTypeValue: 5
    }
];

// @ts-ignore partial mock
const mockContext: ICoreContext  = {
    app: {
        config: {
            maxQuantityForCartLineItem: 5,
            titleHeadingTag:'h2',
            enableStockCheck: true
        }
    },
    request: {
        // @ts-ignore partial mock
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};

// @ts-ignore partial mock
const mockContextNoMaxQuantity: ICoreContext  = {
    app: {
        config: {
            enableStockCheck: true
        }
    },
    request: {
        // @ts-ignore partial mock
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};

// @ts-ignore partial mock
const mockContextWithMaxQuantity: ICoreContext  = {
    app: {
        config: {
            maxQuantityForCartLineItem: 10,
            enableStockCheck: true
        }
    },
    request: {
        // @ts-ignore partial mock
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};

const mockSlots = {
    mediaGallery: [],
    storeSelector: [],
    textBlocks: [],
    socialShare:[]
};

describe('Buybox Module tests', () => {
    let moduleProps: IBuyboxProps<IBuyboxData>;

    beforeEach(() => {
        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue(undefined);

        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        // @ts-ignore
        RetailActions.getPriceForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        // @ts-ignore
        RetailActions.getDeliveryOptionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        // @ts-ignore
        RetailActions.getProductAvailabilitiesForSelectedVariant = jest.fn().mockResolvedValue(undefined);
    });

    it('Renders as expected when no product defined', () => {
        moduleProps = {
            ...buildMockModuleProps(mockData, {}, {}, mockContext) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
          };

        mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).not.toBeCalled();
    });

    it('Renders as expected when product defined but no media gallery present', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
          };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.mediaGallery).not.toBeTruthy();
    });

    it('Renders as expected when product defined and media gallery present', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                mediaGallery: [(<div>Media Gallery</div>)],
            },
            resources: mockResources
          };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.mediaGallery).toBeTruthy();
    });

    it('Renders as expected when product defined but no store selector state manager', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).not.toBeTruthy();
    });

    it('Renders as expected when product defined and store selector state manager also defined but no store selector present', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    storeSelectorStateManager: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<IStoreSelectorStateManager>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).not.toBeTruthy();
    });

    it('Renders as expected when product defined and store selector state manager also defined and also store selector present', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    storeSelectorStateManager: {
                        status: 'SUCCESS',
                        result: {},
                    } as AsyncResult<IStoreSelectorStateManager>,
                    // @ts-ignore partial mock
                    deliveryOptions: {
                        status: 'SUCCESS',
                        result: {
                            DeliveryOptions: [
                                {
                                    Code: '60'
                                }
                            ]
                        }
                    } as AsyncResult<ProductDeliveryOptions | undefined>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).toBeTruthy();
    });

    it('Renders as expected when productPrice is not defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).toBeFalsy();
    });

    it('Renders as expected when product and productDimensions are defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: [{DimensionTypeValue: 1}]
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.configure).toBeTruthy();
    });

    it('Renders as expected when productPrice is defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productPrice: {
                        status: 'SUCCESS',
                        result: {
                            CustomerContextualPrice: 15
                        }
                    }
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).toBeTruthy();
    });

    it('Renders as expected when ratingSummary is not defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).not.toBeTruthy();
        expect(viewProps.rating).not.toBeTruthy();

    });

    it('Renders as expected when ratingSummary and product is defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    ratingsSummary: {
                        status: 'SUCCESS',
                        result: {
                            averageRating: 3.7,
                            reviewsCount: 1000
                        }
                    }
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: {...mockSlots,
                storeSelector: [(<div>Store Selector</div>)]
            },
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).not.toBeTruthy();
        expect(viewProps.rating).toBeTruthy();
    });

    it('Renders add to wishlist as expected when product is defined', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.addToWishlist).toBeTruthy();
    });

    it('Renders quantity as expected', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },

                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        expect(viewProps.quantity).toBeTruthy();
    });

    it('When quantity updates, quantity in add to cart updates too', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const quantityProps: IQuantityProps = viewProps.quantity!.input.props;

        quantityProps.onChange(2);

        // @ts-ignore
        expect(result.state().quantity).toEqual(2);
    });

    it('When add to cart fails, properly updates state when add to cart fails with EMPTYINPUT', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'EMPTYINPUT'});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('Add to cart failed. Please refresh and retry');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED but not MAXQUANTITY', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED'});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('Add to cart failed. Please refresh and retry');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    cart: {
                        status: 'FAILED',
                        result: {
                            cart: {
                                Id: 'id',
                                CartLines: [ {ProductId: 10} ]
                            }
                        }
                    } as AsyncResult<ICartState>,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Available',
                                ProductAvailableQuantity: { AvailableQuantity: 10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY'}});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 5 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and use config value', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    cart: {
                        status: 'FAILED',
                        result: {
                            cart: {
                                Id: 'id',
                                CartLines: [ {ProductId: 10} ]
                            }
                        }
                    } as AsyncResult<ICartState>,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Available',
                                ProductAvailableQuantity: { AvailableQuantity: 10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContextWithMaxQuantity
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY'}});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and use config value and no availableQty', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    cart: {
                        status: 'FAILED',
                        result: {
                            cart: {
                                Id: 'id',
                                CartLines: [ {ProductId: 10} ]
                            }
                        }
                    } as AsyncResult<ICartState>,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>
                },
                {},
                {},
                mockContextWithMaxQuantity
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY'}});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and uses default value', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    cart: {
                        status: 'FAILED',
                        result: {
                            cart: {
                                Id: 'id',
                                CartLines: [ {ProductId: 10} ]
                            }
                        }
                    } as AsyncResult<ICartState>,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Available',
                                ProductAvailableQuantity: { AvailableQuantity: 10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContextNoMaxQuantity
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY'}});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and no availbleQty', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    cart: {
                        status: 'FAILED',
                        result: {
                            cart: {
                                Id: 'id',
                                CartLines: [ {ProductId: 10} ]
                            }
                        }
                    } as AsyncResult<ICartState>,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>
                },
                {},
                {},
                mockContextNoMaxQuantity
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY'}});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and 0 stock left', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'OUTOFSTOCK', stockLeft: 0});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('This product is out of stock');
    });

    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and 1 stock left', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'OUTOFSTOCK', stockLeft: 1});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('There is only one product left. Please choose quantity within the available range');
    });

    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and more than one stock left', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'OUTOFSTOCK', stockLeft: 5});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('There are only 5 products left. Please choose quantity within the available range');
    });

    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'MISSINGDIMENSION', missingDimensions: [
            { DimensionTypeValue: 3 },
            { DimensionTypeValue: 1 },
            { DimensionTypeValue: 4 }
        ]});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors[1]).toEqual('Color is required. Please choose a color');
        expect(state.errorState.configureErrors[2]).toBeUndefined();
        expect(state.errorState.configureErrors[3]).toEqual('Size is required. Please choose a size');
        expect(state.errorState.configureErrors[4]).toEqual('Style is required. Please choose a style');
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION but no missing dimensions returned', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'MISSINGDIMENSION'});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
    });

    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION even if dimension ids don\'t match whats expected', () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(moduleProps.renderView).toBeCalled();

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();

        // @ts-ignore
        const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

        addToCartProps.onError!({failureReason: 'MISSINGDIMENSION', missingDimensions: [
            { DimensionTypeValue: 2 },
            { DimensionTypeValue: 5 }
        ]});

        const state: IBuyboxState = result.state() as IBuyboxState;

        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors[1]).toBeUndefined();
        expect(state.errorState.configureErrors[2]).toEqual('Configuration is required. Please choose a configuration');
        expect(state.errorState.configureErrors[3]).toBeUndefined();
        expect(state.errorState.configureErrors[4]).toBeUndefined();
        expect(state.errorState.configureErrors[5]).toEqual('');
        expect(state.errorState.quantityError).toBeUndefined();
    });

    it('Callbacks work', async () => {
        let callbacks: IBuyboxCallbacks | undefined;
        // @ts-ignore
        getBuyboxProductConfigure = jest.fn().mockImplementation((props, state, callback) => {
            callbacks = callback;
            return undefined;
        });

        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(getBuyboxProductConfigure).toBeCalled();

        expect(callbacks).toBeDefined();

        callbacks!.updateErrorState({
            errorHost: 'ADDTOCART',
            configureErrors: {
                1: 'Error 1',
                2: 'Error 2',
                4: 'Error 4'
            }
        });
        // @ts-ignore gets confused by path
        expect(result.state().errorState.configureErrors[1]).toEqual('Error 1');
        // @ts-ignore gets confused by path
        expect(result.state().errorState.configureErrors[2]).toEqual('Error 2');
        // @ts-ignore gets confused by path
        expect(result.state().errorState.configureErrors[4]).toEqual('Error 4');
        const test = await callbacks!.dimensionSelectedAsync(4, '0');
        expect(test).toBeUndefined();
    });

    it('updateSelectedProduct Callbacks', async () => {
        let callbacks: IBuyboxCallbacks | undefined;
        // @ts-ignore
        getBuyboxProductConfigure = jest.fn().mockImplementation((props, state, callback) => {
            callbacks = callback;
            return undefined;
        });

        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        expect(getBuyboxProductConfigure).toBeCalled();

        expect(callbacks).toBeDefined();

        callbacks!.updateSelectedProduct(new Promise<SimpleProduct | null>((resolve) => resolve(null)), undefined, undefined, undefined);

        // @ts-ignore gets confused by path
        expect(result.state().selectedProduct).toBeDefined();

        // @ts-ignore gets confused by path
        expect(await (result.state().selectedProduct)).toEqual(null);
    });

    it('_getDropdownName tests', async () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions,
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;

        expect(viewProps.callbacks.getDropdownName(1, mockResources)).toEqual('Color');
        expect(viewProps.callbacks.getDropdownName(2, mockResources)).toEqual('Configuration');
        expect(viewProps.callbacks.getDropdownName(3, mockResources)).toEqual('Size');
        expect(viewProps.callbacks.getDropdownName(4, mockResources)).toEqual('Style');
        expect(viewProps.callbacks.getDropdownName(5, mockResources)).toEqual('');
    });

    it('dimensionSelectedAsync -- updates state to newly selected dimension', async () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions,
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore gets confused by path
        expect(result.state().selectedDimensions[4]).toEqual('0');
    });

    it('dimensionSelectedAsync -- clears error states after selecting new dimension', async () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions,
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;

        viewProps.callbacks.updateErrorState({
            errorHost: 'ADDTOCART',
            configureErrors: {
                1: 'Error 1',
                2: 'Error 2',
                4: 'Error 4'
            }
        });

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore gets confused by path
        expect(result.state().errorState.configureErrors[4]).toBeUndefined();
    });

    it('dimensionSelectedAsync -- If getSelectedVariant returns null doesnt get dimensions', async () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions,
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;

        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue(undefined);
        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore
        const selectedProduct = await result.state().selectedProduct;

        expect(selectedProduct).toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).not.toBeCalled();
    });

    it('dimensionSelectedAsync -- If getSelectedVariant returns not null, does get dimensions', async () => {
        moduleProps = {
            ...buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        },
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions,
                    } as AsyncResult<ProductDimensionFull[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>,
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;

        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({RecordId: '10'});
        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore
        const selectedProduct = await result.state().selectedProduct;

        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getPriceForSelectedVariant).toBeCalled();
        expect(RetailActions.getDeliveryOptionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
    });

    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns AVAILABLE', async () => {
        moduleProps = {
            ...(buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        }
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions
                    } as AsyncResult<ProductDimensionFull[]>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Available',
                                StockLevelCode:'X123',
                                ProductAvailableQuantity: { AvailableQuantity:10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>),
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(<Buybox {...moduleProps} />);
        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel as React.ReactElement);
        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        // @ts-ignore
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });

    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns LOW STOCK AVAIABLE', async () => {
        moduleProps = {
            ...(buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        }
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions
                    } as AsyncResult<ProductDimensionFull[]>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Low stock available',
                                ProductAvailableQuantity: { AvailableQuantity:10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>),
            // @ts-ignore
            renderView: jest.fn(props => {return <div props={props} />; }),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel as React.ReactElement);

        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore
        const selectedProduct = await result.state().selectedProduct;

        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Low stock available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });

    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns ONLY FEW AVAILABLE', async () => {
        moduleProps = {
            ...(buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        }
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions
                    } as AsyncResult<ProductDimensionFull[]>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Only few available',
                                ProductAvailableQuantity: { AvailableQuantity:10 }
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>),
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);

        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel as React.ReactElement);

        // @ts-ignore
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        // @ts-ignore
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);

        await viewProps.callbacks.dimensionSelectedAsync(4, '0');

        // @ts-ignore
        const selectedProduct = await result.state().selectedProduct;

        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Only few available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });

    it('renders inventory label correctly, when add to cart fails with OUTOFSTOCK', async() => {
      moduleProps = {
          ...(buildMockModuleProps(
              {
                  ...mockData,
                  product: {
                      status: 'SUCCESS',
                      result: {
                          RecordId: 10
                      }
                  } as AsyncResult<SimpleProduct>
              },
              {},
              {},
              mockContext
          ) as IBuyboxProps<IBuyboxData>),
          // @ts-ignore
          renderView: jest.fn(props => {return <div props={props} />;}),
          slots: mockSlots,
          resources: mockResources
      };

      const result = mount(<Buybox {...moduleProps} />);

      expect(moduleProps.renderView).toBeCalled();

      const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
      expect(viewProps).toBeDefined();
      // @ts-ignore
      const addToCartProps: IAddToCartComponentProps = viewProps.addToCart.button!.props;

      addToCartProps.onError!({ failureReason: 'OUTOFSTOCK', stockLeft: 0 });
      const state: IBuyboxState = result.state() as IBuyboxState;
      expect(addToCartProps.outOfStockText).toEqual('Out of Stock');
      expect(state.errorState.quantityError).toEqual('This product is out of stock');
    });
    it('renders Inventory level label correctly ,if getBuyBoxInventoryLabel returns undefined', async () => {
        moduleProps = {
            ...(buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        }
                    } as AsyncResult<SimpleProduct>,
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions
                    } as AsyncResult<ProductDimensionFull[]>,
                    productAvailableQuantity: {
                        status: 'LOADING',
                        result: [
                            {
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>),
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };

        const result = mount(<Buybox {...moduleProps} />);
        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps.inventoryLabel).toBe(undefined);
    });
    it('renders SimilarLook product', async () => {
        moduleProps = {
            ...(buildMockModuleProps(
                {
                    ...mockData,
                    product: {
                        status: 'SUCCESS',
                        result: {
                            RecordId: 10
                        }
                    } as AsyncResult<SimpleProduct>,
                    ratingsSummary: {
                        status: 'SUCCESS',
                        result: {
                            reviewsCount: 1000
                        }
                    },
                    productDimensions: {
                        status: 'SUCCESS',
                        result: mockDimensions
                    } as AsyncResult<ProductDimensionFull[]>,
                    productAvailableQuantity: {
                        status: 'SUCCESS',
                        result: [
                            {
                                StockLevelLabel: 'Only few available'
                            }
                        ]
                    } as AsyncResult<RetailActions.IProductInventoryInformation[]>
                },
                {},
                {},
                mockContext
            ) as IBuyboxProps<IBuyboxData>),
            // @ts-ignore
            renderView: jest.fn(props => { return <div props={props} />;}),
            slots: mockSlots,
            resources: mockResources
        };
        const moduleProps2 = {...moduleProps,config:{enableShopSimilarLooks:true}};
        const result = mount(<Buybox {...moduleProps2} />);
        const viewProps: IBuyboxViewProps = result.childAt(0).props().props;
        expect(viewProps.shopSimilarLook).toBeDefined();
    });
});
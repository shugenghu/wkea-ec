import * as RetailActions from '@msdyn365-commerce-modules/retail-actions';
import { buildMockModuleProps } from '@msdyn365-commerce/core';
import { mount } from 'enzyme';
import * as React from 'react';
import { Buybox } from '../../../index';
import { mockResources } from '../__mocks__/mock-resources';
import { getBuyboxProductConfigure } from '../components';
const mockData = {
    deliveryOptions: {
        status: 'FAILED',
        result: undefined,
    },
    product: {
        status: 'FAILED',
        result: undefined,
    },
    productDimensions: {
        status: 'FAILED',
        result: undefined,
    },
    storeSelectorStateManager: {
        status: 'FAILED',
        result: undefined,
    },
    productPrice: {
        status: 'FAILED',
        result: undefined
    },
    ratingsSummary: {
        status: 'SUCCESS',
        result: undefined
    },
    cart: {
        status: 'SUCCESS',
        result: undefined
    },
    wishlists: {
        status: 'FAILED',
        result: undefined
    },
    orderTemplates: {
        status: 'FAILED',
        result: undefined
    },
    productAvailableQuantity: {
        status: 'SUCCESS',
        result: undefined
    },
    customerInformation: {
        status: 'SUCCESS',
        result: undefined
    }
};
const mockDimensions = [
    {
        DimensionTypeValue: 3,
        DimensionValues: [{
                RecordId: 22565421223,
                Value: '32',
                ExtensionProperties: []
            }, {
                RecordId: 22565421225,
                Value: '36',
                ExtensionProperties: []
            }, {
                RecordId: 22565421226,
                Value: '38',
                ExtensionProperties: []
            }, {
                RecordId: 22565421227,
                Value: '40',
                ExtensionProperties: []
            }, {
                RecordId: 22565421228,
                Value: '42',
                ExtensionProperties: []
            }, {
                RecordId: 22565421229,
                Value: '44',
                ExtensionProperties: []
            }, {
                RecordId: 22565421230,
                Value: '46',
                ExtensionProperties: []
            }, {
                RecordId: 22565421231,
                Value: '48',
                ExtensionProperties: []
            }
        ]
    },
    {
        DimensionTypeValue: 1,
        DimensionValues: [
            {
                RecordId: 22565421201,
                Value: 'Light Blue',
                ExtensionProperties: []
            }
        ]
    },
    {
        DimensionTypeValue: 4,
        DimensionValues: [{
                RecordId: 5637144584,
                Value: 'Big',
                ExtensionProperties: []
            }, {
                RecordId: 5637144583,
                Value: 'Regular',
                ExtensionProperties: []
            }
        ]
    },
    {
        DimensionTypeValue: 2,
        DimensionValues: [{
                RecordId: 56371445841,
                ExtensionProperties: []
            }, {
                RecordId: 56371445831,
                ExtensionProperties: []
            }
        ]
    },
    {
        DimensionTypeValue: 5
    }
];
const mockContext = {
    app: {
        config: {
            maxQuantityForCartLineItem: 5,
            titleHeadingTag: 'h2',
            enableStockCheck: true
        }
    },
    request: {
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};
const mockContextNoMaxQuantity = {
    app: {
        config: {
            enableStockCheck: true
        }
    },
    request: {
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};
const mockContextWithMaxQuantity = {
    app: {
        config: {
            maxQuantityForCartLineItem: 10,
            enableStockCheck: true
        }
    },
    request: {
        channel: {
            PickupDeliveryModeCode: '60'
        }
    }
};
const mockSlots = {
    mediaGallery: [],
    storeSelector: [],
    textBlocks: [],
    socialShare: []
};
describe('Buybox Module tests', () => {
    let moduleProps;
    beforeEach(() => {
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue(undefined);
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        RetailActions.getPriceForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        RetailActions.getDeliveryOptionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        RetailActions.getProductAvailabilitiesForSelectedVariant = jest.fn().mockResolvedValue(undefined);
    });
    it('Renders as expected when no product defined', () => {
        moduleProps = {
            ...buildMockModuleProps(mockData, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).not.toBeCalled();
    });
    it('Renders as expected when product defined but no media gallery present', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.mediaGallery).not.toBeTruthy();
    });
    it('Renders as expected when product defined and media gallery present', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                mediaGallery: [(React.createElement("div", null, "Media Gallery"))],
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.mediaGallery).toBeTruthy();
    });
    it('Renders as expected when product defined but no store selector state manager', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).not.toBeTruthy();
    });
    it('Renders as expected when product defined and store selector state manager also defined but no store selector present', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                storeSelectorStateManager: {
                    status: 'SUCCESS',
                    result: {},
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).not.toBeTruthy();
    });
    it('Renders as expected when product defined and store selector state manager also defined and also store selector present', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                storeSelectorStateManager: {
                    status: 'SUCCESS',
                    result: {},
                },
                deliveryOptions: {
                    status: 'SUCCESS',
                    result: {
                        DeliveryOptions: [
                            {
                                Code: '60'
                            }
                        ]
                    }
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.findInStore).toBeTruthy();
    });
    it('Renders as expected when productPrice is not defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).toBeFalsy();
    });
    it('Renders as expected when product and productDimensions are defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: [{ DimensionTypeValue: 1 }]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.configure).toBeTruthy();
    });
    it('Renders as expected when productPrice is defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productPrice: {
                    status: 'SUCCESS',
                    result: {
                        CustomerContextualPrice: 15
                    }
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).toBeTruthy();
    });
    it('Renders as expected when ratingSummary is not defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).not.toBeTruthy();
        expect(viewProps.rating).not.toBeTruthy();
    });
    it('Renders as expected when ratingSummary and product is defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                ratingsSummary: {
                    status: 'SUCCESS',
                    result: {
                        averageRating: 3.7,
                        reviewsCount: 1000
                    }
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: { ...mockSlots,
                storeSelector: [(React.createElement("div", null, "Store Selector"))]
            },
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.title).toBeTruthy();
        expect(viewProps.description).toBeTruthy();
        expect(viewProps.addToCart).toBeTruthy();
        expect(viewProps.price).not.toBeTruthy();
        expect(viewProps.rating).toBeTruthy();
    });
    it('Renders add to wishlist as expected when product is defined', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.addToWishlist).toBeTruthy();
    });
    it('Renders quantity as expected', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        expect(viewProps.quantity).toBeTruthy();
    });
    it('When quantity updates, quantity in add to cart updates too', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const quantityProps = viewProps.quantity.input.props;
        quantityProps.onChange(2);
        expect(result.state().quantity).toEqual(2);
    });
    it('When add to cart fails, properly updates state when add to cart fails with EMPTYINPUT', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'EMPTYINPUT' });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('Add to cart failed. Please refresh and retry');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED but not MAXQUANTITY', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED' });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('Add to cart failed. Please refresh and retry');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                cart: {
                    status: 'FAILED',
                    result: {
                        cart: {
                            Id: 'id',
                            CartLines: [{ ProductId: 10 }]
                        }
                    }
                },
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Available',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY' } });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 5 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and use config value', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                cart: {
                    status: 'FAILED',
                    result: {
                        cart: {
                            Id: 'id',
                            CartLines: [{ ProductId: 10 }]
                        }
                    }
                },
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Available',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContextWithMaxQuantity),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY' } });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and use config value and no availableQty', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                cart: {
                    status: 'FAILED',
                    result: {
                        cart: {
                            Id: 'id',
                            CartLines: [{ ProductId: 10 }]
                        }
                    }
                },
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                }
            }, {}, {}, mockContextWithMaxQuantity),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY' } });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and uses default value', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                cart: {
                    status: 'FAILED',
                    result: {
                        cart: {
                            Id: 'id',
                            CartLines: [{ ProductId: 10 }]
                        }
                    }
                },
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Available',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContextNoMaxQuantity),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY' } });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with CARTACTIONFAILED and result substatus MAXQUANTITY and no availbleQty', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                cart: {
                    status: 'FAILED',
                    result: {
                        cart: {
                            Id: 'id',
                            CartLines: [{ ProductId: 10 }]
                        }
                    }
                },
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                }
            }, {}, {}, mockContextNoMaxQuantity),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'CARTACTIONFAILED', cartActionResult: { status: 'FAILED', substatus: 'MAXQUANTITY' } });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toEqual('You already have 0 of this item in your shopping bag. You can only add 10 of this item to your shopping bag');
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and 0 stock left', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'OUTOFSTOCK', stockLeft: 0 });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('This product is out of stock');
    });
    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and 1 stock left', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'OUTOFSTOCK', stockLeft: 1 });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('There is only one product left. Please choose quantity within the available range');
    });
    it('When add to cart fails, properly updates state when add to cart fails with OUTOFSTOCK and more than one stock left', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'OUTOFSTOCK', stockLeft: 5 });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
        expect(state.errorState.quantityError).toEqual('There are only 5 products left. Please choose quantity within the available range');
    });
    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'MISSINGDIMENSION', missingDimensions: [
                { DimensionTypeValue: 3 },
                { DimensionTypeValue: 1 },
                { DimensionTypeValue: 4 }
            ] });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors[1]).toEqual('Color is required. Please choose a color');
        expect(state.errorState.configureErrors[2]).toBeUndefined();
        expect(state.errorState.configureErrors[3]).toEqual('Size is required. Please choose a size');
        expect(state.errorState.configureErrors[4]).toEqual('Style is required. Please choose a style');
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION but no missing dimensions returned', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'MISSINGDIMENSION' });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors).toEqual({});
    });
    it('When add to cart fails, properly updates state when add to cart fails with MISSINGDIMENSION even if dimension ids don\'t match whats expected', () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'MISSINGDIMENSION', missingDimensions: [
                { DimensionTypeValue: 2 },
                { DimensionTypeValue: 5 }
            ] });
        const state = result.state();
        expect(state.errorState.errorHost).toEqual('ADDTOCART');
        expect(state.errorState.otherError).toBeUndefined();
        expect(state.errorState.configureErrors[1]).toBeUndefined();
        expect(state.errorState.configureErrors[2]).toEqual('Configuration is required. Please choose a configuration');
        expect(state.errorState.configureErrors[3]).toBeUndefined();
        expect(state.errorState.configureErrors[4]).toBeUndefined();
        expect(state.errorState.configureErrors[5]).toEqual('');
        expect(state.errorState.quantityError).toBeUndefined();
    });
    it('Callbacks work', async () => {
        let callbacks;
        getBuyboxProductConfigure = jest.fn().mockImplementation((props, state, callback) => {
            callbacks = callback;
            return undefined;
        });
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(getBuyboxProductConfigure).toBeCalled();
        expect(callbacks).toBeDefined();
        callbacks.updateErrorState({
            errorHost: 'ADDTOCART',
            configureErrors: {
                1: 'Error 1',
                2: 'Error 2',
                4: 'Error 4'
            }
        });
        expect(result.state().errorState.configureErrors[1]).toEqual('Error 1');
        expect(result.state().errorState.configureErrors[2]).toEqual('Error 2');
        expect(result.state().errorState.configureErrors[4]).toEqual('Error 4');
        const test = await callbacks.dimensionSelectedAsync(4, '0');
        expect(test).toBeUndefined();
    });
    it('updateSelectedProduct Callbacks', async () => {
        let callbacks;
        getBuyboxProductConfigure = jest.fn().mockImplementation((props, state, callback) => {
            callbacks = callback;
            return undefined;
        });
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(getBuyboxProductConfigure).toBeCalled();
        expect(callbacks).toBeDefined();
        callbacks.updateSelectedProduct(new Promise((resolve) => resolve(null)), undefined, undefined, undefined);
        expect(result.state().selectedProduct).toBeDefined();
        expect(await (result.state().selectedProduct)).toEqual(null);
    });
    it('_getDropdownName tests', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions,
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        expect(viewProps.callbacks.getDropdownName(1, mockResources)).toEqual('Color');
        expect(viewProps.callbacks.getDropdownName(2, mockResources)).toEqual('Configuration');
        expect(viewProps.callbacks.getDropdownName(3, mockResources)).toEqual('Size');
        expect(viewProps.callbacks.getDropdownName(4, mockResources)).toEqual('Style');
        expect(viewProps.callbacks.getDropdownName(5, mockResources)).toEqual('');
    });
    it('dimensionSelectedAsync -- updates state to newly selected dimension', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions,
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        expect(result.state().selectedDimensions[4]).toEqual('0');
    });
    it('dimensionSelectedAsync -- clears error states after selecting new dimension', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions,
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        viewProps.callbacks.updateErrorState({
            errorHost: 'ADDTOCART',
            configureErrors: {
                1: 'Error 1',
                2: 'Error 2',
                4: 'Error 4'
            }
        });
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        expect(result.state().errorState.configureErrors[4]).toBeUndefined();
    });
    it('dimensionSelectedAsync -- If getSelectedVariant returns null doesnt get dimensions', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions,
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue(undefined);
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).not.toBeCalled();
    });
    it('dimensionSelectedAsync -- If getSelectedVariant returns not null, does get dimensions', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    },
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions,
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getPriceForSelectedVariant).toBeCalled();
        expect(RetailActions.getDeliveryOptionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
    });
    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns AVAILABLE', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Available',
                            StockLevelCode: 'X123',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel);
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });
    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns LOW STOCK AVAIABLE', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Low stock available',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel);
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Low stock available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });
    it('renders Inventory level label correctly, if getBuyBoxInventoryLabel returns ONLY FEW AVAILABLE', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Only few available',
                            ProductAvailableQuantity: { AvailableQuantity: 10 }
                        }
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        const test = mount(viewProps.inventoryLabel);
        RetailActions.getSelectedVariant = jest.fn().mockResolvedValue({ RecordId: '10' });
        RetailActions.getDimensionsForSelectedVariant = jest.fn().mockResolvedValue(undefined);
        await viewProps.callbacks.dimensionSelectedAsync(4, '0');
        const selectedProduct = await result.state().selectedProduct;
        expect(selectedProduct).not.toBeUndefined();
        expect(RetailActions.getSelectedVariant).toBeCalled();
        expect(RetailActions.getDimensionsForSelectedVariant).toBeCalled();
        expect(RetailActions.getProductAvailabilitiesForSelectedVariant).toBeCalled();
        expect(test.text()).toBe('Only few available');
        expect(viewProps.inventoryLabel).toMatchSnapshot();
    });
    it('renders inventory label correctly, when add to cart fails with OUTOFSTOCK', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        expect(moduleProps.renderView).toBeCalled();
        const viewProps = result.childAt(0).props().props;
        expect(viewProps).toBeDefined();
        const addToCartProps = viewProps.addToCart.button.props;
        addToCartProps.onError({ failureReason: 'OUTOFSTOCK', stockLeft: 0 });
        const state = result.state();
        expect(addToCartProps.outOfStockText).toEqual('Out of Stock');
        expect(state.errorState.quantityError).toEqual('This product is out of stock');
    });
    it('renders Inventory level label correctly ,if getBuyBoxInventoryLabel returns undefined', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions
                },
                productAvailableQuantity: {
                    status: 'LOADING',
                    result: [
                        {}
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps)));
        const viewProps = result.childAt(0).props().props;
        expect(viewProps.inventoryLabel).toBe(undefined);
    });
    it('renders SimilarLook product', async () => {
        moduleProps = {
            ...buildMockModuleProps({
                ...mockData,
                product: {
                    status: 'SUCCESS',
                    result: {
                        RecordId: 10
                    }
                },
                ratingsSummary: {
                    status: 'SUCCESS',
                    result: {
                        reviewsCount: 1000
                    }
                },
                productDimensions: {
                    status: 'SUCCESS',
                    result: mockDimensions
                },
                productAvailableQuantity: {
                    status: 'SUCCESS',
                    result: [
                        {
                            StockLevelLabel: 'Only few available'
                        }
                    ]
                }
            }, {}, {}, mockContext),
            renderView: jest.fn(props => { return React.createElement("div", { props: props }); }),
            slots: mockSlots,
            resources: mockResources
        };
        const moduleProps2 = { ...moduleProps, config: { enableShopSimilarLooks: true } };
        const result = mount(React.createElement(Buybox, Object.assign({}, moduleProps2)));
        const viewProps = result.childAt(0).props().props;
        expect(viewProps.shopSimilarLook).toBeDefined();
    });
});
//# sourceMappingURL=buybox.test.js.map
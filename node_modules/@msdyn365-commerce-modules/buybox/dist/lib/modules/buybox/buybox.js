import { getDeliveryOptionsForSelectedVariant, GetDeliveryOptionsForSelectedVariantInput, getDimensionsForSelectedVariant, GetDimensionsForSelectedVariantInput, getPriceForSelectedVariant, getProductAvailabilitiesForSelectedVariant, getSelectedVariant, PriceForSelectedVariantInput, ProductAvailabilitiesForSelectedVariantInput, SelectedVariantInput } from '@msdyn365-commerce-modules/retail-actions';
import { getTelemetryObject } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import * as React from 'react';
import { getBuyboxAddToCart, getBuyboxFindInStore, getBuyBoxInventoryLabel, getBuyboxProductAddToOrderTemplate, getBuyboxProductAddToWishlist, getBuyboxProductConfigure, getBuyboxProductDescription, getBuyboxProductPrice, getBuyboxProductQuantity, getBuyboxProductRating, getBuyboxProductTitle, getBuyboxShopSimilarLook } from './components';
class Buybox extends React.PureComponent {
    constructor(props, state) {
        super(props);
        this.buyboxCallbacks = {
            updateQuantity: (newQuantity) => {
                const errorState = { ...this.state.errorState };
                errorState.quantityError = undefined;
                errorState.otherError = undefined;
                this.setState({ quantity: newQuantity, errorState: errorState });
            },
            updateErrorState: (newErrorState) => {
                this.setState({ errorState: newErrorState });
            },
            updateSelectedProduct: (newSelectedProduct, newInventory, newPrice, newDeliveryOptions) => {
                this.setState({
                    selectedProduct: newSelectedProduct,
                    productAvailableQuantity: newInventory,
                    productPrice: newPrice,
                    productDeliveryOptions: newDeliveryOptions
                });
            },
            dimensionSelectedAsync: (selectedDimensionId, selectedDimensionValueId) => {
                return this._dimensionSelected(selectedDimensionId, selectedDimensionValueId);
            },
            getDropdownName: (dimensionType, resources) => {
                return this._getDropdownName(dimensionType, resources);
            },
            changeModalOpen: (isModalOpen) => {
                this.setState({ modalOpen: isModalOpen });
            },
            changeUpdatingDimension: (isUpdatingDimension) => {
                this.setState({ isUpdatingDimension: isUpdatingDimension });
            }
        };
        this._dimensionSelected = async (selectedDimensionId, selectedDimensionValue) => {
            const { data: { product: { result: product }, productDimensions: { result: productDimensions }, }, context: { actionContext, request: { apiSettings: { channelId } } } } = this.props;
            const { selectedDimensions } = this.state;
            if (!product || !productDimensions) {
                return;
            }
            if (this.state.errorState.otherError) {
                const clearOtherErrorState = { ...this.state.errorState };
                clearOtherErrorState.otherError = undefined;
                this.setState({ errorState: clearOtherErrorState });
            }
            const newSelectedDimensions = { ...selectedDimensions };
            newSelectedDimensions[selectedDimensionId] = selectedDimensionValue;
            this.setState({ selectedDimensions: newSelectedDimensions, isUpdatingDimension: true });
            if (this.state.errorState.configureErrors[selectedDimensionId]) {
                const errorState = { ...this.state.errorState };
                errorState.configureErrors[selectedDimensionId] = undefined;
                this.setState({ errorState: errorState });
            }
            const mappedDimensions = productDimensions.map(dimension => {
                return {
                    DimensionTypeValue: dimension.DimensionTypeValue,
                    DimensionValue: this._updateDimensionValue(dimension, newSelectedDimensions[dimension.DimensionTypeValue]) || dimension.DimensionValue,
                    ExtensionProperties: dimension.ExtensionProperties
                };
            }).filter(dimension => {
                return dimension && dimension.DimensionValue;
            });
            const selectedProduct = new Promise(async (resolve, reject) => {
                const newProduct = (await getSelectedVariant(new SelectedVariantInput(product.MasterProductId ? product.MasterProductId : product.RecordId, channelId, mappedDimensions), actionContext));
                if (newProduct) {
                    await getDimensionsForSelectedVariant(new GetDimensionsForSelectedVariantInput(newProduct.MasterProductId ? newProduct.MasterProductId : newProduct.RecordId, channelId, mappedDimensions), actionContext);
                }
                resolve(newProduct);
            });
            this.setState({ selectedProduct: selectedProduct });
            const variantProduct = await selectedProduct;
            if (variantProduct) {
                const newAvailableQuantity = await getProductAvailabilitiesForSelectedVariant(new ProductAvailabilitiesForSelectedVariantInput(variantProduct.RecordId, channelId), actionContext);
                const PRODUCTASSERVICE = 2;
                if (variantProduct.ItemTypeValue === PRODUCTASSERVICE) {
                    this.setState({ isServiceItem: true });
                }
                if (newAvailableQuantity && newAvailableQuantity.length) {
                    this.setState({ productAvailableQuantity: newAvailableQuantity[0] });
                }
                else {
                    this.setState({ productAvailableQuantity: undefined });
                }
                const newPrice = await getPriceForSelectedVariant(new PriceForSelectedVariantInput(variantProduct.RecordId, channelId), actionContext);
                if (newPrice) {
                    this.setState({ productPrice: newPrice });
                }
                const newDeliveryOptions = await getDeliveryOptionsForSelectedVariant(new GetDeliveryOptionsForSelectedVariantInput(variantProduct.RecordId, channelId), actionContext);
                if (newDeliveryOptions) {
                    this.setState({ productDeliveryOptions: newDeliveryOptions });
                }
            }
        };
        this._updateDimensionValue = (productDimensionFull, newValueId) => {
            if (newValueId && productDimensionFull.DimensionValues) {
                return productDimensionFull.DimensionValues.find(dimension => dimension.RecordId === +newValueId);
            }
            return undefined;
        };
        this._getDropdownName = (dimensionType, resources) => {
            switch (dimensionType) {
                case 1:
                    return resources.productDimensionTypeColor;
                case 2:
                    return resources.productDimensionTypeConfiguration;
                case 3:
                    return resources.productDimensionTypeSize;
                case 4:
                    return resources.productDimensionTypeStyle;
                default:
                    return '';
            }
        };
        this.state = {
            errorState: {
                configureErrors: {}
            },
            quantity: 1,
            selectedProduct: undefined,
            selectedDimensions: {},
            productPrice: undefined,
            productDeliveryOptions: undefined,
            modalOpen: false,
            isUpdatingDimension: false
        };
        this.telemetryContent = getTelemetryObject(props.context.request.telemetryPageName, props.friendlyName, props.telemetry);
    }
    render() {
        const { slots: { mediaGallery, }, data: { product: { result: product } }, config: { className = '' } } = this.props;
        if (!product) {
            this.props.context.telemetry.error('Product content is empty, module wont render');
            return null;
        }
        const viewProps = {
            ...this.props,
            state: this.state,
            mediaGallery: mediaGallery && mediaGallery.length > 0 ? mediaGallery[0] : undefined,
            ModuleProps: {
                moduleProps: this.props,
                className: classnames('ms-buybox', className)
            },
            ProductInfoContainerProps: {
                className: 'ms-buybox__content'
            },
            MediaGalleryContainerProps: {
                className: 'ms-buybox__media-gallery'
            },
            telemetryContent: this.telemetryContent,
            callbacks: this.buyboxCallbacks,
            title: getBuyboxProductTitle(this.props),
            description: getBuyboxProductDescription(this.props),
            configure: getBuyboxProductConfigure(this.props, this.state, this.buyboxCallbacks),
            findInStore: getBuyboxFindInStore(this.props, this.state, this.buyboxCallbacks),
            price: getBuyboxProductPrice(this.props),
            addToCart: getBuyboxAddToCart(this.props, this.state, this.buyboxCallbacks),
            addToOrderTemplate: getBuyboxProductAddToOrderTemplate(this.props, this.state, this.buyboxCallbacks),
            addToWishlist: getBuyboxProductAddToWishlist(this.props, this.state, this.buyboxCallbacks),
            rating: !this.props.context.app.config.hideRating && getBuyboxProductRating(this.props),
            quantity: getBuyboxProductQuantity(this.props, this.state, this.buyboxCallbacks),
            inventoryLabel: getBuyBoxInventoryLabel(this.props),
            shopSimilarLook: this.props.config.enableShopSimilarLooks ? getBuyboxShopSimilarLook(this.props, this.state, this.buyboxCallbacks) : undefined
        };
        return this.props.renderView(viewProps);
    }
}
export default Buybox;
//# sourceMappingURL=buybox.js.map
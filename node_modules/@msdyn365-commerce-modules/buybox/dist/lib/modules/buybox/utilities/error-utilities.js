export function getQuantityError(stockLeft, resources) {
    if (!stockLeft || stockLeft <= 0) {
        return resources.errorMessageOutOfStock;
    }
    else if (stockLeft === 1) {
        return resources.errorMessageOutOfRangeOneLeft;
    }
    else {
        return resources.errorMessageOutOfRangeFormat.replace('{numLeft}', stockLeft.toString());
    }
}
export function getGenericError(result, cart, resources, context, product, productAvailability, location) {
    if (result.failureReason === 'EMPTYINPUT') {
        return resources.addedToCartFailureMessage;
    }
    else if (result.failureReason === 'CARTACTIONFAILED') {
        if (result.cartActionResult && result.cartActionResult.substatus === 'MAXQUANTITY') {
            let elementFoundAt = -1;
            const productIdToFind = product?.RecordId;
            for (let i = 0; i < cart.cart.CartLines.length; i++) {
                if (cart.cart.CartLines[i].ProductId === productIdToFind &&
                    (cart.cart.CartLines[i].DeliveryMode || '') === (location && context.actionContext.requestContext.channel?.PickupDeliveryModeCode || '') &&
                    (cart.cart.CartLines[i].FulfillmentStoreId || '') === (location?.OrgUnitNumber || '')) {
                    elementFoundAt = i;
                    break;
                }
            }
            let curQuantity = 0;
            if (elementFoundAt !== -1) {
                const cartLineToUpdate = { ...cart.cart.CartLines[elementFoundAt] };
                curQuantity = cartLineToUpdate.Quantity || 0;
            }
            const maxQuantityForCartLineItem = context.app.config.maxQuantityForCartLineItem;
            const availableQty = productAvailability?.AvailableQuantity;
            let quantityLimit;
            if (maxQuantityForCartLineItem === undefined && availableQty === undefined) {
                quantityLimit = 10;
            }
            else if (availableQty === undefined) {
                quantityLimit = maxQuantityForCartLineItem;
            }
            else if (maxQuantityForCartLineItem === undefined) {
                quantityLimit = availableQty;
            }
            else {
                quantityLimit = Math.min(maxQuantityForCartLineItem, availableQty);
            }
            return resources.maxQuantityLimitText.replace('{curQuantity}', curQuantity.toString()).replace('{maxQuantity}', quantityLimit.toString());
        }
        return resources.addedToCartFailureMessage;
    }
    return undefined;
}
export function getConfigureErrors(result, resources) {
    if (!result) {
        return {};
    }
    const dimensions = {};
    result.forEach(dimension => {
        dimensions[dimension.DimensionTypeValue] = getDimensionErrorString(dimension.DimensionTypeValue, resources);
    });
    return dimensions;
}
export function getDimensionErrorString(dimensionTypeValue, resources) {
    switch (dimensionTypeValue) {
        case 1:
            return resources.productDimensionTypeColorErrorMessage;
        case 2:
            return resources.productDimensionTypeConfigurationErrorMessage;
        case 3:
            return resources.productDimensionTypeSizeErrorMessage;
        case 4:
            return resources.productDimensionTypeStyleErrorMessage;
        default:
            return '';
    }
}
//# sourceMappingURL=error-utilities.js.map
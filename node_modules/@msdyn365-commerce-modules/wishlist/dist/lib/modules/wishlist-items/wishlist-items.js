import { __decorate } from "tslib";
import { getProductUrlSync } from '@msdyn365-commerce-modules/retail-actions';
import { getTelemetryObject } from '@msdyn365-commerce-modules/utilities';
import * as MsDyn365 from '@msdyn365-commerce/core';
import { createGetByCustomerInput, removeLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CommerceListsDataActions.g';
import classnames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import getItemsInWishlists, { ActiveWishlistInput } from './actions/get-items-in-wishlists';
import { WishlistItem, WishlistItemsStatusMessage } from './components/';
let WishlistItems = class WishlistItems extends React.Component {
    constructor(props) {
        super(props);
        this.handleHeadingChange = (event) => this.props.config.heading.text = event.target.value;
        this._onDismiss = () => {
            this.setState({
                isOpen: false
            });
        };
        this._renderHeading = (heading) => {
            if (!heading) {
                return undefined;
            }
            return (React.createElement(MsDyn365.Text, { className: 'ms-wishlist-items__heading', tag: heading.tag || 'h2', text: heading.text, editProps: { onEdit: this.handleHeadingChange, requestContext: this.props.context.request } }));
        };
        this._addItemToCart = async (product, itemKey) => {
            const { context, data, resources, telemetry } = this.props;
            const { cart, productAvailability } = data;
            const { addedToCartSuccessMessage, addedToCartFailureMessage } = resources;
            const productInventoryInformation = this._getProductInventory({ ProductDetails: product }, productAvailability.result);
            if (context) {
                if (cart.result) {
                    const addProductToCartInput = {
                        product: product,
                        quantity: 1,
                        enableStockCheck: context.app.config.enableStockCheck,
                        availableQuantity: productInventoryInformation ? productInventoryInformation.ProductAvailableQuantity.AvailableQuantity : 0
                    };
                    cart.result.addProductToCart(addProductToCartInput)
                        .then(async (result) => {
                        if (result.status === 'SUCCESS') {
                            this.setState({
                                productId: product.RecordId,
                                itemKey: itemKey,
                                userMessage: addedToCartSuccessMessage,
                                statusCssString: 'success',
                                messageGlyph: 'fas fa-check',
                                isOpen: true
                            });
                        }
                        else if (result.substatus === 'MAXQUANTITY') {
                            const curQuantity = (await cart).cart?.CartLines?.find(item => item.ProductId === product.RecordId)?.Quantity || 0;
                            const maxQtyLimitReachedMessage = this._getInventoryValueMessage(productInventoryInformation, curQuantity);
                            this.setState({
                                productId: product.RecordId,
                                itemKey: itemKey,
                                userMessage: maxQtyLimitReachedMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        }
                        else {
                            this.props.telemetry.debug('[wishlist-items] Unable to Update Cart Line from the wishlist');
                            this.setState({
                                productId: product.RecordId,
                                itemKey: itemKey,
                                userMessage: addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        }
                    })
                        .catch(error => {
                        telemetry.warning(error);
                        telemetry.debug('[wishlist-items] Error trying to Update Cart Line from the wishlist');
                        this.setState({
                            productId: product.RecordId,
                            itemKey: itemKey,
                            userMessage: addedToCartFailureMessage,
                            statusCssString: 'danger',
                            messageGlyph: 'fas fa-exclamation-triangle',
                            isOpen: true
                        });
                    });
                }
            }
        };
        this._removeItemFromWishlist = (productId) => {
            const { context, data, telemetry } = this.props;
            const { wishlists } = data;
            if (context && context.actionContext) {
                const userToken = context.request.user.isAuthenticated && context.request.user.token;
                const wishlistLineId = this._getWishlistLineIdFromProductId(productId);
                if (userToken && wishlists.result && wishlists.result[0] && wishlistLineId) {
                    removeLinesAsync({ callerContext: context.actionContext }, wishlists.result[0].Id, [{ LineId: wishlistLineId }])
                        .then(commerceList => {
                        const castCommerceList = commerceList;
                        if (castCommerceList && castCommerceList.Id && context.request.user.isAuthenticated) {
                            context.actionContext.update(createGetByCustomerInput({}, null), [castCommerceList]);
                            getItemsInWishlists(new ActiveWishlistInput(), context.actionContext)
                                .then((products) => {
                                const castSimpleProducts = products;
                                if (castSimpleProducts && castSimpleProducts.length > 0) {
                                    context.actionContext.update(new ActiveWishlistInput(), castSimpleProducts);
                                }
                            })
                                .catch(error => {
                                telemetry.warning('[wishlist-items] Unable to hyderate the wishlist with product information');
                                telemetry.error(error);
                            });
                        }
                    })
                        .catch(error => {
                        telemetry.warning('[wishlist-items] Unable remove items from the wishlist');
                        telemetry.error(error);
                    });
                }
                else {
                    telemetry.warning('[wishlist-items] Unable remove items from the wishlist user token or lineItemID wasn\'t found');
                }
            }
        };
        this._inventoryLabel = (product) => {
            const { productAvailability } = this.props.data;
            if (productAvailability && productAvailability.result) {
                const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
                if (productInventoryInformation) {
                    return productInventoryInformation.StockLevelLabel;
                }
            }
            return undefined;
        };
        this._inventoryClassName = (product) => {
            const { productAvailability } = this.props.data;
            if (productAvailability && productAvailability.result) {
                const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
                if (productInventoryInformation && productInventoryInformation.StockLevelCode) {
                    return `ms-wishlist-items__${productInventoryInformation.StockLevelCode.toLowerCase()}`;
                }
            }
            return undefined;
        };
        this._isProductInStock = (product) => {
            const { data, context } = this.props;
            const { productAvailability } = data;
            if (!context.app.config.enableStockCheck) {
                return true;
            }
            if (!productAvailability.result || !product.ProductDetails) {
                return false;
            }
            for (const productResult of productAvailability.result) {
                if (productResult.ProductAvailableQuantity &&
                    productResult.ProductAvailableQuantity.ProductId &&
                    productResult.ProductAvailableQuantity.ProductId === product.ProductDetails.RecordId) {
                    return productResult.IsProductAvailable;
                }
            }
            return false;
        };
        this._getWishlistLineIdFromProductId = (productId) => {
            const { wishlists } = this.props.data;
            if (!wishlists.result || !(wishlists.result.length > 0) || !wishlists.result[0].CommerceListLines || !(wishlists.result[0].CommerceListLines.length > 0)) {
                this.props.telemetry.error('Wishlist content is empty, module wont render.');
                return null;
            }
            const foundWishlistItem = wishlists.result[0].CommerceListLines.filter((commerceListLine) => {
                return commerceListLine.ProductId === productId;
            });
            if (foundWishlistItem && foundWishlistItem[0].LineId) {
                return foundWishlistItem[0].LineId;
            }
            else {
                return null;
            }
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    async componentDidMount() {
        this.setState({});
    }
    render() {
        const { heading, className } = this.props.config;
        const { emptyWishlistText, wishlistErrorGettingWishlist } = this.props.resources;
        const { cart, productAvailability, wishlists, products } = this.props.data;
        if (cart.status === 'LOADING' || productAvailability.status === 'LOADING' || wishlists.status === 'LOADING') {
            const errorProps = {
                ...this.props,
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'LOADING',
                statusMessage: React.createElement(WishlistItemsStatusMessage, { errorType: 'LOADING', text: 'Loading...' }),
                heading: this._renderHeading(heading)
            };
            return this.props.renderView(errorProps);
        }
        if (cart.status === 'FAILED' || productAvailability.status === 'FAILED' || wishlists.status === 'FAILED') {
            const errorProps = {
                ...this.props,
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'FAILED',
                statusMessage: React.createElement(WishlistItemsStatusMessage, { errorType: 'FAILED', text: wishlistErrorGettingWishlist }),
                heading: this._renderHeading(heading)
            };
            return this.props.renderView(errorProps);
        }
        const productsList = products && products.result;
        if (!!productsList && productsList.length === 0) {
            const emptyViewProps = {
                ...this.props,
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'EMPTY',
                statusMessage: React.createElement(WishlistItemsStatusMessage, { errorType: 'EMPTY', text: emptyWishlistText }),
                heading: this._renderHeading(heading)
            };
            return this.props.renderView(emptyViewProps);
        }
        const viewProps = {
            ...this.props,
            WishlistItems: {
                moduleProps: this.props,
                className: classnames('ms-wishlist-items', className),
            },
            status: 'SUCCESS',
            heading: this._renderHeading(heading),
            Products: {
                className: 'ms-wishlist-items__products',
                tag: 'ul',
            },
            Product: {
                className: 'ms-wishlist-items__product',
                tag: 'li',
            },
            ProductDetails: {
                className: 'ms-wishlist-items__product-link',
                tag: 'a',
            },
            telemetryContent: this.telemetryContent,
            ProductDimensions: {
                className: 'ms-wishlist-items__product-dimensions',
            },
            products: productsList && this._renderProductList(productsList),
        };
        return this.props.renderView(viewProps);
    }
    _renderProductList(products) {
        const { priceFree, originalPriceText, currentPriceText, addToCartButtonText, outOfStockText, removeButtonText, productDimensionTypeColor, productDimensionTypeSize, productDimensionTypeStyle } = this.props.resources;
        const { context, telemetry } = this.props;
        const { imageSettings, enableImageProductLink } = this.props.config;
        return products.map((product, index) => {
            const currentProductProps = {
                product: product.ProductDetails,
                price: product.ProductPrice,
                context: context,
                wishlistState: this.state,
                productUrl: getProductUrlSync(product.ProductDetails, context.actionContext, undefined),
                imageSettings: imageSettings,
                removeFromWishlistText: removeButtonText,
                isInStock: this._isProductInStock(product),
                addToCartText: addToCartButtonText,
                outOfStockText: outOfStockText,
                index: index,
                itemKey: `${product.ProductDetails.RecordId}-${product.ProductDetails.ItemId}-${index}`,
                telemetry: telemetry,
                moduleId: this.props.id,
                moduleTypeName: this.props.typeName,
                enableImageProductLink: enableImageProductLink,
                inventoryInformationLabel: this._inventoryLabel(product),
                inventoryLabelClassName: this._inventoryClassName(product),
                telemetryContent: this.telemetryContent,
                handlers: {
                    onAddToCart: this._addItemToCart,
                    onRemoveItem: this._removeItemFromWishlist,
                    onDismiss: this._onDismiss
                },
                resources: {
                    productDimensionTypeColor: productDimensionTypeColor,
                    productDimensionTypeSize: productDimensionTypeSize,
                    productDimensionTypeStyle: productDimensionTypeStyle,
                    freePriceText: priceFree,
                    originalPriceText: originalPriceText,
                    currentPriceText: currentPriceText
                }
            };
            return (WishlistItem(currentProductProps));
        });
    }
    _getInventoryValueMessage(product, curQuantity) {
        const { context, resources } = this.props;
        const { maxQuantityLimitText } = resources;
        const maxQuantityForLineItem = context.app.config.maxQuantityForCartLineItem || 10;
        if (!product || !product.ProductAvailableQuantity.AvailableQuantity || !context.app.config.enableStockCheck) {
            return maxQuantityLimitText.replace('{maxQuantity}', maxQuantityForLineItem.toString()).replace('{curQuantity}', curQuantity.toString());
        }
        const minInventory = Math.min(maxQuantityForLineItem, product.ProductAvailableQuantity.AvailableQuantity);
        return maxQuantityLimitText.replace('{maxQuantity}', minInventory.toString()).replace('{curQuantity}', curQuantity.toString());
    }
    _getProductInventory(product, productInventoryCollection) {
        if (productInventoryCollection && productInventoryCollection.length) {
            for (const productResult of productInventoryCollection) {
                if (product.ProductDetails.RecordId === productResult.ProductAvailableQuantity.ProductId) {
                    return productResult;
                }
            }
        }
        return undefined;
    }
};
WishlistItems = __decorate([
    observer
], WishlistItems);
export default WishlistItems;
//# sourceMappingURL=wishlist-items.js.map
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IProductInventoryInformation, wrapInRejectedAsyncResult, wrapInResolvedAsyncResult } from '@msdyn365-commerce-modules/retail-actions';
import { FullProduct } from '@msdyn365-commerce/commerce-entities';
import { buildHydratedMockActionContext, buildMockModuleProps } from '@msdyn365-commerce/core';
import * as GlobalStateActions from '@msdyn365-commerce/global-state';
import { AsyncResult, Cart, CommerceList } from '@msdyn365-commerce/retail-proxy';
import * as RetailActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CommerceListsDataActions.g';
import { mount } from 'enzyme';
import * as React from 'react';
import getActiveWishlistItems from '../actions/get-items-in-wishlists';
import WishlistItems from '../wishlist-items';
import { IWishlistItemsData } from '../wishlist-items.data';
import { HeadingTag, IWishlistItemsConfig, IWishlistItemsProps, IWishlistItemsResources } from '../wishlist-items.props.autogenerated';

// @ts-ignore partial mock
const mockFullProduct = {
  ProductDetails: {
    RecordId: 22565423116,
    ItemId: '2101',
    Name: 'A. Datum Compact Digital Camera M200',
    Description: 'A. Datum Compact Dig',
    ProductTypeValue: 5,
    DefaultUnitOfMeasure: 'Ea',
    BasePrice: 129,
    Price: 129,
    AdjustedPrice: 103.2,
    MasterProductId: 22565423455,
    Components: [],
    Dimensions: [
      {
        DimensionTypeValue: 1,
        DimensionValue: {
          RecordId: 22565420935,
          Value: 'Black',
          ExtensionProperties: []
        },
        ExtensionProperties: []
      },
      {
        DimensionTypeValue: 2,
        DimensionValue: {
          RecordId: 22565420935,
          Value: 'Invalid',
          ExtensionProperties: []
        },
        ExtensionProperties: []
      },
      {
        DimensionTypeValue: 3,
        DimensionValue: {
          RecordId: 22565420935,
          Value: 'Large',
          ExtensionProperties: []
        },
        ExtensionProperties: []
      },
      {
        DimensionTypeValue: 4,
        DimensionValue: {
          RecordId: 22565420935,
          Value: 'Hooded',
          ExtensionProperties: []
        },
        ExtensionProperties: []
      },
    ],
    Behavior: {
      HasSerialNumber: false,
      IsDiscountAllowed: true,
      IsManualDiscountAllowed: true,
      IsKitDisassemblyAllowed: false,
      IsNegativeQuantityAllowed: false,
      IsReturnAllowed: true,
      IsSaleAtPhysicalStoresAllowed: true,
      IsZeroSalePriceAllowed: false,
      KeyInPriceValue: 0,
      KeyInQuantityValue: 0,
      MustKeyInComment: false,
      MustPrintIndividualShelfLabelsForVariants: false,
      MustPromptForSerialNumberOnlyAtSale: false,
      MustWeighProductAtSale: false,
      ValidFromDateForSaleAtPhysicalStores: new Date('Wed Jul 03 2019 14:44:37 GMT-0700'),
      ValidToDateForSaleAtPhysicalStores: new Date('Wed Jul 03 2019 14:44:37 GMT-0700'),
      IsBlankSerialNumberAllowed: false,
      ExtensionProperties: [],
      IsStorageDimensionGroupLocationActive: false,
      IsStorageDimensionGroupLocationAllowBlankReceiptEnabled: false
    },
    LinkedProducts: [],
    PrimaryImageUrl: 'https://cms-ppe-imageresizer-mr.trafficmanager.net/cms/api/fabrikamsb/imageFileData/search?fileName=/Products%2F92091_000_001.png&w=315&h=315&q=80&m=6&f=jpg',
    ExtensionProperties: []
  },
  ProductPrice: {
    ProductId: 68719494542,
    ListingId: 68719494542,
    BasePrice: 165,
    TradeAgreementPrice: 165,
    AdjustedPrice: 165,
    CustomerContextualPrice: 165,
    DiscountAmount: 0,
    CurrencyCode: 'USD',
    ItemId: '93037',
    InventoryDimensionId: '#000000100000711B',
    UnitOfMeasure: 'ea',
    ValidFrom: new Date('Wed Jul 03 2019 14:44:37 GMT-0700'),
    ProductLookupId: 0,
    ChannelId: 68719478279,
    CatalogId: 0,
    DiscountLines: [],
    ExtensionProperties: []
  },
  ProductRating: {
    ProductId: 68719494542,
    AverageRating: 3,
    TotalRatings: 0,
    RatingDistribution: [],
    ExtensionProperties: []
  }
} as FullProduct;

const mockCartState = {
  cart: {
    Id: 'gB8DCi6AK3mzMavh08C4P18wFDbEEyto',
    Version: 123
  } as Cart,
  addProductToCart: jest.fn(),
};

const mockWishlistResult: CommerceList[] = [
  {
    Id: 112312412412,
    CommerceListLines: [
      {
        CommerceListId: 68719478990,
        LineId: 68719486568,
        ProductId: 22565423116
      }
    ]
  }
];

const mockCommerceList = {
  Id: 68719478990,
  CommerceListTypeValue: 1,
  CommerceListLines: [
    {
      CommerceListId: 68719478990,
      LineId: 68719485044,
      ProductId: 22565423116,
    }
  ]
};

const mockItemsInWishlist = [
  { mockFullProduct }
];
const productAvailabilityMockData:IProductInventoryInformation[] = [{
      ProductAvailableQuantity:{
        ProductId:10,
        AvailableQuantity:2000,
      },
      StockLevelCode:'x123',
      StockLevelLabel:'x123',
      IsProductAvailable:true,
      InventLocationId:'InventLocationId'
}];

const mockData: IWishlistItemsData = {
  products: wrapInResolvedAsyncResult<FullProduct[]>([]),
  // @ts-ignore
  cart: wrapInResolvedAsyncResult(mockCartState),
  wishlists: wrapInResolvedAsyncResult(mockWishlistResult),
  productAvailability: wrapInResolvedAsyncResult(productAvailabilityMockData)
};

const mockDataFailedResponse: IWishlistItemsData = {
  products: wrapInResolvedAsyncResult<FullProduct[]>([]),
  cart: {} as AsyncResult<GlobalStateActions.ICartState>,
  wishlists: wrapInResolvedAsyncResult<CommerceList[]>([]),
  productAvailability: wrapInRejectedAsyncResult<IProductInventoryInformation[]>([])
};

const mockConfig: IWishlistItemsConfig = {
  heading: {
    text: 'Wishlist',
    tag: HeadingTag.h2
  }
};

const mockResources: IWishlistItemsResources = {
  emptyWishlistText: 'Your wishlist is empty',
  removeButtonText: 'Remove from wishlist',
  removeButtonAriaLabel: 'Remove from wishlist',
  waitingClass: 'waiting',
  unableToGetWishlist: 'Unable to get your wishlists!',
  addToCartButtonText: 'add to cart',
  outOfStockText: 'This item is out of stock',
  addedToCartSuccessMessage: 'Added to your cart',
  addedToCartFailureMessage: 'Add to cart failed',
  maxQuantityLimitText: '"You already have {curQuantity} of this item in your shopping bag. You can only add {maxQuantity} of this item to your shopping bag"',
  priceFree: 'Free',
  originalPriceText: 'Original price',
  currentPriceText: 'Current price',
  productDimensionTypeColor: 'Color',
  productDimensionTypeSize: 'Size',
  productDimensionTypeStyle: 'Style',
  wishlistErrorGettingWishlist: 'Sorry we are unable to load your wishlist at this moment, please try again later.'
};

const mockActions = {};

const mockActionContext = buildHydratedMockActionContext();
// @ts-ignore
mockActionContext.requestContext.apiSettings = {baseImageUrl: 'https://cms-ppe-imageresizer-mr.trafficmanager.net/cms/api/fabrikamsb/imageFileData/search?fileName=/'};
// @ts-ignore
const mockContext: ICoreContext<{}> = {
  actionContext: mockActionContext,
  request: {
    user: {
      isAuthenticated: true,
      token: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ilg1ZVhrNHh5b2pORnVtMWtsMll0djhkbE5QNC1jNTdkTzZRR1RWQndhTmsifQ.eyJleHAiOjE1NzQzODA2MTQsIm5iZiI6MTU3NDM3NzAxNCwidmVyIjoiMS4wIiwiaXNzIjoiaHR0cHM6Ly9sb2dpbi5mYWJyaWthbS5jb20vMDcxODA4YzMtMDIxMy00ZjQzLWI1ZTItZGYwMTI2NmU0NGFlL3YyLjAvIiwic3ViIjoiMmE2YjYwZjMtNTE3NS00YmExLWI5YzYtODM2ODQ5MWYyMWQ2IiwiYXVkIjoiNWY2M2Y1MGQtZDdlNy00YTRlLTg1MzQtZTg3NTk5ZmMwZmQ5Iiwibm9uY2UiOiI2MzcwOTk3MzgxMzc3MDMyNjYuTURnM056a3lOekl0T0RnNE9TMDBOVGxqTFRnNFpqa3RPRFUyTm1VelkyWmtObUU0WWpFMlpUVXhOREF0TUdRMU5DMDBOR0UyTFdFNVlUTXRabU0xWmpjM05EQTFPRGhrIiwiaWF0IjoxNTc0Mzc3MDE0LCJhdXRoX3RpbWUiOjE1NzQzNzcwMTQsIm9pZCI6IjJhNmI2MGYzLTUxNzUtNGJhMS1iOWM2LTgzNjg0OTFmMjFkNiIsImdpdmVuX25hbWUiOiJKb3JkYW5Ud28iLCJmYW1pbHlfbmFtZSI6IkV1Z2VuaW8iLCJlbWFpbHMiOlsidi1qb2V1Z0BtaWNyb3NvZnQuY29tIl0sInRmcCI6IkIyQ18xX3Npc3VfcjJwcGUiLCJjX2hhc2giOiI3a2ZPSnFMRDhNUUFfMnBmdnBpQVBnIn0.XUqgKAIBfc2eQBGSeBjgvAzGNyxmftcxEQktcbvM2aeChseBrZfl9-Jd8E5FbwY4x2cAxeTG_-NH6J7An_Q4gcCiGVb625BSEmgVuOj9KLN3yuUmgz3BwRgyu_pbByqpLWQXQGdiNTUDPUEGRReINEVneqCQ18iXScTgy_r4kMjB3dHeV8eWfrdtXlFz4IAinfKU19eoc_FixpJ_6jjUzcnrwt9E9eEnd09dOjSeByM4KRUAY9RWVNrJiqK33-kyUXPT8QCR3bEP9ApTe2DTSirMvAfpQ7_9m99EB7MbF2a6CqpBaBlUTAdvavwIDSPGItSklJ8zNvNWDIL-laf5gg',
      customerAccountNumber: '004219'
    }
  },
  app: {
    config: {
      maxQuantityForCartLineItem: 10,
      outOfStockThreshold: 2,
      enableStockCheck: false
    }
  },
};

describe('WishlistItems', () => {
  let moduleProps: IWishlistItemsProps<IWishlistItemsData>;
  const mockConfig2: IWishlistItemsConfig = {
    heading: {
      text: 'Wishlist',
    }
  };
  beforeEach(() => {
    const productsList = [];
    productsList.push(mockFullProduct);
    productsList.push(mockFullProduct);
    mockData.products = wrapInResolvedAsyncResult(productsList);
    moduleProps = {
      ...buildMockModuleProps(mockData, mockActions, mockConfig2, mockContext) as IWishlistItemsProps<IWishlistItemsData>,
      resources: mockResources,
      // @ts-ignore
      renderView: jest.fn(props => <div props={props} />)
    };
  });
  it('default maxQuantity should be 10 ', async () => {
    delete moduleProps.context.app.config.maxQuantityForCartLineItem;
    mockCartState.addProductToCart.mockImplementation(() => Promise.resolve({substatus: 'MAXQUANTITY'}));
    mockCartState.cart.ExtensionProperties = [];
    // @ts-ignore
    GlobalStateActions.getCartState = jest.fn().mockImplementation(() => Promise.resolve(mockCartState));

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.addToCartButton).toBeDefined();
    const addToCartButton = mount(product.addToCartButton as React.ReactElement);
    addToCartButton.simulate('click');

    // tslint:disable-next-line:no-string-based-set-timeout
    await new Promise(resolve => setTimeout(resolve, 0));
    expect(wishlist.state('isOpen')).toBeTruthy();
    expect(wishlist.state('userMessage')).toEqual(mockResources.maxQuantityLimitText.replace('{curQuantity}', '0').replace('{maxQuantity}', '10'));
  });
  it('renders correctly', () => {
    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;
    expect(viewProps.status).toBe('SUCCESS');
  });

  it('Successful - add to cart', async () => {
    mockCartState.addProductToCart.mockImplementation(() => Promise.resolve({status: 'SUCCESS'}));
    // @ts-ignore
    GlobalStateActions.getCartState = jest.fn().mockImplementation(() => Promise.resolve(mockCartState));

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.addToCartButton).toBeDefined();
    const addToCartButton = mount(product.addToCartButton as React.ReactElement);
    addToCartButton.simulate('click');

    // tslint:disable-next-line:no-string-based-set-timeout
    await new Promise(resolve => setTimeout(resolve, 0));

    expect(wishlist.state('isOpen')).toBeTruthy();
    expect(wishlist.state('userMessage')).toEqual(mockResources.addedToCartSuccessMessage);
  });

  it('Failure - Max Quanity - add to cart', async () => {
    mockCartState.addProductToCart.mockImplementation(() => Promise.resolve({status: 'FAILED', substatus: 'MAXQUANTITY'}));
    mockCartState.cart.ExtensionProperties = [];
    // @ts-ignore
    GlobalStateActions.getCartState = jest.fn().mockImplementation(() => Promise.resolve(mockCartState));
    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.addToCartButton).toBeDefined();
    const addToCartButton = mount(product.addToCartButton as React.ReactElement);
    addToCartButton.simulate('click');
    // tslint:disable-next-line:no-string-based-set-timeout
    await new Promise(resolve => setTimeout(resolve, 0));
    expect(wishlist.state('isOpen')).toBeTruthy();
    expect(wishlist.state('userMessage')).toEqual(mockResources.maxQuantityLimitText.replace('{curQuantity}', '0').replace('{maxQuantity}', '10'));
  });

  it('Failure - Other - add to cart', async () => {
    mockCartState.addProductToCart.mockImplementation(() => Promise.resolve({status: 'FAILED'}));
    // @ts-ignore
    GlobalStateActions.getCartState = jest.fn().mockImplementation(() => Promise.resolve(mockCartState));

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.addToCartButton).toBeDefined();
    const addToCartButton = mount(product.addToCartButton as React.ReactElement);
    addToCartButton.simulate('click');

    // tslint:disable-next-line:no-string-based-set-timeout
    await new Promise(resolve => setTimeout(resolve, 0));

    expect(wishlist.state('isOpen')).toBeTruthy();
    expect(wishlist.state('userMessage')).toEqual(mockResources.addedToCartFailureMessage);
  });

  it('Add to cart shows out of stock text', async () => {
    const outOfStockContext = mockContext;
    outOfStockContext.app.config.enableStockCheck = true;
    outOfStockContext.app.config.maxQuantityForCartLineItem = null;

    const noStockModuleProps = {
      ...buildMockModuleProps(mockData, mockActions,{}, outOfStockContext) as IWishlistItemsProps<IWishlistItemsData>,
      resources: mockResources,
      // @ts-ignore
      renderView: jest.fn(props => <div props={props} />)
    };
    const wishlist = mount(<WishlistItems {...noStockModuleProps}/>);
    expect(noStockModuleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.addToCartButton).toBeDefined();
    expect(product.addToCartButton.props.title).toEqual('This item is out of stock');
  });

  it('ProductStatusMessage shows and can be dismissed', async () => {
    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();

    wishlist.setState({
      productId: mockFullProduct.ProductDetails.RecordId,
      itemKey: `${mockFullProduct.ProductDetails.RecordId}-${mockFullProduct.ProductDetails.ItemId}-0`,
      userMessage: mockResources.addedToCartSuccessMessage,
      statusCssString: 'success',
      messageGlyph: 'fas fa-check',
      isOpen: true
    });

    const viewProps = wishlist.childAt(0).props().props;

    expect(viewProps.products).toBeDefined();
    const product = viewProps.products[0];
    expect(product.productStatusMessage).toBeDefined();
    const statusMessage = mount(product.productStatusMessage as React.ReactElement);
    const closeButton = statusMessage.find('button.close');
    closeButton.simulate('click');
    expect(wishlist.state('isOpen')).toBeFalsy();
  });

  it('Successful - remove item', async () => {
    // @ts-ignore
    RetailActions.removeLinesAsync = jest.fn().mockImplementation(() => Promise.resolve(mockCommerceList));
    // @ts-ignore
    getActiveWishlistItems = jest.fn().mockImplementation(() => Promise.resolve(mockItemsInWishlist));

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;
    expect(viewProps.products).toBeDefined();

    const product = viewProps.products[0];
    expect(product.removeButton).toBeDefined();
    const removeButton = mount(product.removeButton as React.ReactElement);
    removeButton.simulate('click');

    // tslint:disable-next-line:no-string-based-set-timeout
    await new Promise(resolve => setTimeout(resolve, 0));

    expect(getActiveWishlistItems).toBeCalled();
  });

  it('renders failure message correctly', () => {
    moduleProps = {
      ...buildMockModuleProps(mockDataFailedResponse, mockActions, mockConfig, mockContext) as IWishlistItemsProps<IWishlistItemsData>,
      resources: mockResources,
      // @ts-ignore
      renderView: jest.fn(props => <div props={props} />)
    };
    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;
    expect(viewProps.status).toBe('FAILED');
    expect(viewProps.statusMessage).toMatchSnapshot();
  });

  it('renders empty message correctly', () => {
    mockData.products = wrapInRejectedAsyncResult<FullProduct[]>([]);
    moduleProps = {
      ...buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as IWishlistItemsProps<IWishlistItemsData>,
      resources: mockResources,
      // @ts-ignore
      renderView: jest.fn(props => <div props={props} />)
    };

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;
    expect(viewProps.status).toBe('EMPTY');
    expect(viewProps.statusMessage).toMatchSnapshot();
  });

  it('renders loading  message correctly', () => {
    mockData.cart.status = 'LOADING';
    moduleProps = {
      ...buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as IWishlistItemsProps<IWishlistItemsData>,
      resources: mockResources,
      // @ts-ignore
      renderView: jest.fn(props => <div props={props} />)
    };

    const wishlist = mount(<WishlistItems {...moduleProps}/>);
    expect(moduleProps.renderView).toBeCalled();
    const viewProps = wishlist.childAt(0).props().props;
    expect(viewProps.status).toBe('LOADING');
    expect(viewProps.statusMessage).toMatchSnapshot();
  });
});

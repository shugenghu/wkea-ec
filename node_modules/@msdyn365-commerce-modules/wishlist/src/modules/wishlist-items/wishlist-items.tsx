/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { getProductUrlSync, IProductInventoryInformation } from '@msdyn365-commerce-modules/retail-actions';
import { getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import { FullProduct } from '@msdyn365-commerce/commerce-entities';
import * as MsDyn365 from '@msdyn365-commerce/core';
import { AsyncResult, CommerceList, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { createGetByCustomerInput, removeLinesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CommerceListsDataActions.g';
import classnames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import getItemsInWishlists, { ActiveWishlistInput } from './actions/get-items-in-wishlists';
import { IWishlistItemViewProps, WishlistItem, WishlistItemsStatusMessage } from './components/';
import { IWishlistItemsData } from './wishlist-items.data';
import { IHeadingData, IWishlistItemsProps } from './wishlist-items.props.autogenerated';

export interface IWishlistItemActionMessageState {
    productId: number;
    itemKey: string;
    userMessage: string;
    statusCssString: string;
    messageGlyph: string;
    isOpen: boolean;
}

export type wishlistStatus = 'LOADING' | 'SUCCESS' | 'FAILED' | 'EMPTY';

export interface IWishlistItemsViewProps extends IWishlistItemsProps<IWishlistItemsData> {
    WishlistItems: IModuleProps;
    status?: wishlistStatus;
    statusMessage?: React.ReactNode;
    heading?: React.ReactNode;
    Products?: INodeProps;
    Product?: INodeProps;
    ProductDetails?: INodeProps;
    ProductDimensions?: INodeProps;
    products?: IWishlistItemViewProps[];
    telemetryContent?: ITelemetryContent;
}

/**
 *
 * WishlistItems component
 * @extends {React.PureComponent<IWishlistItemsProps<IWishlistItemsData>, IWishlistItemActionMessageState>}
 */
@observer
class WishlistItems extends React.Component<IWishlistItemsProps<IWishlistItemsData>, IWishlistItemActionMessageState> {

    private telemetryContent: ITelemetryContent;

    constructor(props: IWishlistItemsProps<IWishlistItemsData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,  this.props.friendlyName, this.props.telemetry);
    }

    public async componentDidMount(): Promise<void> {
        this.setState({});
    }

    public render(): JSX.Element | null {
        const { heading, className } = this.props.config;
        const { emptyWishlistText, wishlistErrorGettingWishlist } = this.props.resources;
        const { cart, productAvailability, wishlists, products } = this.props.data;

        if (cart.status === 'LOADING' || productAvailability.status === 'LOADING' || wishlists.status === 'LOADING') {
            const errorProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'LOADING',
                // statusMessage: <Waiting className={ waitingClass || 'ms-wishlist-items__message-loading'} />
                statusMessage: <WishlistItemsStatusMessage errorType='LOADING' text='Loading...'/>,
                heading: this._renderHeading(heading)
            };
            return this.props.renderView(errorProps);
        }

        if (cart.status === 'FAILED' || productAvailability.status === 'FAILED' || wishlists.status === 'FAILED') {
            const errorProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'FAILED',
                statusMessage: <WishlistItemsStatusMessage errorType='FAILED' text={ wishlistErrorGettingWishlist }/>,
                heading: this._renderHeading(heading)
            };

            return this.props.renderView(errorProps);
        }

        const productsList = products && (products as AsyncResult<FullProduct[]>).result;

        if (!!productsList && productsList.length === 0) {
            const emptyViewProps: IWishlistItemsViewProps = {
                ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
                WishlistItems: {
                    moduleProps: this.props,
                    className: classnames('ms-wishlist-items', className),
                },
                status: 'EMPTY',
                statusMessage: <WishlistItemsStatusMessage errorType='EMPTY' text={ emptyWishlistText }/>,
                heading: this._renderHeading(heading)
            };

            return this.props.renderView(emptyViewProps);
        }

        const viewProps: IWishlistItemsViewProps = {
            ...(this.props as IWishlistItemsProps<IWishlistItemsData>),
            WishlistItems: {
                moduleProps: this.props,
                className: classnames('ms-wishlist-items', className),
            },
            status: 'SUCCESS',
            heading: this._renderHeading(heading),
            Products: {
                className: 'ms-wishlist-items__products',
                tag: 'ul',
            },
            Product: {
                className: 'ms-wishlist-items__product',
                tag: 'li',
            },
            ProductDetails: {
                className: 'ms-wishlist-items__product-link',
                tag: 'a',
            },
            telemetryContent: this.telemetryContent,
            ProductDimensions: {
                className: 'ms-wishlist-items__product-dimensions',
            },
            products: productsList && this._renderProductList(productsList),
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public handleHeadingChange = (event: MsDyn365.ContentEditableEvent) => this.props.config.heading!.text = event.target.value;

    private _renderProductList(products: FullProduct[]): IWishlistItemViewProps[] {

        const { priceFree, originalPriceText, currentPriceText, addToCartButtonText, outOfStockText, removeButtonText, productDimensionTypeColor, productDimensionTypeSize, productDimensionTypeStyle} = this.props.resources;
        const { context, telemetry } = this.props;
        const { imageSettings, enableImageProductLink } = this.props.config;

        return products.map((product: FullProduct, index) => {
            const currentProductProps = {
                product: product.ProductDetails,
                price: product.ProductPrice,
                context: context,
                wishlistState: this.state,
                productUrl: getProductUrlSync(product.ProductDetails, context.actionContext, undefined),
                imageSettings: imageSettings,
                removeFromWishlistText: removeButtonText,
                isInStock: this._isProductInStock(product),
                addToCartText: addToCartButtonText,
                outOfStockText: outOfStockText,
                index: index,
                itemKey: `${product.ProductDetails.RecordId}-${product.ProductDetails.ItemId}-${index}`,
                telemetry: telemetry,
                moduleId: this.props.id,
                moduleTypeName: this.props.typeName,
                enableImageProductLink: enableImageProductLink,
                inventoryInformationLabel: this._inventoryLabel(product),
                inventoryLabelClassName: this._inventoryClassName(product),
                telemetryContent: this.telemetryContent,
                handlers: {
                    onAddToCart: this._addItemToCart,
                    onRemoveItem: this._removeItemFromWishlist,
                    onDismiss: this._onDismiss
                },
                resources: {
                    productDimensionTypeColor: productDimensionTypeColor,
                    productDimensionTypeSize: productDimensionTypeSize,
                    productDimensionTypeStyle: productDimensionTypeStyle,
                    freePriceText: priceFree,
                    originalPriceText: originalPriceText,
                    currentPriceText: currentPriceText
                }
            };

            return (
                WishlistItem(currentProductProps)!
            );
        });
    }

    // dismiss alert when addingToCart/removeItem
    private _onDismiss = () => {
        this.setState({
            isOpen: false
        });
    }

    private _renderHeading = (heading?: IHeadingData): JSX.Element | undefined => {
        if(!heading) {
            return undefined;
        }
        return(
            <MsDyn365.Text
                className={'ms-wishlist-items__heading'}
                tag={heading.tag || 'h2'}
                text= {heading.text}
                editProps={{onEdit:this.handleHeadingChange, requestContext: this.props.context.request}}
            />
        );
    }

    private _addItemToCart = async (product: SimpleProduct, itemKey: string): Promise<void> => {
        const { context, data, resources, telemetry } = this.props;
        const { cart, productAvailability } = data;
        const { addedToCartSuccessMessage, addedToCartFailureMessage } = resources;

        const productInventoryInformation = this._getProductInventory({ProductDetails:product}, productAvailability.result);

        if (context) {
            if (cart.result) {
                const addProductToCartInput = {
                    product: product,
                    quantity: 1,
                    enableStockCheck: context.app.config.enableStockCheck,
                    availableQuantity: productInventoryInformation?productInventoryInformation.ProductAvailableQuantity.AvailableQuantity : 0
                };

                cart.result.addProductToCart(addProductToCartInput)
                        .then(async result => {
                            if (result.status === 'SUCCESS') {
                                this.setState({
                                    productId: product.RecordId,
                                    itemKey: itemKey,
                                    userMessage: addedToCartSuccessMessage,
                                    statusCssString: 'success',
                                    messageGlyph: 'fas fa-check',
                                    isOpen: true
                                });
                            } else if (result.substatus === 'MAXQUANTITY') {
                                const curQuantity = (await cart).cart?.CartLines?.find(item => item.ProductId === product.RecordId)?.Quantity || 0;
                                const maxQtyLimitReachedMessage =  this._getInventoryValueMessage(productInventoryInformation, curQuantity);

                                this.setState({
                                    productId: product.RecordId,
                                    itemKey: itemKey,
                                    userMessage: maxQtyLimitReachedMessage,
                                    statusCssString: 'danger',
                                    messageGlyph: 'fas fa-exclamation-triangle',
                                    isOpen: true
                                });
                            } else {
                                this.props.telemetry.debug('[wishlist-items] Unable to Update Cart Line from the wishlist');
                                this.setState({
                                    productId: product.RecordId,
                                    itemKey: itemKey,
                                    userMessage: addedToCartFailureMessage,
                                    statusCssString: 'danger',
                                    messageGlyph: 'fas fa-exclamation-triangle',
                                    isOpen: true
                                });
                            }
                        })
                        .catch(error => {
                            telemetry.warning(error);
                            telemetry.debug('[wishlist-items] Error trying to Update Cart Line from the wishlist');
                            this.setState({
                                productId: product.RecordId,
                                itemKey: itemKey,
                                userMessage: addedToCartFailureMessage,
                                statusCssString: 'danger',
                                messageGlyph: 'fas fa-exclamation-triangle',
                                isOpen: true
                            });
                        });
            }
        }
    };

    private _removeItemFromWishlist = (productId: number): void => {
        const { context, data, telemetry } = this.props;
        const { wishlists } = data;

        if (context && context.actionContext) {
            const userToken = context.request.user.isAuthenticated && context.request.user.token;
            const wishlistLineId = this._getWishlistLineIdFromProductId(productId);
            if (userToken && wishlists.result && wishlists.result[0] && wishlistLineId) {
                removeLinesAsync({ callerContext: context.actionContext }, wishlists.result[0].Id, [{ LineId: wishlistLineId }])
                    .then(commerceList => {
                        const castCommerceList: CommerceList | null = commerceList as (CommerceList | null);

                        if (castCommerceList && castCommerceList.Id && context.request.user.isAuthenticated) {
                            context.actionContext.update(createGetByCustomerInput({}, null), [castCommerceList]);
                            getItemsInWishlists(new ActiveWishlistInput(), context.actionContext)
                                .then((products) => {
                                    const castSimpleProducts: FullProduct[] | null = products as (FullProduct[] | null);
                                    if (castSimpleProducts && castSimpleProducts.length > 0) {
                                        context.actionContext.update(new ActiveWishlistInput(), castSimpleProducts);
                                    }
                                })
                                .catch(error => {
                                    telemetry.warning('[wishlist-items] Unable to hyderate the wishlist with product information');
                                    telemetry.error(error);
                                });
                        }
                    })
                    .catch(error => {
                        telemetry.warning('[wishlist-items] Unable remove items from the wishlist');
                        telemetry.error(error);
                    });
            } else {
                telemetry.warning('[wishlist-items] Unable remove items from the wishlist user token or lineItemID wasn\'t found');
            }
        }
    }

    private _getInventoryValueMessage(product: IProductInventoryInformation | undefined, curQuantity: number):string {
        const { context, resources } = this.props;
        const { maxQuantityLimitText } = resources;

        const maxQuantityForLineItem = context.app.config.maxQuantityForCartLineItem || 10;

        if(!product || !product.ProductAvailableQuantity.AvailableQuantity || !context.app.config.enableStockCheck) {
            return maxQuantityLimitText.replace('{maxQuantity}', maxQuantityForLineItem.toString()).replace('{curQuantity}', curQuantity.toString());
        }

        const minInventory = Math.min(maxQuantityForLineItem, product.ProductAvailableQuantity.AvailableQuantity);

        return maxQuantityLimitText.replace('{maxQuantity}', minInventory.toString()).replace('{curQuantity}', curQuantity.toString());
    }

    private _getProductInventory(product: FullProduct, productInventoryCollection: IProductInventoryInformation[] | undefined): IProductInventoryInformation | undefined {
        if(productInventoryCollection && productInventoryCollection.length) {
            for (const productResult of productInventoryCollection) {
                if(product.ProductDetails.RecordId === productResult.ProductAvailableQuantity.ProductId) {
                    return productResult;
                }
            }
        }
        return undefined;
    }

    private _inventoryLabel = (product: FullProduct):string | undefined => {
        const { productAvailability } = this.props.data;
        if(productAvailability && productAvailability.result) {
            const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
            if(productInventoryInformation) {
                return productInventoryInformation.StockLevelLabel;
            }
        }

        return undefined;
    }

    private _inventoryClassName = (product: FullProduct):string | undefined => {
        const { productAvailability } = this.props.data;
        if(productAvailability && productAvailability.result) {
            const productInventoryInformation = this._getProductInventory(product, productAvailability.result);
            if(productInventoryInformation && productInventoryInformation.StockLevelCode) {
                return `ms-wishlist-items__${productInventoryInformation.StockLevelCode.toLowerCase()}`;
            }
        }

        return undefined;
    }

    private _isProductInStock = (product: FullProduct): boolean => {
        const { data, context } = this.props;
        const { productAvailability } = data;

        if (!context.app.config.enableStockCheck) {
            return true;
        }

        if (!productAvailability.result || !product.ProductDetails) {
            return false;
        }

        for (const productResult of productAvailability.result) {
            if (productResult.ProductAvailableQuantity &&
                productResult.ProductAvailableQuantity.ProductId &&
                productResult.ProductAvailableQuantity.ProductId === product.ProductDetails.RecordId) {
                return productResult.IsProductAvailable;
            }
        }

        return false;
    }

    private _getWishlistLineIdFromProductId = (productId: number): number | null => {
        const { wishlists } = this.props.data;

        if (!wishlists.result || !(wishlists.result.length > 0) || !wishlists.result[0].CommerceListLines || !(wishlists.result[0].CommerceListLines.length > 0)) {
            this.props.telemetry.error('Wishlist content is empty, module wont render.');
            return null;
        }

        const foundWishlistItem = wishlists.result[0].CommerceListLines.filter((commerceListLine) => {
            return commerceListLine.ProductId === productId;
        });

        if (foundWishlistItem && foundWishlistItem[0].LineId) {
            return foundWishlistItem[0].LineId;
        } else {
            return null;
        }
    }
}

export default WishlistItems;

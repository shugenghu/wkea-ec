import { AddressItemDisplayType, AddressItemType, AddressValidationRuleType } from './address-format.data';
export class AddressMetaData {
    constructor(resources, excluded, required) {
        this.metaData = [];
        this.requiredFieldRegEx = '\\S';
        this.resourcesPrefix = 'address';
        this.maxLength = 64;
        this.resources = resources || {};
        this.excludedTypes = excluded || [];
        this.requiredFields = required !== undefined ? required : [AddressItemType.Name, AddressItemType.ZipCode, AddressItemType.City, AddressItemType.State, AddressItemType.ThreeLetterISORegionName, AddressItemType.Street];
        this._init();
    }
    getItemFormat(id) {
        return this.metaData.find((item) => {
            return item.type === id;
        });
    }
    _init() {
        this._addItem(AddressItemType.Name, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.Phone, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.ZipCode, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.City, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.County, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.State, AddressItemDisplayType.Dropdown);
        this._addItem(AddressItemType.ThreeLetterISORegionName, AddressItemDisplayType.Dropdown);
        this._addItem(AddressItemType.Street, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.District, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.StreetNumber, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.BuildingCompliment, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.Postbox, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.House_RU, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.Flat_RU, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.CountryOKSMCode_RU, AddressItemDisplayType.Input);
        this._addItem(AddressItemType.AddressTypeValue, AddressItemDisplayType.Dropdown);
        this._addItem(AddressItemType.IsPrimary, AddressItemDisplayType.Checkbox);
    }
    _addItem(type, displayType) {
        if (this.excludedTypes.includes(type)) {
            return;
        }
        const nameKey = AddressItemType[type].replace('_', '');
        const validationRules = this._validationRules(type, nameKey);
        let isRequired = false;
        validationRules.forEach(rule => {
            if (rule.type === AddressValidationRuleType.Required) {
                isRequired = true;
            }
        });
        const optionalString = this.resources[`${this.resourcesPrefix}${nameKey}LabelOptional`] || this.resources[`${this.resourcesPrefix}${nameKey}Label`];
        const item = {
            type,
            displayType,
            name: AddressItemType[type],
            label: isRequired ? this.resources[`${this.resourcesPrefix}${nameKey}Label`] : optionalString,
            maxLength: this.maxLength,
            validationRules: validationRules,
            isNewLine: true
        };
        this.metaData.push(item);
    }
    _validationRules(type, name) {
        const validationRules = [];
        for (const ruleType of Object.keys(AddressValidationRuleType)) {
            const key = `${this.resourcesPrefix}${name}${ruleType}`;
            const message = this.resources[`${key}ErrorMessage`];
            switch (ruleType) {
                case AddressValidationRuleType.Required: {
                    if (this.requiredFields.find((itemType) => itemType === type)) {
                        validationRules.push(this._validationRule(ruleType, this.requiredFieldRegEx, message));
                    }
                    break;
                }
                default:
            }
        }
        return validationRules;
    }
    _validationRule(type, regEx, message) {
        return {
            type,
            regEx,
            message
        };
    }
}
//# sourceMappingURL=address-meta-data.js.map
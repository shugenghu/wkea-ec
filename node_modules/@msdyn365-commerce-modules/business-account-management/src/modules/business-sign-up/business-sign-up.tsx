/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import * as React from 'react';

import { getTelemetryObject, Heading, IModuleProps, INodeProps, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import { getUrlSync, RichTextComponent } from '@msdyn365-commerce/core';
import { Address, BusinessPartnerProspect } from '@msdyn365-commerce/retail-proxy';
import { createProspectAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/BusinessPartnersDataActions.g';
import classnames from 'classnames';
import { IBusinessSignUpConfig, IBusinessSignUpProps } from './business-sign-up.props.autogenerated';
import { SignUpButton, SignUpError, SignUpInput, SignUpLabel } from './components';

export interface IBusinessSignUpExtendedProps extends IBusinessSignUpProps<IBusinessSignUpConfig> {
    formItems?: IFormItem[];
}

export interface IBusinessSignUpItem {
    wrapper: INodeProps;
    isAddressInput?: boolean;
    id: string;
    label: React.ReactNode;
    errorMessage: React.ReactNode;
    input?: React.ReactNode;
}

export interface IBusinessState {
    isReady: boolean;
    formItems: IFormItem[];
    addressHasErrors: boolean;
    showAddressErrors: boolean;
    hasSubmitErrors: boolean;
}

export interface IBusinessSignUpLocalAccount {
    FormWrapper: INodeProps;
    items: IBusinessSignUpItem[];
    buttons: React.ReactNode[];
    errorMessage: React.ReactNode[];
    disclaimer: React.ReactNode;
}

export interface IBusinessSignUpViewProps {
    className: string;
    businessSignUp: IModuleProps;
    ContainerWrapper: INodeProps;
    heading: React.ReactNode;
    businessSignUpForm: IBusinessSignUpLocalAccount;
    formItems: IFormItem[];
}

export interface IFormItem {
    id: string;
    type: InputType;
    label: string;
    value: string;
    maxChars?: string;
    isRequired: boolean;
    pattern?: string;
    address?: Address;
    customClass?: string;
}

export enum InputType {
    Text = 'text',
    Address = 'address',
    Email = 'email',
    TextArea = 'textarea'
}

export enum InputID {
    FirstName = 'FirstName',
    LastName = 'LastName',
    Email = 'CompanyEmail',
    CompanyName = 'CompanyName',
    Address = 'CompanyAddress',
    JobTitle = 'JobTitle',
    Size = 'CompanySize',
    Department = 'Department',
    Comment = 'Comment'
}

export const renderInputSection = (inputs: IFormItem[], className: string, needToReset: boolean, onInputChange: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void,
                                   showErrors: boolean, addressForm?: React.ReactNode, updateAddress?: (errors: boolean, currAddress?: Address) => void): IBusinessSignUpItem[] => {
    return inputs.map((element, index) => {
        const { id, type, label, maxChars, isRequired, pattern, customClass, value } = element;

        const baseSignUpItem: IBusinessSignUpItem = {
            wrapper: {
                className: classnames(className, `${className}-${id}`, customClass)
            },
            id: id,
            label: <SignUpLabel { ...{ id, forId: id, className, text: label }} />,
            errorMessage: <SignUpError { ...{ className: className, type: 'item' }} />,
        };

        if (type === InputType.Address) {
            if (addressForm) {
                baseSignUpItem.isAddressInput = true;
                baseSignUpItem.input = (
                    <React.Fragment>
                        {React.cloneElement(addressForm as React.ReactElement, { updateForm: updateAddress, hasError: showErrors, isRequired: isRequired === undefined ? false : isRequired, resetAddress: needToReset })}
                    </React.Fragment>
                );
            } else {
                // if the address slot is not filled, remove this input from the form
                inputs.splice(index, 1);
            }
        } else {
            baseSignUpItem.input = (
                <SignUpInput
                    {
                    ...{
                            id: id,
                            type: type,
                            value: value,
                            maxLength: maxChars,
                            pattern: pattern,
                            className: className,
                            isRequired: isRequired === undefined ? false : isRequired,
                            onChange: onInputChange
                        }
                    }
                />
            );
        }

        return baseSignUpItem;
    });
};

/**
 *
 * Business Request Form Modules
 * Form that a business can use to submit a request to become a partner with Microsoft.
 * @extends {React.Component<IBusinessSignUpProps<IBusinessSignUpConfig>>}
 */
class BusinessSignUp extends React.Component<IBusinessSignUpExtendedProps, IBusinessState> {
    // used as default data
    public BusinessSignUpDefaultInputs: IFormItem[] = [
        {
            id: InputID.FirstName,
            type: InputType.Text,
            label: this.props.resources.firstNameLabel,
            value: '',
            isRequired: true,
            customClass: 'width-25'
        },
        {
            id: InputID.LastName,
            type: InputType.Text,
            label: this.props.resources.lastNameLabel,
            value: '',
            isRequired: true,
            customClass: 'width-25'
        },
        {
            id: InputID.Email,
            type: InputType.Email,
            label: this.props.resources.emailAddressLabel,
            value: '',
            isRequired: true,
            pattern: '^[a-zA-Z0-9.!#$%&\'^_`{}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$',
            customClass: 'width-50'
        },
        {
            id: InputID.CompanyName,
            type: InputType.Text,
            label: this.props.resources.companyLabel,
            value: '',
            isRequired: true,
            customClass: 'width-50'
        },
        {
            id: InputID.Department,
            type: InputType.Text,
            label: this.props.resources.departmentLabel,
            value: '',
            isRequired: false,
            customClass: 'width-50'
        },
        {
            id: InputID.JobTitle,
            type: InputType.Text,
            label: this.props.resources.jobTitleLabel,
            value: '',
            isRequired: false,
            customClass: 'width-50'
        },
        {
            id: InputID.Size,
            type: InputType.Text,
            label: this.props.resources.companySizeLabel,
            value: '',
            isRequired: false,
            customClass: 'width-50'
        },
        {
            id: InputID.Address,
            type: InputType.Address,
            label: this.props.resources.companyAddressLabel,
            value: '',
            isRequired: false,
            customClass: 'width-100'
        },
        {
            id: InputID.Comment,
            type: InputType.TextArea,
            label: this.props.resources.commentLabel,
            value: '',
            isRequired: false,
            customClass: 'width-100'
        }
    ];

    private moduleClassName: string = 'ms-business-sign-up';
    private needsToReset: boolean = false;
    private telemetryContent: ITelemetryContent;

    constructor(props: IBusinessSignUpExtendedProps) {
        super(props);

        this.state = {
            isReady: false,
            formItems: this.props.formItems || this.BusinessSignUpDefaultInputs,
            addressHasErrors: false,
            showAddressErrors: false,
            hasSubmitErrors: false
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
    }

    public render(): JSX.Element {
        const { config } = this.props;
        const { formItems } = this.state;
        const { className, heading } = config;

        const viewProps = {
            ...this.props,
            businessSignUp: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, className)
            },
            ContainerWrapper: {
                className: `${this.moduleClassName}__container`
            },
            heading: <Heading className={`${this.moduleClassName}__heading`} {...heading} />,
            businessSignUpForm: this._renderForm(),
            formItems: formItems
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private _renderForm(): IBusinessSignUpLocalAccount {
        const { config, resources, slots } = this.props;
        const { showAddressErrors, hasSubmitErrors, isReady, formItems } = this.state;
        const { signUpButtonArialabel, signUpButtonText, cancelButtonArialabel, cancelButtonText, errorMessage, partialAddressErrorMessage } = resources;
        const addressForm = slots && slots.addressSlot && slots.addressSlot.length > 0 && slots.addressSlot[0] || undefined;
        const successPageURL = config.confirmationLink && config.confirmationLink.linkUrl && config.confirmationLink.linkUrl.destinationUrl || getUrlSync('home', this.props.context.actionContext);

        const form = {
            FormWrapper: {
                className: `${this.moduleClassName}__form `
            },
            items: renderInputSection(formItems, `${this.moduleClassName}__form-item`, this.needsToReset, this._onInputChange, showAddressErrors, addressForm, this._onAddressChange),
            buttons: [
                // tslint:disable-next-line:max-line-length
                <SignUpButton key='continue' id='continue' className={`${this.moduleClassName}__create-button`} link={successPageURL} ariaLabel={signUpButtonArialabel} text={signUpButtonText} disabled={!isReady} onClick={this._onSubmit} telemetryContent={this.telemetryContent}/>,
                <SignUpButton key='cancel' id='cancel' className={`${this.moduleClassName}__cancel-button`} ariaLabel={cancelButtonArialabel} text={cancelButtonText} onClick={this._onCancel} telemetryContent={this.telemetryContent}/>
            ],
            errorMessage: [
                hasSubmitErrors && <SignUpError key='error' id='error' className={this.moduleClassName} message={errorMessage} />,
                showAddressErrors && <SignUpError key='error' id='error' className={this.moduleClassName} message={partialAddressErrorMessage} />
            ],
            disclaimer: config.disclaimer && <RichTextComponent className={`${this.moduleClassName}__disclaimer`} text={config.disclaimer} />,
        };

        if (this.needsToReset) {
            this.needsToReset = false;
        }

        return form;
    }

    private _onInputChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
        const newForm = this.state.formItems;
        newForm.forEach(item => {
            if (item.id === event.target.id) {
                item.value = event.target.value;
            }
        });

        // check if form is ready, update state object with latest values, values have changed so reset hasSubmitErrros
        this.setState({
            isReady: this._isFormReady(),
            formItems: newForm,
            hasSubmitErrors: false
        });
    }

    private _onAddressChange = (errors: boolean, currentAddress?: Address): void => {
        // find address item
        const newForm = this.state.formItems;
        const addressItem = newForm.find((item) => {
            return item.type === InputType.Address;
        });

        // if found --> set to currentAddress
        if (addressItem) {
            addressItem.address = currentAddress;

            // update state with new values and set errors to false if address is not required field
            this.setState({
                isReady: this._isFormReady(),
                formItems: newForm,
                addressHasErrors: errors,
                showAddressErrors: false
            });
        }
    }

    private _isFormReady = (): boolean => {
        const { formItems } = this.state;

        for (let i = 0; i < formItems.length; i++) {
            // will return FALSE if:
            //  - input field is required
            //      IF is address AND addressHasErrors === true
            //      ELSE value is undefined OR empty
            //  OR
            //  - pattern provided and value does not match pattern
            const currentInput = formItems[i];

            if (currentInput.isRequired) {
                if (currentInput.type === InputType.Address) {
                    if (this.state.addressHasErrors) {
                        return false;
                    }
                } else {
                    if (currentInput.value === undefined || currentInput.value === '') {
                        return false;
                    }
                }
            }
            if (currentInput.pattern !== undefined && currentInput.value.match(formItems[i].pattern as string) === null) {
                return false;
            }
        }

        return true;
    }

    private _onSubmit = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (this.state.addressHasErrors) {
            this.setState({
                showAddressErrors: true
            });

            event.preventDefault();
            return;
        }

        const { context } = this.props;

        // check for matching id and if not empty
        const firstName = this._getItem(InputID.FirstName);
        const lastName =  this._getItem(InputID.LastName);
        const companyName =  this._getItem(InputID.CompanyName);
        const companyEmail =  this._getItem(InputID.Email);
        const companyAddress = this._getItem(InputID.Address, true);
        const jobTitle =  this._getItem(InputID.JobTitle);
        const department =  this._getItem(InputID.Department);
        const companySize =  this._getItem(InputID.Size);
        const comments =  this._getItem(InputID.Comment);

        // API gets email as part of the address object, but I do not use the email input from the address component, thus we need to copy it over
        if (companyEmail && companyEmail.value && companyAddress && companyAddress.address) {
            companyAddress.address.Email = companyEmail.value;
        }

        const newPartner: BusinessPartnerProspect = {
            FirstName: firstName && firstName.value,
            LastName: lastName && lastName.value,
            CompanyName: companyName && companyName.value,
            Address: companyAddress && companyAddress.address && companyAddress.address,
            JobTitle: jobTitle && jobTitle.value,
            Department: department && department.value,
            CompanySize: companySize && parseInt(companySize.value, 10) || 0,
            Comments: comments && comments.value,
        };

        // create business partner request
        createProspectAsync({ callerContext: context.actionContext }, newPartner)
            .catch(() => {
                this.setState({
                    hasSubmitErrors: true,
                    isReady: false
                });
            });
    }

    private _onCancel = () => {
        // reset values of the form
        const cleanForm = this.state.formItems;
        cleanForm.forEach(input => {input.value = '';});

        // set reset flag so address input will get reset on next renderInputSection() call
        this.needsToReset = true;

        this.setState({
            isReady: false,
            formItems: cleanForm,
            addressHasErrors: true,
            showAddressErrors: false,
            hasSubmitErrors: false
        });
    }

    private _getItem = (id: string, isAddress: boolean = false) => {
        if (isAddress) {
            return this.state.formItems.find((item) => { return item.id === id && item.address;});
        }
        return this.state.formItems.find((item) => { return item.id === id && item.value !== '';});
    }
}

export default BusinessSignUp;

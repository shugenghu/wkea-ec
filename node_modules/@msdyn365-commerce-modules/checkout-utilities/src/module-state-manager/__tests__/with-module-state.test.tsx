/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { shallow } from 'enzyme';
// tslint:disable-next-line:no-unused-variable
import * as React from 'react';
import * as MoudleStateAction from '../module-state';
import withModuleState from '../with-module-state';

jest.mock('../module-state');

let mockStore;
let Component;
let ComponentWithModuleState;

let moduleProps;
let moduleChildProps1;
let moduleChildProps2;
let wrapper;
let wrapperChild1;
let wrapperChild2;

let moduleContextProps;

describe('CheckoutState.ModuleStates', () => {
    beforeEach(() => {
        mockStore = {};
        Component = () => <div />;
        ComponentWithModuleState = withModuleState(Component);
        moduleContextProps = {
            context: {
                actionContext: {}
            },
            telemetry: {
                error: jest.fn()
            }
        };

        moduleProps = {
            id: 'mock_id',
            typeName: 'mock_type_name_1',
            ...moduleContextProps
        };
        moduleChildProps1 = {
            id: 'child_1',
            typeName: 'mock_type_name_2',
            ...moduleContextProps
        };
        moduleChildProps2 = {
            id: 'child_2',
            typeName: 'mock_type_name_3',
            ...moduleContextProps
        };
        // @ts-ignore: Jest Mocking Confuses TS Complier
        MoudleStateAction.getModuleStates.mockImplementation(() => mockStore);
    });

    describe('Single module', () => {
        beforeEach(() => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            MoudleStateAction.updateModuleStates.mockImplementation(value => {
                mockStore = value;
            });
            wrapper = shallow(<ComponentWithModuleState {...moduleProps} />);
        });

        xit('renders correctly', () => {
            expect(wrapper).toMatchSnapshot();
        });

        xit('initializes module state', () => {
            expect(mockStore).toEqual({
                mock_id: {
                    id: 'mock_id',
                    hasInitialized: false,
                    hasError: false,
                    isRequired: true,
                    status: undefined,
                    childIds: [],
                    typeName: 'mock_type_name_1'
                }
            });
            expect(wrapper.props().moduleState.hasInitialized).toBe(false);
            expect(wrapper.props().moduleState.hasError).toBe(false);
            expect(wrapper.props().moduleState.isReady).toBe(false);
            expect(wrapper.props().moduleState.isUpdating).toBe(false);
            expect(wrapper.props().moduleState.isPending).toBe(false);
            expect(wrapper.props().moduleState.isDisabled).toBe(false);
            expect(wrapper.props().moduleState.hasExternalSubmitGroup).toBe(false);
        });

        xit('init module state', () => {
            wrapper.props().moduleState.init();

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasInitialized).toBe(true);
        });

        xit('init module state with optional data', () => {
            wrapper.props().moduleState.init({
                onEdit: jest.fn(),
                onCancel: jest.fn(),
                onSubmit: jest.fn(),
                status: 'ready'
            });

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasInitialized).toBe(true);
            expect(moduleState.isReady).toBe(true);
        });

        xit('set module state to ready', () => {
            wrapper.props().moduleState.onReady();

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isReady).toBe(true);
        });

        xit('set module state to updating', () => {
            wrapper.props().moduleState.onUpdating();

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isUpdating).toBe(true);
        });

        xit('set module state to pending', () => {
            wrapper.props().moduleState.onPending();

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isPending).toBe(true);
        });

        xit('set module state to disabled', () => {
            wrapper.props().moduleState.onDisable();

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isDisabled).toBe(true);
        });

        xit('has external submit group when props.enableControl is true', () => {
            wrapper = shallow(<ComponentWithModuleState {...moduleProps} enableControl={true} />);

            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasExternalSubmitGroup).toBe(true);
        });
    });

    describe('Multiple modules', () => {
        beforeEach(() => {
            mockStore = {
                mock_id: {
                    id: 'mock_id',
                    childIds: ['child_1', 'child_2']
                },
                child_1: {
                    id: 'child_1',
                    hasInitialized: false,
                    hasError: false,
                    isRequired: true,
                    status: undefined
                },
                child_2: {
                    id: 'child_2',
                    hasInitialized: false,
                    hasError: false,
                    isRequired: true,
                    status: undefined
                }
            };

            // Diable the initialize process
            // @ts-ignore: Jest Mocking Confuses TS Complier
            MoudleStateAction.updateModuleStates.mockImplementation(value => value);

            wrapper = shallow(<ComponentWithModuleState {...moduleProps} />);
            wrapperChild1 = shallow(<ComponentWithModuleState {...moduleChildProps1} enableControl={true} />);
            wrapperChild2 = shallow(<ComponentWithModuleState {...moduleChildProps2} enableControl={true} />);
        });

        xit('completes initialized when all children has initialized', () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasInitialized).toBe(false);

            wrapperChild1.props().moduleState.init();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasInitialized).toBe(false);

            wrapperChild2.props().moduleState.init();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.hasInitialized).toBe(true);
        });

        xit('is ready when all children is ready, excludes disabled and skipped', () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isReady).toBe(false);

            wrapperChild1.props().moduleState.onReady();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isReady).toBe(false);

            wrapperChild2.props().moduleState.onReady();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isReady).toBe(true);

            wrapperChild2.props().moduleState.onSkip();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            // it is ready when all children is ready, excludes skipped chilren
            expect(moduleState.isReady).toBe(true);

            wrapperChild2.props().moduleState.onDisable();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            // it is ready when all children is ready, excludes disabled chilren
            expect(moduleState.isReady).toBe(true);
        });

        xit('is updating when some of the child is updating', () => {
            wrapperChild1.props().moduleState.onUpdating();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isUpdating).toBe(true);
        });

        xit('is pending when some of the child is pending', () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isPending).toBe(false);

            wrapperChild1.props().moduleState.onPending();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isPending).toBe(true);
        });

        xit('is skipped when all children is skipped, excludes disabled', () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isSkipped).toBe(false);

            wrapperChild1.props().moduleState.onSkip();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isSkipped).toBe(false);

            wrapperChild2.props().moduleState.onSkip();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isSkipped).toBe(true);

            wrapperChild2.props().moduleState.onDisable();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            // it is skipped when all children is skipped, excludes disabled chilren
            expect(moduleState.isSkipped).toBe(true);
        });

        xit('is disabled when all children is disabled', () => {
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isDisabled).toBe(false);

            wrapperChild1.props().moduleState.onDisable();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isDisabled).toBe(false);

            wrapperChild2.props().moduleState.onDisable();
            // @ts-ignore: Jest Mocking Confuses TS Complier
            const moduleState = wrapper.instance().getModuleStateManager('mock_id');
            expect(moduleState.isDisabled).toBe(true);
        });
    });

    afterEach(() => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        MoudleStateAction.getModuleStates.mockReset();
        // @ts-ignore: Jest Mocking Confuses TS Complier
        MoudleStateAction.updateModuleStates.mockReset();
    });

    afterAll(() => {
        jest.unmock('../module-state');
    });
});

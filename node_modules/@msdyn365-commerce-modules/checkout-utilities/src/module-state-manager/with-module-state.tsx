/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IModule } from '@msdyn365-commerce/core';
import isMatch from 'lodash/isMatch';
import { observer } from 'mobx-react';
import * as React from 'react';
import { getModuleStates, updateModuleStates } from './module-state';
import { IModuleState, IModuleStateManager, IModuleStateProps, IModuleStates } from './module-state.data';

export interface IProps extends IModule, IModuleStateProps {
    enableControl?: boolean;
}

const withModuleState = <P extends IProps>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {
    /**
     *
     * ModuleState component
     * @extends {React.Component<P>}
     */
    @observer
    class ModuleState extends React.Component<P> {
        constructor(props: P) {
            super(props);
            this.initializeState();
        }

        public render(): JSX.Element | null {
            const { id } = this.props;
            return <WrappedComponent {...this.props} moduleState={this.getModuleStateManager(id)} />;
        }

        private initializeState = (): void => {
            const { id, typeName, context } = this.props;
            const states = getModuleStates(context.actionContext);
            if (!states) {
                this.props.telemetry.error('withModuleState initializeState() - states not found');
                return;
            }

            if (states[id]) {
                // state has been initialized
                return;
            }

            updateModuleStates(
                {
                    ...states,
                    [id]: {
                        id,
                        typeName,
                        hasInitialized: false,
                        hasError: false,
                        isRequired: true,
                        isCancellable: true,
                        isSubmitContainer: false,
                        status: undefined,
                        childIds: []
                    }
                },
                context.actionContext
            );
        };

        /**
         * GetModuleStateManager
         * Get module state manager by id
         */
        private getModuleStateManager = (id: string): IModuleStateManager => {
            const moduleState = this.get()[id];
            return {
                ...moduleState,
                hasInitialized: this.validate(id, { hasInitialized: true }, true), // All has initialized is initialized
                hasError: this.validate(id, { hasError: true }), // Partial has error is error
                isReady: this.validate(id, { status: 'ready' }, true, true), // All ready is ready (exclued disabled and skipped)
                isUpdating: this.validate(id, { status: 'updating' }), // Partial updating is updating
                isPending: this.validate(id, { status: 'pending' }), // Partial pending is pending
                isSkipped: this.validate(id, { status: 'skipped' }, true, true), // All skipped is skipped (exclued disabled)
                isDisabled: this.validate(id, { status: 'disabled' }, true), // All disabled is disabled
                isCancelAllowed: this.validate(id, { isCancellable: true }, true, true), // Partial not allowed is not allowed
                shouldSubmitContainer: this.validate(id, { isSubmitContainer: true }), // Partial submit is submit.
                hasExternalSubmitGroup: this.hasExternalSubmitGroup(),
                hasModuleState: this.hasModuleState(id),
                setIsRequired: (value: boolean): void => this.update(id, { isRequired: value }),
                setIsCancellable: (value: boolean): void => this.update(id, { isCancellable: value }),
                setIsSubmitContainer: (value: boolean): void => this.update(id, { isSubmitContainer: value }),
                setHasError: (value: boolean): void => this.update(id, { hasError: value }),
                onReady: (): void => this.update(id, { status: 'ready' }),
                onUpdating: (): void => this.update(id, { status: 'updating' }),
                onPending: (): void => this.update(id, { status: 'pending' }),
                onSkip: (): void => this.update(id, { status: 'skipped' }),
                onDisable: (): void => this.update(id, { status: 'disabled' }),
                getModule: (moduleId: string): IModuleStateManager => this.getModuleStateManager(moduleId),
                getModuleByTypeName: (typeName: string): IModuleStateManager => this.getModuleStateManagerByTypeName(typeName),
                init: (options?: Partial<IModuleState>): void => {
                    if (moduleState.hasInitialized) {
                        // state has been initialized
                        return;
                    }
                    this.update(id, {
                        hasInitialized: true,
                        ...options
                    });
                }
            };
        };

        /**
         * GetModuleStateManagerByTypeName
         * Get module state manager by type name
         */
        private getModuleStateManagerByTypeName = (typeName: string): IModuleStateManager => {
            const moduleStates = getModuleStates(this.props.context.actionContext);
            const moduleState = Object.values(moduleStates).find(_moduleState => _moduleState.typeName === typeName);
            return this.getModuleStateManager((moduleState && moduleState.id) || '');
        };

        /**
         * Get
         * Get all module states
         */
        private get = (): IModuleStates => {
            return getModuleStates(this.props.context.actionContext);
        };

        /**
         * Update
         * Update module state
         */
        private update = (id: string, value: Partial<IModuleState>): void => {
            // console.log('withModuleState - update', id, value);
            const modules = this.get();
            if (!modules[id]) {
                this.props.telemetry.error(`withModuleState update() - Module state with id ${id} is not found.`);
                return;
            }
            modules[id] = {
                ...modules[id],
                ...value
            };
        };

        private _validateLeaf = (id: string, source: Partial<IModuleState>): boolean => {
            const modules = this.get();
            const module = modules[id];
            if (!module) {
                return false;
            }
            return isMatch(module, source);
        };

        private _validateContainer = (
            id: string,
            source: Partial<IModuleState>,
            allMatched?: boolean,
            skipSkippableItem?: boolean
        ): boolean => {
            const modules = this.get();
            const module = modules[id];
            if (!module) {
                // module doesn't has module state
                return !!allMatched;
            }

            if (skipSkippableItem && (module.status === 'disabled' || module.status === 'skipped')) {
                // Skip disabled or skipped modules
                return !!allMatched;
            }

            // It is leaf module
            if (!module.childIds || !module.childIds.length) {
                return this._validateLeaf(id, source);
            }

            // It is container module
            const method = allMatched ? 'every' : 'some';
            return module.childIds[method](childId => this._validateContainer(childId, source, allMatched, skipSkippableItem));
        };

        /**
         * Validate
         * Validate current module and all its child module match the provided condition
         */
        private validate = (id: string, source: Partial<IModuleState>, allMatched?: boolean, skipSkippableItem?: boolean): boolean => {
            const modules = this.get();
            const module = modules[id];
            if (!module) {
                return false;
            }

            // It is leaf module
            if (!module.childIds || !module.childIds.length) {
                return this._validateLeaf(id, source);
            }

            // It is container module
            return this._validateContainer(id, source, allMatched, skipSkippableItem);
        };

        /**
         * hasExternalSubmitGroup
         * Module will use external submit group
         */
        private hasExternalSubmitGroup = (): boolean => {
            return !!this.props.enableControl;
        };

        /**
         * hasModuleState
         * Module is using module state manager
         */
        private hasModuleState = (id: string): boolean => {
            const modules = this.get();
            const module = modules[id];
            return !!module;
        };
    }

    return ModuleState;
};

export default withModuleState;
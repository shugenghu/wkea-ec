import { createSearchStateInput } from '@msdyn365-commerce-modules/search-utilities';
import { getTelemetryObject } from '@msdyn365-commerce-modules/utilities';
import { getUrlSync } from '@msdyn365-commerce/core';
import { getProductSearchRefinersAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import classnames from 'classnames';
import { debounce } from 'lodash';
import * as React from 'react';
import getSearchSuggestionsAction, { AutoSuggestInput } from './actions/get-auto-suggest-suggestions';
import { CategorySuggestionsComponent, FormComponent, KeywordSuggestionsComponent, LabelComponent, ProductSuggestionsComponent } from './components';
class Search extends React.Component {
    constructor(props) {
        super(props);
        this.hitPrefix = '{';
        this.hitSuffix = '}';
        this.waitTime = 500;
        this._focusOutTarget = (e) => {
            const { suggestions } = this.state;
            if (suggestions &&
                suggestions.AllSearchResults &&
                e.target.closest('.ms-search') === null) {
                this._clearAutoSuggestState();
            }
        };
        this._keyup = (e) => {
            const { suggestions } = this.state;
            if (suggestions && suggestions.AllSearchResults && e.keyCode === 27) {
                this._clearAutoSuggestState();
            }
            else if (this.state.isSearchFormExpanded && e.keyCode === 27) {
                if (this.state.isSearchFormExpanded) {
                    this.setState({ isSearchFormExpanded: false });
                }
            }
            if (!((this.formReference.current && this.formReference.current.contains(e.target)) ||
                (this.autoSuggestResultDiv.current && this.autoSuggestResultDiv.current.contains(e.target)))) {
                if (suggestions && suggestions.AllSearchResults) {
                    this._clearAutoSuggestState();
                }
                if (this.state.isSearchFormExpanded) {
                    this.setState({ isSearchFormExpanded: false });
                }
            }
        };
        this._clearAutoSuggestState = () => {
            const { context: { actionContext }, data: { searchState } } = this.props;
            if (this.searchTextInput.current && this.searchTextInput.current.value.length > 0) {
                searchState.searchText = '';
                searchState.defaultBasicSearchUrl = '';
                searchState.searchQueryStringParameter = '';
                actionContext ? actionContext.update(createSearchStateInput(searchState), searchState) : null;
                this.searchTextInput.current.value = '';
            }
            this.setState({ searchText: '', suggestions: undefined, searchRefiners: undefined });
        };
        this._handleInputChange = (query) => {
            if (!query || query.length < this.maxChars) {
                this.setState({ searchText: query });
            }
            if (this.cancellabelDebounce) {
                this.cancellabelDebounce.cancel();
            }
            const { telemetry, context, data: { searchState } } = this.props;
            if (context) {
                if (query && query.length > 0) {
                    if (query.length > this.maxChars) {
                        return;
                    }
                    this.cancellabelDebounce = debounce(() => {
                        getSearchSuggestionsAction(new AutoSuggestInput(query, this.topResultsCount, this._getSuggestionType(this.inputSuggestionType), this.hitPrefix, this.hitSuffix), context.actionContext)
                            .then(results => {
                            this._getSearchRefiners(query)
                                .then(refiners => {
                                this.setState({ suggestions: results, searchRefiners: refiners,
                                    autoSuggestAriaLabel: this._setAutoSuggestResultCount(results) });
                            })
                                .catch(error => {
                                this.setState({ suggestions: results, searchRefiners: undefined,
                                    autoSuggestAriaLabel: this._setAutoSuggestResultCount(results) });
                                telemetry.exception(error);
                                telemetry.debug('Unable to get refiners results');
                            });
                        })
                            .catch(error => {
                            this.setState({ suggestions: undefined, searchRefiners: undefined,
                                autoSuggestAriaLabel: this._setAutoSuggestResultCount() });
                            telemetry.exception(error);
                            telemetry.debug('Unable to get auto suggest results');
                        });
                    }, this.waitTime);
                    setTimeout(() => {
                        this.cancellabelDebounce();
                    }, 0);
                    searchState.searchText = query;
                }
                else {
                    this.setState({ suggestions: undefined, searchRefiners: undefined });
                    searchState.searchText = '';
                }
                context.actionContext.update(createSearchStateInput(searchState), searchState);
            }
        };
        this._getSuggestionType = (suggestionTypes) => {
            if (suggestionTypes && suggestionTypes.length > 0) {
                const distinctSuggestionTypes = [];
                suggestionTypes && suggestionTypes.forEach((suggestionTypeItem, index) => {
                    suggestionTypeItem.SuggestionType && distinctSuggestionTypes.push(suggestionTypeItem.SuggestionType.charAt(0).toUpperCase() + suggestionTypeItem.SuggestionType.slice(1));
                });
                return distinctSuggestionTypes.join(',');
            }
            return 'Keyword, Product, ScopedCategory';
        };
        this._handleSubmit = (e) => {
            const { config: { disableSubmitSearch }, context: { actionContext, app: { config: { searchQueryStringParameter } } } } = this.props;
            const query = this.searchTextInput.current && this.searchTextInput.current.value;
            e.preventDefault();
            if (!query || (query && query.length === 0) || disableSubmitSearch) {
                this.searchTextInput && this.searchTextInput.current && this.searchTextInput.current.focus();
            }
            else {
                const searchQsp = searchQueryStringParameter || 'q';
                const searchURL = this._appendQueryParams(getUrlSync('search', actionContext) || '', query, searchQsp);
                document.location.href = searchURL;
            }
        };
        this._handleCancelSearchChange = () => {
            const { isSearchFormExpanded, suggestions } = this.state;
            if (!isSearchFormExpanded) {
                this.setState({
                    isSearchFormExpanded: true,
                    searchText: '',
                    isInitialState: false
                });
            }
            else {
                if (suggestions && suggestions.AllSearchResults) {
                    this._clearAutoSuggestState();
                }
                this.setState({ isSearchFormExpanded: false });
            }
        };
        this._appendQueryParams = (route, query, qsp) => {
            if (route && route.length > 0) {
                return query && query.length > 0 ? `${route}${route.indexOf('?') === -1 ? '?' : '&'}${qsp}=${query}` : route;
            }
            return '';
        };
        this._setAutoSuggestResultCount = (result) => {
            if (this.autoSuggestResultScreenReaderDiv.current !== null) {
                const ariaLiveRegion = this.autoSuggestResultScreenReaderDiv.current;
                const suggestResultString = this.props.resources.autoSuggestFoundMessage;
                const emptyResultString = this.props.resources.noAutoSuggestionMessage;
                ariaLiveRegion.innerText = result && (result.AllSearchResults && result.AllSearchResults.length > 0) ? suggestResultString : emptyResultString;
                ariaLiveRegion.setAttribute('aria-live', 'assertive');
                return ariaLiveRegion.innerText;
            }
            else {
                return '';
            }
        };
        this.searchTextInput = React.createRef();
        this.searchCollapsedLabel = React.createRef();
        this.autoSuggestResultScreenReaderDiv = React.createRef();
        this.autoSuggestResultDiv = React.createRef();
        this.formReference = React.createRef();
        this.state = {
            isSearchFormExpanded: false,
            searchText: '',
            searchKeywordSuggestClass: 'ms-search__autoSuggest__keyword',
            searchProductSuggestClass: 'ms-search__autoSuggest__product',
            searchCategorySuggestClass: 'ms-search__autoSuggest__category',
            suggestions: undefined,
            searchRefiners: undefined,
            autoSuggestAriaLabel: '',
            isInitialState: true
        };
        this.maxChars =
            (this.props.context &&
                this.props.context.app &&
                this.props.context.app.config &&
                this.props.context.app.config.searchInputMaxLength) ||
                50;
        this.inputSuggestionType = this.props.config && this.props.config.suggestionTypeCriterion;
        this.topResultsCount = this.props.config && this.props.config.topResultsCount ? this.props.config.topResultsCount : 5;
        this.searchFormClass = 'ms-search__form';
        this.searchLabelClass = 'ms-search__label';
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    async componentDidMount() {
        document.body && document.body.addEventListener('mousedown', this._focusOutTarget);
        window && window.addEventListener('keyup', this._keyup);
    }
    componentWillUnmount() {
        document.body && document.body.removeEventListener('mousedown', this._focusOutTarget, false);
        window && window.removeEventListener('keyup', this._keyup, false);
    }
    componentDidUpdate() {
        const { config: { hideSearchLabel } } = this.props;
        const { isSearchFormExpanded, isInitialState } = this.state;
        if (!this.props.context.request.params.isEditor) {
            if (!hideSearchLabel && isSearchFormExpanded) {
                this.searchTextInput && this.searchTextInput.current && this.searchTextInput.current.focus();
            }
            else if (!isInitialState) {
                this.searchCollapsedLabel && this.searchCollapsedLabel.current && this.searchCollapsedLabel.current.focus();
            }
        }
    }
    render() {
        const { context, resources: { searchtext, searchLabelArialLabel, cancelBtnAriaLabel, searchBtnAriaLabel, submitBtnAriaLabel }, config: { hideSearchLabel, disableSubmitSearch, searchplaceholderText, className = '' } } = this.props;
        const { isSearchFormExpanded, searchText, searchKeywordSuggestClass, searchProductSuggestClass, searchCategorySuggestClass, suggestions, searchRefiners } = this.state;
        const searchQsp = (context && context.app && context.app.config && context.app.config.searchQueryStringParameter) || 'q';
        const searchPageURL = getUrlSync('search', context && context.actionContext) || '';
        const searchURL = this._appendQueryParams(searchPageURL, searchText, searchQsp);
        const searchPlaceholder = searchplaceholderText && searchplaceholderText.length > 0 ? searchplaceholderText : 'Search in Fabrikam';
        const keywordSuggestions = suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(i => i.SuggestionType === "Keyword" || i.SuggestionType === "None");
        const productSuggestions = suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(i => i.SuggestionType === "Product");
        const categorySuggestions = suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(i => i.SuggestionType === "ScopedCategory");
        const viewProps = {
            ...this.props,
            Search: {
                moduleProps: this.props,
                className: `${classnames('ms-search', className)} ${disableSubmitSearch ? 'no-submit' : 'with-submit'}`,
            },
            AutoSuggestAriaLabel: {
                tag: 'div',
                className: 'msc-autoSuggest__screen-reader',
                'aria-live': 'assertive',
                ref: this.autoSuggestResultScreenReaderDiv
            },
            AutoSuggestAriaLabelText: this.state.autoSuggestAriaLabel,
            searchText: this.state.searchText,
            AutoSuggest: {
                ref: this.autoSuggestResultDiv,
                className: 'ms-search__autoSuggest'
            },
            KeywordSuggest: {
                className: searchKeywordSuggestClass
            },
            ProductSuggest: {
                className: searchProductSuggestClass
            },
            CategorySuggest: {
                className: searchCategorySuggestClass
            },
            SearchForm: {
                className: `${this.searchFormClass} ${isSearchFormExpanded ? 'bx-show' : 'bx-hide'}`
            },
            FormWrapper: {
                tag: 'form',
                ref: this.formReference,
                className: 'ms-search__searchForm',
                'aria-label': 'Search',
                name: 'searchForm',
                role: 'Search',
                action: searchURL,
                autoComplete: 'off',
                onSubmit: this._handleSubmit
            },
            UlKeyword: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__keywordResults-items', className)
            },
            UlProduct: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__productResults-items', className)
            },
            UlCategory: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__categoryResults-items', className)
            },
            label: LabelComponent({
                isSearchFormExpanded: isSearchFormExpanded,
                searchLabelClass: `${this.searchLabelClass} ${isSearchFormExpanded ? 'bx-hide' : 'bx-show'}`,
                searchtext: searchtext,
                searchLabelArialLabel: searchLabelArialLabel,
                searchCollapsedLabel: this.searchCollapsedLabel,
                hideSearchLabel: hideSearchLabel,
                handleCancelSearchChange: this._handleCancelSearchChange,
                telemetryContent: this.telemetryContent
            }),
            form: FormComponent({
                ariaLabelCancel: cancelBtnAriaLabel,
                ariaLabelSearch: searchBtnAriaLabel,
                ariaLabelSubmit: submitBtnAriaLabel,
                hideSearchLabel: hideSearchLabel,
                searchTextInput: this.searchTextInput,
                isSearchFormExpanded: isSearchFormExpanded,
                disableSubmitSearch: disableSubmitSearch,
                handleInputChange: this._handleInputChange,
                handleCancelSearchChange: this._handleCancelSearchChange,
                maxChars: this.maxChars,
                searchQsp: searchQsp,
                searchPlaceholder: searchPlaceholder,
                query: searchText
            }),
            autosuggestKeyword: searchText && searchText.length > 0 && keywordSuggestions && keywordSuggestions.length > 0
                ? KeywordSuggestionsComponent({
                    searchKeywordSuggestClass: searchKeywordSuggestClass,
                    searchPageURL: searchPageURL,
                    searchQsp: searchQsp,
                    hitPrefix: this.hitPrefix,
                    hitSuffix: this.hitSuffix,
                    autoSuggestProps: this.props,
                    searchText: searchText,
                    suggestions: keywordSuggestions,
                    telemetryContent: this.telemetryContent
                })
                : undefined,
            autosuggestProduct: searchText && searchText.length > 0 && productSuggestions && productSuggestions.length > 0
                ? ProductSuggestionsComponent({
                    searchProductSuggestClass: searchProductSuggestClass,
                    searchPageURL: searchPageURL,
                    searchQsp: searchQsp,
                    hitPrefix: this.hitPrefix,
                    hitSuffix: this.hitSuffix,
                    autoSuggestProps: this.props,
                    searchText: searchText,
                    suggestions: productSuggestions,
                    telemetry: this.props.telemetry,
                    moduleType: this.props.typeName,
                    moduleId: this.props.id,
                    telemetryContent: this.telemetryContent
                })
                : undefined,
            autosuggestCategory: searchText && searchText.length > 0 && categorySuggestions && categorySuggestions.length > 0
                ? CategorySuggestionsComponent({
                    searchCategorySuggestClass: searchCategorySuggestClass,
                    searchPageURL: searchPageURL,
                    searchQsp: searchQsp,
                    hitPrefix: this.hitPrefix,
                    hitSuffix: this.hitSuffix,
                    autoSuggestProps: this.props,
                    searchText: searchText,
                    suggestions: categorySuggestions,
                    searchRefiners: searchRefiners,
                    telemetryContent: this.telemetryContent
                })
                : undefined,
            callbacks: {
                handleCancelSearchChange: this._handleCancelSearchChange
            },
            isSearchFormExpanded: this.state.isSearchFormExpanded
        };
        return this.props.renderView(viewProps);
    }
    async _getSearchRefiners(searchText) {
        const { actionContext: ctx } = this.props.context;
        return getProductSearchRefinersAsync({ callerContext: ctx }, {
            SearchCondition: searchText,
            Context: {
                ChannelId: +ctx.requestContext.apiSettings.channelId,
                CatalogId: +ctx.requestContext.apiSettings.catalogId
            }
        });
    }
}
export default Search;
//# sourceMappingURL=search.js.map
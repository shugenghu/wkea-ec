/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { createSearchStateInput } from '@msdyn365-commerce-modules/search-utilities';
import { getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, KeyCodes } from '@msdyn365-commerce-modules/utilities';
import { Autosuggestions } from '@msdyn365-commerce/commerce-entities';
import { getUrlSync } from '@msdyn365-commerce/core';
import { ProductRefiner } from '@msdyn365-commerce/retail-proxy';
import { getProductSearchRefinersAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import classnames from 'classnames';
import { debounce } from 'lodash';
import * as React from 'react';

import getSearchSuggestionsAction, { AutoSuggestInput, SuggestionType } from './actions/get-auto-suggest-suggestions';
import {
    CategorySuggestionsComponent,
    FormComponent,
    ISearchCategoryViewProps,
    ISearchKeywordViewProps,
    ISearchProductViewProps,
    KeywordSuggestionsComponent,
    LabelComponent,
    ProductSuggestionsComponent
} from './components';
import { ISearchData } from './search.data';
import { ISearchProps, ISuggestionTypeCriterionData } from './search.props.autogenerated';

export interface ISearchState {
    isSearchFormExpanded: boolean;
    searchText: string;
    searchKeywordSuggestClass: string;
    searchProductSuggestClass: string;
    searchCategorySuggestClass: string;
    suggestions: Autosuggestions | undefined;
    searchRefiners?: ProductRefiner[] | undefined;
    autoSuggestAriaLabel: string;
    isInitialState: boolean;
}

export interface ISearchViewProps extends ISearchProps<ISearchData> {
    Search: IModuleProps;
    AutoSuggestAriaLabel: INodeProps;
    AutoSuggestAriaLabelText: string;
    searchText: string;
    AutoSuggest: INodeProps;
    KeywordSuggest: INodeProps;
    ProductSuggest: INodeProps;
    CategorySuggest: INodeProps;
    SearchForm: INodeProps;
    FormWrapper: INodeProps;
    UlKeyword: INodeProps;
    UlProduct: INodeProps;
    UlCategory: INodeProps;
    label: React.ReactNode;
    form: React.ReactNode;
    autosuggestKeyword?: ISearchKeywordViewProps;
    autosuggestProduct?: ISearchProductViewProps;
    autosuggestCategory?: ISearchCategoryViewProps;
    callbacks: {
        handleCancelSearchChange(): void;
    };
    isSearchFormExpanded: boolean;
}

/**
 *
 * Search module
 * @extends {React.Component<ISearchProps<ISearchData>, ISearchState>}
 */
class Search extends React.Component<ISearchProps<ISearchData>, ISearchState> {
    private searchTextInput: React.RefObject<HTMLInputElement>;
    private searchCollapsedLabel: React.RefObject<HTMLButtonElement>;
    private formReference: React.RefObject<HTMLButtonElement>;
    private maxChars: number;
    private inputSuggestionType?: ISuggestionTypeCriterionData[];
    private topResultsCount?: number;
    private hitPrefix: string = '{';
    private hitSuffix: string = '}';
    private waitTime: number = 500;
    private autoSuggestResultScreenReaderDiv: React.RefObject<HTMLDivElement>;
    private autoSuggestResultDiv: React.RefObject<HTMLDivElement>;
    private searchFormClass: string;
    private searchLabelClass: string;
    private telemetryContent: ITelemetryContent;
    // @ts-ignore
    private cancellabelDebounce: debounce;

    constructor(props: ISearchProps<ISearchData>) {
        super(props);
        this.searchTextInput = React.createRef();
        this.searchCollapsedLabel = React.createRef();
        this.autoSuggestResultScreenReaderDiv = React.createRef();
        this.autoSuggestResultDiv = React.createRef();
        this.formReference = React.createRef();
        this.state = {
            isSearchFormExpanded: false,
            searchText: '',
            searchKeywordSuggestClass: 'ms-search__autoSuggest__keyword',
            searchProductSuggestClass: 'ms-search__autoSuggest__product',
            searchCategorySuggestClass: 'ms-search__autoSuggest__category',
            suggestions: undefined,
            searchRefiners: undefined,
            autoSuggestAriaLabel: '',
            isInitialState: true
        };
        this.maxChars =
            (this.props.context &&
                this.props.context.app &&
                this.props.context.app.config &&
                this.props.context.app.config.searchInputMaxLength) ||
            50;
        this.inputSuggestionType = this.props.config && this.props.config.suggestionTypeCriterion;
        this.topResultsCount = this.props.config && this.props.config.topResultsCount ? this.props.config.topResultsCount : 5;
        this.searchFormClass = 'ms-search__form';
        this.searchLabelClass = 'ms-search__label';
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
    }

    public async componentDidMount(): Promise<void> {
        document.body && document.body.addEventListener('mousedown', this._focusOutTarget);
        window && window.addEventListener('keyup', this._keyup);
    }

    public componentWillUnmount(): void {
        document.body && document.body.removeEventListener('mousedown', this._focusOutTarget, false);
        window && window.removeEventListener('keyup', this._keyup, false);
    }

    public componentDidUpdate(): void {
        const {
            config: { hideSearchLabel }
        } = this.props;
        const { isSearchFormExpanded, isInitialState } = this.state;

        if (!this.props.context.request.params.isEditor) {
            if (!hideSearchLabel && isSearchFormExpanded) {
                this.searchTextInput && this.searchTextInput.current && this.searchTextInput.current.focus();
            } else if (!isInitialState) {
                this.searchCollapsedLabel && this.searchCollapsedLabel.current && this.searchCollapsedLabel.current.focus();
            }
        }
    }

    // tslint:disable-next-line: cyclomatic-complexity max-func-body-length
    public render(): JSX.Element {
        const {
            context,
            resources: { searchtext, searchLabelArialLabel, cancelBtnAriaLabel, searchBtnAriaLabel, submitBtnAriaLabel},
            config: { hideSearchLabel, disableSubmitSearch, searchplaceholderText, className = '' }
        } = this.props;

        const {
            isSearchFormExpanded,
            searchText,
            searchKeywordSuggestClass,
            searchProductSuggestClass,
            searchCategorySuggestClass,
            suggestions,
            searchRefiners
        } = this.state;

        const searchQsp = (context && context.app && context.app.config && context.app.config.searchQueryStringParameter) || 'q';
        const searchPageURL = getUrlSync('search', context && context.actionContext) || '';
        const searchURL = this._appendQueryParams(searchPageURL, searchText, searchQsp);
        const searchPlaceholder = searchplaceholderText && searchplaceholderText.length > 0 ? searchplaceholderText : 'Search in Fabrikam';

        const keywordSuggestions =
            suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(
                i => i.SuggestionType === SuggestionType.Keyword || i.SuggestionType === SuggestionType.None
            );
        const productSuggestions =
            suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(i => i.SuggestionType === SuggestionType.Product);
        const categorySuggestions =
            suggestions &&
            suggestions.AllSearchResults &&
            suggestions.AllSearchResults.filter(i => i.SuggestionType === SuggestionType.Category);

        const viewProps: ISearchViewProps = {
            ...(this.props as ISearchProps<ISearchData>),

            Search: {
                moduleProps: this.props,
                className: `${classnames('ms-search', className)} ${disableSubmitSearch ? 'no-submit' : 'with-submit'}`,
            },
            AutoSuggestAriaLabel: {
                tag: 'div',
                className: 'msc-autoSuggest__screen-reader',
                'aria-live': 'assertive',
                ref: this.autoSuggestResultScreenReaderDiv
            },
            AutoSuggestAriaLabelText: this.state.autoSuggestAriaLabel,
            searchText: this.state.searchText,
            AutoSuggest: {
                ref: this.autoSuggestResultDiv,
                className: 'ms-search__autoSuggest'
            },
            KeywordSuggest: {
                className: searchKeywordSuggestClass
            },
            ProductSuggest: {
                className: searchProductSuggestClass
            },
            CategorySuggest: {
                className: searchCategorySuggestClass
            },
            SearchForm: {
                className: `${this.searchFormClass} ${isSearchFormExpanded ? 'bx-show' : 'bx-hide'}`
            },
            FormWrapper: {
                tag: 'form',
                ref: this.formReference,
                className: 'ms-search__searchForm',
                'aria-label': 'Search',
                name: 'searchForm',
                role: 'Search',
                action: searchURL,
                autoComplete: 'off',
                onSubmit: this._handleSubmit
            },
            UlKeyword: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__keywordResults-items', className)
            },
            UlProduct: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__productResults-items', className)
            },
            UlCategory: {
                tag: 'ul',
                className: classnames('msc-autoSuggest__categoryResults-items', className)
            },
            label:LabelComponent({
                isSearchFormExpanded: isSearchFormExpanded,
                searchLabelClass: `${this.searchLabelClass} ${isSearchFormExpanded ? 'bx-hide' : 'bx-show'}`,
                searchtext: searchtext,
                searchLabelArialLabel: searchLabelArialLabel,
                searchCollapsedLabel: this.searchCollapsedLabel,
                hideSearchLabel: hideSearchLabel,
                handleCancelSearchChange: this._handleCancelSearchChange,
                telemetryContent: this.telemetryContent
            }),
            form: FormComponent({
                ariaLabelCancel: cancelBtnAriaLabel,
                ariaLabelSearch: searchBtnAriaLabel,
                ariaLabelSubmit: submitBtnAriaLabel,
                hideSearchLabel: hideSearchLabel,
                searchTextInput: this.searchTextInput,
                isSearchFormExpanded: isSearchFormExpanded,
                disableSubmitSearch: disableSubmitSearch,
                handleInputChange: this._handleInputChange,
                handleCancelSearchChange: this._handleCancelSearchChange,
                maxChars: this.maxChars,
                searchQsp: searchQsp,
                searchPlaceholder: searchPlaceholder,
                query: searchText
            }),
            autosuggestKeyword:
                searchText && searchText.length > 0 && keywordSuggestions && keywordSuggestions.length > 0
                    ? KeywordSuggestionsComponent({
                          searchKeywordSuggestClass: searchKeywordSuggestClass,
                          searchPageURL: searchPageURL,
                          searchQsp: searchQsp,
                          hitPrefix: this.hitPrefix,
                          hitSuffix: this.hitSuffix,
                          autoSuggestProps: this.props,
                          searchText: searchText,
                          suggestions: keywordSuggestions,
                          telemetryContent: this.telemetryContent
                      })
                    : undefined,
            autosuggestProduct:
                searchText && searchText.length > 0 && productSuggestions && productSuggestions.length > 0
                    ? ProductSuggestionsComponent({
                          searchProductSuggestClass: searchProductSuggestClass,
                          searchPageURL: searchPageURL,
                          searchQsp: searchQsp,
                          hitPrefix: this.hitPrefix,
                          hitSuffix: this.hitSuffix,
                          autoSuggestProps: this.props,
                          searchText: searchText,
                          suggestions: productSuggestions,
                          telemetry: this.props.telemetry,
                          moduleType: this.props.typeName,
                          moduleId: this.props.id,
                          telemetryContent: this.telemetryContent
                      })
                    : undefined,
            autosuggestCategory:
                searchText && searchText.length > 0 && categorySuggestions && categorySuggestions.length > 0
                    ? CategorySuggestionsComponent({
                          searchCategorySuggestClass: searchCategorySuggestClass,
                          searchPageURL: searchPageURL,
                          searchQsp: searchQsp,
                          hitPrefix: this.hitPrefix,
                          hitSuffix: this.hitSuffix,
                          autoSuggestProps: this.props,
                          searchText: searchText,
                          suggestions: categorySuggestions,
                          searchRefiners: searchRefiners,
                          telemetryContent: this.telemetryContent
                      })
                    : undefined,
            callbacks: {
                handleCancelSearchChange: this._handleCancelSearchChange
            },
            isSearchFormExpanded: this.state.isSearchFormExpanded
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    // tslint:disable-next-line:no-any
    private _focusOutTarget = (e: any): void => {
        const { suggestions } = this.state;

        if (
            suggestions &&
            suggestions.AllSearchResults &&
            e.target.closest('.ms-search') === null
        ) {
            this._clearAutoSuggestState();
        }
    };

    private _keyup = (e: KeyboardEvent): void => {
        const { suggestions } = this.state;

        if (suggestions && suggestions.AllSearchResults && e.keyCode === KeyCodes.Escape) {
            this._clearAutoSuggestState();
        } else if(this.state.isSearchFormExpanded && e.keyCode === KeyCodes.Escape) {
            if(this.state.isSearchFormExpanded) {
                this.setState({ isSearchFormExpanded: false });
            }
        }

        if (!((this.formReference.current && this.formReference.current.contains(e.target as unknown as Node)) ||
        (this.autoSuggestResultDiv.current && this.autoSuggestResultDiv.current.contains(e.target as unknown as Node)))) {
            if (suggestions && suggestions.AllSearchResults) {
                this._clearAutoSuggestState();
            }

            if(this.state.isSearchFormExpanded) {
                this.setState({ isSearchFormExpanded: false });
            }
        }
    };

    private _clearAutoSuggestState = (): void => {
        const {
            context: { actionContext },
            data: { searchState }
        } = this.props;

        if (this.searchTextInput.current && this.searchTextInput.current.value.length > 0) {
            searchState.searchText = '';
            searchState.defaultBasicSearchUrl = '';
            searchState.searchQueryStringParameter = '';
            actionContext ? actionContext.update(createSearchStateInput(searchState), searchState) : null;
            this.searchTextInput.current.value = '';
        }

        this.setState({ searchText: '', suggestions: undefined, searchRefiners: undefined });
    };

    private _handleInputChange = (query: string): void => {
        if (!query || query.length < this.maxChars) {
            this.setState({ searchText: query });
        }

        if (this.cancellabelDebounce) {
            this.cancellabelDebounce.cancel();
        }

        const {
            telemetry,
            context,
            data: { searchState }
        } = this.props;

        if (context) {
            if (query && query.length > 0) {
                if (query.length > this.maxChars) {
                    return;
                }

                this.cancellabelDebounce = debounce(() => {
                    getSearchSuggestionsAction(
                        new AutoSuggestInput(
                            query,
                            this.topResultsCount,
                            this._getSuggestionType(this.inputSuggestionType),
                            this.hitPrefix,
                            this.hitSuffix
                        ),
                        context.actionContext
                    )
                        .then(results => {
                            this._getSearchRefiners(query)
                                .then(refiners => {
                                    this.setState({ suggestions: results, searchRefiners: refiners,
                                        autoSuggestAriaLabel: this._setAutoSuggestResultCount(results) });
                                })
                                .catch(error => {
                                    this.setState({ suggestions: results, searchRefiners: undefined,
                                        autoSuggestAriaLabel: this._setAutoSuggestResultCount(results) });
                                    telemetry.exception(error);
                                    telemetry.debug('Unable to get refiners results');
                                });
                        })
                        .catch(error => {
                            this.setState({ suggestions: undefined, searchRefiners: undefined,
                                autoSuggestAriaLabel: this._setAutoSuggestResultCount() });
                            telemetry.exception(error);
                            telemetry.debug('Unable to get auto suggest results');
                        });
                },                                  this.waitTime);

                setTimeout(() => {
                    this.cancellabelDebounce();
                },         0);

                searchState.searchText = query;
            } else {
                this.setState({ suggestions: undefined, searchRefiners: undefined });
                searchState.searchText = '';
            }
            context.actionContext.update(createSearchStateInput(searchState), searchState);
        }
    };

    private _getSuggestionType = (suggestionTypes?: ISuggestionTypeCriterionData[]): string => {
        if (suggestionTypes && suggestionTypes.length > 0) {
            const distinctSuggestionTypes: string[] = [];
            suggestionTypes && suggestionTypes.forEach((suggestionTypeItem, index) => {
                suggestionTypeItem.SuggestionType && distinctSuggestionTypes.push(suggestionTypeItem.SuggestionType.charAt(0).toUpperCase() + suggestionTypeItem.SuggestionType.slice(1));
            });
            return distinctSuggestionTypes.join(',');
        }
        return 'Keyword, Product, ScopedCategory';
    };

    private async _getSearchRefiners(searchText: string): Promise<ProductRefiner[]> {
        const { actionContext: ctx } = this.props.context;
        return getProductSearchRefinersAsync(
            { callerContext: ctx },
            {
                SearchCondition: searchText,
                Context: {
                    ChannelId: +ctx.requestContext.apiSettings.channelId,
                    CatalogId: +ctx.requestContext.apiSettings.catalogId
                }
            }
        );
    }

    private _handleSubmit = (
        e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement> | React.FormEvent<HTMLFormElement>
    ): void => {
        const {
            config: { disableSubmitSearch },
            context: {
                actionContext,
                app: {
                    config: { searchQueryStringParameter }
                }
            }
        } = this.props;

        const query = this.searchTextInput.current && this.searchTextInput.current.value;
        e.preventDefault();

        if (!query || (query && query.length === 0) || disableSubmitSearch) {
            this.searchTextInput && this.searchTextInput.current && this.searchTextInput.current.focus();
        } else {
            const searchQsp = searchQueryStringParameter || 'q';
            const searchURL = this._appendQueryParams(getUrlSync('search', actionContext) || '', query, searchQsp);
            document.location.href = searchURL;
        }
    };

    private _handleCancelSearchChange = (): void => {
        const { isSearchFormExpanded, suggestions } = this.state;

        if (!isSearchFormExpanded) {
            this.setState({
                isSearchFormExpanded: true,
                searchText: '',
                isInitialState: false
            });
        } else {
            if (suggestions && suggestions.AllSearchResults) {
                this._clearAutoSuggestState();
            }

            this.setState({ isSearchFormExpanded: false });
        }
    };

    private _appendQueryParams = (route: string, query: string, qsp: string): string => {
        if (route && route.length > 0) {
            return query && query.length > 0 ? `${route}${route.indexOf('?') === -1 ? '?' : '&'}${qsp}=${query}` : route;
        }
        return '';
    };

    private _setAutoSuggestResultCount = (result?: Autosuggestions) => {
        if (this.autoSuggestResultScreenReaderDiv.current !== null) {
            const ariaLiveRegion = this.autoSuggestResultScreenReaderDiv.current;
            const suggestResultString = this.props.resources.autoSuggestFoundMessage;
            const emptyResultString = this.props.resources.noAutoSuggestionMessage;
            ariaLiveRegion.innerText = result && (result.AllSearchResults && result.AllSearchResults.length > 0) ? suggestResultString : emptyResultString;
            ariaLiveRegion.setAttribute('aria-live','assertive');
            return ariaLiveRegion.innerText;
        } else {
            return '';
        }
    };
}

export default Search;

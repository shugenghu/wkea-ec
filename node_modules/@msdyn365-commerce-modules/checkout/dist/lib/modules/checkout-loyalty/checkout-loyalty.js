import { __decorate } from "tslib";
import classnames from 'classnames';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { GetLoyaltyTransactionEstimationInput } from '@msdyn365-commerce-modules/retail-actions';
import { Button, Drawer, Heading } from '@msdyn365-commerce-modules/utilities';
import { PriceComponent } from '@msdyn365-commerce/components';
import { callActionOrExecute } from '@msdyn365-commerce/retail-proxy';
import { createGetMaxLoyaltyPointsToRedeemForTransactionBalanceInput } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import InputComponent from './components/checkout-loyalty-input';
import LabelComponent from './components/checkout-loyalty-label';
import TextComponent from './components/checkout-loyalty-text';
let CheckoutLoyalty = class CheckoutLoyalty extends React.Component {
    constructor(props) {
        super(props);
        this.moduleClassName = 'ms-checkout-loyalty';
        this.init = async () => {
            this.props.moduleState.init({
                onEdit: this.onEdit,
                onCancel: this.onCancel,
                onSubmit: this.onSubmit,
                isRequired: false,
                ...(!this.isEnabled() && { status: 'disabled' })
            });
            const savedLoyaltyAmount = this.props.data.checkout.result?.loyaltyAmount;
            if (savedLoyaltyAmount) {
                this.props.moduleState.onReady();
            }
            else if (this.isPaymentVerificationRedirection) {
                this.props.moduleState.onSkip();
            }
            else if (this.props.data.loyaltyCard.result &&
                this.props.data.checkout.result &&
                this.props.data.loyaltyCard.result.CardNumber !== this.props.data.checkout.result.checkoutCart.cart.LoyaltyCardId) {
                this.props.data.checkout.result.checkoutCart
                    .updateLoyaltyCardId({ loyaltyCardNumber: this.props.data.loyaltyCard.result.CardNumber })
                    .catch(error => {
                    if (this.context.telemetry) {
                        this.context.telemetry.warning(error);
                        this.context.telemetry.debug('Unable to update the loyalty card');
                    }
                });
            }
        };
        this.onEdit = () => {
            this.props.moduleState.onUpdating();
        };
        this.onCancel = () => {
            this.handleCancelOrSubmit();
        };
        this.onSubmit = () => {
            this.handleCancelOrSubmit();
        };
        this.handleCancelOrSubmit = () => {
            const checkoutState = this.props.data.checkout.result;
            if (checkoutState && checkoutState.loyaltyAmount > 0) {
                this.props.moduleState.onReady();
            }
            else {
                this.props.moduleState.onSkip();
            }
        };
        this.isEnabled = () => {
            return (this.props.context.request.user.isAuthenticated &&
                this.props.data.loyaltyCard.result &&
                this.props.data.loyaltyCard.result.CardNumber &&
                this.shouldPayLoyalty);
        };
        this._dialogToggleRef = React.createRef();
        this._applyLoyaltyPoints = this._applyLoyaltyPoints.bind(this);
        this._removeLoyaltyPoints = this._removeLoyaltyPoints.bind(this);
        this._onInputChange = this._onInputChange.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this.state = { dollarsApplied: this.maxDollars, isFetchingLoyaltyCard: false };
    }
    get shouldPayLoyalty() {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }
        const amountDue = cart.TotalAmount || 0;
        return amountDue > 0;
    }
    get isDataReady() {
        return ((this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS' &&
            (this.props.data.loyaltyCard && this.props.data.loyaltyCard.status) !== 'LOADING' &&
            (this.props.data.loyaltyTransactionEstimation && this.props.data.loyaltyTransactionEstimation.status) !== 'LOADING');
    }
    get maxDollars() {
        return this.props.data.loyaltyTransactionEstimation.result &&
            this.props.data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints
            ? this.props.data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints
            : 0;
    }
    get isPaymentVerificationRedirection() {
        const { requestFormData, query } = this.props.context.request;
        return requestFormData && query && query.pv === '1' ? true : false;
    }
    async componentDidMount() {
        when(() => this.isDataReady, async () => {
            await this.init();
        });
        reaction(() => this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart, async () => {
            this._updateEstimate();
        });
        reaction(() => this.props.data.loyaltyCard.result, async () => {
            this._updateLoyalty();
        });
    }
    render() {
        const { resources, renderView, moduleState: { isReady } } = this.props;
        if (this.props.data.loyaltyCard &&
            this.props.data.loyaltyCard.result &&
            this.props.data.loyaltyCard.result.CardNumber &&
            this.shouldPayLoyalty) {
            const loyaltyCard = this.props.data.loyaltyCard.result;
            const checkoutState = this.props.data.checkout.result;
            let isShowLoyalty = false;
            if (isReady) {
                if (!checkoutState || checkoutState.loyaltyAmount === 0) {
                    return null;
                }
                else {
                    isShowLoyalty = true;
                }
            }
            const viewProps = {
                ...this.props,
                viewState: {
                    isShowLoyalty: isShowLoyalty,
                    isShowAddLoyalty: !isReady
                },
                checkoutLoyalty: {
                    moduleProps: this.props,
                    className: classnames(this.moduleClassName, { [`${this.moduleClassName}__applied`]: isShowLoyalty }, this.props.config.className)
                },
                showLoyalty: {
                    heading: React.createElement(Heading, { headingTag: 'h3', className: `${this.moduleClassName}__heading`, text: resources.loyaltyHeadingText }),
                    coveredAmountText: (React.createElement(TextComponent, { className: `${this.moduleClassName}__text`, text: resources.loyaltyCoveredAmountText })),
                    amount: (React.createElement(PriceComponent, { className: `${this.moduleClassName}__applied-value`, id: this.props.id, typeName: this.props.typeName, context: this.props.context, data: { price: { CustomerContextualPrice: checkoutState && checkoutState.loyaltyAmount } } }))
                },
                addLoyalty: {
                    heading: React.createElement(Heading, { headingTag: 'h3', className: `${this.moduleClassName}__heading`, text: resources.loyaltyHeadingText }),
                    drawer: {
                        tag: Drawer,
                        className: `${this.moduleClassName}__drawer`,
                        toggleButtonText: this._drawerHeader(),
                        openGlyph: `${this.moduleClassName}__drawer-open`,
                        closeGlyph: `${this.moduleClassName}__drawer-close`,
                        glyphPlacement: 'end'
                    },
                    cardNumber: React.createElement(TextComponent, { className: `${this.moduleClassName}__card-number`, text: loyaltyCard.CardNumber || '' }),
                    rewardPoints: loyaltyCard.RewardPoints &&
                        loyaltyCard.RewardPoints.map((points, index) => {
                            return this._renderPointSection(points, resources.availablePointsLabel, resources.expiringLoyaltyPointsLabel);
                        }),
                    loyaltyAmountContainer: {
                        className: `${this.moduleClassName}__amount`
                    },
                    appliedLoyaltyAmountContainer: {
                        className: `${this.moduleClassName}__applied-amount`
                    },
                    loyaltyAmountLabel: (React.createElement(LabelComponent, { className: `${this.moduleClassName}__amount-label`, text: resources.payWithLoyaltyAmountLabel, htmlFor: `${this.props.id}-label` })),
                    loyaltyAmountInput: (React.createElement(InputComponent, { className: `${this.moduleClassName}__amount-input`, onChange: this._onInputChange, onBlur: this._onBlur, type: 'number', step: '.01', value: this.state.dollarsApplied, min: 0, max: this.maxDollars, ariaValueMax: this.maxDollars, ariaValueMin: 0, ariaValueNow: this.state.dollarsApplied, id: `${this.props.id}-label` })),
                    loyaltyAmountApplyButton: (React.createElement(Button, { className: `${this.moduleClassName}__amount-button`, title: this.props.resources.applyCheckoutLoyaltyPaymentText, onClick: this._applyLoyaltyPoints, disabled: this.state.dollarsApplied > this.maxDollars ||
                            this.state.dollarsApplied <= 0 ||
                            this.state.isFetchingLoyaltyCard }, this.props.resources.applyCheckoutLoyaltyPaymentText)),
                    showAppliedAmount: checkoutState && checkoutState.loyaltyAmount > 0,
                    loyaltyAmountAppliedText: (React.createElement(TextComponent, { className: `${this.moduleClassName}__applied-text`, text: resources.loyaltyCoveredAmountText })),
                    loyaltyAmountAppliedPrice: (React.createElement(PriceComponent, { className: `${this.moduleClassName}__applied-value`, id: this.props.id, typeName: this.props.typeName, context: this.props.context, data: { price: { CustomerContextualPrice: checkoutState && checkoutState.loyaltyAmount } } })),
                    loyaltyAmountRemoveButton: (React.createElement(Button, { className: 'ms-checkout-loyalty-remove-btn', title: this.props.resources.removeCheckoutLoyaltyPaymentText, onClick: this._removeLoyaltyPoints, innerRef: this._dialogToggleRef }, this.props.resources.removeCheckoutLoyaltyPaymentText))
                }
            };
            return renderView(viewProps);
        }
        this.props.context.telemetry.error('Checkout loyalty content is empty, module wont render');
        return null;
    }
    _drawerHeader() {
        return (React.createElement(React.Fragment, null,
            React.createElement("p", { className: `${this.moduleClassName}__covered-text` }, this.props.resources.loyaltyCoveredAmountText),
            React.createElement(PriceComponent, { className: `${this.moduleClassName}__applied-value`, id: this.props.id, typeName: this.props.typeName, context: this.props.context, data: { price: { CustomerContextualPrice: this.maxDollars } } })));
    }
    _renderPointSection(point, loyaltyCoveredAmountText, expiringLoyaltyPointsLabel) {
        return {
            key: point.RewardPointId || '',
            checkoutLoyaltyRewardPoint: {
                className: `${this.moduleClassName}__program`
            },
            title: React.createElement(TextComponent, { className: `${this.moduleClassName}__program-title`, text: point.Description }),
            availablePointsText: React.createElement(TextComponent, { className: `${this.moduleClassName}__program-available`, text: loyaltyCoveredAmountText }),
            activePoints: (React.createElement(TextComponent, { className: `${this.moduleClassName}__program-points`, text: (point && point.ActivePoints).toString() })),
            expiringPointsText: React.createElement(TextComponent, { className: `${this.moduleClassName}__program-expiring`, text: expiringLoyaltyPointsLabel }),
            expiringPoints: (React.createElement(TextComponent, { className: `${this.moduleClassName}__program-points`, text: (point && point.PointsExpiringSoon).toString() }))
        };
    }
    async _applyLoyaltyPoints() {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState) {
            return;
        }
        await checkoutState.updateLoyaltyAmount({ newAmount: parseFloat(this.state.dollarsApplied.toString()) });
        this.setState({
            isFetchingLoyaltyCard: true
        });
    }
    async _removeLoyaltyPoints() {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState) {
            return;
        }
        await checkoutState.updateLoyaltyAmount({ newAmount: 0 });
        this.setState({
            dollarsApplied: 0
        });
    }
    _onInputChange(event) {
        const value = event.currentTarget.value;
        this.setState({ dollarsApplied: value.length ? Number(value) : parseFloat(value), isFetchingLoyaltyCard: false });
    }
    _onBlur(event) {
        const num = parseFloat(event.currentTarget.value).toFixed(2);
        const element = document.getElementById(`${this.props.id}-label`);
        if (element && num) {
            element.value = num;
            this.setState({ dollarsApplied: parseFloat(num) });
        }
    }
    _updateLoyalty() {
        if (this.props.moduleState.isDisabled && this.isEnabled()) {
            this._updateEstimate();
            this.props.moduleState.onUpdating();
        }
    }
    _updateEstimate() {
        const card = this.props.data.loyaltyCard.result;
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        const channelConfig = this.props.context.request.channel;
        if (card && cart && channelConfig) {
            const currencyCode = channelConfig.Currency || '';
            const loyalPointsRequest = createGetMaxLoyaltyPointsToRedeemForTransactionBalanceInput(cart.Id, card.CardNumber, currencyCode);
            loyalPointsRequest._query.options.bypassCache = 'get';
            callActionOrExecute(loyalPointsRequest, this.props.context.actionContext)
                .then(async (points) => {
                this.props.context.actionContext.update(new GetLoyaltyTransactionEstimationInput(this.props.context.request.apiSettings), points);
                const newMaxPoints = (points && points.MaxCurrencyValueOfLoyaltyPoints) || 0;
                if (this.props.data.checkout.result && this.props.data.checkout.result.loyaltyAmount > newMaxPoints) {
                    await this.props.data.checkout.result.updateLoyaltyAmount({ newAmount: newMaxPoints });
                }
                if (this.state.dollarsApplied > newMaxPoints) {
                    this.setState({ dollarsApplied: newMaxPoints });
                }
            })
                .catch(error => {
                this.props.context.actionContext.telemetry.exception(error);
                this.props.context.actionContext.telemetry.debug('Error getting Loyalty Point Redemption Estimate');
            });
        }
    }
};
__decorate([
    computed
], CheckoutLoyalty.prototype, "shouldPayLoyalty", null);
__decorate([
    computed
], CheckoutLoyalty.prototype, "isDataReady", null);
__decorate([
    computed
], CheckoutLoyalty.prototype, "maxDollars", null);
__decorate([
    computed
], CheckoutLoyalty.prototype, "isPaymentVerificationRedirection", null);
CheckoutLoyalty = __decorate([
    withModuleState,
    observer
], CheckoutLoyalty);
export default CheckoutLoyalty;
//# sourceMappingURL=checkout-loyalty.js.map
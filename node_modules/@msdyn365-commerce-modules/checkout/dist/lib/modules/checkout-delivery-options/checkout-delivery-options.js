import { __decorate } from "tslib";
import classname from 'classnames';
import get from 'lodash/get';
import { action, observable, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { Button, getTelemetryObject, Waiting } from '@msdyn365-commerce-modules/utilities';
import { PriceComponent } from '@msdyn365-commerce/components';
import { getDeliveryOptionsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import DescriptionComponent from './components/checkout-delivery-options.description';
import ErrorMessageComponent from './components/checkout-delivery-options.error-message';
import ErrorTitleComponent from './components/checkout-delivery-options.error-title';
import RadioButtonComponent from './components/checkout-delivery-options.radio-button';
let CheckoutDeliveryOptions = class CheckoutDeliveryOptions extends React.Component {
    constructor(props) {
        super(props);
        this.selectedItemId = '';
        this.deliveryOptions = [];
        this.isLoading = false;
        this.init = async () => {
            this.props.moduleState.init({
                onEdit: this.onEdit,
                onCancel: this.onCancel,
                onSubmit: this.onSubmit,
                status: this.canShip() ? 'updating' : 'disabled'
            });
            this.cartDeliveryMode = this.getSavedDeliveryOption();
            await this.loadDeliveryOptions();
        };
        this.canShip = () => {
            return this.getCartLinesForShipping().length > 0;
        };
        this.isDeliveryModeExists = (deliveryMode) => {
            if (deliveryMode) {
                if (this.deliveryOptions.find(deliveryOption => deliveryOption.Code === deliveryMode)) {
                    return true;
                }
            }
            return false;
        };
        this.getDeliveryOptionSelected = () => {
            const selectedItem = this.deliveryOptions.find(deliveryOption => deliveryOption.Code === this.selectedItemId);
            if (!selectedItem) {
                this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
                return null;
            }
            const { id, typeName, context } = this.props;
            const { priceFree } = this.props.resources;
            const price = get(selectedItem, 'ShippingChargeAmount', 0);
            return {
                DeliveryOption: { className: 'ms-checkout-delivery-options__option-selected' },
                description: React.createElement(DescriptionComponent, Object.assign({}, { description: selectedItem.Description })),
                price: React.createElement(PriceComponent, { id: id, typeName: typeName, context: context, className: 'ms-checkout-delivery-options__price', data: { price: { CustomerContextualPrice: price } }, freePriceText: priceFree })
            };
        };
        this.getErrorMessage = () => {
            const { errorMessageTitle } = this.props.resources;
            return {
                CheckoutDeliveryOptionsError: { tag: 'span', className: 'ms-address-form__error', role: 'alert', 'aria-live': 'assertive' },
                title: React.createElement(ErrorTitleComponent, Object.assign({}, { title: errorMessageTitle })),
                message: React.createElement(ErrorMessageComponent, Object.assign({}, { message: this.errorMessage }))
            };
        };
        this.getDeliveryOptionList = () => {
            const count = this.deliveryOptions.length;
            const { priceFree } = this.props.resources;
            const { id, typeName, context } = this.props;
            return this.deliveryOptions.map((deliveryOption, index) => {
                return {
                    DeliveryOption: { className: 'ms-checkout-delivery-options__option' },
                    code: deliveryOption.Code || '',
                    radioButton: (React.createElement(RadioButtonComponent, Object.assign({}, {
                        isChecked: deliveryOption.Code === this.selectedItemId,
                        value: deliveryOption.Code,
                        ariaSetSize: count,
                        ariaPosInSet: index + 1,
                        ariaLabel: `${deliveryOption.Description} ${priceFree}`,
                        onChange: this.onDeliveryOptionChange,
                        telemetryContent: this.telemetryContent
                    }))),
                    description: (React.createElement(DescriptionComponent, Object.assign({}, {
                        description: deliveryOption.Description
                    }))),
                    price: (React.createElement(PriceComponent, { id: id, typeName: typeName, context: context, className: 'ms-checkout-delivery-options__price', data: { price: { CustomerContextualPrice: get(deliveryOption, 'ShippingChargeAmount', 0) } }, freePriceText: priceFree }))
                };
            });
        };
        this.getSaveButton = () => {
            const { saveBtnLabel = 'Save' } = this.props.resources;
            return (React.createElement(Button, { className: 'ms-checkout-delivery-options__btn-save', title: saveBtnLabel, color: 'primary', disabled: !this.selectedItemId, onClick: this.onSave }, saveBtnLabel));
        };
        this.getEditButton = () => {
            const { editBtnLabel = 'Change' } = this.props.resources;
            return (React.createElement(Button, { className: 'ms-checkout-delivery-options__btn-edit', title: editBtnLabel, color: 'primary', onClick: this.onEdit }, editBtnLabel));
        };
        this.getCancelButton = () => {
            const { cancelBtnLabel = 'Cancel' } = this.props.resources;
            return (React.createElement(Button, { className: 'ms-checkout-delivery-options__btn-cancel', title: cancelBtnLabel, color: 'secondary', onClick: this.onCancel }, cancelBtnLabel));
        };
        this.setError = (errorMessage) => {
            this.props.telemetry.error(errorMessage);
            this.props.moduleState.setHasError(true);
            this.props.moduleState.onUpdating();
            this.errorMessage = errorMessage;
        };
        this.clearError = () => {
            this.props.moduleState.setHasError(false);
            this.errorMessage = undefined;
        };
        this.onSave = () => {
            this.onSubmit();
        };
        this.onEdit = () => {
            this.onUpdating();
        };
        this.onSubmit = () => {
            this.updateCartDeliverySpecification(this.selectedItemId);
        };
        this.onCancel = () => {
            const savedDeliveryOption = this.getSavedDeliveryOption();
            if (savedDeliveryOption) {
                this.selectedItemId = savedDeliveryOption;
                this.onReady();
            }
            else {
                this.onUpdating();
            }
        };
        this.getSavedDeliveryOption = () => {
            const cartLinesForShipping = this.getCartLinesForShipping();
            return cartLinesForShipping[0] && cartLinesForShipping[0].DeliveryMode;
        };
        this.updateCartDeliverySpecification = async (deliveryModeId) => {
            if (deliveryModeId.trim() === '') {
                return;
            }
            const { resources } = this.props;
            const checkoutState = this.props.data.checkout.result;
            const updateCartDeliverySpecificationInput = {
                deliveryModeId: deliveryModeId,
                shippingAddress: checkoutState.shippingAddress
            };
            this.clearError();
            this.onPending();
            await checkoutState.checkoutCart.updateCartDeliverySpecification(updateCartDeliverySpecificationInput)
                .then((response) => {
                if (response.status === 'FAILED') {
                    this.setError(resources.genericErrorMessage);
                }
                else {
                    this.onReady();
                    this.props.moduleState.setIsCancellable(true);
                }
            })
                .catch(() => {
                this.setError(resources.genericErrorMessage);
            });
        };
        this.getCartLinesForShipping = () => {
            const { request } = this.props.context;
            const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;
            return ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(cartLine => (cartLine.DeliveryMode && cartLine.DeliveryMode !== '') ? cartLine.DeliveryMode !== pickupDeliveryModeCode : cartLine);
        };
        this.getDeliveryOptions = async (shippingAddress) => {
            if (!this.props.data.checkout.result) {
                return;
            }
            const { context, resources, config } = this.props;
            const cartState = this.props.data.checkout.result?.checkoutCart;
            const cartId = cartState.cart.Id;
            if (context) {
                this.isLoading = true;
                this.deliveryOptions = [];
                this.selectedItemId = '';
                this.clearError();
                try {
                    let originalDeliveryMode = '';
                    const shippingCartLines = this.getCartLinesForShipping();
                    const hasShippingDeliveryLines = (shippingCartLines && shippingCartLines.length > 0 && shippingCartLines[0].DeliveryMode);
                    if (hasShippingDeliveryLines) {
                        originalDeliveryMode = shippingCartLines[0].DeliveryMode || '';
                        const cart = cartState.cart;
                        await cartState.clearCartLinesDeliveryInformation({ cart });
                    }
                    let deliveryOptionFilter;
                    switch (config.filterDeliveryModeOption) {
                        case "none":
                            deliveryOptionFilter = 0;
                            break;
                        case "filterOutNonCarrierDeliveryMode":
                            deliveryOptionFilter = 1;
                            break;
                        default:
                            deliveryOptionFilter = 1;
                    }
                    const response = await getDeliveryOptionsAsync({ callerContext: context.actionContext, queryResultSettings: {} }, cartId, shippingAddress, [], deliveryOptionFilter);
                    if (hasShippingDeliveryLines) {
                        await this.updateCartDeliverySpecification(originalDeliveryMode);
                    }
                    if (response && response.length) {
                        this.deliveryOptions = response;
                    }
                }
                catch (error) {
                    this.setError(resources.genericErrorMessage);
                }
                if (this.deliveryOptions.length === 0) {
                    this.setError(resources.deliveryOptionsNotFound);
                }
                else {
                    if (this.cartDeliveryMode && this.isDeliveryModeExists(this.cartDeliveryMode) && !this.props.data.checkout.result?.checkoutCart.cart.ShippingAddress) {
                        this.selectedItemId = this.cartDeliveryMode;
                        this.cartDeliveryMode = undefined;
                        this.onReady();
                    }
                    else {
                        this.onUpdating();
                        this.selectedItemId = this.deliveryOptions.length > 0 ? this.deliveryOptions[0].Code || '' : '';
                    }
                }
                this.isLoading = false;
            }
        };
        this.loadDeliveryOptions = async () => {
            const shippingAddress = this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress;
            if (this.canShip() && shippingAddress) {
                await this.getDeliveryOptions(shippingAddress);
            }
        };
        this.onDeliveryOptionChange = (event) => {
            const deliveryModeId = event.currentTarget.value;
            this.selectedItemId = deliveryModeId;
        };
        this.onReady = () => {
            this.props.moduleState.onReady();
        };
        this.onUpdating = () => {
            this.props.moduleState.onUpdating();
        };
        this.onPending = () => {
            this.props.moduleState.onPending();
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
    }
    async componentDidMount() {
        this.props.data.checkout.then(async () => {
            await this.init();
        });
        reaction(() => this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress, async () => {
            await this.loadDeliveryOptions();
            this.props.moduleState.setIsCancellable(false);
        });
    }
    render() {
        if (!this.canShip()) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }
        const { moduleState: { isReady, isUpdating, hasError } } = this.props;
        const isError = !this.isLoading && hasError;
        const isShowList = !this.isLoading && !hasError && isUpdating;
        const isShowSelected = !this.isLoading && !hasError && isReady;
        const viewProps = {
            ...this.props,
            onDeliveryOptionChange: this.onDeliveryOptionChange,
            selectedItemId: this.selectedItemId,
            deliveryOptionsData: this.deliveryOptions,
            isLoading: this.isLoading,
            errorMessageData: this.errorMessage,
            viewState: {
                isLoading: this.isLoading,
                isError: isError,
                isShowList: isShowList,
                isShowSelected: isShowSelected,
                isShowSaveButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup,
                isShowEditButton: isShowSelected && !this.props.moduleState.hasExternalSubmitGroup,
                isShowCancelButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup && !!this.getSavedDeliveryOption()
            },
            CheckoutDeliveryOptions: {
                moduleProps: this.props,
                className: classname('ms-checkout-delivery-options', this.props.config.className)
            },
            deliveryOptions: {
                DeliveryOptionsList: { className: 'ms-checkout-delivery-options__list' },
                list: this.getDeliveryOptionList()
            },
            deliveryOptionSelected: this.getDeliveryOptionSelected(),
            errorMessage: this.getErrorMessage(),
            waiting: React.createElement(Waiting, null),
            saveButton: this.getSaveButton(),
            editButton: this.getEditButton(),
            cancelButton: this.getCancelButton(),
            onSave: this.onSave,
            onEdit: this.onEdit,
            onCancel: this.onCancel
        };
        return this.props.renderView(viewProps);
    }
};
__decorate([
    observable
], CheckoutDeliveryOptions.prototype, "selectedItemId", void 0);
__decorate([
    observable
], CheckoutDeliveryOptions.prototype, "deliveryOptions", void 0);
__decorate([
    observable
], CheckoutDeliveryOptions.prototype, "isLoading", void 0);
__decorate([
    observable
], CheckoutDeliveryOptions.prototype, "errorMessage", void 0);
__decorate([
    action
], CheckoutDeliveryOptions.prototype, "init", void 0);
CheckoutDeliveryOptions = __decorate([
    withModuleState,
    observer
], CheckoutDeliveryOptions);
export default CheckoutDeliveryOptions;
//# sourceMappingURL=checkout-delivery-options.js.map
import { __decorate } from "tslib";
import classnames from 'classnames';
import get from 'lodash/get';
import { action, computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { Modal } from '@msdyn365-commerce-modules/utilities';
import { getUrlSync } from '@msdyn365-commerce/core';
import { retrieveCardPaymentAcceptResultAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { resolveCardTypesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import getCardPaymentAcceptPointAction, { GetCardPaymentAcceptPointInput } from './actions/get-card-payment-accept-point';
import AddPaymentFormComponent from './components/add-payment-form';
import ErrorComponent from './components/error';
import PaymentInformationComponent from './components/payment-information';
import WaitingComponent from './components/waiting';
import withVisibilityObserver from './components/with-visibility-observer';
import { paymentConnectorExtraContextMessage, PaymentConnectorPostMessageType, paymentConnectorSubmitMessage } from './payment-instrument-message';
let CheckoutPaymentInstrument = class CheckoutPaymentInstrument extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isFetchingPaymentConnector: true
        };
        this.moduleClassName = 'ms-checkout-payment-instrument';
        this.iframeRef = React.createRef();
        this.onIFrameMessage = async (event) => {
            let result;
            try {
                if (typeof event.data !== 'string') {
                    return;
                }
                result = JSON.parse(event.data);
            }
            catch (error) {
                this.setTerminalError(error);
                return;
            }
            const paymentConnectorId = this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId;
            if (!result || !result.type || result.id !== paymentConnectorId) {
                return;
            }
            const { type, value } = result;
            switch (type) {
                case PaymentConnectorPostMessageType.Height:
                    this.setState({
                        isFetchingPaymentConnector: false,
                        paymentConnectorHeight: value
                    });
                    return;
                case PaymentConnectorPostMessageType.Result:
                    this.handlePaymentResult(value);
                    return;
                case PaymentConnectorPostMessageType.CardPrefix:
                    await this.handlePaymentCardPrefix(value);
                    return;
                case PaymentConnectorPostMessageType.Error:
                    this.handlePaymentError(value);
                    return;
                case PaymentConnectorPostMessageType.Redirect:
                    this.handlePaymentRedirect(value);
                    return;
                case PaymentConnectorPostMessageType.Showoverlay:
                    this.showOverlayModal(true);
                    return;
                case PaymentConnectorPostMessageType.Hideoverlay:
                    this.showOverlayModal(false);
                    return;
                default:
                    return;
            }
        };
        this.handlePaymentResult = (resultAccessCode, isRedirectedFromPaymentGateway = false) => {
            const { data: { checkout, cardPaymentAcceptPoint }, config: { paymenTenderType } } = this.props;
            const cartId = checkout.result?.checkoutCart.cart.Id || '';
            const paymentConnectorId = cardPaymentAcceptPoint.result?.PaymentConnectorId;
            const settings = {
                ReturnUrl: this.getReturnUrl(),
                ...(paymentConnectorId && { PaymentConnectorId: paymentConnectorId }),
            };
            retrieveCardPaymentAcceptResultAsync({ callerContext: this.props.context.actionContext }, resultAccessCode, [], cartId, settings)
                .then(async (cardPaymentAcceptResult) => {
                const { TenderLine, TokenizedPaymentCard, AdditionalContext } = cardPaymentAcceptResult || {};
                await this.saveBillingAddress(TokenizedPaymentCard);
                if (AdditionalContext) {
                    this.handleAdditionalContext(AdditionalContext);
                }
                else {
                    if (!TokenizedPaymentCard) {
                        this.setTerminalError(new Error('No TokenizedPaymentCard found'));
                        return;
                    }
                    const checkoutState = this.props.data.checkout.result;
                    if (checkoutState) {
                        if (!checkoutState.cardPrefix) {
                            const cardPrefix = TokenizedPaymentCard &&
                                TokenizedPaymentCard.CardTokenInfo &&
                                TokenizedPaymentCard.CardTokenInfo.MaskedCardNumber;
                            if (cardPrefix) {
                                await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
                            }
                        }
                        if (!TokenizedPaymentCard.CardTypeId) {
                            const cardTypeId = await this.getCardTypeId(checkoutState.cardPrefix || '');
                            if (!cardTypeId) {
                                const error = new Error('The specified card type is not supported.');
                                error.name = 'CARDTYPENOTFOUND';
                                this.setTerminalError(error);
                                return;
                            }
                            TokenizedPaymentCard.CardTypeId = cardTypeId;
                        }
                        await checkoutState.updateTenderLine({ newTenderLine: TenderLine });
                        await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: TokenizedPaymentCard });
                        await checkoutState.updatePaymentTenderType({ newPaymentTenderType: paymenTenderType });
                        if (isRedirectedFromPaymentGateway) {
                            this.props.data.checkout.result?.checkoutCart.refreshCart({});
                        }
                        this.props.moduleState.setHasError(false);
                        this.props.moduleState.onReady();
                        this.setState({
                            terminalError: null,
                            errorMessage: null
                        });
                        this.props.moduleState.setIsSubmitContainer(true);
                    }
                }
            })
                .catch(error => {
                this.updatePaymentAcceptPageData();
                this.setTerminalError(error);
                return;
            })
                .finally(() => {
                this.setState({
                    isPaymentProcessing: false
                });
            });
        };
        this.handlePaymentCardPrefix = async (cardPrefix) => {
            const checkoutState = this.props.data.checkout.result;
            if (checkoutState) {
                await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
            }
        };
        this.handlePaymentRedirect = (redirectData) => {
            this.setState({
                isPaymentVerificationRequried: true,
                paymentVerificationPostData: redirectData
            });
            this.props.moduleState.setHasError(false);
            this.props.moduleState.onReady();
        };
        this.showOverlayModal = (isShow) => {
            this.setState({ isOverlayModal: isShow });
        };
        this.getCardTypeId = async (cardPrefix = '') => {
            try {
                const response = await resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, cardPrefix, -1);
                if (response && response.length > 0) {
                    return response[0].TypeId;
                }
            }
            catch (error) {
                this.props.context.telemetry.error('Call to resolveCardTypesAsync failed.', error);
            }
            return undefined;
        };
        this.redirectToPaymentVerification = async () => {
            const { isPaymentVerificationRequried, paymentVerificationPostData } = this.state;
            if (!isPaymentVerificationRequried || !paymentVerificationPostData) {
                return;
            }
            const checkoutState = this.props.data.checkout.result;
            if (checkoutState) {
                await checkoutState.updatePaymentTenderType({ newPaymentTenderType: this.props.config.paymenTenderType });
                await checkoutState.saveDataInStorage({});
            }
            const redirectInfo = JSON.parse(paymentVerificationPostData);
            const { url, data } = redirectInfo;
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = url;
            for (const propertyName of Object.keys(data)) {
                const element = document.createElement('input');
                element.name = propertyName;
                element.value = data[propertyName];
                form.appendChild(element);
            }
            document.body.appendChild(form);
            form.submit();
        };
        this.handlePaymentError = (value) => {
            const { resources: { defaultSubmitErrorMessage = 'An error occurred in payment method details. Please try again.' } } = this.props;
            if (!value || value.length === 0) {
                this.setErrorMessage(defaultSubmitErrorMessage);
                return;
            }
            this.setErrorMessage(value.map((_value) => _value.Message).join('\n'));
        };
        this.getReturnUrl = () => {
            let returnUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
            const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
            const isAbsoluteUrl = absoluteUrlRegExp.test(returnUrl);
            if (window && !isAbsoluteUrl) {
                returnUrl = `${window.location.origin}${returnUrl}`;
            }
            return `${returnUrl}${returnUrl.indexOf('?') === -1 ? '?' : '&'}pv=1`;
        };
        this.init = () => {
            this.props.moduleState.init({
                onEdit: this.onEdit,
                onCancel: this.onCancel,
                onSubmit: this.onSubmit,
                onContainerReady: this.onContainerReady,
                isCancellable: false,
                status: this.shouldPaidByCard ? 'updating' : 'disabled'
            });
            const { data: { checkout }, config } = this.props;
            if (this.isPaymentVerificationRedirection) {
                if (config.paymenTenderType === checkout.result?.paymentTenderType) {
                    const { requestFormData } = this.props.context.request;
                    const formData = btoa(JSON.stringify(requestFormData));
                    this.setState({
                        isPaymentProcessing: true
                    });
                    this.props.moduleState.onPending();
                    this.handlePaymentResult(formData, true);
                }
                else {
                    this.props.moduleState.onSkip();
                }
            }
            else {
                if (this.asyncResultStatus === 'FAILED') {
                    this.setState({
                        isFetchingPaymentConnector: false
                    });
                    this.setTerminalError(new Error('Failed in load data'));
                }
            }
        };
        this.setTerminalError = (terminalError) => {
            this.props.telemetry.exception(terminalError);
            this.props.moduleState.setHasError(true);
            this.props.moduleState.onUpdating();
            const { resources: { genericErrorMessage, cardTypeErrorMessage } } = this.props;
            let errorMessage = genericErrorMessage;
            switch (terminalError.name) {
                case 'CARDTYPENOTFOUND': {
                    errorMessage = cardTypeErrorMessage;
                    break;
                }
                default:
            }
            this.setState({
                terminalError,
                errorMessage: errorMessage
            });
        };
        this.setErrorMessage = (errorMessage) => {
            this.props.telemetry.error(errorMessage);
            this.props.moduleState.setHasError(true);
            this.props.moduleState.onUpdating();
            this.setState({
                errorMessage
            });
        };
        this.updatePaymentAcceptPageData = async () => {
            const { context: { actionContext }, config: { showBillingAddress, paymenTenderType }, context: { request: { apiSettings } }, data: { checkout } } = this.props;
            const input = {
                showBillingAddress: showBillingAddress,
                paymenTenderType: paymenTenderType,
                apiSettings: apiSettings
            };
            this.setState({
                isFetchingPaymentConnector: true
            });
            const checkoutState = checkout.result;
            if (checkoutState) {
                await checkoutState.updatePaymentTenderType({ newPaymentTenderType: undefined });
                await checkoutState.updateTenderLine({ newTenderLine: undefined });
                await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: undefined });
            }
            getCardPaymentAcceptPointAction(new GetCardPaymentAcceptPointInput(input), actionContext)
                .then(paymentAcceptPoint => {
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });
                actionContext.update(new GetCardPaymentAcceptPointInput(input), paymentAcceptPoint);
                this.setState({ paymentConnectorId: paymentAcceptPoint.PaymentConnectorId });
            })
                .catch((error) => {
                this.setTerminalError(error);
                this.setState({
                    isFetchingPaymentConnector: false
                });
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });
            });
        };
        this.postMessageToIframe = (message) => {
            const postMessage = get(this.iframeRef, 'current.postMessage');
            if (postMessage) {
                this.props.moduleState.onPending();
                postMessage(message);
            }
        };
        this.handleAdditionalContext = (additionalContext) => {
            const message = paymentConnectorExtraContextMessage(additionalContext);
            this.postMessageToIframe(message);
        };
        this.saveBillingAddress = async (tokenizedPaymentCard) => {
            const { showBillingAddress } = this.props.config;
            const checkoutState = this.props.data.checkout.result;
            if (checkoutState && showBillingAddress && tokenizedPaymentCard && tokenizedPaymentCard.Zip) {
                const billingAddress = {
                    ThreeLetterISORegionName: tokenizedPaymentCard.Country,
                    Name: tokenizedPaymentCard.House === 'N/A' ? '' : tokenizedPaymentCard.House,
                    Street: tokenizedPaymentCard.Address1,
                    StreetNumber: tokenizedPaymentCard.Address2,
                    City: tokenizedPaymentCard.City,
                    State: tokenizedPaymentCard.State,
                    ZipCode: tokenizedPaymentCard.Zip,
                    Phone: tokenizedPaymentCard.Phone
                };
                await checkoutState.updateBillingAddress({ newBillingAddress: billingAddress });
            }
        };
        this.togglePayment = () => {
            if (this.shouldPaidByCard && this.props.moduleState.isDisabled) {
                this.props.moduleState.onUpdating();
            }
            else if (!this.shouldPaidByCard && !this.props.moduleState.isDisabled) {
                this.props.moduleState.setHasError(false);
                this.props.moduleState.onDisable();
            }
        };
        this.onSubmit = () => {
            const { isPrimaryPayment = true } = this.props.config;
            if (isPrimaryPayment) {
                this.postMessageToIframe(paymentConnectorSubmitMessage());
            }
            else {
                this.props.moduleState.onSkip();
            }
        };
        this.onCancel = () => {
            if (this.hasSelectedItem) {
                this.props.moduleState.onReady();
            }
            else {
                this.props.moduleState.onUpdating();
            }
        };
        this.onEdit = () => {
            this.props.moduleState.onUpdating();
            this.updatePaymentAcceptPageData();
        };
        this.onContainerReady = () => {
            this.redirectToPaymentVerification();
            this.props.moduleState.setIsSubmitContainer(false);
        };
    }
    get getLoyaltyAmount() {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }
    get getCustomerAccountAmount() {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.customerAccountAmount ? checkoutState.customerAccountAmount : 0;
    }
    get getGiftCardTotalAmount() {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count, giftCard) => {
            const balance = giftCard.Balance || 0;
            return count + balance;
        }, 0);
    }
    get shouldPaidByCard() {
        const { data: { checkout }, config } = this.props;
        if (!checkout.result) {
            return false;
        }
        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || !cart.CartLines.length) {
            return false;
        }
        const { paymentTenderType, tokenizedPaymentCard } = checkoutResult;
        const isPaidByOtherPaymentSource = config.paymenTenderType !== paymentTenderType && tokenizedPaymentCard;
        const amountDue = (cart.TotalAmount || 0) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;
        return amountDue > 0 && !isPaidByOtherPaymentSource;
    }
    get isCartContainsItemsForShipping() {
        const pickupDeliveryModeCode = get(this.props, 'context.request.channel.PickupDeliveryModeCode');
        return (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some((cartLine) => cartLine.DeliveryMode !== pickupDeliveryModeCode);
    }
    get isCartHasSelectedDeliveryMethods() {
        return (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).every((cartLine) => !!cartLine.DeliveryMode);
    }
    get asyncResultStatus() {
        const isLoading = Object.values(this.props.data).some(data => get(data, 'status') === 'LOADING');
        if (isLoading) {
            return 'LOADING';
        }
        const isSuccess = Object.values(this.props.data).every(data => get(data, 'status') === 'SUCCESS');
        if (isSuccess) {
            return 'SUCCESS';
        }
        const isFailed = Object.values(this.props.data).some(data => get(data, 'status') === 'FAILED');
        if (isFailed) {
            return 'FAILED';
        }
        return;
    }
    get hasSelectedItem() {
        return !!get(this.props.data, 'checkoutState.result.tokenizedPaymentCard');
    }
    get isPaymentVerificationRedirection() {
        const { requestFormData, query } = this.props.context.request;
        return (requestFormData && query && query.pv === '1') ? true : false;
    }
    get requestUrlOrigin() {
        const origin = get(window, 'location.origin');
        const requestUrl = typeof get(this.props, 'context.request.url.requestUrl') === 'string'
            ? new URL(get(this.props, 'context.request.url.requestUrl'))
            : get(this.props, 'context.request.url.requestUrl');
        return origin || requestUrl.origin;
    }
    componentDidMount() {
        when(() => this.asyncResultStatus !== 'LOADING', () => {
            this.init();
        });
        reaction(() => this.asyncResultStatus !== 'FAILED' && this.shouldPaidByCard, () => {
            this.togglePayment();
        });
    }
    render() {
        const { errorMessage, isFetchingPaymentConnector, paymentConnectorHeight, isPaymentVerificationRequried, isPaymentProcessing, isOverlayModal } = this.state;
        const { moduleState: { isReady, hasError, hasInitialized, isPending, hasExternalSubmitGroup }, config: { iFrameHeightOverride, paymentStyleOverride, className, showBillingAddress }, resources, data: { checkout, cardPaymentAcceptPoint }, visibilityObserver } = this.props;
        const isVisible = visibilityObserver && visibilityObserver.isVisible;
        if (!hasInitialized || (this.asyncResultStatus !== 'FAILED' && !this.shouldPaidByCard)) {
            this.props.context.telemetry.error('Checkout payment content is empty, module wont render');
            return null;
        }
        const { AcceptPageUrl, AcceptPageContent, MessageOrigin } = cardPaymentAcceptPoint.result || {
            AcceptPageUrl: undefined,
            AcceptPageContent: undefined,
            MessageOrigin: undefined
        };
        const { tokenizedPaymentCard, tenderLine, billingAddress } = checkout.result || {
            tokenizedPaymentCard: undefined,
            tenderLine: undefined,
            billingAddress: undefined
        };
        const viewProps = {
            ...this.props,
            ...this.state,
            isVisible,
            className,
            checkoutPaymentInstrument: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, className)
            },
            waiting: !isReady && this.asyncResultStatus !== 'FAILED' && (this.asyncResultStatus === 'LOADING' || isFetchingPaymentConnector || isPending) && (React.createElement(WaitingComponent, Object.assign({}, { message: resources.loadingMessage }))),
            alert: hasError && errorMessage && React.createElement(ErrorComponent, Object.assign({}, { title: resources.errorMessageTitle, message: errorMessage })),
            paymentInformation: isReady && !isPaymentVerificationRequried && !isPaymentProcessing && (React.createElement(PaymentInformationComponent, { tokenizedPaymentCard: tokenizedPaymentCard, tenderLine: tenderLine, billingAddress: showBillingAddress ? billingAddress : undefined, canEdit: !hasExternalSubmitGroup, onEdit: this.onEdit, resources: resources })),
            addPaymentForm: (!isReady || isPaymentVerificationRequried) && !isPaymentProcessing && (AcceptPageUrl || AcceptPageContent) && isVisible && (React.createElement(AddPaymentFormComponent, { acceptPageUrl: AcceptPageUrl, acceptPageContent: AcceptPageContent, messageOrigin: MessageOrigin, onSubmit: this.onSubmit, onCancel: this.onCancel, onIFrameMessage: this.onIFrameMessage, iframeRef: this.iframeRef, canSubmit: !hasExternalSubmitGroup, canCancel: !hasExternalSubmitGroup && this.hasSelectedItem, iFrameHeightOverride: iFrameHeightOverride || paymentConnectorHeight, requestUrlOrigin: this.requestUrlOrigin, isFetchingPaymentConnector: isFetchingPaymentConnector, paymentStyleOverride: paymentStyleOverride, resources: resources })),
            overlayModal: {
                modal: {
                    tag: Modal,
                    className: `${this.moduleClassName}__overlay-modal`,
                    isOpen: isOverlayModal
                }
            }
        };
        return this.props.renderView(viewProps);
    }
};
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "getLoyaltyAmount", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "getCustomerAccountAmount", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "getGiftCardTotalAmount", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "shouldPaidByCard", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "isCartContainsItemsForShipping", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "isCartHasSelectedDeliveryMethods", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "asyncResultStatus", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "hasSelectedItem", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "isPaymentVerificationRedirection", null);
__decorate([
    computed
], CheckoutPaymentInstrument.prototype, "requestUrlOrigin", null);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "handlePaymentResult", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "handlePaymentCardPrefix", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "handlePaymentRedirect", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "init", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "setTerminalError", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "setErrorMessage", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "togglePayment", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "onSubmit", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "onCancel", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "onEdit", void 0);
__decorate([
    action
], CheckoutPaymentInstrument.prototype, "onContainerReady", void 0);
CheckoutPaymentInstrument = __decorate([
    withModuleState,
    observer
], CheckoutPaymentInstrument);
export { CheckoutPaymentInstrument };
export default withVisibilityObserver(CheckoutPaymentInstrument);
//# sourceMappingURL=checkout-payment-instrument.js.map
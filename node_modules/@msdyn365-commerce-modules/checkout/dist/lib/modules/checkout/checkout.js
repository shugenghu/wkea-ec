import { __decorate } from "tslib";
import { withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { getAvailabilitiesForCartLineItems, ProductAvailabilitiesForCartLineItems } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, TelemetryConstant, Waiting } from '@msdyn365-commerce-modules/utilities';
import * as Msdyn365 from '@msdyn365-commerce/core';
import classnames from 'classnames';
import get from 'lodash/get';
import isEmpty from 'lodash/isEmpty';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import AlertComponent from './components/alert';
import { getLineItems } from './components/get-line-items';
import { getOrderSummary } from './components/get-order-summary';
import GuidedFormComponent from './components/guided-form';
import PlaceOrderButtonComponent from './components/place-order-button';
import placeOrder from './methods/place-order';
export * from './components/get-line-items';
export * from './components/get-order-summary';
let Checkout = class Checkout extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            errorMessage: ''
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName, this.props.friendlyName, this.props.telemetry);
        this.handleCheckoutHeadingChange = (event) => this.props.config.checkoutHeading.text = event.target.value;
        this.isLoading = () => {
            return !this.cartStatus || this.cartStatus === 'LOADING' || this.isEmptyCart;
        };
        this.getSlotItems = (key) => {
            const { slots } = this.props;
            return slots && slots[key] && slots[key].length ? slots[key] : undefined;
        };
        this.onPlaceOrder = async () => {
            const { resources: { checkoutOutOfStockErrorMessage, genericErrorMessage }, context: { actionContext, app: { config: { enableStockCheck = false } } }, slots: { orderConfirmation }, data: { checkout } } = this.props;
            if (enableStockCheck && await this.isOverMaxQuantity((await checkout).checkoutCart.cart)) {
                this.setState({
                    errorMessage: checkoutOutOfStockErrorMessage
                });
                this.props.context.telemetry.error(checkoutOutOfStockErrorMessage);
            }
            else {
                const hasOrderConfirmation = orderConfirmation && orderConfirmation.length > 0;
                await placeOrder(actionContext, this.props.data.checkout.result, this.props.data.products.result, !hasOrderConfirmation).catch(error => {
                    this.setState({
                        errorMessage: genericErrorMessage
                    });
                    this.props.telemetry.exception(error);
                });
            }
        };
        this.isOverMaxQuantity = async (cart) => {
            let isOverMaxQuantity = false;
            await getAvailabilitiesForCartLineItems(new ProductAvailabilitiesForCartLineItems(this.props.context.actionContext.requestContext.apiSettings), this.props.context.actionContext).then(productInventoryInformation => {
                cart.CartLines?.map((cartline) => {
                    if (productInventoryInformation && productInventoryInformation.length > 0) {
                        const foundProductAvailability = productInventoryInformation.find((productInventory) => {
                            return productInventory.ProductAvailableQuantity?.ProductId === cartline.ProductId;
                        });
                        if (!(foundProductAvailability?.IsProductAvailable && foundProductAvailability.ProductAvailableQuantity.AvailableQuantity !== undefined
                            && cartline.Quantity && cartline.Quantity <= foundProductAvailability.ProductAvailableQuantity.AvailableQuantity)) {
                            isOverMaxQuantity = true;
                        }
                    }
                });
            })
                .catch(error => {
                this.props.context.actionContext.telemetry.exception(error);
                throw new Error('[getAvailabilitiesForCartLineItems] Unable to get availabilities for products in checkout cart');
            });
            return isOverMaxQuantity;
        };
        this.getActiveChildModuleStates = () => {
            const { childIds, getModule } = this.props.moduleState;
            return childIds
                .map(getModule)
                .filter((state) => !!state && !state.isDisabled && state.hasModuleState);
        };
        this.onContainerReady = () => {
            this.getActiveChildModuleStates().forEach(state => {
                state.isReady && state.onContainerReady && state.onContainerReady();
            });
        };
    }
    get cartStatus() {
        return get(this.props, 'data.checkout.status');
    }
    get isEmptyCart() {
        if (this.isEditorialMode) {
            return false;
        }
        const cart = get(this.props, 'data.checkout.result.checkoutCart.cart');
        return this.cartStatus === 'SUCCESS' && !!cart && !isEmpty(cart) && (!cart.CartLines || cart.CartLines.length === 0);
    }
    get hasError() {
        const cart = get(this.props, 'data.checkout.result.checkoutCart.cart');
        return this.cartStatus === 'FAILED' || (this.cartStatus === 'SUCCESS' && (!cart || isEmpty(cart)));
    }
    get isEditorialMode() {
        return get(this.props, 'context.request.params.isEditor');
    }
    get canPlaceOrder() {
        const isTermsAndConditionAccepted = this.props.data.checkout.result && this.props.data.checkout.result?.isTermsAndConditionAccepted;
        return this.props.moduleState.isReady && (isTermsAndConditionAccepted === undefined || isTermsAndConditionAccepted) && this.state.errorMessage === '';
    }
    componentDidMount() {
        const { resources: { genericErrorMessage } } = this.props;
        when(() => this.hasError, () => {
            this.setState({
                errorMessage: genericErrorMessage
            });
            this.props.context.telemetry.error('Failed to get cart');
        });
        when(() => {
            return this.isEmptyCart;
        }, () => {
            const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';
            if (window && editCartLink) {
                window.location.assign(editCartLink);
            }
            else {
                this.setState({
                    errorMessage: genericErrorMessage
                });
                this.props.context.telemetry.error('Cart is empty, but no editCartLink found');
            }
        });
        reaction(() => this.props.moduleState.isReady, () => {
            this.onContainerReady();
        });
    }
    render() {
        const { moduleState, config: { className, checkoutHeading, disableGuidedCheckoutFlow }, resources } = this.props;
        const { errorMessage } = this.state;
        const { backToShopping, placeOrderText, cookieConsentRequiredMessage, genericErrorMessage } = resources;
        const checkoutClass = classnames('ms-checkout', className);
        const checkoutInformation = this.getSlotItems('checkoutInformation');
        const isConsentGiven = this.props.context.request &&
            this.props.context.request.cookies &&
            this.props.context.request.cookies.isConsentGiven &&
            this.props.context.request.cookies.isConsentGiven();
        const isMobile = this.props.context.request &&
            this.props.context.request.device &&
            this.props.context.request.device.Type === 'Mobile';
        const backToShoppingUrl = Msdyn365.getUrlSync('home', this.props.context.actionContext) || '';
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';
        const termsAndConditions = this.props.slots.termsAndConditions &&
            this.props.slots.termsAndConditions.length > 0 &&
            this.props.slots.termsAndConditions[0];
        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.BackToShopping);
        const backToShoppingAttributes = getTelemetryAttributes(this.telemetryContent, payLoad);
        let viewProps = {
            ...this.props,
            className: checkoutClass,
            isEmptyCart: this.isEmptyCart,
            isConsentGiven,
            hasError: this.hasError,
            hasSalesOrder: this.props.data.checkout && this.props.data.checkout.result !== undefined && this.props.data.checkout.result.salesOrder !== undefined,
            cartStatus: this.cartStatus,
            isMobile,
            backToShoppingUrl,
            editCartLink,
            isEditorialMode: this.isEditorialMode,
            orderConfirmation: this.props.slots.orderConfirmation && this.props.slots.orderConfirmation.length > 0 ? this.props.slots.orderConfirmation[0] : undefined,
            checkoutProps: { moduleProps: this.props, className: checkoutClass },
            headerProps: { className: 'ms-checkout__head' },
            bodyProps: { className: 'ms-checkout__body' },
            mainProps: { className: 'ms-checkout__main' },
            mainControlProps: { className: 'ms-checkout__main-control' },
            sideProps: { className: 'ms-checkout__side' },
            sideControlFirstProps: { className: 'ms-checkout__side-control-first' },
            sideControlSecondProps: { className: 'ms-checkout__side-control-second' },
            termsAndConditionsProps: { className: 'ms-checkout__terms-and-conditions' },
            title: checkoutHeading && (this.renderMsdyn365Text(checkoutHeading))
        };
        if (isConsentGiven === false) {
            viewProps = {
                ...viewProps,
                alert: React.createElement(AlertComponent, Object.assign({}, { message: cookieConsentRequiredMessage }))
            };
        }
        else if (this.isLoading()) {
            viewProps = {
                ...viewProps,
                loading: React.createElement(Waiting, { className: 'msc-waiting-circular msc-waiting-lg' })
            };
        }
        else if (this.hasError) {
            viewProps = {
                ...viewProps,
                alert: React.createElement(AlertComponent, Object.assign({}, { message: genericErrorMessage }))
            };
        }
        else {
            viewProps = {
                ...viewProps,
                alert: errorMessage && React.createElement(AlertComponent, Object.assign({}, { message: errorMessage })),
                canShow: true,
                guidedForm: checkoutInformation ? (React.createElement(GuidedFormComponent, Object.assign({}, {
                    items: checkoutInformation,
                    moduleState: moduleState,
                    disableGuidedCheckoutFlow: disableGuidedCheckoutFlow,
                    resource: resources,
                    requestContext: this.props.context,
                    isMobile: isMobile,
                    isEditor: this.isEditorialMode,
                    telemetryContent: this.telemetryContent
                }))) : (undefined),
                orderSummary: getOrderSummary(this.props),
                lineItems: getLineItems(this.props, this.telemetryContent),
                placeOrderButton: (React.createElement(PlaceOrderButtonComponent, Object.assign({}, { placeOrderText, placeOrder: this.onPlaceOrder, canPlaceOrder: this.canPlaceOrder, telemetryContent: this.telemetryContent }))),
                termsAndConditions: termsAndConditions,
                keepShoppingButton: backToShoppingUrl && (React.createElement(Button, Object.assign({ className: 'ms-checkout__btn-keep-shopping msc-btn', title: backToShopping, color: 'secondary', href: backToShoppingUrl }, backToShoppingAttributes), backToShopping))
            };
        }
        return this.props.renderView(viewProps);
    }
    renderMsdyn365Text(checkoutHeading) {
        return (React.createElement(Msdyn365.Text, Object.assign({}, checkoutHeading, { tag: checkoutHeading.tag || 'h2', className: 'ms-checkout__title', text: checkoutHeading.text, editProps: { onEdit: this.handleCheckoutHeadingChange, requestContext: this.props.context.request } })));
    }
};
__decorate([
    computed
], Checkout.prototype, "cartStatus", null);
__decorate([
    computed
], Checkout.prototype, "isEmptyCart", null);
__decorate([
    computed
], Checkout.prototype, "hasError", null);
__decorate([
    computed
], Checkout.prototype, "isEditorialMode", null);
__decorate([
    computed
], Checkout.prototype, "canPlaceOrder", null);
Checkout = __decorate([
    withModuleState,
    observer
], Checkout);
export default Checkout;
//# sourceMappingURL=checkout.js.map
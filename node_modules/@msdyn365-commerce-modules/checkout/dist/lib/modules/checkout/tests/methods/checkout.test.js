import { buildHydratedMockActionContext } from '@msdyn365-commerce/core';
import * as GlobalStateActions from '@msdyn365-commerce/global-state';
import * as CartsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import * as OrgUnitsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/OrgUnitsDataActions.g';
import * as StoreOperationsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import placeOrderAction from '../../methods/checkout';
import { mockChannelConfiguration, mockCheckoutCart, mockCheckoutCartWithFreeItem, mockCheckoutState, mockGiftCardA, mockGiftCardB, mockGiftCardC, mockGiftCardCheckoutState, mockReceiptEmail, mockResolvedCardTypes, mockSalesOrder, mockTenderTypes, mockTokenizedPaymentCard } from '../__mock__';
jest.mock('@msdyn365-commerce/global-state');
jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/OrgUnitsDataActions.g');
jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g');
jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g');
let mockActionContext;
let mockCheckoutStateWithCart;
describe('CheckoutPlaceOrder', () => {
    describe('placeOrderAction', () => {
        beforeEach(() => {
            mockActionContext = buildHydratedMockActionContext({});
            mockActionContext.requestContext.channel = mockChannelConfiguration;
            mockCheckoutStateWithCart = {
                ...mockCheckoutState,
                checkoutCart: {
                    cart: mockCheckoutCart,
                    updateLoyaltyCardId: jest.fn()
                }
            };
            StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation(async () => mockResolvedCardTypes);
            StoreOperationsDataActions.getTenderTypesAsync.mockImplementation(async () => mockTenderTypes);
            CartsDataActions.checkoutAsync.mockImplementation(async () => mockSalesOrder);
        });
        it('places order with only credit card when credit card is the only payment method', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                guestCheckoutEmail: mockReceiptEmail,
                tokenizedPaymentCard: mockTokenizedPaymentCard
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCart.Id, mockReceiptEmail, undefined, undefined, [
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 100,
                    CardTypeId: 'VISA',
                    Currency: 'USD',
                    TenderTypeId: '3',
                    TokenizedPaymentCard: {
                        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.TokenizedPaymentCard',
                        CardTypeId: 'VISA',
                        NameOnCard: 'John',
                        Address1: undefined,
                        Country: undefined,
                        Phone: undefined,
                        State: undefined,
                        Zip: undefined,
                        House: 'N/A',
                        City: 'Seattle'
                    }
                }
            ], mockCheckoutCart.Version);
        });
        it('places order with loyalty card', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                guestCheckoutEmail: mockReceiptEmail,
                loyaltyAmount: 300,
                tokenizedPaymentCard: null,
                giftCardExtends: []
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCart.Id, mockReceiptEmail, undefined, undefined, [
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 100,
                    Currency: 'USD',
                    LoyaltyCardId: 'ABC',
                    TenderTypeId: '10'
                }
            ], mockCheckoutCart.Version);
        });
        it('places order with gift card when gift card balance can cover the order total amount', async () => {
            mockCheckoutStateWithCart = {
                ...mockGiftCardCheckoutState,
                checkoutCart: {
                    cart: mockCheckoutCart,
                    updateLoyaltyCardId: jest.fn()
                }
            };
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                guestCheckoutEmail: mockReceiptEmail,
                tokenizedPaymentCard: mockTokenizedPaymentCard,
                giftCardExtends: [mockGiftCardA, mockGiftCardB, mockGiftCardC]
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCart.Id, mockReceiptEmail, undefined, undefined, [
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 60,
                    Currency: 'USD',
                    GiftCardExpirationMonth: 10,
                    GiftCardExpirationYear: 2020,
                    GiftCardId: '123-456-111',
                    GiftCardPin: '1111',
                    TenderTypeId: '12'
                },
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 40,
                    Currency: 'USD',
                    GiftCardExpirationMonth: undefined,
                    GiftCardExpirationYear: undefined,
                    GiftCardId: '123-456-222',
                    GiftCardPin: undefined,
                    TenderTypeId: '8'
                }
            ], mockCheckoutCart.Version);
        });
        it('places order with gift card and credit card when gift card balbance cannot cover the order total amount', async () => {
            mockCheckoutStateWithCart = {
                ...mockGiftCardCheckoutState,
                checkoutCart: {
                    cart: mockCheckoutCart,
                    updateLoyaltyCardId: jest.fn()
                }
            };
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                guestCheckoutEmail: mockReceiptEmail,
                tokenizedPaymentCard: mockTokenizedPaymentCard,
                giftCardExtends: [mockGiftCardA]
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCart.Id, mockReceiptEmail, undefined, undefined, [
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 60,
                    Currency: 'USD',
                    GiftCardExpirationMonth: 10,
                    GiftCardExpirationYear: 2020,
                    GiftCardId: '123-456-111',
                    GiftCardPin: '1111',
                    TenderTypeId: '12'
                },
                {
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
                    'Amount@odata.type': '#Decimal',
                    Amount: 40,
                    CardTypeId: 'VISA',
                    Currency: 'USD',
                    TenderTypeId: '3',
                    TokenizedPaymentCard: {
                        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.TokenizedPaymentCard',
                        CardTypeId: 'VISA',
                        NameOnCard: 'John',
                        House: 'N/A',
                        Address1: undefined,
                        Country: undefined,
                        Phone: undefined,
                        State: undefined,
                        Zip: undefined,
                        City: 'Seattle'
                    }
                }
            ], mockCheckoutCart.Version);
        });
        it('place order without payment method when amount due is 0', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutState,
                guestCheckoutEmail: mockReceiptEmail,
                checkoutCart: {
                    cart: mockCheckoutCartWithFreeItem
                }
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCartWithFreeItem.Id, mockReceiptEmail, undefined, undefined, null, mockCheckoutCartWithFreeItem.Version);
        });
        it('place order without payment method when amount due is 0 and payment method is provided', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutState,
                guestCheckoutEmail: mockReceiptEmail,
                tokenizedPaymentCard: mockTokenizedPaymentCard,
                giftCardExtends: [mockGiftCardA],
                checkoutCart: {
                    cart: mockCheckoutCartWithFreeItem
                }
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                throw error;
            });
            expect(salesOrder).toEqual(mockSalesOrder);
            expect(CartsDataActions.checkoutAsync).toBeCalledWith({ callerContext: mockActionContext, bypassCache: 'get' }, mockCheckoutCartWithFreeItem.Id, mockReceiptEmail, undefined, undefined, null, mockCheckoutCartWithFreeItem.Version);
        });
        it('throw error when no tokenizedPaymentCard provided', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                tokenizedPaymentCard: null
            }));
            const salesOrder = await placeOrderAction(mockActionContext).catch(error => {
                expect(error).toBeDefined();
            });
        });
        it('throw error when no tokenizedPaymentCard provided', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                tokenizedPaymentCard: null
            }));
            await placeOrderAction(mockActionContext).catch(error => {
                expect(error).toBeDefined();
            });
        });
        it('throw error when checkout fail', async () => {
            GlobalStateActions.getCheckoutState.mockImplementation(() => Promise.resolve({
                ...mockCheckoutStateWithCart,
                guestCheckoutEmail: mockReceiptEmail,
                tokenizedPaymentCard: mockTokenizedPaymentCard
            }));
            CartsDataActions.checkoutAsync.mockImplementation(async () => {
                throw new Error();
            });
            await placeOrderAction(mockActionContext).catch(error => {
                expect(error).toBeDefined();
            });
        });
        afterEach(() => {
            OrgUnitsDataActions.getOrgUnitConfigurationAsync.mockReset();
            StoreOperationsDataActions.getCardTypesAsync.mockReset();
            StoreOperationsDataActions.getTenderTypesAsync.mockReset();
            CartsDataActions.checkoutAsync.mockReset();
        });
        afterAll(() => {
            jest.unmock('@msdyn365-commerce/global-state');
            jest.unmock('@msdyn365-commerce/retail-proxy/dist/DataActions/OrgUnitsDataActions.g');
            jest.unmock('@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g');
            jest.unmock('@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g');
        });
    });
});
//# sourceMappingURL=checkout.test.js.map
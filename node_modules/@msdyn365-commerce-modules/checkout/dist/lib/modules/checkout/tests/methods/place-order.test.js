import * as coreMethods from '@msdyn365-commerce/core';
import checkout from '../../methods/checkout';
import emptyActiveCart from '../../methods/empty-active-cart';
import placeOrder from '../../methods/place-order';
jest.mock('../../methods/checkout');
jest.mock('../../methods/empty-active-cart');
jest.mock('@msdyn365-commerce/core');
let mockCheckoutState;
const mockActionContext = {};
const mockSalesOrder = {
    Id: 'order_1',
    ChannelReferenceId: 'ABC'
};
const confirmationPageUrl = '/order-confirmation';
describe('CheckoutPlaceOrder', () => {
    describe('emptyActiveCartAction', () => {
        beforeEach(() => {
            checkout.mockImplementation(async () => mockSalesOrder);
            emptyActiveCart.mockImplementation(async () => ({}));
            coreMethods.getUrlSync.mockImplementation(() => confirmationPageUrl);
            window.location.assign = jest.fn();
        });
        afterEach(() => {
            jest.resetAllMocks();
        });
        afterAll(() => {
            jest.unmock('../../methods/checkout');
            jest.unmock('../../methods/empty-active-cart');
            jest.unmock('@msdyn365-commerce/core');
        });
        it('runs correctly', async () => {
            try {
                await placeOrder(mockActionContext, undefined, undefined, true);
                expect(checkout).toBeCalled();
                expect(coreMethods.getUrlSync).toBeCalled();
                expect(window.location.assign).toBeCalledWith(`${confirmationPageUrl}?transactionId=order_1`);
            }
            catch (e) {
                expect(e).not.toBeDefined();
            }
        });
        it('runs correctly if redirect not requried', async () => {
            try {
                mockCheckoutState = {
                    updateSalesOrder: jest.fn().mockResolvedValue({ status: 'SUCCESS' })
                };
                await placeOrder(mockActionContext, mockCheckoutState, undefined, false);
                expect(checkout).toBeCalled();
                expect(mockCheckoutState.updateSalesOrder).toBeCalled();
            }
            catch (e) {
                expect(e).not.toBeDefined();
            }
        });
        it('throw error when updateSalesOrder method fail', async () => {
            try {
                mockCheckoutState = {
                    updateSalesOrder: jest.fn().mockResolvedValue({ status: 'FAILED' })
                };
                await placeOrder(mockActionContext, mockCheckoutState, undefined, false);
                expect(checkout).toBeCalled();
                expect(mockCheckoutState.updateSalesOrder).toBeCalled();
            }
            catch (e) {
                expect(e).toBeDefined();
            }
        });
        it('throw error when checkout method fail', async () => {
            checkout.mockImplementation(async () => {
                throw new Error();
            });
            try {
                await placeOrder(mockActionContext, undefined, undefined, true);
                expect(checkout).not.toBeCalled();
                expect(coreMethods.getUrlSync).not.toBeCalled();
                expect(window.location.assign).not.toBeCalled();
            }
            catch (e) {
                expect(e).toBeDefined();
            }
        });
        it('throw error when emptyActiveCart method fail', async () => {
            emptyActiveCart.mockImplementation(async () => {
                throw new Error();
            });
            try {
                await placeOrder(mockActionContext, undefined, undefined, true);
                expect(checkout).not.toBeCalled();
                expect(coreMethods.getUrlSync).not.toBeCalled();
                expect(window.location.assign).not.toBeCalled();
            }
            catch (e) {
                expect(e).toBeDefined();
            }
        });
        it('throw error when redirect page url not found', async () => {
            coreMethods.getUrlSync.mockImplementation(() => '');
            try {
                await placeOrder(mockActionContext, undefined, undefined, true);
                expect(checkout).not.toBeCalled();
                expect(coreMethods.getUrlSync).not.toBeCalled();
                expect(window.location.assign).not.toBeCalled();
            }
            catch (e) {
                expect(e).toBeDefined();
            }
        });
        it('handles url with params', async () => {
            coreMethods.getUrlSync.mockImplementation(() => `${confirmationPageUrl}?d=1`);
            try {
                await placeOrder(mockActionContext, undefined, undefined, true);
                expect(checkout).toBeCalled();
                expect(coreMethods.getUrlSync).toBeCalled();
                expect(window.location.assign).toBeCalledWith(`${confirmationPageUrl}?d=1&transactionId=order_1`);
            }
            catch (e) {
                expect(e).not.toBeDefined();
            }
        });
        it('throw error when checkout state not available', async () => {
            coreMethods.getUrlSync.mockImplementation(() => '');
            try {
                await placeOrder(mockActionContext, undefined, undefined, false);
                expect(checkout).not.toBeCalled();
                expect(coreMethods.getUrlSync).not.toBeCalled();
                expect(window.location.assign).not.toBeCalled();
            }
            catch (e) {
                expect(e).toBeDefined();
            }
        });
    });
});
//# sourceMappingURL=place-order.test.js.map
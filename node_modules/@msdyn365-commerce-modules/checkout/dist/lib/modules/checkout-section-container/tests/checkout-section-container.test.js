import { buildHydratedMockActionContext, buildMockModuleProps } from '@msdyn365-commerce/core';
import { render, shallow } from 'enzyme';
import * as React from 'react';
import CheckoutPlainContainerWithState, { CheckoutPlainContainer } from '../checkout-section-container';
import View from '../checkout-section-container.view';
const mockConfig = {};
const mockActions = {};
let mockContext;
const MockItem = ({ id }) => React.createElement(React.Fragment, null, `{${id}}`);
const mockSlot1 = React.createElement(MockItem, { id: 'item_1' });
const mockSlot2 = React.createElement(MockItem, { id: 'item_2' });
let mockModuleState = {};
let moduleProps;
let mockItem1State = {};
let mockItem2State = {};
describe('CheckoutPlainContainer', () => {
    beforeEach(() => {
        mockItem1State = {
            hasModuleState: true,
            isReady: true,
            isDisabled: false,
            onEdit: jest.fn(),
            onSubmit: jest.fn(),
            onCancel: jest.fn(),
            setHasError: jest.fn()
        };
        mockItem2State = {
            hasModuleState: true,
            isReady: true,
            isDisabled: false,
            onEdit: jest.fn(),
            onSubmit: jest.fn(),
            onCancel: jest.fn(),
            setHasError: jest.fn()
        };
        mockModuleState = {
            childIds: ['item_1', 'item_2'],
            init: jest.fn(),
            hasModuleState: true,
            hasExternalSubmitGroup: true,
            hasError: false,
            hasInitialized: true,
            isReady: true,
            getModule: jest.fn(id => {
                if (id === 'item_1') {
                    return mockItem1State;
                }
                else if (id === 'item_2') {
                    return mockItem2State;
                }
                return;
            })
        };
        mockContext = {
            actionContext: buildHydratedMockActionContext()
        };
        moduleProps = {
            ...buildMockModuleProps({}, mockActions, mockConfig, mockContext),
            renderView: View,
            slots: {
                primary: [mockSlot1, mockSlot2]
            },
            enableControl: true,
            moduleState: mockModuleState
        };
    });
    it('has slot items', () => {
        const component = render(React.createElement(CheckoutPlainContainerWithState, Object.assign({}, moduleProps)));
        expect(component).toMatchSnapshot();
    });
    it('has no slot item', () => {
        moduleProps = {
            ...moduleProps,
            slots: undefined
        };
        const component = render(React.createElement(CheckoutPlainContainerWithState, Object.assign({}, moduleProps)));
        expect(component).toMatchSnapshot();
    });
    it('has non initialized item', () => {
        mockItem1State = {
            ...mockItem1State,
            hasInitialized: false
        };
        const component = render(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        expect(component).toMatchSnapshot();
    });
    it('has disabled item', () => {
        mockItem1State = {
            ...mockItem1State,
            isDisabled: true
        };
        const component = render(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        expect(component.find('.ms-checkout-section-container__item').hasClass('hidden')).toBe(true);
    });
    it('onSubmit', () => {
        mockItem1State = {
            ...mockItem1State,
            isReady: false
        };
        const component = shallow(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        component.instance().onSubmit();
        expect(mockItem1State.onSubmit).toBeCalled();
        expect(mockItem2State.onSubmit).not.toBeCalled();
    });
    it('onCancel', () => {
        mockItem1State = {
            ...mockItem1State,
            isReady: false
        };
        const component = shallow(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        component.instance().onCancel();
        expect(mockItem1State.onCancel).toBeCalled();
        expect(mockItem2State.onCancel).not.toBeCalled();
    });
    it('onEdit', () => {
        const component = shallow(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        component.instance().onEdit();
        expect(mockItem1State.onEdit).toBeCalled();
        expect(mockItem2State.onEdit).toBeCalled();
    });
    it('componentDidUpdate', () => {
        mockModuleState = {
            ...mockModuleState,
            hasError: true
        };
        moduleProps = {
            ...moduleProps,
            moduleState: mockModuleState
        };
        const component = shallow(React.createElement(CheckoutPlainContainer, Object.assign({}, moduleProps)));
        component.instance().componentDidUpdate();
        expect(mockItem1State.onEdit).toBeCalled();
        expect(mockItem2State.onEdit).toBeCalled();
    });
});
//# sourceMappingURL=checkout-section-container.test.js.map
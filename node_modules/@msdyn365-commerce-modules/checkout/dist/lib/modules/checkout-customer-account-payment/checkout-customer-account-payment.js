import { __decorate } from "tslib";
import * as React from 'react';
import { withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import classnames from 'classnames';
import get from 'lodash/get';
import { computed, reaction } from 'mobx';
import { observer } from 'mobx-react';
import { getAccountPaymentFormEditMode } from './components/get-account-payment-form-edit-mode';
import { getAccountPaymentFormSummaryMode } from './components/get-account-payment-form-summary-mode';
let CheckoutCustomerAccountPayment = class CheckoutCustomerAccountPayment extends React.Component {
    constructor(props) {
        super(props);
        this.baseClassName = 'ms-checkout-customer-account';
        this.getAvailableCredit = (creditBalances) => {
            if (!creditBalances) {
                return 0;
            }
            return creditBalances.CreditLimit - creditBalances.Balance - creditBalances.PendingBalance;
        };
        this.addPayment = async () => {
            const checkoutState = this.props.data.checkout.result;
            if (!checkoutState) {
                this.props.context.telemetry.error('checkout state not found');
                return;
            }
            await checkoutState.updateCustomerAccountAmount({ newAmount: this.state.paymentAmount });
            this.props.context.telemetry.information('customer account payment amount updated');
        };
        this.toggleCreditSection = () => {
            this.setState({
                isCreditSectionExpanded: !this.state.isCreditSectionExpanded
            });
        };
        this.init = async () => {
            this.props.moduleState.init({
                onCancel: this.handleCancelOrSubmit,
                onSubmit: this.handleCancelOrSubmit,
                onEdit: this.onEdit
            });
            if (this.props.data.checkout.result && this.props.data.checkout.result.customerAccountAmount !== 0) {
                this.props.moduleState.onReady();
            }
        };
        this.onChangePaymentAmount = (newAmount) => {
            this.setState({
                paymentAmount: newAmount
            });
        };
        this.updateMaxAmount = (newAmount) => {
            if (this.props.data.checkout.result && this.props.data.checkout.result.customerAccountAmount === 0) {
                this.setState({
                    paymentAmount: Math.max(0, newAmount)
                });
            }
        };
        this.onEdit = () => {
            this.props.moduleState.onUpdating();
        };
        this.handleCancelOrSubmit = () => {
            const checkoutState = this.props.data.checkout.result;
            if (checkoutState && checkoutState.customerAccountAmount > 0) {
                this.props.moduleState.onReady();
            }
            else {
                this.props.moduleState.onSkip();
            }
        };
        this.removePayment = async () => {
            const checkoutState = this.props.data.checkout.result;
            if (!checkoutState) {
                this.props.context.telemetry.error('checkout state not found');
                return;
            }
            this.setState({
                paymentAmount: 0
            });
            await checkoutState.updateCustomerAccountAmount({ newAmount: 0 });
            this.props.context.telemetry.information('customer account payment removed');
        };
        this.state = { paymentAmount: this.maxPaymentAmount, isCreditSectionExpanded: false };
    }
    get isCustomerAccountPaymentEnabled() {
        const customerInfo = get(this.props, 'data.customerInformation.result');
        const platform = get(this.props, 'context.request.app.platform');
        return customerInfo &&
            customerInfo.AllowOnAccountPayment === true &&
            platform &&
            (platform.enableCustomerAccountPayment === 'all' ||
                (platform.enableCustomerAccountPayment === 'b2b' && customerInfo.IsB2b === true) ||
                (platform.enableCustomerAccountPayment === 'b2c' && customerInfo.IsB2b === false));
    }
    get getLoyaltyAmount() {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.loyaltyAmount) {
            return 0;
        }
        return checkoutState.loyaltyAmount;
    }
    get getGiftCardAmount() {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCards || checkoutState.giftCards.length === 0) {
            return 0;
        }
        let giftCardAmount = 0;
        checkoutState.giftCards.forEach(giftCard => {
            giftCardAmount += (giftCard.Balance || 0);
        });
        return giftCardAmount;
    }
    get maxPaymentAmount() {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return 0;
        }
        const amountDue = Math.max(0, (cart.TotalAmount || 0) - this.getLoyaltyAmount - this.getGiftCardAmount);
        if (this.props.data.customerInformation?.result?.MandatoryCreditLimit) {
            return Math.min(this.getAvailableCredit(this.props.data.creditBalances?.result), amountDue);
        }
        else {
            return amountDue;
        }
    }
    get errorMessage() {
        if (this.state.paymentAmount > this.maxPaymentAmount || this.state.paymentAmount < 0) {
            return this.props.resources.invalidAmountMessage;
        }
        return undefined;
    }
    get currencyCode() {
        return get(this.props, 'context.request.channel.Currency');
    }
    get availableCredit() {
        const creditBalances = get(this.props, 'data.creditBalances.result');
        return creditBalances ? this.getAvailableCredit(creditBalances) : 0;
    }
    get orderTotal() {
        const orderTotal = get(this.props, 'data.checkout.result.checkoutCart.cart.TotalAmount');
        return orderTotal ? orderTotal : 0;
    }
    get formattedExcessCredit() {
        const excessCredit = this.availableCredit - this.orderTotal;
        return excessCredit < 0 ? this.props.context.cultureFormatter.formatCurrency(excessCredit, this.currencyCode) : undefined;
    }
    async componentDidMount() {
        await this.init();
        reaction(() => this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart && this.props.data.checkout.result.checkoutCart.cart.TotalAmount, totalAmount => {
            this.updateMaxAmount(this.maxPaymentAmount);
        });
    }
    render() {
        const customerInfo = this.props.data.customerInformation.result;
        if (!this.isCustomerAccountPaymentEnabled) {
            this.props.context.telemetry.information('customer account payments will not display, because the feature is disabled or not enabled for this type of customer');
            return null;
        }
        const checkoutState = this.props.data.checkout.result;
        const cart = checkoutState ? checkoutState.checkoutCart.cart : undefined;
        const creditBalances = this.props.data.creditBalances.result;
        if (!cart) {
            return null;
        }
        const resources = this.props.resources;
        const locale = get(this.props, 'context.request.locale') || 'en-us';
        const customerSinceDate = new Date(customerInfo?.CreatedDateTime || 0).toLocaleDateString(locale);
        const props = {
            ...this.props,
            checkoutCustomerAccount: {
                moduleProps: this.props,
                className: classnames(this.baseClassName)
            },
            editView: getAccountPaymentFormEditMode({
                onAddPayment: this.addPayment,
                resources,
                amount: this.state.paymentAmount,
                onChangePaymentAmount: this.onChangePaymentAmount,
                maxAmount: this.maxPaymentAmount,
                customer: customerInfo,
                customerCreatedDate: customerSinceDate,
                availableCredit: this.props.context.cultureFormatter.formatCurrency(this.getAvailableCredit(creditBalances), this.currencyCode),
                showCreditLimit: customerInfo?.MandatoryCreditLimit || false,
                errorMessage: this.errorMessage,
                onToggleCreditSection: this.toggleCreditSection,
                creditSectionIsExpanded: this.state.isCreditSectionExpanded,
                orderTotal: this.props.context.cultureFormatter.formatCurrency(this.orderTotal, this.currencyCode),
                excessCredit: this.formattedExcessCredit,
                onRemovePayment: this.removePayment,
                appliedAmount: checkoutState && checkoutState.customerAccountAmount > 0 ? this.props.context.cultureFormatter.formatCurrency(checkoutState.customerAccountAmount, this.currencyCode) : undefined
            }),
            summaryView: getAccountPaymentFormSummaryMode({
                resources,
                amount: this.state.paymentAmount,
                appliedAmount: checkoutState && checkoutState.customerAccountAmount > 0 ? this.props.context.cultureFormatter.formatCurrency(checkoutState.customerAccountAmount, this.currencyCode) : undefined
            })
        };
        return this.props.renderView(props);
    }
};
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "isCustomerAccountPaymentEnabled", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "getLoyaltyAmount", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "getGiftCardAmount", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "maxPaymentAmount", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "errorMessage", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "currencyCode", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "availableCredit", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "orderTotal", null);
__decorate([
    computed
], CheckoutCustomerAccountPayment.prototype, "formattedExcessCredit", null);
CheckoutCustomerAccountPayment = __decorate([
    withModuleState,
    observer
], CheckoutCustomerAccountPayment);
export { CheckoutCustomerAccountPayment };
export default CheckoutCustomerAccountPayment;
//# sourceMappingURL=checkout-customer-account-payment.js.map
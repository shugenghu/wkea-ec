/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// tslint:disable-next-line:no-unused-variable
// @ts-ignore
import { mount, render, shallow } from 'enzyme';
import * as React from 'react';

import {
    buildHydratedMockActionContext,
    buildMockModuleProps,
    IActionContext,
    IAny,
    ICoreContext,
    IGeneric
} from '@msdyn365-commerce/core';
import { IGiftCardExtend } from '@msdyn365-commerce/global-state';
// @ts-ignore
import { AsyncResult, CardTypeInfo, Cart } from '@msdyn365-commerce/retail-proxy';
// @ts-ignore
import GiftCardBalanceCheck, { IGiftCardBalanceCheckModuleProps, IGiftCardBalanceCheckViewProps } from '../gift-card-balance-check';

import * as StoreOperationsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import { TenderType } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
// @ts-ignore
import { IGiftCardBalanceCheckConfig, IGiftCardBalanceCheckProps, IGiftCardBalanceCheckResources, showAdditionalFields } from '../gift-card-balance-check.props.autogenerated';
import View from '../gift-card-balance-check.view';

jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g');

let mockInternalGiftCardTypes: CardTypeInfo[];
let mockExternalGiftCardTypes: CardTypeInfo[];
let mockGiftCard: IGiftCardExtend;
let mockGiftCardEmpty: IGiftCardExtend;
let mockConfig: IGiftCardBalanceCheckConfig;
let mockContext: ICoreContext;
let mockActions: IGeneric<IAny>;
let actionContext: IActionContext;
let mockResources: IGiftCardBalanceCheckResources;
let mockTenderTypes: TenderType[];

describe('GiftCardBalanceCheck', () => {
    // tslint:disable-next-line:max-func-body-length
    beforeEach(() => {
        mockInternalGiftCardTypes = [
            {
                IsPinRequired: false,
                IsExpirationDateRequired: false,
                PaymentMethodId: '13'
            }
        ];

        mockExternalGiftCardTypes = [
            {
                IsPinRequired: true,
                IsExpirationDateRequired: false,
                PaymentMethodId: '12'
            }
        ];

        mockGiftCard = {
            Id: 'abc',
            Balance: 100,
            BalanceCurrencyCode: 'USD',
            BalanceInCardCurrency: 100,
            CardCurrencyCode: 'USD'
        };

        mockGiftCardEmpty = {
            Id: 'empty',
            Balance: 0,
            BalanceCurrencyCode: 'USD',
            BalanceInCardCurrency: 0,
            CardCurrencyCode: 'USD'
        };

        mockActions = {};

        actionContext = buildHydratedMockActionContext();

        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'internal'
                }
            }
        };

        mockConfig = {
            showAdditionalFields: showAdditionalFields.pinAndExpirationDate
        };

        mockResources = {
            emptyInputError: 'Please enterd a gift card number',
            invalidCodeError: 'Invalid gift card code entered',
            invalidCardInfoError: 'Invalid gift card information entered',
            invalidCardTypeError: 'The gift card type is not suported',
            noCardPinError: 'Gift card PIN is required',
            noCardExpError: 'Gift card expiration date is required',
            noBalanceError: 'Gift card has no balance left',
            giftCardFormLabel: 'Gift card',
            giftCardNumberLabel: 'Gift card number',
            giftCardPinLabel: 'PIN',
            giftCardExpLabel: 'Expiration date',
            giftCardAlertLabel: 'You gift card may or may not include these fields',
            balanceCheckButton: 'Balance check',
            giftCardAvailableBalanceLabel: 'Available balance',
            giftCardPinPlaceholderText: 'PIN',
            giftCardExpPlaceholderText: 'MM/YYYY',
            enteredGiftCardLabel: 'Gift card ending in'
        };

        mockTenderTypes = [
            {
                OperationId: 214,
                ConnectorId: 'Adyen',
                TenderTypeId: '12'
            },
            {
                OperationId: 214,
                ConnectorId: '',
                TenderTypeId: '13'
            },
            {
                OperationId: 214,
                ConnectorId: '',
                TenderTypeId: '8'
            },
        ] as TenderType[];

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve(mockInternalGiftCardTypes);
        });

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.getGiftCardAsync.mockImplementation((context, id, typeId, pin, month, year) => {
            if (id === 'abc') {
                return Promise.resolve(mockGiftCard);
            } else if (id === 'empty') {
                return Promise.resolve(mockGiftCardEmpty);
            }
            return Promise.reject(new Error('Not found'));
        });

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.getTenderTypesAsync.mockImplementation(async () => mockTenderTypes);
    });

    it('renders correctly for auth user when support internal gift card', () => {
        let moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
        // @ts-ignore
        let wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(false);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(false);

        // module config only show pin
        mockConfig = {
            showAdditionalFields: showAdditionalFields.pin
        };

        moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(false);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(false);
    });

    it('renders correctly for auth user when support external gift card', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'external'
                }
            }
        };

        let moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
         // @ts-ignore
        let wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(true);

         // module config only show pin
        mockConfig = {
            showAdditionalFields: showAdditionalFields.pin
        };
        moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(false);
    });

    it('renders correctly for auth user when support both gift card', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        let moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
        // @ts-ignore
        let wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(true);

        // module config only show pin
        mockConfig = {
            showAdditionalFields: showAdditionalFields.pin
        };
        moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(false);
    });

    it('renders correctly for guest when support internal gift card', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: false,
                    token: ''
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'internal'
                }
            }
        };

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
        // @ts-ignore
        const wrapper = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper).toEqual({});
    });

    it('renders correctly for guest when support external gift card', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: false,
                    token: ''
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'external'
                }
            }
        };

        let moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
         // @ts-ignore
        let wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(true);

         // module config only show pin
        mockConfig = {
            showAdditionalFields: showAdditionalFields.pin
        };
        moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        wrapper  = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper.find('.ms-gift-card-balance-check__input-pin-fields').exists()).toBe(true);
        expect(wrapper.find('.ms-gift-card-balance-check__input-exp-fields').exists()).toBe(false);
    });

    it('renders correctly for guest when support both gift card', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: false,
                    token: ''
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = render(<GiftCardBalanceCheck {...moduleProps} />);
        expect(component).toMatchSnapshot();
        // @ts-ignore
        const wrapper = mount(<GiftCardBalanceCheck {...moduleProps} />);
        expect(wrapper).toEqual({});
    });

    it('disables the apply button when input is empty', () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = mount(shallow(<GiftCardBalanceCheck {...moduleProps} />).get(0));
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        expect(button.is('[disabled]')).toBe(true);
    });

    it('shows error when apply an invalid gift card number', async () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        // @ts-ignore: mockContext
        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'xxx';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe(mockResources.invalidCardInfoError);
                // unmount after complete state update
                component.unmount();
            });
    });

    it('shows error for empty input', async () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = shallow(<GiftCardBalanceCheck {...moduleProps} />);
        const instance = component.instance();

        // test empty input
        // @ts-ignore
        instance._applyGiftCard();
        expect(component.state('errorMessage')).toBe('Please enterd a gift card number');
    });

    it('handles empty gift card', async () => {
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // test empty card
        input.simulate('change', {
            target: {
                value: 'empty'
            }
        });
        button.simulate('click');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('Gift card has no balance left');
                component.unmount();
            });
    });

    // tslint:disable-next-line:max-func-body-length
    it('handle if resolveCardTypes return empty', async () => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve([]);
        });

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).not.toBeCalled();
                expect(component.state('errorMessage')).toBe('Invalid gift card code entered');
            });
    });

    // tslint:disable-next-line:max-func-body-length
    it('handle config support external when add an internal gift card', async () => {
        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'external'
                }
            }
        };

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('The gift card type is not suported');
            });
    });

    // tslint:disable-next-line:max-func-body-length
    it('handle config support internal when add an external gift card', async () => {
        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'internal'
                }
            }
        };

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve(mockExternalGiftCardTypes);
        });

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('The gift card type is not suported');
            });
    });

    // tslint:disable-next-line:max-func-body-length
    it('handle config support both when add an external gift card', async () => {
        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve(mockExternalGiftCardTypes);
        });

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('Gift card PIN is required');
            });
    });

        // tslint:disable-next-line:max-func-body-length
    it('handle config support both when add an external gift card with pin and date', async () => {
        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: true,
                    token: 'xxx'
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'both'
                }
            }
        };

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve(mockExternalGiftCardTypes);
        });

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');
        const pinInput = component.find('input.ms-gift-card-balance-check__input-pin-text');
        const expInput = component.find('input.ms-gift-card-balance-check__input-exp-text');

        button.simulate('click');
        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        pinInput.simulate('change', {
            target: {
                value: '1111'
            }
        });
        expInput.simulate('change', {
            target: {
                value: '10/20'
            }
        });

        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        expect(component.state('giftCardPin')).toBe('1111');
        expect(component.state('giftCardExp')).toBe('10/20');

        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('');
            });
    });

    // tslint:disable-next-line:max-func-body-length
    it('handle config support external when guest add an internal gift card', async () => {
        // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
        mockContext = {
            actionContext,
            // @ts-ignore: Don't throw even though requestContext type is not correct
            request: {
                market: 'AB',
                // @ts-ignore: optOutWebActivityTracking should not be required
                user: {
                    isAuthenticated: false,
                    token: ''
                }
            },
            // @ts-ignore: Using partial for testing
            cultureFormatter: {
                formatCurrency: jest.fn(price => `$${price}`)
            },
            app: {
                config: {
                    giftCardSupported: 'external'
                }
            }
        };

        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockImplementation((context, id) => {
            return Promise.resolve(mockInternalGiftCardTypes);
        });

        const moduleProps = {
            ...(buildMockModuleProps({}, mockActions, mockConfig, mockContext) as IGiftCardBalanceCheckModuleProps),
            resources: mockResources,
            renderView: View
        };
        const giftCardNumber = 'abc';
        // @ts-ignore
        const component = mount(<GiftCardBalanceCheck {...moduleProps} />);
        debugger;
        const button = component.find('button.ms-gift-card-balance-check__btn-apply');
        const input = component.find('input.ms-gift-card-balance-check__input-text');

        // And apply 'abc'
        input.simulate('change', {
            target: {
                value: giftCardNumber
            }
        });
        expect(component.state('errorMessage')).toBe('');
        expect(component.state('isFetchingGiftCard')).toBe(false);
        expect(component.state('giftCardNumber')).toBe(giftCardNumber);
        button.simulate('click');
        expect(component.state('errorMessage')).toBe('');

        return Promise.resolve(component)
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => Promise.resolve(component))
            .then(() => {
                component.update();
                expect(StoreOperationsDataActions.getTenderTypesAsync).toBeCalled();
                expect(component.state('errorMessage')).toBe('The gift card type is not suported');
            });
    });

    afterEach(() => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.getGiftCardAsync.mockReset();
        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.getTenderTypesAsync.mockReset();
        // @ts-ignore: Jest Mocking Confuses TS Complier
        StoreOperationsDataActions.resolveCardTypesAsync.mockReset();
    });

    afterAll(() => {
        jest.unmock('@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g');
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import * as React from 'react';

import { IModuleStateManager, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps } from '@msdyn365-commerce-modules/utilities';
import { CustomerBalances } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import get from 'lodash/get';
import { computed, reaction } from 'mobx';
import { observer } from 'mobx-react';
import { ICheckoutCustomerAccountPaymentData } from './checkout-customer-account-payment.data';
import { ICheckoutCustomerAccountPaymentProps } from './checkout-customer-account-payment.props.autogenerated';
import { getAccountPaymentFormEditMode, IAccountPaymentEditViewForm } from './components/get-account-payment-form-edit-mode';
import { getAccountPaymentFormSummaryMode, IAccountPaymentSummaryViewForm } from './components/get-account-payment-form-summary-mode';

export interface ICheckoutCustomerAccountPaymentViewProps extends ICheckoutCustomerAccountPaymentProps<ICheckoutCustomerAccountPaymentData> {
    checkoutCustomerAccount: IModuleProps;
    summaryView: IAccountPaymentSummaryViewForm;
    editView: IAccountPaymentEditViewForm;
    moduleState: IModuleStateManager;
}

export interface ICheckoutCustomerAccountPaymentState {
    paymentAmount: number;
    isCreditSectionExpanded: boolean;
}

/**
 *
 * CheckoutCustomerAccount component
 * @extends {React.Component<ICheckoutCustomerAccountPaymentProps<ICheckoutCustomerAccountPaymentData>>}
 */
// @ts-ignore
@withModuleState
@observer
export class CheckoutCustomerAccountPayment extends React.Component<ICheckoutCustomerAccountPaymentViewProps, ICheckoutCustomerAccountPaymentState> {

    @computed get isCustomerAccountPaymentEnabled(): boolean {
        const customerInfo = get(this.props, 'data.customerInformation.result');
        const platform = get(this.props, 'context.request.app.platform');

        return customerInfo &&
        customerInfo.AllowOnAccountPayment === true &&
        platform &&
        (platform.enableCustomerAccountPayment === 'all' ||
        (platform.enableCustomerAccountPayment === 'b2b' && customerInfo.IsB2b === true) ||
        (platform.enableCustomerAccountPayment === 'b2c' && customerInfo.IsB2b === false));
    }

    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.loyaltyAmount) {
            return 0;
        }
        return checkoutState.loyaltyAmount;
    }

    @computed get getGiftCardAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCards || checkoutState.giftCards.length === 0) {
            return 0;
        }

        let giftCardAmount: number = 0;
        checkoutState.giftCards.forEach(giftCard => {
                giftCardAmount += (giftCard.Balance || 0);
            });

        return giftCardAmount;
    }

    @computed get maxPaymentAmount(): number {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return 0;
        }
        // Use customer account after gift card and loyalty.
        const amountDue = Math.max(0, (cart.TotalAmount || 0) - this.getLoyaltyAmount - this.getGiftCardAmount);

        // if the user has a mandatory credit limit, then the max amount must not be more than that
        if (this.props.data.customerInformation?.result?.MandatoryCreditLimit) {
            return Math.min(this.getAvailableCredit(this.props.data.creditBalances?.result), amountDue);
        } else {
            return amountDue;
        }
    }

    @computed get errorMessage(): string | undefined {
        if (this.state.paymentAmount > this.maxPaymentAmount || this.state.paymentAmount < 0) {
            return this.props.resources.invalidAmountMessage;
        }

        return undefined;
    }

    @computed get currencyCode(): string | undefined {
        return get(this.props, 'context.request.channel.Currency');
    }

    @computed get availableCredit(): number {
        const creditBalances = get(this.props, 'data.creditBalances.result');

        return creditBalances ? this.getAvailableCredit(creditBalances) : 0;
    }

    @computed get orderTotal(): number {
        const orderTotal = get(this.props, 'data.checkout.result.checkoutCart.cart.TotalAmount');

        return orderTotal ? orderTotal : 0;
    }

    @computed get formattedExcessCredit(): string | undefined {
        const excessCredit = this.availableCredit - this.orderTotal;
        return excessCredit < 0 ? this.props.context.cultureFormatter.formatCurrency(excessCredit, this.currencyCode) : undefined;
    }

    private baseClassName: string = 'ms-checkout-customer-account';
    public constructor(props: ICheckoutCustomerAccountPaymentViewProps) {
        super(props);
        this.state = {paymentAmount: this.maxPaymentAmount, isCreditSectionExpanded: false};
    }

    public async componentDidMount(): Promise<void> {
        await this.init();

        // when the cart.TotalAmount gets updated (like if selecting the delivery option adds a charge) we need to update the amount based on the new total amount.
        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart && this.props.data.checkout.result.checkoutCart.cart.TotalAmount,
            totalAmount => {
                this.updateMaxAmount(this.maxPaymentAmount);
            }
        );
    }

    public render(): JSX.Element | null {
        const customerInfo = this.props.data.customerInformation.result;

        if (!this.isCustomerAccountPaymentEnabled) {
            this.props.context.telemetry.information('customer account payments will not display, because the feature is disabled or not enabled for this type of customer');
            return null;
        }

        const checkoutState = this.props.data.checkout.result;
        const cart =  checkoutState ? checkoutState.checkoutCart.cart : undefined;

        const creditBalances = this.props.data.creditBalances.result;

        if (!cart) {
            return null;
        }
        const resources = this.props.resources;
        const locale = get(this.props, 'context.request.locale') || 'en-us';

        const customerSinceDate = new Date(customerInfo?.CreatedDateTime || 0).toLocaleDateString(locale);

        const props = {
            ...this.props,
            checkoutCustomerAccount: {
            moduleProps: this.props,
            className: classnames(
                this.baseClassName
            )},
            editView: getAccountPaymentFormEditMode({
                onAddPayment: this.addPayment,
                resources,
                amount: this.state.paymentAmount,
                onChangePaymentAmount: this.onChangePaymentAmount,
                maxAmount: this.maxPaymentAmount,
                customer: customerInfo,
                customerCreatedDate: customerSinceDate,
                availableCredit: this.props.context.cultureFormatter.formatCurrency(this.getAvailableCredit(creditBalances), this.currencyCode),
                showCreditLimit: customerInfo?.MandatoryCreditLimit || false,
                errorMessage: this.errorMessage,
                onToggleCreditSection: this.toggleCreditSection,
                creditSectionIsExpanded: this.state.isCreditSectionExpanded,
                orderTotal: this.props.context.cultureFormatter.formatCurrency(this.orderTotal, this.currencyCode),
                excessCredit: this.formattedExcessCredit,
                onRemovePayment: this.removePayment,
                appliedAmount: checkoutState && checkoutState.customerAccountAmount > 0 ? this.props.context.cultureFormatter.formatCurrency(checkoutState.customerAccountAmount, this.currencyCode) : undefined
            }),
            summaryView: getAccountPaymentFormSummaryMode({
                resources,
                amount: this.state.paymentAmount,
                appliedAmount: checkoutState && checkoutState.customerAccountAmount > 0 ? this.props.context.cultureFormatter.formatCurrency(checkoutState.customerAccountAmount, this.currencyCode) : undefined
            })
        };

        return this.props.renderView(props) as React.ReactElement;
    }

    private getAvailableCredit = (creditBalances: CustomerBalances | undefined) => {
        if (!creditBalances) {
            return 0;
        }
        return creditBalances.CreditLimit - creditBalances.Balance - creditBalances.PendingBalance;
    };

    private addPayment = async (): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;

        if (!checkoutState) {
            this.props.context.telemetry.error('checkout state not found');
            return;
        }

        await checkoutState.updateCustomerAccountAmount({ newAmount: this.state.paymentAmount });
        this.props.context.telemetry.information('customer account payment amount updated');
    }

    private toggleCreditSection = (): void => {
        this.setState({
            isCreditSectionExpanded: !this.state.isCreditSectionExpanded
        });
    };

    private init = async(): Promise<void> => {
        this.props.moduleState.init({
            onCancel: this.handleCancelOrSubmit,
            onSubmit: this.handleCancelOrSubmit,
            onEdit: this.onEdit
        });

        if (this.props.data.checkout.result && this.props.data.checkout.result.customerAccountAmount !== 0) {
            this.props.moduleState.onReady();
        }
    }

    private onChangePaymentAmount =(newAmount: number): void => {
        this.setState({
            paymentAmount: newAmount
        });
    };

    private updateMaxAmount =(newAmount: number): void => {

        // if the user has already set an amount, we should not override that in the UI because it will be confusing.
        if (this.props.data.checkout.result && this.props.data.checkout.result.customerAccountAmount === 0) {
            this.setState({
                // We should never allow a negative amount.
                paymentAmount: Math.max(0, newAmount)
            });
        }
    };

    private onEdit = (): void => {
        this.props.moduleState.onUpdating();
    };

    private handleCancelOrSubmit = () => {
        const checkoutState = this.props.data.checkout.result;
        if (checkoutState && checkoutState.customerAccountAmount > 0) {
            this.props.moduleState.onReady();
        } else {
            // Skip the module
            this.props.moduleState.onSkip();
        }
    };

    private removePayment = async (): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;

        if (!checkoutState) {
            this.props.context.telemetry.error('checkout state not found');
            return;
        }

        this.setState({
            paymentAmount: 0
        });

        await checkoutState.updateCustomerAccountAmount({ newAmount: 0});
        this.props.context.telemetry.information('customer account payment removed');
    }
}

export default CheckoutCustomerAccountPayment;

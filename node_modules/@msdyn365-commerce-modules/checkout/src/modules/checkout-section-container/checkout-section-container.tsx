/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IModuleStateManager, IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import get from 'lodash/get';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { ICheckoutSectionContainerProps } from './checkout-section-container.props.autogenerated';
import LoadingComponent from './components/loading';

export interface ICheckoutSectionContainerModuleProps extends ICheckoutSectionContainerProps<{}>, IModuleStateProps {
    enableControl: boolean;
}

export interface ICheckoutSectionContainerItem {
    id: string;
    loading?: React.ReactNode;
    itemProps: INodeProps;
    item: React.ReactNode;
}

export interface ICheckoutSectionContainerViewProps extends ICheckoutSectionContainerProps<{}> {
    className: string;
    checkoutPlainContainerProps: IModuleProps;
    items: ICheckoutSectionContainerItem[];
}

/**
 *
 * CheckoutPlainContainer component
 * @extends {React.Component<ICheckoutSectionContainerModuleProps>}
 */
@observer
export class CheckoutPlainContainer extends React.Component<ICheckoutSectionContainerModuleProps> {
    public componentDidMount(): void {
        const items = this.getItems();
        const childIds = items.map((item: React.ReactNode) => get(item, 'props.id'));
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            childIds
        });

        reaction(
            () => this.props.moduleState.isReady,
            () => {
                this.onContainerReady();
            }
        );

        reaction(
            () => this.props.moduleState.shouldSubmitContainer,
            () => {
                this.onSubmit();
            }
        );
    }

    public componentDidUpdate(): void {
        if (!this.props.moduleState.hasExternalSubmitGroup) {
            return;
        }
        /**
         * Review all modules to updating status if one of the modules has error
         */
        const { childIds, hasError, getModule } = this.props.moduleState;
        const hasReadyItems = childIds.some((childId: string) => {
            const state = getModule(childId);
            return !!state && state.isReady;
        });
        if (hasReadyItems && hasError) {
            this.onEdit();
        }
    }

    public render(): JSX.Element | null {
        const {
            enableControl,
            moduleState,
            config: { width }
        } = this.props;

        const items = this.getItems();
        if (!items.length) {
            this.props.context.telemetry.error('Checkout section content is empty, module wont render');
            return null;
        }

        const moduleClassName = classname(
            'ms-checkout-section-container',
            {
                'has-initialized': moduleState.hasInitialized,
                'is-ready': moduleState.isReady,
                'is-updating': !moduleState.isReady,
                container: width === 'container',
                'col-12 fullwidth': width === 'fluid'
            },
            this.props.config.className
        );

        const viewProps: ICheckoutSectionContainerViewProps = {
            ...this.props,

            className: moduleClassName,
            checkoutPlainContainerProps: {
                moduleProps: this.props,
                className: moduleClassName
            },
            items: items.map((item: React.ReactNode) => {
                const childId = get(item, 'props.id');
                const state = moduleState.getModule(childId);
                // Modules has not completed initializing or it's disable
                const hidden = state.hasModuleState && (!state.hasInitialized || state.isDisabled || state.isSkipped);
                return {
                    id: childId,
                    loading: state.hasModuleState && !state.hasInitialized && <LoadingComponent />,
                    itemProps: {
                        'data-type-name': state.typeName,
                        className: classname('ms-checkout-section-container__item', {
                            hidden: hidden,
                            initialized: state.hasInitialized,
                            disabled: state.isDisabled,
                            skipped: state.isSkipped,
                            ready: state.isReady,
                            updating: state.isUpdating,
                            pending: state.isPending
                        })
                    },
                    item: React.cloneElement(item as React.ReactElement, { enableControl })
                };
            })
        };
        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private getItems = (): React.ReactNode[] => {
        const { slots } = this.props;
        return (slots && slots.primary && slots.primary.length && slots.primary) || [];
    };

    private getActiveChildModuleStates = (): IModuleStateManager[] => {
        const { childIds, getModule } = this.props.moduleState;
        return childIds
            .map(getModule)
            .filter((state): state is IModuleStateManager => !!state && !state.isDisabled && state.hasModuleState);
    };

    private clearError = (): void => {
        // Clear error before action, otherwise it will rise conflict;
        this.getActiveChildModuleStates().forEach(state => {
            state.hasError && state.setHasError(false);
        });
    };

    private onSubmit = (): void => {
        this.clearError();
        this.getActiveChildModuleStates().forEach(state => {
            !state.isReady && state.onSubmit && state.onSubmit();
        });
    };

    private onCancel = (): void => {
        this.clearError();
        this.getActiveChildModuleStates().forEach(state => {
            !state.isReady && state.onCancel && state.onCancel();
        });
    };

    private onEdit = (): void => {
        this.getActiveChildModuleStates().forEach(state => {
            (state.isReady || state.isSkipped) && state.onEdit && state.onEdit();
        });
    };

    private onContainerReady = (): void => {
        this.getActiveChildModuleStates().forEach(state => {
            state.isReady && state.onContainerReady && state.onContainerReady();
        });
    };
}

export default withModuleState(CheckoutPlainContainer);

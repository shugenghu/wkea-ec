/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import classnames from 'classnames';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { GetLoyaltyTransactionEstimationInput } from '@msdyn365-commerce-modules/retail-actions';
import { Button, Drawer, Heading, IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import { PriceComponent } from '@msdyn365-commerce/components';
import { callActionOrExecute } from '@msdyn365-commerce/retail-proxy';
import { createGetMaxLoyaltyPointsToRedeemForTransactionBalanceInput } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { LoyaltyPointRedemptionEstimate, LoyaltyRewardPoint } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';

import { ICheckoutLoyaltyData } from './checkout-loyalty.data';
import { ICheckoutLoyaltyProps } from './checkout-loyalty.props.autogenerated';
import InputComponent from './components/checkout-loyalty-input';
import LabelComponent from './components/checkout-loyalty-label';
import TextComponent from './components/checkout-loyalty-text';

export interface ICheckoutLoyaltyState {
    dollarsApplied: number;
    isFetchingLoyaltyCard: boolean;
}

export interface ICheckoutLoyaltyModuleProps extends ICheckoutLoyaltyProps<ICheckoutLoyaltyData>, IModuleStateProps {}

export interface ICheckoutLoyaltyViewState {
    isShowLoyalty: boolean;
    isShowAddLoyalty: boolean;
}

export interface ICheckoutLoyaltyShow {
    heading: React.ReactNode;
    coveredAmountText: React.ReactNode;
    amount: React.ReactNode;
}

export interface ICheckoutLoyaltyRewardPoint {
    checkoutLoyaltyRewardPoint: INodeProps;
    key: string;
    title: React.ReactNode;
    availablePointsText: React.ReactNode;
    activePoints: React.ReactNode;
    expiringPointsText: React.ReactNode;
    expiringPoints: React.ReactNode;
}

export interface ICheckoutLoyaltyAdd {
    heading: React.ReactNode;
    cardNumber: React.ReactNode;
    drawer: INodeProps;
    rewardPoints: ICheckoutLoyaltyRewardPoint[];
    loyaltyAmountContainer: INodeProps;
    appliedLoyaltyAmountContainer: INodeProps;
    loyaltyAmountLabel: React.ReactNode;
    loyaltyAmountInput: React.ReactNode;
    loyaltyAmountApplyButton: React.ReactNode;
    showAppliedAmount: boolean;
    loyaltyAmountAppliedText: React.ReactNode;
    loyaltyAmountAppliedPrice: React.ReactNode;
    loyaltyAmountRemoveButton: React.ReactNode;
}

export interface ICheckoutLoyaltyViewProps extends ICheckoutLoyaltyModuleProps {
    checkoutLoyalty: IModuleProps;
    viewState: ICheckoutLoyaltyViewState;
    showLoyalty: ICheckoutLoyaltyShow;
    addLoyalty: ICheckoutLoyaltyAdd;
}

/**
 *
 * CheckoutLoyalty component
 * @extends {React.Component<ICheckoutLoyaltyProps<ICheckoutLoyaltyData>>}
 */
// @ts-ignore
@withModuleState
@observer
class CheckoutLoyalty extends React.Component<ICheckoutLoyaltyModuleProps, ICheckoutLoyaltyState> {
    private _dialogToggleRef: React.RefObject<HTMLButtonElement> | undefined;
    private moduleClassName: string = 'ms-checkout-loyalty';

    constructor(props: ICheckoutLoyaltyModuleProps) {
        super(props);
        this._dialogToggleRef = React.createRef();
        this._applyLoyaltyPoints = this._applyLoyaltyPoints.bind(this);
        this._removeLoyaltyPoints = this._removeLoyaltyPoints.bind(this);
        this._onInputChange = this._onInputChange.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this.state = { dollarsApplied: this.maxDollars, isFetchingLoyaltyCard: false };
    }

    @computed get shouldPayLoyalty(): boolean {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }
        // Use loyalty when cart is not full of free items
        const amountDue = cart.TotalAmount || 0;
        return amountDue > 0;
    }

    @computed get isDataReady(): boolean {
        return (
            (this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS' &&
            (this.props.data.loyaltyCard && this.props.data.loyaltyCard.status) !== 'LOADING' &&
            (this.props.data.loyaltyTransactionEstimation && this.props.data.loyaltyTransactionEstimation.status) !== 'LOADING'
        );
    }

    @computed get maxDollars(): number {
        return this.props.data.loyaltyTransactionEstimation.result &&
            this.props.data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints
            ? this.props.data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints
            : 0;
    }

    @computed get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return requestFormData && query && query.pv === '1' ? true : false;
    }

    public async componentDidMount(): Promise<void> {
        when(
            () => this.isDataReady,
            async () => {
                await this.init();
            }
        );

        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart,
            async () => {
                this._updateEstimate();
            }
        );

        reaction(
            () => this.props.data.loyaltyCard.result,
            async () => {
                this._updateLoyalty();
            }
        );
    }

    // tslint:disable-next-line:max-func-body-length
    public render(): JSX.Element | null {
        const {
            resources,
            renderView,
            moduleState: { isReady }
        } = this.props;

        if (
            this.props.data.loyaltyCard &&
            this.props.data.loyaltyCard.result &&
            this.props.data.loyaltyCard.result.CardNumber &&
            this.shouldPayLoyalty
        ) {
            const loyaltyCard = this.props.data.loyaltyCard.result;
            const checkoutState = this.props.data.checkout.result;
            let isShowLoyalty = false;

            if (isReady) {
                if (!checkoutState || checkoutState.loyaltyAmount === 0) {
                    return null;
                } else {
                    isShowLoyalty = true;
                }
            }

            const viewProps = {
                ...this.props,
                viewState: {
                    isShowLoyalty: isShowLoyalty,
                    isShowAddLoyalty: !isReady
                },
                checkoutLoyalty: {
                    moduleProps: this.props,
                    className: classnames(
                        this.moduleClassName,
                        { [`${this.moduleClassName}__applied`]: isShowLoyalty },
                        this.props.config.className
                    )
                },
                showLoyalty: {
                    heading: <Heading headingTag='h3' className={`${this.moduleClassName}__heading`} text={resources.loyaltyHeadingText} />,
                    coveredAmountText: (
                        <TextComponent className={`${this.moduleClassName}__text`} text={resources.loyaltyCoveredAmountText} />
                    ),
                    amount: (
                        <PriceComponent
                            className={`${this.moduleClassName}__applied-value`}
                            id={this.props.id}
                            typeName={this.props.typeName}
                            context={this.props.context}
                            data={{ price: { CustomerContextualPrice: checkoutState && checkoutState.loyaltyAmount } }}
                        />
                    )
                },
                addLoyalty: {
                    heading: <Heading headingTag='h3' className={`${this.moduleClassName}__heading`} text={resources.loyaltyHeadingText} />,
                    drawer: {
                        tag: Drawer,
                        className: `${this.moduleClassName}__drawer`,
                        toggleButtonText: this._drawerHeader(),
                        openGlyph: `${this.moduleClassName}__drawer-open`,
                        closeGlyph: `${this.moduleClassName}__drawer-close`,
                        glyphPlacement: 'end'
                    },
                    cardNumber: <TextComponent className={`${this.moduleClassName}__card-number`} text={loyaltyCard.CardNumber || ''} />,
                    rewardPoints:
                        loyaltyCard.RewardPoints &&
                        loyaltyCard.RewardPoints.map((points, index) => {
                            return this._renderPointSection(points, resources.availablePointsLabel, resources.expiringLoyaltyPointsLabel);
                        }),
                    loyaltyAmountContainer: {
                        className: `${this.moduleClassName}__amount`
                    },
                    appliedLoyaltyAmountContainer: {
                        className: `${this.moduleClassName}__applied-amount`
                    },
                    loyaltyAmountLabel: (
                        <LabelComponent
                            className={`${this.moduleClassName}__amount-label`}
                            text={resources.payWithLoyaltyAmountLabel}
                            htmlFor={`${this.props.id}-label`}
                        />
                    ),
                    loyaltyAmountInput: (
                        <InputComponent
                            className={`${this.moduleClassName}__amount-input`}
                            onChange={this._onInputChange}
                            onBlur={this._onBlur}
                            type='number'
                            step='.01'
                            value={this.state.dollarsApplied}
                            min={0}
                            max={this.maxDollars}
                            ariaValueMax={this.maxDollars}
                            ariaValueMin={0}
                            ariaValueNow={this.state.dollarsApplied}
                            id={`${this.props.id}-label`}
                        />
                    ),
                    loyaltyAmountApplyButton: (
                        <Button
                            className={`${this.moduleClassName}__amount-button`}
                            title={this.props.resources.applyCheckoutLoyaltyPaymentText}
                            onClick={this._applyLoyaltyPoints}
                            disabled={
                                this.state.dollarsApplied > this.maxDollars ||
                                this.state.dollarsApplied <= 0 ||
                                this.state.isFetchingLoyaltyCard
                            }
                        >
                            {this.props.resources.applyCheckoutLoyaltyPaymentText}
                        </Button>
                    ),
                    showAppliedAmount: checkoutState && checkoutState.loyaltyAmount > 0,
                    loyaltyAmountAppliedText: (
                        <TextComponent className={`${this.moduleClassName}__applied-text`} text={resources.loyaltyCoveredAmountText} />
                    ),
                    loyaltyAmountAppliedPrice: (
                        <PriceComponent
                            className={`${this.moduleClassName}__applied-value`}
                            id={this.props.id}
                            typeName={this.props.typeName}
                            context={this.props.context}
                            data={{ price: { CustomerContextualPrice: checkoutState && checkoutState.loyaltyAmount } }}
                        />
                    ),
                    loyaltyAmountRemoveButton: (
                        <Button
                            className='ms-checkout-loyalty-remove-btn'
                            title={this.props.resources.removeCheckoutLoyaltyPaymentText}
                            onClick={this._removeLoyaltyPoints}
                            innerRef={this._dialogToggleRef}
                        >
                            {this.props.resources.removeCheckoutLoyaltyPaymentText}
                        </Button>
                    )
                }
            };

            return renderView(viewProps) as React.ReactElement;
        }
        this.props.context.telemetry.error('Checkout loyalty content is empty, module wont render');
        return null;
    }

    private _drawerHeader(): JSX.Element {
        return (
            <React.Fragment>
                <p className={`${this.moduleClassName}__covered-text`}>{this.props.resources.loyaltyCoveredAmountText}</p>
                <PriceComponent
                    className={`${this.moduleClassName}__applied-value`}
                    id={this.props.id}
                    typeName={this.props.typeName}
                    context={this.props.context}
                    data={{ price: { CustomerContextualPrice: this.maxDollars } }}
                />
            </React.Fragment>
        );
    }

    private _renderPointSection(
        point: LoyaltyRewardPoint,
        loyaltyCoveredAmountText: string,
        expiringLoyaltyPointsLabel: string
    ): ICheckoutLoyaltyRewardPoint {
        return {
            key: point.RewardPointId || '',
            checkoutLoyaltyRewardPoint: {
                className: `${this.moduleClassName}__program`
            },
            title: <TextComponent className={`${this.moduleClassName}__program-title`} text={point.Description} />,
            availablePointsText: <TextComponent className={`${this.moduleClassName}__program-available`} text={loyaltyCoveredAmountText} />,
            activePoints: (
                <TextComponent className={`${this.moduleClassName}__program-points`} text={(point && point.ActivePoints!).toString()} />
            ),
            expiringPointsText: <TextComponent className={`${this.moduleClassName}__program-expiring`} text={expiringLoyaltyPointsLabel} />,
            expiringPoints: (
                <TextComponent
                    className={`${this.moduleClassName}__program-points`}
                    text={(point && point.PointsExpiringSoon!).toString()}
                />
            )
        };
    }

    private init = async (): Promise<void> => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            isRequired: false,
            ...(!this.isEnabled() && { status: 'disabled' })
        });

        const savedLoyaltyAmount = this.props.data.checkout.result?.loyaltyAmount;
        if (savedLoyaltyAmount) {
            this.props.moduleState.onReady();
        } else if (this.isPaymentVerificationRedirection) {
            this.props.moduleState.onSkip();
        } else if (
            this.props.data.loyaltyCard.result &&
            this.props.data.checkout.result &&
            this.props.data.loyaltyCard.result.CardNumber !== this.props.data.checkout.result.checkoutCart.cart.LoyaltyCardId
        ) {
            this.props.data.checkout.result.checkoutCart
                .updateLoyaltyCardId({ loyaltyCardNumber: this.props.data.loyaltyCard.result.CardNumber })
                .catch(error => {
                    if (this.context.telemetry) {
                        this.context.telemetry.warning(error);
                        this.context.telemetry.debug('Unable to update the loyalty card');
                    }
                });
        }
    };

    private onEdit = () => {
        this.props.moduleState.onUpdating();
    };

    private onCancel = () => {
        this.handleCancelOrSubmit();
    };

    private onSubmit = () => {
        this.handleCancelOrSubmit();
    };

    private handleCancelOrSubmit = () => {
        const checkoutState = this.props.data.checkout.result;
        if (checkoutState && checkoutState.loyaltyAmount > 0) {
            // Show summary screen
            this.props.moduleState.onReady();
        } else {
            // Skip the module
            this.props.moduleState.onSkip();
        }
    };

    private isEnabled = () => {
        return (
            this.props.context.request.user.isAuthenticated &&
            this.props.data.loyaltyCard.result &&
            this.props.data.loyaltyCard.result.CardNumber &&
            this.shouldPayLoyalty
        );
    };

    private async _applyLoyaltyPoints(): Promise<void> {
        const checkoutState = this.props.data.checkout.result;

        if (!checkoutState) {
            return;
        }

        await checkoutState.updateLoyaltyAmount({ newAmount: parseFloat(this.state.dollarsApplied.toString()) });
        this.setState({
            isFetchingLoyaltyCard: true
        });
    }

    private async _removeLoyaltyPoints(): Promise<void> {
        const checkoutState = this.props.data.checkout.result;

        if (!checkoutState) {
            return;
        }

        await checkoutState.updateLoyaltyAmount({ newAmount: 0 });
        this.setState({
            dollarsApplied: 0
        });
    }

    private _onInputChange(event: React.ChangeEvent<HTMLInputElement>): void {
        const value = event.currentTarget.value;
        this.setState({ dollarsApplied: value.length ? Number(value) : parseFloat(value), isFetchingLoyaltyCard: false });
    }

    private _onBlur(event: React.FocusEvent<HTMLInputElement>): void {
        const num = parseFloat(event.currentTarget.value).toFixed(2);
        const element = document.getElementById(`${this.props.id}-label`) as HTMLInputElement;
        if (element && num) {
            element.value = num;
            this.setState({ dollarsApplied: parseFloat(num) });
        }
    }

    private _updateLoyalty(): void {
        if (this.props.moduleState.isDisabled && this.isEnabled()) {
            this._updateEstimate();
            this.props.moduleState.onUpdating();
        }
    }

    private _updateEstimate(): void {
        const card = this.props.data.loyaltyCard.result;
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        const channelConfig = this.props.context.request.channel;
        if (card && cart && channelConfig) {
            const currencyCode = channelConfig.Currency || '';
            const loyalPointsRequest = createGetMaxLoyaltyPointsToRedeemForTransactionBalanceInput(cart.Id, card.CardNumber!, currencyCode);

            // @ts-ignore
            // Due to bug 23214358, this is getting improperly cached. Need to turn on cache bypass for now to work around issue
            loyalPointsRequest._query.options.bypassCache = 'get';

            callActionOrExecute<LoyaltyPointRedemptionEstimate>(loyalPointsRequest, this.props.context.actionContext)
                .then(async points => {
                    this.props.context.actionContext.update(
                        new GetLoyaltyTransactionEstimationInput(this.props.context.request.apiSettings),
                        points
                    );
                    const newMaxPoints = (points && points.MaxCurrencyValueOfLoyaltyPoints) || 0;

                    // If points are already applied, ensure you don't apply more points than max
                    if (this.props.data.checkout.result && this.props.data.checkout.result.loyaltyAmount > newMaxPoints) {
                        await this.props.data.checkout.result.updateLoyaltyAmount({ newAmount: newMaxPoints });
                    }

                    // If input amount is already equal to max, keep it at new max. Also if input amount would be more than new max, set it to new max
                    if (this.state.dollarsApplied > newMaxPoints) {
                        this.setState({ dollarsApplied: newMaxPoints });
                    }
                })
                .catch(error => {
                    this.props.context.actionContext.telemetry.exception(error);
                    this.props.context.actionContext.telemetry.debug('Error getting Loyalty Point Redemption Estimate');
                });
        }
    }
}

export default CheckoutLoyalty;

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------
 */
/// <reference types="jest" />
import { mount } from 'enzyme';
import * as React from 'react';
import * as renderer from 'react-test-renderer';

import { updateModuleStates } from '@msdyn365-commerce-modules/checkout-utilities';
import { wrapInResolvedAsyncResult } from '@msdyn365-commerce-modules/retail-actions';
import { buildHydratedMockActionContext, buildMockModuleProps } from '@msdyn365-commerce/core';
import { ICartActionResult, ICheckoutState } from '@msdyn365-commerce/global-state';
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import {
    Cart, LoyaltyCard, LoyaltyPointRedemptionEstimate
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';

import CheckoutLoyalty, { ICheckoutLoyaltyModuleProps } from '../checkout-loyalty';
import { ICheckoutLoyaltyData } from '../checkout-loyalty.data';
import {
    ICheckoutLoyaltyConfig, ICheckoutLoyaltyResources
} from '../checkout-loyalty.props.autogenerated';

const loyaltyCard: LoyaltyCard = {
    CardNumber: '1234567890',
    LoyaltyEnrollmentDate: new Date('Wed Jul 03 2019 14:44:37 GMT-0700'),
    RewardPoints: [
        {
            RewardPointId: 'Fabrikam',
            RewardPointTypeValue: 1,
            RewardPointCurrency: 'USD',
            IsRedeemable: true,
            PointsExpiringSoon: 34,
            ActivePoints: 90,
            Description: 'Fabrikam awesome points'
        }
    ]
};

const estimation: LoyaltyPointRedemptionEstimate = {
    MaxCurrencyValueOfLoyaltyPoints: 37
};

const mockCart = {
    Id: 'jWvjTh2wyxWnopUGQmzpkGoQVuu5pUh6',
    TotalAmount: 479.25,
    CartLines: [
        {
            LineId: '2',
            ProductId: 2,
            Quantity: 2,
            Price: 300,
            ExtendedPrice: 450,
            TaxAmount: 29.25,
            ItemTaxGroupId: 'RP',
            TotalAmount: 479.25,
            NetAmountWithoutTax: 450,
            NetPrice: 600,
            DiscountAmountWithoutTax: 150,
            DiscountAmount: 150
        }
    ]
} as Cart;

const mockAddLoyalty = (input: {loyaltyCardNumber: string}): Promise<ICartActionResult> => {
    mockCart.LoyaltyCardId = input.loyaltyCardNumber;
    return Promise.resolve({ status: 'SUCCESS' } as ICartActionResult);
};

// @ts-ignore partial class
let mockCheckoutState: ICheckoutState = {
    // @ts-ignore partial class
    checkoutCart: {
        cart: mockCart
    }
};

const mockData: ICheckoutLoyaltyData = {
    checkout: wrapInResolvedAsyncResult(mockCheckoutState),
    loyaltyCard: wrapInResolvedAsyncResult(loyaltyCard),
    loyaltyTransactionEstimation: wrapInResolvedAsyncResult(estimation)
};

const mockActionContext = buildHydratedMockActionContext();

// @ts-ignore
const mockContext: ICoreContext = {
    actionContext: mockActionContext,
    cultureFormatter: {
        formatCurrency: jest.fn((price, _foo) => `$${price}`)
    },
    request: {
        locale: 'en-us',
        user: {
            isAuthenticated: true
        },
        channel: {
            Currency: 'USD'
        }
    }
};
const mockConfig: ICheckoutLoyaltyConfig = {};

const mockResources: ICheckoutLoyaltyResources = {
    payWithLoyaltyText: 'Pay with loyalty rewards',
    payWithLoyaltyAmountLabel: 'Amount to use',
    selectLoyaltyProgramLabel: 'Select a loyalty program',
    totalLoyaltyDollarAmountText: 'Total available dollar amount:',
    availablePointsLabel: 'Total available points',
    expiringLoyaltyPointsLabel: 'Expiring points within 30 days',
    loyaltyCoveredAmountText: 'Amount covered by loyalty: ',
    removeCheckoutLoyaltyPaymentText: 'Remove',
    loyaltyHeadingText: 'Loyalty card',
    applyCheckoutLoyaltyPaymentText: 'Apply'
};

const mockActions = {};

describe('CheckoutLoyalty', () => {
    beforeEach(() => {
        mockCheckoutState = {
            // @ts-ignore partial class
            checkoutCart: {
                cart: mockCart,
                updateLoyaltyCardId: mockAddLoyalty
            }
        };
    });

    xit('renders correctly when user has no loyalty card', () => {
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutLoyaltyModuleProps),
            resources: mockResources
        };
        moduleProps.context = mockContext;
        const component: renderer.ReactTestRenderer = renderer.create(<CheckoutLoyalty {...moduleProps} />);
        const tree = component.toJSON();
        expect(tree).toMatchSnapshot();
    });

    xit('The amount of estimated points updates when the data updates', () => {
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutLoyaltyModuleProps),
            resources: mockResources
        };
        const wrapper = mount(<CheckoutLoyalty {...moduleProps} />);
        let points = wrapper.props().data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints;
        let loyaltyAmountNode = wrapper.find('.checkout-loyalty-covered-value').at(0);
        expect((loyaltyAmountNode.getDOMNode().textContent || '').trim()).toBe('$37');
        expect(points).toBe(37);
        mockData.loyaltyTransactionEstimation.result!.MaxCurrencyValueOfLoyaltyPoints = 42;
        wrapper.instance().forceUpdate();
        points = wrapper.props().data.loyaltyTransactionEstimation.result.MaxCurrencyValueOfLoyaltyPoints;
        loyaltyAmountNode = wrapper.find('.checkout-loyalty-covered-value').at(0);
        expect(points).toBe(42);
        expect((loyaltyAmountNode.getDOMNode().textContent || '').trim()).toBe('$42');
        wrapper.unmount();
    });

    xit('calls init when the data is ready', () => {
        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutLoyaltyModuleProps),
            resources: mockResources
        };
        moduleProps.context = mockContext;
        renderer.create(<CheckoutLoyalty {...moduleProps} />);
        expect(mockCheckoutState.checkoutCart.cart.LoyaltyCardId).toBe(loyaltyCard.CardNumber);
    });

    xit('does not call init when the data is not ready', () => {
        const mockLoadingData: ICheckoutLoyaltyData = {
            checkout: wrapInResolvedAsyncResult(mockCheckoutState),
            loyaltyCard: ({ result: loyaltyCard, status: 'LOADING' } as AsyncResult<LoyaltyCard>),
            loyaltyTransactionEstimation: wrapInResolvedAsyncResult(estimation)
        };

        const moduleProps = {
            ...(buildMockModuleProps(mockLoadingData, mockActions, mockConfig, mockContext) as ICheckoutLoyaltyModuleProps),
            resources: mockResources
        };
        moduleProps.data.loyaltyCard.status = 'LOADING';
        moduleProps.context = mockContext;
        renderer.create(<CheckoutLoyalty {...moduleProps} />);
        expect(mockCheckoutState.checkoutCart.cart.LoyaltyCardId).toBe(loyaltyCard.CardNumber);
    });

    xit('does call init when the loyalty fails (anon) scenario.', () => {
        const mockLoadingData: ICheckoutLoyaltyData = {
            checkout: wrapInResolvedAsyncResult(mockCheckoutState),
            loyaltyCard: ({ result: undefined, status: 'FAILED' } as AsyncResult<LoyaltyCard>),
            loyaltyTransactionEstimation: wrapInResolvedAsyncResult(estimation)
        };

        const moduleProps = {
            ...(buildMockModuleProps(mockLoadingData, mockActions, mockConfig, mockContext) as ICheckoutLoyaltyModuleProps),
            resources: mockResources
        };
        const mockModuleStates = {
            test_id: {
                id: 'test_id',
                hasInitialized: true,
                hasError: true,
                status: 'updating'
            }
        };
        // @ts-ignore: Using partial for testing
        updateModuleStates(mockModuleStates, mockActionContext);
        const wrapper = mount(<CheckoutLoyalty {...moduleProps} />,
                              { attachTo: document.body.firstElementChild as HTMLElement }
        );
        expect(wrapper.children().at(0).props().moduleState.status).toBe('disabled');
        wrapper.unmount();
    });
});

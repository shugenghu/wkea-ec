/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import classname from 'classnames';
import get from 'lodash/get';
import { action, observable, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { Button, getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, Waiting } from '@msdyn365-commerce-modules/utilities';
import { PriceComponent } from '@msdyn365-commerce/components';
import { ICheckoutState } from '@msdyn365-commerce/global-state';
import { Cart, FilterDeliveryModeOption } from '@msdyn365-commerce/retail-proxy';
import {
    getDeliveryOptionsAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import {
    Address, CartLine, DeliveryOption
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';

import { ICheckoutDeliveryOptionsData } from './checkout-delivery-options.data';
import { filterDeliveryModeOption, ICheckoutDeliveryOptionsProps } from './checkout-delivery-options.props.autogenerated';
import DescriptionComponent from './components/checkout-delivery-options.description';
import ErrorMessageComponent from './components/checkout-delivery-options.error-message';
import ErrorTitleComponent from './components/checkout-delivery-options.error-title';
import RadioButtonComponent from './components/checkout-delivery-options.radio-button';

export interface ICheckoutDeliveryOptionsModuleProps extends ICheckoutDeliveryOptionsProps<ICheckoutDeliveryOptionsData>, IModuleStateProps { }

export interface ICheckoutDeliveryOption {
    DeliveryOption: INodeProps;
    description?: React.ReactNode;
    price?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionEdit extends ICheckoutDeliveryOption {
    code: string;
    radioButton?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsList {
    DeliveryOptionsList: INodeProps;
    list: ICheckoutDeliveryOptionEdit[];
}

export interface ICheckoutDeliveryOptionsError {
    Error: INodeProps;
    title: React.ReactNode;
    message: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsViewState {
    isLoading: boolean;
    isError: boolean;
    isShowList: boolean;
    isShowSelected: boolean;
    isShowSaveButton: boolean;
    isShowEditButton: boolean;
    isShowCancelButton: boolean;
}

export interface ICheckoutDeliveryOptionsViewProps extends ICheckoutDeliveryOptionsProps<{}> {
    CheckoutDeliveryOptions: IModuleProps;
    selectedItemId: string;
    deliveryOptionsData: DeliveryOption[];
    isLoading: boolean;
    errorMessageData: string;
    viewState: ICheckoutDeliveryOptionsViewState;
    deliveryOptions?: ICheckoutDeliveryOptionsList;
    deliveryOptionSelected?: ICheckoutDeliveryOption;
    errorMessage?: ICheckoutDeliveryOptionsError;
    waiting?: React.ReactNode;
    saveButton?: React.ReactNode;
    editButton?: React.ReactNode;
    cancelButton?: React.ReactNode;
    onDeliveryOptionChange(event: React.ChangeEvent<HTMLInputElement>): void;
    onSave(): void;
    onEdit(): void;
    onCancel(): void;
}

/**
 *
 * CheckoutDeliveryOptions component
 * @extends {React.Component<ICheckoutDeliveryOptionsProps<ICheckoutDeliveryOptionsData>>}
 */
// @ts-ignore
@withModuleState
@observer
class CheckoutDeliveryOptions extends React.Component<ICheckoutDeliveryOptionsModuleProps> {
    @observable private selectedItemId: string = '';
    @observable private deliveryOptions: DeliveryOption[] = [];
    @observable private isLoading: boolean = false;
    @observable private errorMessage?: string;
    private cartDeliveryMode?: string;
    private telemetryContent?: ITelemetryContent;

    constructor(props: ICheckoutDeliveryOptionsModuleProps) {
        super(props);
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
    }

    public async componentDidMount(): Promise<void> {
        this.props.data.checkout.then(async () => {
            await this.init();
        });

        // @ts-ignore: Compiler not reconizing condition check for function params
        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress,
            async () => {
                await this.loadDeliveryOptions();
                this.props.moduleState.setIsCancellable(false);
            }
        );
    }

    public render(): JSX.Element | null {
        if (!this.canShip()) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const {
            moduleState: { isReady, isUpdating, hasError }
        } = this.props;
        const isError = !this.isLoading && hasError;
        const isShowList = !this.isLoading && !hasError && isUpdating;
        const isShowSelected = !this.isLoading && !hasError && isReady;

        const viewProps = {
            ...this.props,
            onDeliveryOptionChange: this.onDeliveryOptionChange,
            selectedItemId: this.selectedItemId,
            deliveryOptionsData: this.deliveryOptions,
            isLoading: this.isLoading,
            errorMessageData: this.errorMessage,
            viewState: {
                isLoading: this.isLoading,
                isError: isError,
                isShowList: isShowList,
                isShowSelected: isShowSelected,
                isShowSaveButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup,
                isShowEditButton: isShowSelected && !this.props.moduleState.hasExternalSubmitGroup,
                isShowCancelButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup && !!this.getSavedDeliveryOption()
            },
            CheckoutDeliveryOptions: {
                moduleProps: this.props,
                className: classname('ms-checkout-delivery-options', this.props.config.className)
            },
            deliveryOptions: {
                // @ts-ignore
                DeliveryOptionsList: { className: 'ms-checkout-delivery-options__list' },
                list: this.getDeliveryOptionList()
            },
            deliveryOptionSelected: this.getDeliveryOptionSelected(),
            errorMessage: this.getErrorMessage(),
            waiting: <Waiting />,
            saveButton: this.getSaveButton(),
            editButton: this.getEditButton(),
            cancelButton: this.getCancelButton(),
            onSave: this.onSave,
            onEdit: this.onEdit,
            onCancel: this.onCancel
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    @action
    private init = async (): Promise<void> => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            status: this.canShip() ? 'updating' : 'disabled'
        });

        this.cartDeliveryMode = this.getSavedDeliveryOption();

        await this.loadDeliveryOptions();
    };

    private canShip = (): boolean => {
        return this.getCartLinesForShipping().length > 0;
    };

    private isDeliveryModeExists = (deliveryMode: string | undefined): boolean => {
        if (deliveryMode) {
            if (this.deliveryOptions.find(deliveryOption => deliveryOption.Code === deliveryMode)) {
                return true;
            }
        }
        return false;
    };

    private getDeliveryOptionSelected = (): ICheckoutDeliveryOption | null => {
        const selectedItem = this.deliveryOptions.find(deliveryOption => deliveryOption.Code === this.selectedItemId);
        if (!selectedItem) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const { id, typeName, context } = this.props;
        const { priceFree } = this.props.resources;
        const price = get(selectedItem, 'ShippingChargeAmount', 0);

        // @ts-ignore
        return {
            // @ts-ignore
            DeliveryOption: { className: 'ms-checkout-delivery-options__option-selected' },
            description: <DescriptionComponent {...{ description: selectedItem.Description }} />,
            price: <PriceComponent id={id} typeName={typeName} context={context} className='ms-checkout-delivery-options__price' data={{ price: { CustomerContextualPrice: price } }} freePriceText={priceFree} />
        };
    };

    private getErrorMessage = (): ICheckoutDeliveryOptionsError => {
        const { errorMessageTitle } = this.props.resources;
        return {
            // @ts-ignore
            CheckoutDeliveryOptionsError: { tag: 'span', className: 'ms-address-form__error', role: 'alert', 'aria-live': 'assertive' },
            title: <ErrorTitleComponent {...{ title: errorMessageTitle }} />,
            message: <ErrorMessageComponent {...{ message: this.errorMessage }} />
        };
    };

    private getDeliveryOptionList = (): ICheckoutDeliveryOptionEdit[] => {
        const count = this.deliveryOptions.length;
        const { priceFree } = this.props.resources;
        const { id, typeName, context } = this.props;

        // @ts-ignore
        return this.deliveryOptions.map((deliveryOption: DeliveryOption, index: number) => {
            return {
                // @ts-ignore
                DeliveryOption: { className: 'ms-checkout-delivery-options__option' },
                code: deliveryOption.Code || '',
                radioButton: (
                    <RadioButtonComponent
                        {
                        ...{
                            isChecked: deliveryOption.Code === this.selectedItemId,
                            value: deliveryOption.Code,
                            ariaSetSize: count,
                            ariaPosInSet: index + 1,
                            ariaLabel: `${deliveryOption.Description} ${priceFree}`,
                            onChange: this.onDeliveryOptionChange,
                            telemetryContent: this.telemetryContent
                        }
                        }
                    />
                ),
                description: (
                    <DescriptionComponent
                        {
                        ...{
                            description: deliveryOption.Description
                        }
                        }
                    />
                ),
                price: (
                    <PriceComponent
                        id={id}
                        typeName={typeName}
                        context={context}
                        className='ms-checkout-delivery-options__price'
                        data={{ price: { CustomerContextualPrice: get(deliveryOption, 'ShippingChargeAmount', 0) } }}
                        freePriceText={priceFree}
                    />
                )
            };
        });
    };

    private getSaveButton = (): React.ReactNode => {
        const { saveBtnLabel = 'Save' } = this.props.resources;
        return (
            <Button
                className='ms-checkout-delivery-options__btn-save'
                title={saveBtnLabel}
                color='primary'
                disabled={!this.selectedItemId}
                onClick={this.onSave}
            >
                {saveBtnLabel}
            </Button>
        );
    };

    private getEditButton = (): React.ReactNode => {
        const { editBtnLabel = 'Change' } = this.props.resources;
        return (
            <Button
                className='ms-checkout-delivery-options__btn-edit'
                title={editBtnLabel}
                color='primary'
                onClick={this.onEdit}
            >
                {editBtnLabel}
            </Button>
        );
    };

    private getCancelButton = (): React.ReactNode => {
        const { cancelBtnLabel = 'Cancel' } = this.props.resources;
        return (
            <Button
                className='ms-checkout-delivery-options__btn-cancel'
                title={cancelBtnLabel}
                color='secondary'
                onClick={this.onCancel}
            >
                {cancelBtnLabel}
            </Button>
        );
    };

    private setError = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.errorMessage = errorMessage;
    };

    private clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.errorMessage = undefined;
    };

    private onSave = (): void => {
        this.onSubmit();
    };

    private onEdit = (): void => {
        this.onUpdating();
    };

    private onSubmit = (): void => {
        // tslint:disable-next-line:no-floating-promises
        this.updateCartDeliverySpecification(this.selectedItemId);
    };

    private onCancel = (): void => {
        // Reset to the saved value
        const savedDeliveryOption = this.getSavedDeliveryOption();
        if (savedDeliveryOption) {
            this.selectedItemId = savedDeliveryOption;
            this.onReady();
        } else {
            this.onUpdating();
        }
    };

    private getSavedDeliveryOption = (): string | undefined => {
        const cartLinesForShipping = this.getCartLinesForShipping();
        return cartLinesForShipping[0] && cartLinesForShipping[0].DeliveryMode;
    };

    private updateCartDeliverySpecification = async (deliveryModeId: string): Promise<void> => {
        if (deliveryModeId.trim() === '') {
            return;
        }

        const { resources } = this.props;
        const checkoutState = this.props.data.checkout.result as ICheckoutState;
        const updateCartDeliverySpecificationInput = {
            deliveryModeId: deliveryModeId,
            shippingAddress: checkoutState.shippingAddress
        };

        this.clearError();
        this.onPending();

        await checkoutState.checkoutCart.updateCartDeliverySpecification(updateCartDeliverySpecificationInput)
            .then((response) => {
                if (response.status === 'FAILED') {
                    this.setError(resources.genericErrorMessage);
                } else {
                    this.onReady();
                    this.props.moduleState.setIsCancellable(true);
                }
            })
            .catch(
                () => {
                    this.setError(resources.genericErrorMessage);
                }
            );
    };

    private getCartLinesForShipping = (): CartLine[] => {
        const { request } = this.props.context;
        const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;

        return ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(
            cartLine => (cartLine.DeliveryMode && cartLine.DeliveryMode !== '') ? cartLine.DeliveryMode !== pickupDeliveryModeCode : cartLine
        );
    };

    private getDeliveryOptions = async (shippingAddress: Address): Promise<void> => {
        if (!this.props.data.checkout.result) {
            return;
        }

        const { context, resources, config } = this.props;
        const cartState = this.props.data.checkout.result?.checkoutCart;
        const cartId = (cartState.cart as Cart).Id;
        if (context) {
            this.isLoading = true;
            this.deliveryOptions = [];
            this.selectedItemId = '';
            this.clearError();

            try {

                let originalDeliveryMode: string = '';
                const shippingCartLines = this.getCartLinesForShipping();
                const hasShippingDeliveryLines = (shippingCartLines && shippingCartLines.length > 0 && shippingCartLines[0].DeliveryMode);
                if (hasShippingDeliveryLines) {

                    // first store the delivery mode, so that we can restore the shipping information.
                    originalDeliveryMode = shippingCartLines[0].DeliveryMode || '';

                    // clear the delivery information on retail server, so GetDeliveryOptions charge calculation works correctly
                    const cart = cartState.cart;
                    await cartState.clearCartLinesDeliveryInformation({ cart });
                }

                // TODO: Check if we can move this getDeliveryOptions to checkout state
                let deliveryOptionFilter: FilterDeliveryModeOption;
                switch (config.filterDeliveryModeOption) {
                    case filterDeliveryModeOption.none:
                        deliveryOptionFilter = FilterDeliveryModeOption.None;
                        break;
                    case filterDeliveryModeOption.filterOutNonCarrierDeliveryMode:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                        break;
                    default:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                }
                const response = await getDeliveryOptionsAsync({ callerContext: context.actionContext, queryResultSettings: {} }, cartId, shippingAddress, [], deliveryOptionFilter);

                if (hasShippingDeliveryLines) {
                    await this.updateCartDeliverySpecification(originalDeliveryMode);
                }

                if (response && response.length) {
                    this.deliveryOptions = response;
                }
            } catch (error) {
                this.setError(resources.genericErrorMessage);
            }

            if (this.deliveryOptions.length === 0) {
                this.setError(resources.deliveryOptionsNotFound);
            } else {
                if (this.cartDeliveryMode && this.isDeliveryModeExists(this.cartDeliveryMode) && !this.props.data.checkout.result?.checkoutCart.cart.ShippingAddress) {
                    this.selectedItemId = this.cartDeliveryMode;
                    this.cartDeliveryMode = undefined;
                    this.onReady();
                } else {
                    this.onUpdating();
                    this.selectedItemId = this.deliveryOptions.length > 0 ? this.deliveryOptions[0].Code || '' : ''; // By default, select first delivery
                }
            }

            this.isLoading = false;
        }
    };

    private loadDeliveryOptions = async (): Promise<void> => {
        const shippingAddress = this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress;

        if (this.canShip() && shippingAddress) {
            await this.getDeliveryOptions(shippingAddress);
        }
    };

    private onDeliveryOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const deliveryModeId = event.currentTarget.value;
        this.selectedItemId = deliveryModeId;
    };

    private onReady = () => {
        this.props.moduleState.onReady();
    };

    private onUpdating = () => {
        this.props.moduleState.onUpdating();
    };

    private onPending = () => {
        this.props.moduleState.onPending();
    };
}

export default CheckoutDeliveryOptions;
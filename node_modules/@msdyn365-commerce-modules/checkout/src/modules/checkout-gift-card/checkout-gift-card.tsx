/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps } from '@msdyn365-commerce-modules/utilities';
import {
    getGiftCardAsync, getTenderTypesAsync, resolveCardTypesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    CardType, CardTypeInfo, GiftCard, RetailOperation, TenderType
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import classname from 'classnames';
import { computed, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { OPERATIONS } from '../checkout';
import { ICheckoutGiftCardData } from './checkout-gift-card.data';
import { ICheckoutGiftCardProps } from './checkout-gift-card.props.autogenerated';
import { getForm, IForm } from './components/get-form';
import { getList, IList } from './components/get-list';
import TitleCompoent from './components/title';

export * from './components/get-form';
export * from './components/get-item';
export * from './components/get-list';

interface ICheckoutGiftCardState {
    isFetchingGiftCard: boolean;
    errorMessage: string;
    giftCardNumber: string;
    giftCardPin: string;
    giftCardExp: string;
}

const enum SupportedGiftCardType {
    Internal = 'internal',
    External = 'external',
    Both = 'both'
}

export interface ICheckoutGiftCardModuleProps extends ICheckoutGiftCardProps<ICheckoutGiftCardData>, IModuleStateProps { }

export interface IShowResource {
    title: React.ReactNode;
    list?: IList;
}

export interface IAddResource {
    form: IForm;
    list?: IList;
}

export interface ICheckoutGiftCardViewProps extends ICheckoutGiftCardProps<{}>, ICheckoutGiftCardState {
    className?: string;

    showGiftCard?: IShowResource;
    addGiftCard?: IAddResource;

    checkoutGiftCardProps: IModuleProps;
    couldPaidByGiftCard?: boolean;
    isEnabled?: boolean;
    onEdit?(): void;
    onCancel?(): void;
    onSubmit?(): void;
    enterGiftCardNumber?(giftCardNumber: string): void;
    enterGiftCardPin?(giftCardNumber: string): void;
    enterGiftCardExp?(giftCardNumber: string): void;
    removeGiftCard?(giftCardNumber: string): void;
    applyGiftCard?(): void;
}

/**
 *
 * CheckoutGiftCard component
 * @extends {React.Component<ICheckoutGiftCardProps<ICheckoutGiftCardData>, ICheckoutGiftCardState>}
 */
@observer
export class CheckoutGiftCard extends React.Component<ICheckoutGiftCardModuleProps, ICheckoutGiftCardState> {
    public state: ICheckoutGiftCardState = {
        isFetchingGiftCard: false,
        errorMessage: '',
        giftCardNumber: '',
        giftCardPin: '',
        giftCardExp: ''
    };

    private inputRef: React.RefObject<HTMLInputElement> = React.createRef();

    private inputPinRef: React.RefObject<HTMLInputElement> = React.createRef();

    private inputExpRef: React.RefObject<HTMLInputElement> = React.createRef();

    @computed get isDataReady(): boolean {
        return (this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS';
    }

    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.loyaltyAmount) {
            return 0;
        }
        return checkoutState.loyaltyAmount;
    }

    @computed get shouldPayGiftCard(): boolean {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }
        // Use gift card card when loyalty points do not cover the total amount
        const amountDue = (cart.TotalAmount || 0) - this.getLoyaltyAmount;
        return amountDue > 0;
    }

    @computed get hasSelectedItem(): boolean {
        const {
            data: { checkout }
        } = this.props;
        const giftCards = checkout.result && checkout.result.giftCardExtends;
        return !!giftCards && giftCards.length > 0;
    }

    @computed get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return (requestFormData && query && query.pv === '1') ? true : false;
    }

    public componentDidMount(): void {
        // @ts-ignore: Compiler not reconizing condition check for function params
        when(
            () => this.isDataReady,
            () => {
                this.init();
            }
        );
    }

    public render(): JSX.Element | null {
        const {
            moduleState: { isReady },
            data: { checkout },
            config: { className, showAdditionalFields },
            resources
        } = this.props;
        const { errorMessage, giftCardNumber, giftCardPin, giftCardExp } = this.state;
        const giftCards = checkout.result && checkout.result.giftCardExtends;
        const additionalFields = showAdditionalFields;
        const supportedGiftCardType = this.props.context.app.config.giftCardSupported;

        if (!this.isEnabled() || (!this.shouldPayGiftCard && !isReady)) {
            this.props.context.telemetry.error('Checkout giftcard content is empty, module wont render');
            return null;
        }

        const supportExternalGiftCard = supportedGiftCardType === SupportedGiftCardType.Internal ? false : true;

        const moduleClassName = classname('ms-checkout-gift-card', className, isReady ? 'show' : 'add');

        const viewProps: ICheckoutGiftCardViewProps = {
            ...this.props,
            ...this.state,
            className: moduleClassName,

            checkoutGiftCardProps: { moduleProps: this.props, className: moduleClassName },
            couldPaidByGiftCard: this.couldPaidByGiftCard(),
            isEnabled: this.isEnabled(),
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            enterGiftCardNumber: this.enterGiftCardNumber,
            enterGiftCardPin: this.enterGiftCardPin,
            enterGiftCardExp: this.enterGiftCardExp,
            removeGiftCard: this.removeGiftCard,
            applyGiftCard: this.applyGiftCard,
            showGiftCard: isReady
                ? {
                    title: <TitleCompoent title={resources.giftCardFormLabel} />,
                    list: getList({
                        canRemove: false,
                        getFormattedPrice: this.getFormattedPrice,
                        giftCards: giftCards && [...giftCards], // Note: ReadOnly Checkout State GiftCard[] is not assignable to GiftCard[] type
                        onRemoveGiftCard: this.removeGiftCard,
                        resources
                    })
                }
                : undefined,
            addGiftCard: !isReady
                ? {
                    form: getForm({
                        errorMessage,
                        giftCardNumber,
                        giftCardPin,
                        giftCardExp,
                        inputRef: this.inputRef,
                        inputPinRef: this.inputPinRef,
                        inputExpRef: this.inputExpRef,
                        resources,
                        onEnterGiftCardNumber: this.enterGiftCardNumber,
                        onEnterGiftCardPin: this.enterGiftCardPin,
                        onEnterGiftCardExp: this.enterGiftCardExp,
                        onApplyGiftCard: this.applyGiftCard,
                        supportExternalGiftCard,
                        additionalFields
                    }),
                    list: getList({
                        canRemove: true,
                        getFormattedPrice: this.getFormattedPrice,
                        giftCards: giftCards && [...giftCards], // Note: ReadOnly Checkout State GiftCard[] is not assignable to GiftCard[] type
                        onRemoveGiftCard: this.removeGiftCard,
                        resources
                    })
                }
                : undefined
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private init = (): void => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            isRequired: false,
            ...(!this.isEnabled() && { status: 'disabled' })
        });

        const giftCards = this.props.data.checkout.result?.giftCardExtends;
        if (giftCards && giftCards.length > 0) {
            this.props.moduleState.onReady();
        } else if (this.isPaymentVerificationRedirection) {
            this.props.moduleState.onSkip();
        }

    };

    private couldPaidByGiftCard = (): boolean => {
        const cart = this.props.data.checkout.result ? this.props.data.checkout.result.checkoutCart.cart : undefined;
        if (!cart) {
            return false;
        }
        // Use gift card when it is not free
        return (cart.TotalAmount || 0) > 0;
    };

    private isEnabled = (): boolean => {
        if (!this.props.context.request.user.isAuthenticated && this.props.context.app.config.giftCardSupported !== 'external') {
            return false;
        }
        return this.couldPaidByGiftCard();
    };

    private onEdit = (): void => {
        // Show add gift card form
        this.props.moduleState.onUpdating();
    };

    private onCancel = (): void => {
        this.handleCancelOrSubmit();
    };

    private onSubmit = (): void => {
        this.handleCancelOrSubmit();
    };

    private handleCancelOrSubmit = () => {
        if (this.hasSelectedItem) {
            // Show summary screen
            this.props.moduleState.onReady();
        } else {
            // Skip the module
            this.props.moduleState.onSkip();
        }
    };

    private getFormattedPrice = (price: number = 0, currencyCode: string = 'USD'): string => {
        return this.props.context.cultureFormatter.formatCurrency(price, currencyCode);
    };

    private enterGiftCardNumber = (giftCardNumber: string): void => {
        this.setState({
            giftCardNumber
        });
        this.clearError();
    };

    private enterGiftCardPin = (giftCardPin: string): void => {
        this.setState({
            giftCardPin
        });
        this.clearError();
    };

    private enterGiftCardExp = (giftCardExp: string): void => {
        this.setState({
            giftCardExp
        });
        this.clearError();
    };

    private setError = (errorMessage: string): void => {
        this.props.telemetry.error('Error', errorMessage);
        this.props.telemetry.debug('Error', errorMessage);
        this.props.moduleState.setHasError(true);
        this.setState({
            errorMessage
        });
    };

    private clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.setState({
            errorMessage: ''
        });
    };

    private removeGiftCard = async (giftCardNumber: string): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState) {
            return;
        }

        await checkoutState.removeGiftCard({ giftCardNumber });
    };

    private applyGiftCard = async (): Promise<void> => {
        if (this.state.isFetchingGiftCard) {
            return;
        }
        this.setState({
            isFetchingGiftCard: true
        });

        const checkoutState = this.props.data.checkout.result;
        const giftCardNumber = this.state.giftCardNumber.trim();
        const giftCardPin = this.state.giftCardPin.trim();
        const giftCardExp = this.state.giftCardExp.trim();

        const giftCardTypes = await this.getGiftCardTypes(giftCardNumber);
        const giftCardType = giftCardTypes && giftCardTypes[0];
        const isPinRequired = giftCardType && giftCardType.IsPinRequired;
        const isExpRequired = giftCardType && giftCardType.IsExpirationDateRequired;
        const tenderTypeId = giftCardType && giftCardType.PaymentMethodId;
        const giftCard = await this.getGiftCard(giftCardNumber, giftCardPin, giftCardExp, isPinRequired, isExpRequired, tenderTypeId);

        if (checkoutState && giftCard) {
            await checkoutState.addGiftCard({ giftCard: giftCard, additionalProperties: { Pin: giftCardPin, ExpirationDate: giftCardExp, TenderTypeId: tenderTypeId } });
            this.clearError();
            this.setState({
                giftCardNumber: '',
                giftCardPin: '',
                giftCardExp: '',
                isFetchingGiftCard: false
            });
            return Promise.resolve();
        } else {
            const input =
                this.inputRef && this.inputRef.current && this.inputRef.current.focus && (this.inputRef.current as HTMLElement);
            input && input.focus();
            this.setState({
                isFetchingGiftCard: false
            });
        }
    };

    private findGiftcardTenderTypes = (tenderTypes: TenderType[], operationId: RetailOperation, giftcardType: string): string[] | undefined => {
        let matchedTenderTypes: TenderType[] | undefined;

        switch (giftcardType) {
            case SupportedGiftCardType.Internal:
                matchedTenderTypes = tenderTypes.filter(tenderType => (tenderType.OperationId === operationId && tenderType.ConnectorId === ''));
                break;
            case SupportedGiftCardType.External:
                matchedTenderTypes = tenderTypes.filter(tenderType => (tenderType.OperationId === operationId && tenderType.ConnectorId !== ''));
                break;
            default:
                throw new Error('Invalid gift card type');
        }

        if (matchedTenderTypes) {
            return matchedTenderTypes.map(tenderType => tenderType.TenderTypeId || '');
        }
        return;
    };

    private getGiftCard = async (giftCardNumber: string, giftCardPin: string, giftCardExp: string, isPinRequired: boolean | undefined, isExpRequired: boolean | undefined, tenderTypeId: string | undefined): Promise<GiftCard | undefined> => {
        const {
            resources: { noBalanceError, invalidCardInfoError, invalidCardTypeError, noCardPinError, noCardExpError }
        } = this.props;

        const supportedGiftCardType = this.props.context.app.config.giftCardSupported;

        if (!tenderTypeId) {
            return undefined;
        }

        const tenderTypes = await getTenderTypesAsync({ callerContext: this.props.context.actionContext, queryResultSettings: {} }).catch(error => {
            throw error;
        });

        if (!tenderTypes) {
            throw new Error('Fail to get gift card tender line');
        }
        const internalGiftcardTenderTypes = this.findGiftcardTenderTypes(tenderTypes, OPERATIONS.PayGiftCertificate, SupportedGiftCardType.Internal);
        const externalGiftcardTenderTypes = this.findGiftcardTenderTypes(tenderTypes, OPERATIONS.PayGiftCertificate, SupportedGiftCardType.External);

        switch (supportedGiftCardType) {
            case undefined:
            case SupportedGiftCardType.Internal:
                if (!internalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            case SupportedGiftCardType.External:
                if (!externalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            case SupportedGiftCardType.Both:
                if (!internalGiftcardTenderTypes?.includes(tenderTypeId) && !externalGiftcardTenderTypes?.includes(tenderTypeId)) {
                    this.setError(invalidCardTypeError);
                    return undefined;
                }
                break;
            default:
                throw new Error('Unsupported gift card type');
        }

        if (isPinRequired && giftCardPin === '') {
            this.setError(noCardPinError);
            return undefined;
        }

        if (isExpRequired && giftCardExp === '') {
            this.setError(noCardExpError);
            return undefined;
        }

        const month = parseInt(giftCardExp.split('/')[0], 10);
        const year = parseInt(giftCardExp.split('/')[1], 10);

        return getGiftCardAsync({ callerContext: this.props.context.actionContext }, giftCardNumber, tenderTypeId, giftCardPin, month, year)
            .then(activeGiftCard => {
                if (!activeGiftCard.Balance || activeGiftCard.Balance === 0) {
                    this.setError(noBalanceError);
                    return;
                }
                return activeGiftCard;
            })
            .catch(error => {
                this.setError(invalidCardInfoError);
                return undefined;
            });
    };

    private getGiftCardTypes = async (giftCardNumber: string): Promise<CardTypeInfo[] | undefined> => {
        const {
            resources: { emptyInputError, duplicatedCodeError, invalidCodeError },
            data: { checkout }
        } = this.props;

        if (!giftCardNumber) {
            this.setError(emptyInputError);
            return undefined;
        }

        const isDuplicated = checkout.result && checkout.result.giftCardExtends.some((card: GiftCard) => card.Id === giftCardNumber);
        if (isDuplicated) {
            this.setError(duplicatedCodeError);
            return undefined;
        }

        const GIFTCARDTYPE =  7 as CardType.GiftCard; // This is a workaround. ts-jest doesn't support 'const enum'

        return resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, giftCardNumber, GIFTCARDTYPE)
            .then(giftCardTypes => {
                if (!giftCardTypes || giftCardTypes.length === 0 || giftCardTypes[0] === undefined) {
                    this.setError(invalidCodeError);
                    return;
                }
                return giftCardTypes;
            })
            .catch(error => {
                this.setError(invalidCodeError);
                return undefined;
            });
    };
}

export default withModuleState(CheckoutGiftCard);
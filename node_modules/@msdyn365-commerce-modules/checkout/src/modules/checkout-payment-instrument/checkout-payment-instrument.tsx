/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import classnames from 'classnames';
import get from 'lodash/get';
import { action, computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps, INodeProps, Modal } from '@msdyn365-commerce-modules/utilities';
import { AsyncResultStatus, getUrlSync } from '@msdyn365-commerce/core';
import { IGiftCardExtend } from '@msdyn365-commerce/global-state';
import {
    retrieveCardPaymentAcceptResultAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import {
    resolveCardTypesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    Address, CardType, CartLine, TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';

import getCardPaymentAcceptPointAction, {
    GetCardPaymentAcceptPointInput
} from './actions/get-card-payment-accept-point';
import { ICheckoutPaymentInstrumentData } from './checkout-payment-instrument.data';
import { ICheckoutPaymentInstrumentProps } from './checkout-payment-instrument.props.autogenerated';
import AddPaymentFormComponent from './components/add-payment-form';
import ErrorComponent from './components/error';
import Iframe from './components/iframe';
import PaymentInformationComponent from './components/payment-information';
import WaitingComponent from './components/waiting';
import withVisibilityObserver, {
    IVisibilyObserverProps
} from './components/with-visibility-observer';
import {
    paymentConnectorExtraContextMessage, PaymentConnectorPostMessageType,
    paymentConnectorSubmitMessage
} from './payment-instrument-message';

export interface ICheckoutPaymentInstrumentModuleProps extends ICheckoutPaymentInstrumentProps<ICheckoutPaymentInstrumentData>, IModuleStateProps, IVisibilyObserverProps { }

interface ICheckoutPaymentInstrumentState {
    errorMessage?: string;
    isFetchingPaymentConnector?: boolean;
    paymentConnectorHeight?: number;
    isPaymentVerificationRequried?: boolean;
    paymentVerificationPostData?: string;
    isPaymentProcessing?: boolean;
    isOverlayModal?: boolean;
}

export interface ICheckoutPaymentOverlayModal {
    modal: INodeProps;
}

export interface ICheckoutPaymentInstrumentViewProps extends ICheckoutPaymentInstrumentProps<{}>, ICheckoutPaymentInstrumentState {
    className?: string;
    checkoutPaymentInstrument: IModuleProps;
    waiting?: React.ReactNode;
    alert?: React.ReactNode;
    paymentInformation?: React.ReactNode;
    addPaymentForm?: React.ReactNode;
    overlayModal?: ICheckoutPaymentOverlayModal;
    isVisible?: boolean;
}

/**
 *
 * CheckoutPaymentInstrument component
 * @extends {React.Component<ICheckoutPaymentInstrumentProps<ICheckoutPaymentInstrumentData>>}
 */
// @ts-ignore
@withModuleState
@observer
export class CheckoutPaymentInstrument extends React.Component<ICheckoutPaymentInstrumentModuleProps> {

    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }

    @computed get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.customerAccountAmount ? checkoutState.customerAccountAmount : 0;
    }

    @computed get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            const balance: number = giftCard.Balance || 0;
            return count + balance;
            // tslint:disable-next-line:align
        }, 0);
    }

    @computed get shouldPaidByCard(): boolean {
        const {
            data: {
                checkout
            },
            config
        } = this.props;
        if (!checkout.result) {
            return false;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || !cart.CartLines.length) {
            return false;
        }

        const { paymentTenderType, tokenizedPaymentCard } = checkoutResult;
        const isPaidByOtherPaymentSource = config.paymenTenderType !== paymentTenderType && tokenizedPaymentCard;

        // Use the card for payment after all other payment methods
        const amountDue = (cart.TotalAmount || 0) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;

        return amountDue > 0 && !isPaidByOtherPaymentSource;
    }

    @computed get isCartContainsItemsForShipping(): boolean {
        const pickupDeliveryModeCode = get(this.props, 'context.request.channel.PickupDeliveryModeCode');
        return (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some(
            (cartLine: CartLine) => cartLine.DeliveryMode !== pickupDeliveryModeCode
        );
    }

    @computed get isCartHasSelectedDeliveryMethods(): boolean {
        return (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).every(
            (cartLine: CartLine) => !!cartLine.DeliveryMode
        );
    }

    @computed get asyncResultStatus(): AsyncResultStatus | undefined {
        const isLoading = Object.values(this.props.data).some(data => get(data, 'status') === 'LOADING');
        if (isLoading) {
            return 'LOADING';
        }

        const isSuccess = Object.values(this.props.data).every(data => get(data, 'status') === 'SUCCESS');
        if (isSuccess) {
            return 'SUCCESS';
        }

        const isFailed = Object.values(this.props.data).some(data => get(data, 'status') === 'FAILED');
        if (isFailed) {
            return 'FAILED';
        }

        return;
    }

    @computed get hasSelectedItem(): boolean {
        return !!get(this.props.data, 'checkoutState.result.tokenizedPaymentCard');
    }

    @computed get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return (requestFormData && query && query.pv === '1') ? true : false;
    }

    @computed get requestUrlOrigin(): string {
        const origin = get(window, 'location.origin');
        const requestUrl =
            typeof get(this.props, 'context.request.url.requestUrl') === 'string'
                ? new URL(get(this.props, 'context.request.url.requestUrl'))
                : get(this.props, 'context.request.url.requestUrl');
        return origin || requestUrl.origin;
    }

    public state: ICheckoutPaymentInstrumentState = {
        isFetchingPaymentConnector: true
    };

    private moduleClassName: string = 'ms-checkout-payment-instrument';
    private iframeRef: React.RefObject<Iframe> = React.createRef();

    public componentDidMount(): void {
        // @ts-ignore: Compiler not reconizing condition check for function params
        when(
            () => this.asyncResultStatus !== 'LOADING',
            () => {
                this.init();
            }
        );

        // @ts-ignore: Compiler not reconizing condition check for function params
        reaction(
            () => this.asyncResultStatus !== 'FAILED' && this.shouldPaidByCard,
            () => {
                this.togglePayment();
            }
        );
    }

    // tslint:disable-next-line:cyclomatic-complexity
    public render(): JSX.Element | null {
        const { errorMessage, isFetchingPaymentConnector, paymentConnectorHeight, isPaymentVerificationRequried, isPaymentProcessing, isOverlayModal } = this.state;
        const {
            moduleState: { isReady, hasError, hasInitialized, isPending, hasExternalSubmitGroup },
            config: { iFrameHeightOverride, paymentStyleOverride, className, showBillingAddress },
            resources,
            data: { checkout, cardPaymentAcceptPoint },
            visibilityObserver
        } = this.props;

        const isVisible = visibilityObserver && visibilityObserver.isVisible;

        if (!hasInitialized || (this.asyncResultStatus !== 'FAILED' && !this.shouldPaidByCard)) {
            this.props.context.telemetry.error('Checkout payment content is empty, module wont render');
            return null;
        }

        const { AcceptPageUrl, AcceptPageContent, MessageOrigin } = cardPaymentAcceptPoint.result || {
            AcceptPageUrl: undefined,
            AcceptPageContent: undefined,
            MessageOrigin: undefined
        };

        const { tokenizedPaymentCard, tenderLine, billingAddress } = checkout.result || {
            tokenizedPaymentCard: undefined,
            tenderLine: undefined,
            billingAddress: undefined
        };

        const viewProps: ICheckoutPaymentInstrumentViewProps = {
            ...this.props,
            ...this.state,
            isVisible,
            className,

            checkoutPaymentInstrument: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, className)
            },
            waiting: !isReady && this.asyncResultStatus !== 'FAILED' && (this.asyncResultStatus === 'LOADING' || isFetchingPaymentConnector || isPending) && (
                <WaitingComponent {...{ message: resources.loadingMessage }} />
            ),
            alert: hasError && errorMessage && <ErrorComponent {...{ title: resources.errorMessageTitle, message: errorMessage }} />,
            paymentInformation: isReady && !isPaymentVerificationRequried && !isPaymentProcessing && (
                <PaymentInformationComponent
                    tokenizedPaymentCard={tokenizedPaymentCard}
                    tenderLine={tenderLine}
                    billingAddress={showBillingAddress ? billingAddress : undefined}
                    canEdit={!hasExternalSubmitGroup}
                    onEdit={this.onEdit}
                    resources={resources}
                />
            ),
            addPaymentForm: (!isReady || isPaymentVerificationRequried) && !isPaymentProcessing && (AcceptPageUrl || AcceptPageContent) && isVisible && (
                <AddPaymentFormComponent
                    acceptPageUrl={AcceptPageUrl}
                    acceptPageContent={AcceptPageContent}
                    messageOrigin={MessageOrigin}
                    onSubmit={this.onSubmit}
                    onCancel={this.onCancel}
                    onIFrameMessage={this.onIFrameMessage}
                    iframeRef={this.iframeRef}
                    canSubmit={!hasExternalSubmitGroup}
                    canCancel={!hasExternalSubmitGroup && this.hasSelectedItem}
                    iFrameHeightOverride={iFrameHeightOverride || paymentConnectorHeight}
                    requestUrlOrigin={this.requestUrlOrigin}
                    isFetchingPaymentConnector={isFetchingPaymentConnector}
                    paymentStyleOverride={paymentStyleOverride}
                    resources={resources}
                />
            ),
            overlayModal: {
                modal: {
                    tag: Modal,
                    className: `${this.moduleClassName}__overlay-modal`,
                    isOpen: isOverlayModal
                }
            }
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private onIFrameMessage = async (event: MessageEvent): Promise<void> => {
        let result;
        try {
            if (typeof event.data !== 'string') {
                return;
            }
            result = JSON.parse(event.data);
        } catch (error) {
            this.setTerminalError(error);
            return;
        }

        const paymentConnectorId = this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId;
        if (!result || !result.type || result.id !== paymentConnectorId) {
            return;
        }

        const { type, value } = result;

        switch (type) {
            case PaymentConnectorPostMessageType.Height:
                // The payment connector will post height after it completes initialization
                this.setState({
                    isFetchingPaymentConnector: false,
                    paymentConnectorHeight: value
                });
                return;
            case PaymentConnectorPostMessageType.Result:
                this.handlePaymentResult(value);
                return;
            case PaymentConnectorPostMessageType.CardPrefix:
                await this.handlePaymentCardPrefix(value);
                return;
            case PaymentConnectorPostMessageType.Error:
                this.handlePaymentError(value);
                return;
            case PaymentConnectorPostMessageType.Redirect:
                this.handlePaymentRedirect(value);
                return;
            case PaymentConnectorPostMessageType.Showoverlay:
                this.showOverlayModal(true);
                return;
            case PaymentConnectorPostMessageType.Hideoverlay:
                this.showOverlayModal(false);
                return;
            default:
                // Do nothing
                return;
        }
    };

    @action
    private handlePaymentResult = (resultAccessCode: string, isRedirectedFromPaymentGateway: boolean = false): void => {
        const {
            data: {
                checkout,
                cardPaymentAcceptPoint
            },
            config: {
                paymenTenderType
            }
        } = this.props;

        const cartId = checkout.result?.checkoutCart.cart.Id || '';
        const paymentConnectorId = cardPaymentAcceptPoint.result?.PaymentConnectorId;

        const settings = {
            ReturnUrl: this.getReturnUrl(),
            ...(paymentConnectorId && { PaymentConnectorId: paymentConnectorId }),
        };

        retrieveCardPaymentAcceptResultAsync({ callerContext: this.props.context.actionContext }, resultAccessCode, [], cartId, settings)
            .then(async cardPaymentAcceptResult => {
                // tslint:disable-next-line:no-shadowed-variable
                const { TenderLine, TokenizedPaymentCard, AdditionalContext } = cardPaymentAcceptResult || {};

                await this.saveBillingAddress(TokenizedPaymentCard);

                if (AdditionalContext) {
                    this.handleAdditionalContext(AdditionalContext);
                } else {
                    if (!TokenizedPaymentCard) {
                        this.setTerminalError(new Error('No TokenizedPaymentCard found'));
                        return;
                    }
                    const checkoutState = this.props.data.checkout.result;
                    if (checkoutState) {
                        // Try to update card prefix, if it is not set already.
                        // Adyen connector does not send msax-cc-cardprefix message
                        // but it sets the card prefix in tokenized card
                        if (!checkoutState.cardPrefix) {
                            const cardPrefix =
                                TokenizedPaymentCard &&
                                TokenizedPaymentCard.CardTokenInfo &&
                                TokenizedPaymentCard.CardTokenInfo.MaskedCardNumber;
                            if (cardPrefix) {
                                await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
                            }
                        }

                        if (!TokenizedPaymentCard.CardTypeId) {
                            const cardTypeId = await this.getCardTypeId(checkoutState.cardPrefix || '');
                            if (!cardTypeId) {
                                const error = new Error('The specified card type is not supported.');
                                error.name = 'CARDTYPENOTFOUND';
                                this.setTerminalError(error);
                                return;
                            }

                            TokenizedPaymentCard.CardTypeId = cardTypeId;
                        }

                        await checkoutState.updateTenderLine({ newTenderLine: TenderLine });
                        await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: TokenizedPaymentCard });
                        await checkoutState.updatePaymentTenderType({ newPaymentTenderType: paymenTenderType });

                        // In case of PSD2 redirect, cart we be updated in server side so refresh cart.
                        if (isRedirectedFromPaymentGateway) {
                            this.props.data.checkout.result?.checkoutCart.refreshCart({});
                        }

                        this.props.moduleState.setHasError(false);
                        this.props.moduleState.onReady();
                        this.setState({
                            terminalError: null,
                            errorMessage: null
                        });
                        this.props.moduleState.setIsSubmitContainer(true);
                    }
                }
            })
            .catch(error => {
                // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
                // tslint:disable-next-line:no-floating-promises
                this.updatePaymentAcceptPageData();
                this.setTerminalError(error);
                return;
            })
            .finally(() => {
                this.setState({
                    isPaymentProcessing: false
                });
            });
    };

    @action
    private handlePaymentCardPrefix = async (cardPrefix: string): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;
        if (checkoutState) {
            await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
        }
    };

    @action
    private handlePaymentRedirect = (redirectData: string): void => {
        this.setState({
            isPaymentVerificationRequried: true,
            paymentVerificationPostData: redirectData
        });
        this.props.moduleState.setHasError(false);
        this.props.moduleState.onReady();
    };

    private showOverlayModal = (isShow: boolean): void => {
        this.setState({ isOverlayModal: isShow });
    };

    private getCardTypeId = async (cardPrefix: string = ''): Promise<string | undefined> => {
        try {
            const response = await resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, cardPrefix, CardType.Unknown);
            if (response && response.length > 0) {
                return response[0].TypeId;
            }
        } catch (error) {
            this.props.context.telemetry.error('Call to resolveCardTypesAsync failed.', error);
        }
        return undefined;
    };

    private redirectToPaymentVerification = async (): Promise<void> => {
        const { isPaymentVerificationRequried, paymentVerificationPostData } = this.state;
        if (!isPaymentVerificationRequried || !paymentVerificationPostData) {
            return;
        }

        const checkoutState = this.props.data.checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: this.props.config.paymenTenderType });
            await checkoutState.saveDataInStorage({});
        }

        const redirectInfo = JSON.parse(paymentVerificationPostData);
        const { url, data } = redirectInfo;
        const form = document.createElement('form');

        form.method = 'POST';
        form.action = url;

        for (const propertyName of Object.keys(data)) {
            const element = document.createElement('input');
            element.name = propertyName;
            element.value = data[propertyName];
            form.appendChild(element);
        }

        document.body.appendChild(form);
        form.submit();
    };

    private handlePaymentError = (value?: { Message: string }[]): void => {
        const {
            resources: { defaultSubmitErrorMessage = 'An error occurred in payment method details. Please try again.' }
        } = this.props;
        if (!value || value.length === 0) {
            // Fallback, if no message could be translated from payement accept page response
            this.setErrorMessage(defaultSubmitErrorMessage);
            return;
        }
        this.setErrorMessage(value.map((_value: { Message: string }) => _value.Message).join('\n'));
    };

    private getReturnUrl = (): string => {
        let returnUrl = getUrlSync('checkout', this.props.context.actionContext) || '';

        const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
        const isAbsoluteUrl = absoluteUrlRegExp.test(returnUrl);
        if (window && !isAbsoluteUrl) {
            returnUrl = `${window.location.origin}${returnUrl}`;
        }

        return `${returnUrl}${returnUrl.indexOf('?') === -1 ? '?' : '&'}pv=1`;
    }

    @action
    private init = (): void => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            onContainerReady: this.onContainerReady,
            isCancellable: false,
            status: this.shouldPaidByCard ? 'updating' : 'disabled'
        });

        const {
            data: {
                checkout
            },
            config
        } = this.props;

        if (this.isPaymentVerificationRedirection) {
            if (config.paymenTenderType === checkout.result?.paymentTenderType) {
                const { requestFormData } = this.props.context.request;

                const formData = btoa(JSON.stringify(requestFormData));

                this.setState({
                    isPaymentProcessing: true
                });

                this.props.moduleState.onPending();
                this.handlePaymentResult(formData, true);
            } else {
                this.props.moduleState.onSkip();
            }
        } else {
            if (this.asyncResultStatus === 'FAILED') {
                this.setState({
                    isFetchingPaymentConnector: false
                });
                this.setTerminalError(new Error('Failed in load data'));
            }
        }
    }

    @action
    private setTerminalError = (terminalError: Error): void => {
        this.props.telemetry.exception(terminalError);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        const {
            resources: { genericErrorMessage, cardTypeErrorMessage }
        } = this.props;
        let errorMessage = genericErrorMessage;

        switch (terminalError.name) {
            case 'CARDTYPENOTFOUND': {
                errorMessage = cardTypeErrorMessage;
                break;
            }
            default:
        }

        this.setState({
            terminalError,
            errorMessage: errorMessage
        });
    };

    @action
    private setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };

    private updatePaymentAcceptPageData = async (): Promise<void> => {
        const {
            context: { actionContext },
            config: { showBillingAddress, paymenTenderType },
            context: { request: { apiSettings } },
            data: { checkout }
        } = this.props;

        const input = {
            showBillingAddress: showBillingAddress,
            paymenTenderType: paymenTenderType,
            apiSettings: apiSettings
        };

        this.setState({
            isFetchingPaymentConnector: true
        });

        const checkoutState = checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: undefined });
            await checkoutState.updateTenderLine({ newTenderLine: undefined });
            await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: undefined });
        }

        getCardPaymentAcceptPointAction(new GetCardPaymentAcceptPointInput(input), actionContext)
            .then(paymentAcceptPoint => {
                // In case, add form is not hidden. We need to explicty reset value to force re-rendering.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });

                // IMPORTANT: Do NOT set isFetchingPaymentConnector = false in getCardPaymentAcceptPointAction success response.
                // The payment connector will post a message with content height when payment is ready.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), paymentAcceptPoint);
                this.setState({ paymentConnectorId: paymentAcceptPoint.PaymentConnectorId });
            })
            .catch((error: Error) => {
                this.setTerminalError(error);

                this.setState({
                    isFetchingPaymentConnector: false
                });
                // IMPORTANT: Clear the AcceptPageUrl and AcceptPageContent. It should not re-use the previous session for the security reason.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });
            });
    };

    private postMessageToIframe = (message: object) => {
        const postMessage = get(this.iframeRef, 'current.postMessage');
        if (postMessage) {
            this.props.moduleState.onPending();
            postMessage(message);
        }
    }

    private handleAdditionalContext = (additionalContext: string): void => {
        const message = paymentConnectorExtraContextMessage(additionalContext);
        this.postMessageToIframe(message);
    };

    private saveBillingAddress = async (tokenizedPaymentCard?: TokenizedPaymentCard): Promise<void> => {
        const { showBillingAddress } = this.props.config;
        const checkoutState = this.props.data.checkout.result;
        // If we use billing address provided by adyen, billing address returned in TokenizedPaymentCard.
        if (checkoutState && showBillingAddress && tokenizedPaymentCard && tokenizedPaymentCard.Zip) {
            const billingAddress: Address = {
                ThreeLetterISORegionName: tokenizedPaymentCard.Country,
                Name: tokenizedPaymentCard.House === 'N/A' ? '' : tokenizedPaymentCard.House,
                Street: tokenizedPaymentCard.Address1,
                StreetNumber: tokenizedPaymentCard.Address2,
                City: tokenizedPaymentCard.City,
                State: tokenizedPaymentCard.State,
                ZipCode: tokenizedPaymentCard.Zip,
                Phone: tokenizedPaymentCard.Phone
            };
            await checkoutState.updateBillingAddress({ newBillingAddress: billingAddress });
        }
    };

    @action
    private togglePayment = () => {
        if (this.shouldPaidByCard && this.props.moduleState.isDisabled) {
            this.props.moduleState.onUpdating();
        } else if (!this.shouldPaidByCard && !this.props.moduleState.isDisabled) {
            this.props.moduleState.setHasError(false);
            this.props.moduleState.onDisable();
        }
    };

    @action
    private onSubmit = (): void => {
        const { isPrimaryPayment = true } = this.props.config;
        if (isPrimaryPayment) {
            this.postMessageToIframe(paymentConnectorSubmitMessage());
        } else {
            this.props.moduleState.onSkip();
        }
    };

    @action
    private onCancel = (): void => {
        if (this.hasSelectedItem) {
            this.props.moduleState.onReady();
        } else {
            this.props.moduleState.onUpdating();
        }
    };

    @action
    private onEdit = (): void => {
        this.props.moduleState.onUpdating();
        // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
        // tslint:disable-next-line:no-floating-promises
        this.updatePaymentAcceptPageData();
    };

    @action
    private onContainerReady = (): void => {
        // tslint:disable-next-line:no-floating-promises
        this.redirectToPaymentVerification();
        this.props.moduleState.setIsSubmitContainer(false);
    }
}

export default withVisibilityObserver(CheckoutPaymentInstrument);
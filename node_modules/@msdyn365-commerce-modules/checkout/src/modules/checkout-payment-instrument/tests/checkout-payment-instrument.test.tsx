/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import { updateModuleStates } from '@msdyn365-commerce-modules/checkout-utilities';
import { buildHydratedMockActionContext, buildMockModuleProps, IActionContext, ICoreContext, ICultureInfoFormatter, IRequestContext, ITelemetry } from '@msdyn365-commerce/core';
import { ICheckoutState } from '@msdyn365-commerce/global-state';
import { AsyncResult, CardPaymentAcceptPoint, CartLine } from '@msdyn365-commerce/retail-proxy';
import * as cartsDataActions from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { mount, shallow } from 'enzyme';
// tslint:disable-next-line:no-unused-variable
import * as React from 'react';
import { CheckoutPaymentInstrument, ICheckoutPaymentInstrumentModuleProps } from '../checkout-payment-instrument';
import { ICheckoutPaymentInstrumentData } from '../checkout-payment-instrument.data';
import { ICheckoutPaymentInstrumentConfig } from '../checkout-payment-instrument.props.autogenerated';
import View from '../checkout-payment-instrument.view';
import { mockResources, testPaymentAcceptPageContent, testTenderLine, testTokenizedPaymentCard } from './__mock__';

jest.mock('@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g');

const mockConfig: ICheckoutPaymentInstrumentConfig = {};
const mockActions = {};
let mockData: ICheckoutPaymentInstrumentData;
let mockContext: ICoreContext;
let actionContext: IActionContext;

describe('CheckoutPaymentInstrument', () => {
    beforeEach(() => {
        actionContext = buildHydratedMockActionContext();
        // The following context is not saved in a global variable cause weirdly if that's done it would cause waitForDomChange to timeout
        mockContext = {
            actionContext,
            // @ts-ignore: we only need to mock the actionContext, ignore the rest required fields
            app: {},
            telemetry: {} as ITelemetry,
            request: {
                url: {
                    staticCdnUrl: 'testOriginUrl'
                },
                channel: {
                    PickupDeliveryModeCode: '60'
                }
            } as IRequestContext,
            cultureFormatter: {} as ICultureInfoFormatter
        };

        // @ts-ignore: Jest Mocking Confuses TS Complier
        cartsDataActions.getCardPaymentAcceptPointAsync.mockImplementation(() => {
            return Promise.resolve({
                AcceptPageUrl: '',
                AcceptPageContent: testPaymentAcceptPageContent
            });
        });

        // @ts-ignore: Jest Mocking Confuses TS Complier
        cartsDataActions.retrieveCardPaymentAcceptResultAsync.mockImplementation(() => {
            return Promise.resolve({ TenderLine: testTenderLine, TokenizedPaymentCard: testTokenizedPaymentCard });
        });

        // @ts-ignore:
        window.MutationObserver = undefined;
    });

    it('shows error', async () => {
        mockData = {
            checkout: {
                status: 'SUCCESS',
                result: {
                    checkoutCart: {
                        cart: {
                            Id: 'edRKhnNDLp1pAvVeH1yNvaRwI7BARzoW',
                            TotalAmount: 100,
                            CartLines: [
                                {
                                    DeliveryMode: '60'
                                }
                            ] as CartLine[]
                        }
                    }
                }
            } as AsyncResult<ICheckoutState>,
            cardPaymentAcceptPoint: {
                status: 'SUCCESS',
                result: {
                    AcceptPageUrl: '',
                    AcceptPageContent: testPaymentAcceptPageContent
                }
            } as AsyncResult<CardPaymentAcceptPoint>
        };

        const mockModuleStates = {
            test_id: {
                id: 'test_id',
                hasInitialized: true,
                hasError: true,
                status: 'updating'
            }
        };
        // @ts-ignore: Using partial for testing
        updateModuleStates(mockModuleStates, actionContext);

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutPaymentInstrumentModuleProps),
            visibilityObserver: { isVisible: true },
            resources: mockResources,
            renderView: View
        };
        moduleProps.id = 'test_id';
        // @ts-ignore
        const component = mount(shallow(<CheckoutPaymentInstrument {...moduleProps} />).get(0));
        component.setState({
            isVisible: true,
            isFetchingPaymentConnector: false,
            errorMessage: 'Error Message'
        });
        return Promise.resolve(component).then(() => {
            expect(component.render()).toMatchSnapshot();
            component.unmount();
        });
    });

    it('shows add PI form', async () => {
        mockData = {
            checkout: {
                status: 'SUCCESS',
                result: {
                    checkoutCart: {
                        cart: {
                            Id: 'edRKhnNDLp1pAvVeH1yNvaRwI7BARzoW',
                            TotalAmount: 100,
                            CartLines: [
                                {
                                    DeliveryMode: '60'
                                }
                            ] as CartLine[]
                        }
                    }
                }
            } as AsyncResult<ICheckoutState>,
            cardPaymentAcceptPoint: {
                status: 'SUCCESS',
                result: {
                    AcceptPageUrl: '',
                    AcceptPageContent: testPaymentAcceptPageContent
                }
            } as AsyncResult<CardPaymentAcceptPoint>
        };

        const mockModuleStates = {
            test_id: {
                id: 'test_id',
                hasInitialized: true,
                status: 'updating'
            }
        };
        // @ts-ignore: Using partial for testing
        updateModuleStates(mockModuleStates, actionContext);

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutPaymentInstrumentModuleProps),
            visibilityObserver: { isVisible: true },
            resources: mockResources,
            renderView: View
        };
        moduleProps.id = 'test_id';
        // @ts-ignore
        const component = mount(shallow(<CheckoutPaymentInstrument {...moduleProps} />).get(0));
        component.setState({
            isVisible: true,
            isFetchingPaymentConnector: false,
            acceptPageContent: testPaymentAcceptPageContent
        });
        return Promise.resolve(component).then(() => {
            expect(component.render()).toMatchSnapshot();
            component.unmount();
        });
    });

    it('shows PI information', async () => {
        mockData = {
            checkout: {
                status: 'SUCCESS',
                result: {
                    checkoutCart: {
                        cart: {
                            Id: 'edRKhnNDLp1pAvVeH1yNvaRwI7BARzoW',
                            TotalAmount: 100,
                            CartLines: [
                                {
                                    DeliveryMode: '60'
                                }
                            ] as CartLine[]
                        }
                    },
                    tokenizedPaymentCard: testTokenizedPaymentCard,
                    tenderLine: testTenderLine
                }
            } as AsyncResult<ICheckoutState>,
            cardPaymentAcceptPoint: {
                status: 'SUCCESS',
                result: {
                    AcceptPageUrl: '',
                    AcceptPageContent: testPaymentAcceptPageContent
                }
            } as AsyncResult<CardPaymentAcceptPoint>
        };

        const mockModuleStates = {
            test_id: {
                id: 'test_id',
                hasInitialized: true,
                status: 'ready'
            }
        };

        // @ts-ignore: Using partial for testing
        updateModuleStates(mockModuleStates, actionContext);

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, mockContext) as ICheckoutPaymentInstrumentModuleProps),
            visibilityObserver: { isVisible: true },
            resources: mockResources,
            renderView: View
        };
        moduleProps.id = 'test_id';
        // @ts-ignore
        const component = mount(shallow(<CheckoutPaymentInstrument {...moduleProps} />).get(0));
        component.setState({
            isFetchingPaymentConnector: false
        });

        return Promise.resolve(component).then(() => {
            expect(component.render()).toMatchSnapshot();
            component.unmount();
        });
    });

    it('will not init without cart', () => {
        mockData = {
            checkout: {
                status: 'SUCCESS',
                result: {
                    checkoutCart: {
                        cart: {}
                    }
                }
            } as AsyncResult<ICheckoutState>,
            cardPaymentAcceptPoint: {
                status: 'SUCCESS',
                result: {
                    AcceptPageUrl: '',
                    AcceptPageContent: testPaymentAcceptPageContent
                }
            } as AsyncResult<CardPaymentAcceptPoint>
        };

        const contextWithoutChannel = mockContext;
        // @ts-ignore partial mock
        contextWithoutChannel.request.channel = {};

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, contextWithoutChannel) as ICheckoutPaymentInstrumentModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = mount(shallow(<CheckoutPaymentInstrument {...moduleProps} />).get(0));
        return Promise.resolve(component).then(() => {
            expect(cartsDataActions.getCardPaymentAcceptPointAsync).not.toBeCalled();
            component.unmount();
        });
    });

    it('will not init when cart TotalAmount is 0', () => {
        mockData = {
            checkout: {
                status: 'SUCCESS',
                result: {
                    checkoutCart: {
                        cart: {
                            Id: 'edRKhnNDLp1pAvVeH1yNvaRwI7BARzoW',
                            TotalAmount: 0,
                            CartLines: [] as CartLine[]
                        }
                    }
                }
            } as AsyncResult<ICheckoutState>,
            cardPaymentAcceptPoint: {
                status: 'SUCCESS',
                result: {
                    AcceptPageUrl: '',
                    AcceptPageContent: testPaymentAcceptPageContent
                }
            } as AsyncResult<CardPaymentAcceptPoint>
        };

        const contextWithoutChannel = mockContext;
        // @ts-ignore partial mock
        contextWithoutChannel.request.channel = {};

        const moduleProps = {
            ...(buildMockModuleProps(mockData, mockActions, mockConfig, contextWithoutChannel) as ICheckoutPaymentInstrumentModuleProps),
            resources: mockResources,
            renderView: View
        };
        // @ts-ignore
        const component = mount(shallow(<CheckoutPaymentInstrument {...moduleProps} />).get(0));
        return Promise.resolve(component).then(() => {
            expect(cartsDataActions.getCardPaymentAcceptPointAsync).not.toBeCalled();
            component.unmount();
        });
    });

    afterEach(() => {
        // @ts-ignore: Jest Mocking Confuses TS Complier
        cartsDataActions.getCardPaymentAcceptPointAsync.mockReset();

        // @ts-ignore: Jest Mocking Confuses TS Complier
        cartsDataActions.retrieveCardPaymentAcceptResultAsync.mockReset();
    });

    afterAll(() => {
        jest.unmock('../checkout-payment-instrument.action.ts');
        jest.unmock('@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g');
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ //
import { IModuleStateManager, IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { getAvailabilitiesForCartLineItems, ProductAvailabilitiesForCartLineItems } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, TelemetryConstant, Waiting } from '@msdyn365-commerce-modules/utilities';
import * as Msdyn365 from '@msdyn365-commerce/core';
import { Cart } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import get from 'lodash/get';
import isEmpty from 'lodash/isEmpty';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { ICheckoutData } from './checkout.data';
import { ICheckoutHeadingData, ICheckoutProps } from './checkout.props.autogenerated';
import AlertComponent from './components/alert';
import { getLineItems, ILineItems } from './components/get-line-items';
import { getOrderSummary, IOrderSummary } from './components/get-order-summary';
import GuidedFormComponent from './components/guided-form';
import PlaceOrderButtonComponent from './components/place-order-button';
import placeOrder from './methods/place-order';

export * from './components/get-line-items';
export * from './components/get-order-summary';

type DeviceType = 'Mobile';

interface ICheckoutState {
    errorMessage: string;
}

export interface ICheckoutViewProps extends ICheckoutProps<ICheckoutData> {
    className: string;
    canShow?: boolean;
    isEmptyCart?: boolean;
    isConsentGiven?: boolean;
    hasError?: boolean;
    cartStatus?: string;
    isMobile?: boolean;
    isEditorialMode?: boolean;
    backToShoppingUrl?: string;
    editCartLink?: string;
    hasSalesOrder: boolean;

    checkoutProps: IModuleProps;
    headerProps: INodeProps;
    bodyProps: INodeProps;
    mainProps: INodeProps;
    mainControlProps: INodeProps;
    sideProps: INodeProps;
    sideControlFirstProps: INodeProps;
    sideControlSecondProps: INodeProps;
    termsAndConditionsProps: INodeProps;

    guidedForm?: React.ReactNode;
    title?: React.ReactNode;
    loading?: React.ReactNode;
    alert?: React.ReactNode;
    orderSummary?: IOrderSummary;
    lineItems?: ILineItems;
    placeOrderButton?: React.ReactNode;
    termsAndConditions?: React.ReactNode;
    keepShoppingButton?: React.ReactNode;
    orderConfirmation?: React.ReactNode;
}

export interface ICheckoutModuleProps extends ICheckoutProps<ICheckoutData>, IModuleStateProps { }

/**
 *
 * CheckoutContainer component
 * @extends {React.Component<ICheckoutModuleProps>}
 */
// @ts-ignore
@withModuleState
@observer
class Checkout extends React.Component<ICheckoutModuleProps> {

    @computed get cartStatus(): Msdyn365.AsyncResultStatus {
        return get(this.props, 'data.checkout.status');
    }

    @computed get isEmptyCart(): boolean {
        if (this.isEditorialMode) {
            // Editorial mode: Ignore empty cart
            return false;
        }
        const cart = get(this.props, 'data.checkout.result.checkoutCart.cart');
        return this.cartStatus === 'SUCCESS' && !!cart && !isEmpty(cart) && (!cart.CartLines || cart.CartLines.length === 0);
    }

    @computed get hasError(): boolean {
        const cart = get(this.props, 'data.checkout.result.checkoutCart.cart');
        return this.cartStatus === 'FAILED' || (this.cartStatus === 'SUCCESS' && (!cart || isEmpty(cart)));
    }

    @computed get isEditorialMode(): boolean {
        return get(this.props, 'context.request.params.isEditor');
    }

    @computed get canPlaceOrder(): boolean {
        const isTermsAndConditionAccepted = this.props.data.checkout.result && this.props.data.checkout.result?.isTermsAndConditionAccepted;
        // if isTermsAndConditionAccepted is undefined means TermsAndCondition module is not added to page and we should able to place order.
        return this.props.moduleState.isReady && (isTermsAndConditionAccepted === undefined || isTermsAndConditionAccepted) && this.state.errorMessage === '';
    }
    public state: ICheckoutState = {
        errorMessage: ''
    };
    private telemetryContent: ITelemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
                                                                     this.props.friendlyName,
                                                                     this.props.telemetry);

    public componentDidMount(): void {
        const {
            resources: { genericErrorMessage }
        } = this.props;
        // @ts-ignore: Compiler not reconizing condition check for function params
        when(
            () => this.hasError,
            () => {
                this.setState({
                    errorMessage: genericErrorMessage
                });
                this.props.context.telemetry.error('Failed to get cart');
            }
        );

        // @ts-ignore: Compiler not reconizing condition check for function params
        when(
            () => {
                return this.isEmptyCart;
            },
            () => {
                const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';
                if (window && editCartLink) {
                    // Redirect to cart page if cart is empty
                    window.location.assign(editCartLink);
                } else {
                    this.setState({
                        errorMessage: genericErrorMessage
                    });
                    this.props.context.telemetry.error('Cart is empty, but no editCartLink found');
                }
            }
        );

        reaction(
            () => this.props.moduleState.isReady,
            () => {
                this.onContainerReady();
            }
        );
    }

    // tslint:disable-next-line:max-func-body-length cyclomatic-complexity
    public render(): JSX.Element {
        const {
            moduleState,
            config: { className, checkoutHeading, disableGuidedCheckoutFlow },
            resources
        } = this.props;
        const { errorMessage } = this.state;
        const { backToShopping, placeOrderText, cookieConsentRequiredMessage, genericErrorMessage } = resources;
        const checkoutClass = classnames('ms-checkout', className);
        const checkoutInformation = this.getSlotItems('checkoutInformation');

        const isConsentGiven =
            this.props.context.request &&
            this.props.context.request.cookies &&
            this.props.context.request.cookies.isConsentGiven &&
            this.props.context.request.cookies.isConsentGiven();

        const isMobile =
            this.props.context.request &&
            this.props.context.request.device &&
            (this.props.context.request.device.Type as DeviceType) === 'Mobile';

        const backToShoppingUrl = Msdyn365.getUrlSync('home', this.props.context.actionContext) || '';
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';

        const termsAndConditions =
            this.props.slots.termsAndConditions &&
            this.props.slots.termsAndConditions.length > 0 &&
            this.props.slots.termsAndConditions[0];

        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.BackToShopping);
        const backToShoppingAttributes =  getTelemetryAttributes(this.telemetryContent, payLoad);

        let viewProps: ICheckoutViewProps = {
            ...this.props,
            className: checkoutClass,
            isEmptyCart: this.isEmptyCart,
            isConsentGiven,
            hasError: this.hasError,
            hasSalesOrder: this.props.data.checkout && this.props.data.checkout.result !== undefined && this.props.data.checkout.result.salesOrder !== undefined,
            cartStatus: this.cartStatus,
            isMobile,
            backToShoppingUrl,
            editCartLink,
            isEditorialMode: this.isEditorialMode,
            orderConfirmation: this.props.slots.orderConfirmation && this.props.slots.orderConfirmation.length > 0 ? this.props.slots.orderConfirmation[0] : undefined,
            checkoutProps: { moduleProps: this.props, className: checkoutClass },
            headerProps: { className: 'ms-checkout__head' },
            bodyProps: { className: 'ms-checkout__body' },
            mainProps: { className: 'ms-checkout__main' },
            mainControlProps: { className: 'ms-checkout__main-control' },
            sideProps: { className: 'ms-checkout__side' },
            sideControlFirstProps: { className: 'ms-checkout__side-control-first' },
            sideControlSecondProps: { className: 'ms-checkout__side-control-second' },
            termsAndConditionsProps: { className: 'ms-checkout__terms-and-conditions' },
            title: checkoutHeading && (
                this.renderMsdyn365Text(checkoutHeading)
            )
        };

        if (isConsentGiven === false) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: cookieConsentRequiredMessage }} />
            };
        } else if (this.isLoading()) {
            viewProps = {
                ...viewProps,
                loading: <Waiting className='msc-waiting-circular msc-waiting-lg' />
            };
        } else if (this.hasError) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: genericErrorMessage }} />
            };
        } else {
            viewProps = {
                ...viewProps,
                alert: errorMessage && <AlertComponent {...{ message: errorMessage }} />,
                canShow: true,
                guidedForm: checkoutInformation ? (
                    <GuidedFormComponent
                        {...{
                            items: checkoutInformation,
                            moduleState: moduleState,
                            disableGuidedCheckoutFlow: disableGuidedCheckoutFlow,
                            resource: resources,
                            requestContext: this.props.context,
                            isMobile: isMobile,
                            isEditor: this.isEditorialMode,
                            telemetryContent: this.telemetryContent
                        }}
                    />
                ) : (
                        undefined
                    ),
                orderSummary: getOrderSummary(this.props),
                lineItems: getLineItems(this.props, this.telemetryContent),
                placeOrderButton: (
                    <PlaceOrderButtonComponent {...{ placeOrderText, placeOrder: this.onPlaceOrder, canPlaceOrder: this.canPlaceOrder, telemetryContent: this.telemetryContent }} />
                ),
                termsAndConditions: termsAndConditions,
                keepShoppingButton: backToShoppingUrl && (
                    <Button
                        className='ms-checkout__btn-keep-shopping msc-btn'
                        title={backToShopping}
                        color='secondary'
                        href={backToShoppingUrl}
                        {...backToShoppingAttributes}
                    >
                        {backToShopping}
                    </Button>
                )
            };
        }

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public renderMsdyn365Text(checkoutHeading: ICheckoutHeadingData): React.ReactNode {
        return (
            <Msdyn365.Text
                {...checkoutHeading}
                tag={checkoutHeading.tag || 'h2'}
                className='ms-checkout__title'
                text={checkoutHeading.text}
                editProps={{ onEdit: this.handleCheckoutHeadingChange, requestContext: this.props.context.request }}
            />
        );
    }

    public handleCheckoutHeadingChange = (event: Msdyn365.ContentEditableEvent) => this.props.config.checkoutHeading!.text = event.target.value;

    private isLoading = (): boolean => {
        return !this.cartStatus || this.cartStatus === 'LOADING' || this.isEmptyCart;
    }

    private getSlotItems = (key: string): React.ReactNode[] | undefined => {
        const { slots } = this.props;
        return slots && slots[key] && slots[key].length ? slots[key] : undefined;
    };

    private onPlaceOrder = async (): Promise<void> => {
         const {
            resources: { checkoutOutOfStockErrorMessage, genericErrorMessage },
            context: { actionContext, app: { config: { enableStockCheck = false } } },
            slots: { orderConfirmation },
            data: { checkout }
         } = this.props;

         if (enableStockCheck && await this.isOverMaxQuantity((await checkout).checkoutCart.cart)) {
            this.setState({
                errorMessage: checkoutOutOfStockErrorMessage
            });
            this.props.context.telemetry.error(checkoutOutOfStockErrorMessage);
        } else {
            const hasOrderConfirmation = orderConfirmation && orderConfirmation.length > 0;
            await placeOrder(actionContext, this.props.data.checkout.result, this.props.data.products.result, !hasOrderConfirmation).catch(error => {
                this.setState({
                    errorMessage: genericErrorMessage
                });
                this.props.telemetry.exception(error);
            });
        }
    };

    // return true if any product in the cart is over its max quantity
    private isOverMaxQuantity = async (cart: Cart): Promise<boolean> => {
        let isOverMaxQuantity = false;

        await getAvailabilitiesForCartLineItems(
            new ProductAvailabilitiesForCartLineItems(this.props.context.actionContext.requestContext.apiSettings),
            this.props.context.actionContext
        ).then(productInventoryInformation => {
            cart.CartLines?.map((cartline) => {
                if (productInventoryInformation && productInventoryInformation.length > 0) {
                    const foundProductAvailability = productInventoryInformation.find((productInventory) => {
                        return productInventory.ProductAvailableQuantity?.ProductId! === cartline.ProductId;
                    });

                    if (!(foundProductAvailability?.IsProductAvailable && foundProductAvailability.ProductAvailableQuantity.AvailableQuantity !== undefined
                        && cartline.Quantity && cartline.Quantity <= foundProductAvailability.ProductAvailableQuantity.AvailableQuantity)) {
                        isOverMaxQuantity = true;
                    }
                }
            });
        })
        .catch(error => {
            this.props.context.actionContext.telemetry.exception(error);
            throw new Error('[getAvailabilitiesForCartLineItems] Unable to get availabilities for products in checkout cart');
        });

        return isOverMaxQuantity;
    }

    private getActiveChildModuleStates = (): IModuleStateManager[] => {
        const { childIds, getModule } = this.props.moduleState;
        return childIds
            .map(getModule)
            .filter((state): state is IModuleStateManager => !!state && !state.isDisabled && state.hasModuleState);
    };

    private onContainerReady = (): void => {
        this.getActiveChildModuleStates().forEach(state => {
            state.isReady && state.onContainerReady && state.onContainerReady();
        });
    };
}

export default Checkout;

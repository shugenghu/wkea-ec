import { IActionContext } from '@msdyn365-commerce/core';
import { getCheckoutState } from '@msdyn365-commerce/global-state';
import { checkoutAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import {
    getTenderTypesAsync, resolveCardTypesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    Address, CardType, CartTenderLine, RetailOperation, SalesOrder, TenderType, TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';

export const OPERATIONS = {
    PayCard: 201,
    PayGiftCertificate: 214,
    PayLoyalty: 207,
    PayCustomerAccount: 202
};

const getCardTypeId = async (ctx: IActionContext, cardPrefix: string = ''): Promise<string | undefined> => {
    try {
        const response = await resolveCardTypesAsync({ callerContext: ctx }, cardPrefix, CardType.Unknown);
        if (response && response.length > 0) {
            return response[0].TypeId;
        }
    } catch (error) {
        ctx.telemetry.error('Call to resolveCardTypesAsync failed.', error);
    }
    return undefined;
};

const findTenderIdTypeByOperationId = (tenderTypes: TenderType[], operationId: RetailOperation): string | undefined => {
    const matchedTenderType = tenderTypes.find(tenderType => tenderType.OperationId === operationId);
    if (matchedTenderType) {
        return matchedTenderType.TenderTypeId;
    }
    return;
};

const roundNumber = (value: number) => Number(value.toFixed(2));

async function getLoyaltyTenderLine(
    ctx: IActionContext,
    LoyaltyCardId: string,
    Amount: number = 0,
    Currency: string = 'USD'
): Promise<CartTenderLine> {
    const tenderTypes = await getTenderTypesAsync({ callerContext: ctx, queryResultSettings: {} }).catch(error => {
        throw error;
    });

    if (!tenderTypes) {
        throw new Error('Fail to get gift card tender line');
    }

    const TenderTypeId = findTenderIdTypeByOperationId(tenderTypes, OPERATIONS.PayLoyalty);
    return {
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        'Amount@odata.type': '#Decimal',
        Currency,
        TenderTypeId,
        Amount,
        LoyaltyCardId
    };
}

async function getGiftCardTenderLine(
    ctx: IActionContext,
    GiftCardId: string = '',
    Amount: number = 0,
    Currency: string = 'USD',
    tenderTypeId?: string,
    giftCardPin?: string,
    giftCardExpirationYear?: number,
    giftCardExpirationMonth?: number
): Promise<CartTenderLine> {
    let TenderTypeId = tenderTypeId;

    if (!TenderTypeId) {
        const tenderTypes = await getTenderTypesAsync({ callerContext: ctx, queryResultSettings: {} }).catch(error => {
            throw error;
        });
        if (!tenderTypes) {
            throw new Error('Fail to get gift card tender line');
        }
        TenderTypeId = findTenderIdTypeByOperationId(tenderTypes, OPERATIONS.PayGiftCertificate);
    }

    const GiftCardPin = giftCardPin;
    const GiftCardExpirationYear = giftCardExpirationYear;
    const GiftCardExpirationMonth = giftCardExpirationMonth;
    return {
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        'Amount@odata.type': '#Decimal',
        Currency,
        TenderTypeId,
        Amount,
        GiftCardId,
        GiftCardPin,
        GiftCardExpirationYear,
        GiftCardExpirationMonth
    };
}

async function getCreditCardTenderLine(
    ctx: IActionContext,
    tokenizedPaymentCard: TokenizedPaymentCard,
    cardPrefix: string = '',
    Amount: number = 0,
    Currency: string = 'USD',
    billingAddress?: Address
): Promise<CartTenderLine> {
    const tenderTypes = await getTenderTypesAsync({ callerContext: ctx, queryResultSettings: {} }).catch(error => {
        throw error;
    });

    let cartTypeId = tokenizedPaymentCard.CardTypeId;

    if (!cartTypeId) {
        cartTypeId = await getCardTypeId(ctx, cardPrefix);
    }

    if (!tenderTypes) {
        throw new Error('Fail to get card tender type');
    }

    if (!cartTypeId) {
        throw new Error('Fail to get card type id');
    }

    const TenderTypeId = findTenderIdTypeByOperationId(tenderTypes, OPERATIONS.PayCard);
    const cardTenderLine: CartTenderLine = {
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        'Amount@odata.type': '#Decimal',
        Currency,
        Amount,
        TenderTypeId,
        CardTypeId: cartTypeId
    };
    cardTenderLine.TokenizedPaymentCard = {
        ...tokenizedPaymentCard,
        CardTypeId: cartTypeId,
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.TokenizedPaymentCard',
        House: tokenizedPaymentCard.House || 'N/A',
        ...(tokenizedPaymentCard.CardTokenInfo && {
            CardTokenInfo: {
                ...tokenizedPaymentCard.CardTokenInfo,
                // @ts-ignore
                // tslint:disable-next-line:prefer-type-cast
                '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CardTokenInfo'
            }
        }),
        ...(billingAddress && {
            Phone: billingAddress.Phone,
            Country: billingAddress.ThreeLetterISORegionName,
            Address1: billingAddress.Street,
            City: billingAddress.City,
            State: billingAddress.State,
            Zip: billingAddress.ZipCode
        })
    };

    return cardTenderLine;
}

async function createCustomerAccountTenderLine(
    ctx: IActionContext,
    Amount: number,
    Currency: string = 'USD',
): Promise<CartTenderLine> {
    const CustomerId = null;
    if (!ctx.requestContext.user.isAuthenticated) {
       ctx.telemetry.error('A customer id is required to pay with customer account');
    }

    const tenderTypes = await getTenderTypesAsync({ callerContext: ctx, queryResultSettings: {} }).catch(error => {
        throw error;
    });

    if (!tenderTypes) {
        ctx.telemetry.error('No tender types found for this channel');
    }

    const TenderTypeId = findTenderIdTypeByOperationId(tenderTypes, OPERATIONS.PayCustomerAccount);
    if (!TenderTypeId) {
        ctx.telemetry.error('No customer account tender type');
    }
    return {
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.CartTenderLine',
        // @ts-ignore
        // tslint:disable-next-line:prefer-type-cast
        'Amount@odata.type': '#Decimal',
        Currency,
        TenderTypeId,
        Amount,
        // @ts-ignore
        CustomerId
    };
}

// tslint:disable-next-line:max-func-body-length
export default async (ctx: IActionContext): Promise<SalesOrder> => {
    const checkoutState = await getCheckoutState(ctx).catch(error => {
        throw error;
    });

    const cartState = checkoutState.checkoutCart;

    const channelConfiguration = ctx.requestContext.channel;

    if (!cartState || !Object.keys(cartState).length || !checkoutState || !channelConfiguration) {
        throw new Error('Fail to placeOrder');
    }

    const {
        giftCardExtends,
        tokenizedPaymentCard,
        cardPrefix,
        guestCheckoutEmail,
        billingAddress,
        loyaltyAmount
    } = checkoutState;
    const { Currency } = channelConfiguration;

    let amountDue = cartState.cart.AmountDue || 0;
    let cartTenderLines;
    const getTenderLinePromises = [];
    const loyaltyCardNumber = cartState.cart.LoyaltyCardId;

    // Pay by loyalty first
    if (loyaltyAmount && loyaltyCardNumber) {
        const chargedAmount = roundNumber(Math.min(loyaltyAmount, amountDue));
        const loyaltyTenderLinePromise = getLoyaltyTenderLine(ctx, loyaltyCardNumber, chargedAmount, Currency);
        getTenderLinePromises.push(loyaltyTenderLinePromise);
        amountDue = roundNumber(amountDue - chargedAmount);
    }

    // Then by gift card
    if (giftCardExtends && giftCardExtends.length) {
        giftCardExtends.some(giftCardExtend => {
            if (giftCardExtend.Balance && amountDue > 0) {
                const chargedAmount = roundNumber(Math.min(giftCardExtend.Balance, amountDue));
                const tenderTypeId = giftCardExtend.TenderTypeId;
                const giftCardPin = giftCardExtend.Pin;
                const giftCardExpirationYear = giftCardExtend.ExpirationDate ? parseInt(giftCardExtend.ExpirationDate?.split('/')[1], 10) : undefined;
                const giftCardExpirationMonth = giftCardExtend.ExpirationDate ? parseInt(giftCardExtend.ExpirationDate?.split('/')[0], 10) : undefined;
                const creditCardTenderLinePromise = getGiftCardTenderLine(ctx, giftCardExtend.Id, chargedAmount, Currency, tenderTypeId, giftCardPin, giftCardExpirationYear, giftCardExpirationMonth);
                getTenderLinePromises.push(creditCardTenderLinePromise);
                amountDue = roundNumber(amountDue - chargedAmount);
            }
            return amountDue === 0;
        });
    }

    // Then by customer account
    if (checkoutState.customerAccountAmount > 0) {
            const chargedAmount = roundNumber(Math.min(checkoutState.customerAccountAmount, amountDue));
            const customerAccountTenderLinePromise = createCustomerAccountTenderLine(ctx, chargedAmount, Currency);
            getTenderLinePromises.push(customerAccountTenderLinePromise);
            amountDue = roundNumber(amountDue - chargedAmount);
    }

    // Pay the rest by credit card
    if (amountDue > 0) {
        if (!tokenizedPaymentCard) {
            throw new Error('Fail to placeOrder: no token found');
        }
        const creditCardTenderLinePromise = getCreditCardTenderLine(
            ctx,
            tokenizedPaymentCard,
            cardPrefix,
            amountDue,
            Currency,
            billingAddress
        );
        getTenderLinePromises.push(creditCardTenderLinePromise);
    }

    if (getTenderLinePromises.length > 0) {
        // When payment methods is required
        cartTenderLines = await Promise.all(getTenderLinePromises).catch(error => {
            throw error;
        });

        if (!cartTenderLines || !cartTenderLines.length) {
            throw new Error('Fail to placeOrder: fail to get cart tender lines');
        }
    }

    // Proceed checkout
    const salesOrder = await checkoutAsync(
        { callerContext: ctx, bypassCache: 'get' },
        cartState.cart.Id,
        guestCheckoutEmail,
        // @ts-ignore fields tokenizedPaymentCard and receiptNumberSequence are optional
        undefined,
        undefined,
        cartTenderLines || null,
        cartState.cart.Version
        // @ts-ignore
    ).catch(error => {
        throw error;
    });

    if (!salesOrder) {
        throw new Error('Fail to placeOrder: fail to checkout');
    }

    return salesOrder;
};

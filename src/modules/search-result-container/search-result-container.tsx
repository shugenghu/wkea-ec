/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/* tslint:disable: no-duplicate-imports */
import { getTelemetryObject, ILabeledDropdownOnChangeNotification, ILabeledDropdownOption, IModuleProps, INodeProps, ITelemetryContent, LabeledDropdown, UncontrolledPagination } from '@msdyn365-commerce-modules/utilities';
import { CategoryHierarchy as CategoryHierarchyData, IProductRefinerHierarchy } from '@msdyn365-commerce/commerce-entities';
import MsDyn365 from '@msdyn365-commerce/core';
import { format, ProductRefinerValue, SortColumn, TextValueTranslation } from '@msdyn365-commerce/retail-proxy';
import classnames from 'classnames';
import { computed, observable, reaction, transaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { buildListPageUrl, getCollectionProducts, getCurrentUrl, GetFullProductsByCollectionInput, parseQueryParam, sortOptions, } from './actions';
import { ErrorMessage, FeatureSearchResultItem, getUpdatedRefinementCriteria, IChoiceSummaryClickNotification,
     IRefineItemCommonProps, IRefineItemToggleNotification, ISearchResultModalViewProps, isMatchingRefinementCriterion, Link, ModalToggle, ProductSearchResultItems, SearchResultModal, Separator, Title } from './components';
import ChoiceSummary from './components/choice-summary';
import RefineSubmenu from './components/refine-submenu';
import { ISearchResultContainerData } from './search-result-container.data';
import { expandRefinersCount, ISearchResultContainerProps } from './search-result-container.props.autogenerated';

export interface ISearchResultContainerViewProps extends ISearchResultContainerProps<ISearchResultContainerData> {
    products?: React.ReactNode;
    className?: string;
    SearchResultContainer: IModuleProps;
    TitleViewProps: ITitleViewProps;
    categoryHierarchy: ICategoryHierarchyViewProps;
    pagination?: React.ReactNode;
    ProductsContainer: INodeProps;
    ProductSectionContainer: INodeProps;
    refineMenu: IRefineMenuViewProps;
    sortByOptions: ISortByViewProps;
    choiceSummary?: React.ReactNode;
    modalToggle: React.ReactNode;
    searchResultModal: ISearchResultModalViewProps;
    isMobile: boolean;
    CategoryNavContainer: INodeProps;
    RefineAndProductSectionContainer: INodeProps;
    errorMessage: React.ReactNode;
    FeatureSearchContainer: INodeProps;
    similarLookProduct?: React.ReactNode;
}

export interface ITitleViewProps {
    TitleContainer: INodeProps;
    title:ISearchResultTitle;
}

export interface IRefineMenuViewProps {
    RefineMenuContainer: INodeProps;
    RefinerSectionContainer: INodeProps;
    refiners?: React.ReactNode[];
}

export interface ICategoryHierarchyViewProps {
    categoryHierarchyList?: React.ReactNode[];
    categoryHierarchySeparator?: React.ReactNode;
    CategoryHierarchyContainer: INodeProps;
}

export interface ISortByViewProps {
    SortingContainer: INodeProps;
    sortByDropDown?:React.ReactNode;
}

export type GridSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

/**
 * Title component for search result container
 */
export interface ISearchResultTitle {
    titlePrefix?: React.ReactNode;
    titleText?: React.ReactNode;
    titleCount?: React.ReactNode;
}

export interface ISearchResultContainerState {
    sortingState: ISortByCollectionState;
    modalIsOpen: boolean;
}

interface ISortByCollectionState {
    selectedSortByOption: ILabeledDropdownOption;
    pending: boolean;
}

/**
 *
 * SearchResultContainer component
 * @extends {React.PureComponent<ISearchResultContainerProps<ISearchResultContainerData>>}
 */
@observer
export default class SearchResultContainer extends React.PureComponent<ISearchResultContainerProps<ISearchResultContainerData>, ISearchResultContainerState> {

    @computed get isMobile(): boolean {
        return (this._viewport === 'xs' || this._viewport === 'sm');
    }

    private sortByDropdownOptions: ILabeledDropdownOption[] = [
        { key: sortOptions.sortByOptionRelevanceDesc, value: this.props.resources.sortByOptionRelevanceDesc },
        { key: sortOptions.sortByOptionNameAsc, value: this.props.resources.sortByOptionNameAsc },
        { key: sortOptions.sortByOptionNameDesc, value: this.props.resources.sortByOptionNameDesc },
        { key: sortOptions.sortByOptionPriceAsc, value: this.props.resources.sortByOptionPriceAsc },
        { key: sortOptions.sortByOptionPriceDesc, value: this.props.resources.sortByOptionPriceDesc },
        { key: sortOptions.sortByOptionRatingDesc, value: this.props.resources.sortByOptionRatingDesc },
    ];
    private _refineItemCommonProps: IRefineItemCommonProps;
    private _pageType: string | undefined = this.props.context.request.urlTokens.pageType;
    @observable
    private _viewport: GridSize;

    private _modalToggleRef: React.RefObject<HTMLButtonElement>;
    private _sortAndFilterContainerRef: React.RefObject<LabeledDropdown>;
    private expandrefinerCount: number = 0;
    private telemetryContent: ITelemetryContent;

    public static getFriendlyName(locale: string, nameTranslations?: TextValueTranslation[]): string | undefined {
        let nameTranslation: TextValueTranslation | undefined;
        if (locale && nameTranslations && nameTranslations.length > 0) {
            nameTranslation = nameTranslations.find(item => item.Language!.toLowerCase() === locale.toLowerCase());
        }

        return nameTranslation && nameTranslation.Text;
    }

    constructor(props: ISearchResultContainerProps<ISearchResultContainerData>, state: ISearchResultContainerState) {
        super(props);
        this._viewport = props.context.request && props.context.request.device && props.context.request.device.Type === 'Mobile' ? 'xs' : 'lg';
        this._modalToggleRef = React.createRef<HTMLButtonElement>();
        this._sortAndFilterContainerRef = React.createRef<LabeledDropdown>();
        this._toggleModal = this._toggleModal.bind(this);
        this._updateViewport = this._updateViewport.bind(this);
        this.state = {
            sortingState: {
                pending: false,
                selectedSortByOption: this.sortByDropdownOptions[0]
            },
            modalIsOpen: false
        };
        const {
            placeholderTextMax,
            minLabel,
            maxLabel,
            rangeNameFormat
        } = this.props.resources;

        const locale = this.props.context.request.locale;
        const telemetry = this.props.telemetry;
        const validationErrorNaN = this.props.resources.validationErrorNotNumber;
        const validationErrorRange = this.props.resources.validationErrorNotRange;
        this._refineItemCommonProps = {
            telemetry,
            locale,
            placeholderTextMax,
            minLabel,
            maxLabel,
            rangeNameFormat,
            validationErrorNaN,
            validationErrorRange
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
                                                   this.props.friendlyName,
                                                   this.props.telemetry);

        // Initalization of list page
        this.props.data.products.then((products) => {
            this.props.data.listPageState.then((listPageState) => {
                if (this._pageType === 'Category') {
                    listPageState.pageType = 'Category';
                } else {
                    listPageState.pageType = 'Search';
                }

                let querySorting: SortColumn[] = [];

                if (this.props.context.request.query && this.props.context.request.query.sorting) {
                    querySorting = JSON.parse(decodeURIComponent(this.props.context.request.query.sorting)) as SortColumn[];
                }

                listPageState.currentPageNumber = this.props.context.request.query && (+this.props.context.request.query.skip / (this.props.config.itemsPerPage || 10)) || 0;
                listPageState.sortingCritera = { Columns: querySorting };
                listPageState.pageSize = this.props.config.itemsPerPage || 10;
                listPageState.activeProducts = products.products;
                listPageState.totalProductCount = products.count;

                // Initialize reaction based on listPageState properties
                reaction(
                    () => {
                        return [listPageState.activeFilters && listPageState.activeFilters.length, listPageState.currentPageNumber, listPageState.sortingCritera && listPageState.sortingCritera.Columns && listPageState.sortingCritera.Columns.length];
                    },
                    () => {
                        const input = new GetFullProductsByCollectionInput(
                            listPageState.pageType,
                            this.props.context.request.apiSettings,
                            { Paging: { Top: this.props.config.itemsPerPage, Skip: Math.max((listPageState.pageSize * (listPageState.currentPageNumber || 0)), 0) }, count: true, Sorting: listPageState.sortingCritera || {} },
                            listPageState.activeFilters || [],
                            +(this.props.context.request.urlTokens.itemId || 0),
                            this.props.context.request.query && this.props.context.request.query.q ? this.props.context.request.query.q : this.props.context.request.query?.productId,
                            this.props && this.props.config && this.props.config.includeAttributes !== undefined && this.props.config.includeAttributes === true ? true : false,
                            this.props.context.request.locale
                            );

                        getCollectionProducts(input, this.props.context.actionContext).then(productResults => {
                            listPageState.activeProducts = productResults.products;
                            listPageState.totalProductCount = productResults.count;
                        });
                    }
                );

            });
        });

        if (this.props.context.request.query?.productId) {
            this.props.data.featureProduct.then((products) => {
                this.props.data.listPageState.then((listPageStateFeature) => {
                    listPageStateFeature.featureProduct = products;

                });
            });
    }
        this._updateViewport();
    }

    public componentDidMount(): void {
        if (MsDyn365.isBrowser && window.addEventListener) {
            window.addEventListener('resize', this._updateViewport);
            this._updateViewport();
        }
    }

    public componentWillUnmount(): void {
        if (MsDyn365.isBrowser && window.removeEventListener) {
            window.removeEventListener('resize', this._updateViewport);
        }
    }

    public render(): JSX.Element {
        const { imageSettings, className, allowBackNavigation } = this.props.config;
        const { resources } = this.props;
        const products = (this.props.data.listPageState.result && this.props.data.listPageState.result.activeProducts) || [];
        const searchProduct = (this.props.data.listPageState.result && this.props.data.listPageState.result.featureProduct) || null;
        let errorText = '';
        const breaCrumbType = this.props.context.app.config.breadcrumbType;
        const allowBack = allowBackNavigation && (breaCrumbType === 'back' || breaCrumbType === 'categoryAndBack');
        if(!products || products.length === 0) {
            errorText = this._pageType === 'Category'? resources.resultCategoryNotFoundText : resources.resultSearchNotFoundText;

        }
        const productsComponent = (
            <ProductSearchResultItems
                products={products}
                context={this.props.context}
                imageSettings={imageSettings}
                resources={resources}
                moduleType={this.props.typeName}
                moduleId={this.props.id}
                allowBackNavigation = {allowBack}
                telemetryContent={this.telemetryContent}
            />
        );

        const featureComponent = (
            <FeatureSearchResultItem
                product={searchProduct}
                context={this.props.context}
                imageSettings={imageSettings}
                resources={resources}
                moduleType={this.props.typeName}
                moduleId={this.props.id}
                telemetryContent={this.telemetryContent}
            />
        );

        const searchResultContainerViewProps = {
            ...this.props,
            products: productsComponent,
            TitleViewProps: this._getCollectionTitle(),
            categoryHierarchy: !this.props.config.disableHierarchy && this._getCategoryHierarchy(),
            refineMenu: this._getRefineMenu(),
            className: classnames('ms-search-result-container', className),
            SearchResultContainer: {
                moduleProps: this.props,
                className: classnames('ms-search-result-container', className)
            },
            sortByOptions: this.props.data.listPageState.result && this.props.data.listPageState.result.totalProductCount !== 0 ? this._getSortingDropDown(): null,
            pagination: this._getPagination(),
            ProductsContainer: { className: 'ms-search-result-container__Products' },
            ProductSectionContainer: {className: 'ms-search-result-container__product-section'},
            CategoryNavContainer: {className: 'ms-search-result-container__category-nav-section'},
            RefineAndProductSectionContainer: {className: 'ms-search-result-container__refine-product-section'},
            choiceSummary: this._getChoiceSummary(),
            modalToggle: this.props.data.listPageState.result && this.props.data.listPageState.result.totalProductCount !== 0 ?
                (
                    <ModalToggle
                        text={resources.modalTitle}
                        ariaLabel={resources.modalTitle}
                        innerRef={this._modalToggleRef}
                        onClick={this._toggleModal}
                        id='search-result-modal'
                    />
                ) : null,
             searchResultModal: this._getSearchResultModal(),
             isMobile: this.isMobile,
             errorMessage: errorText && (
                 <ErrorMessage text={errorText} />
             ),
             FeatureSearchContainer: { className: 'ms-feature-search-result' },
             similarLookProduct: this.props.data.listPageState.result && (this.props.data.listPageState.result.featureProduct !== null && this.props.data.listPageState.result.featureProduct !== undefined) ? featureComponent : null
        };
        return this.props.renderView(searchResultContainerViewProps) as React.ReactElement;
    }

    private _getSearchResultModal = (): ISearchResultModalViewProps => {
        const {resources} = this.props;
        return SearchResultModal(
            {
           resources:{
               modalCloseButtonText: resources.modalCloseButtonText,
               modalTitle: resources.modalTitle
           },
           isOpen:this.state.modalIsOpen,
           returnRef: this._modalToggleRef,
           onModalToggle: this._toggleModal
        });
    }

    private _getCollectionTitle = (): ITitleViewProps => {
        const { data, context, resources } = this.props;

        let collectionTitle: string | undefined = '';
        if (context && context.request && context.request.query && context.request.query.q) {
            collectionTitle = `"${context.request.query.q}"`;
        } else {
            collectionTitle = (data.category.result && SearchResultContainer.getFriendlyName(context.request.locale, data.category.result.NameTranslations)) ||
                (data.category.result && data.category.result.Name);
        }
        let productCountText = '';
        let productCountNumber: number | undefined;
        if (data.listPageState && data.listPageState.result && data.listPageState.result.totalProductCount !== undefined) {
            productCountNumber = data.listPageState.result.totalProductCount;
        } else if (data.products && data.products.result) {
            productCountNumber = data.products.result.count;
        }

        if (productCountNumber && productCountNumber !== 0) {
            productCountText = productCountNumber !== 1 ? format(this.props.resources.numberOfProducts, productCountNumber) : this.props.resources.oneProduct;
        } else {
            productCountText = format(this.props.resources.numberOfProducts, 0);
        }
        const titlePrefix = <Title className='ms-search-result__collection-title-prefix' text={resources.searchTextPrefix} />;
        const titleText = collectionTitle && <Title className='ms-search-result__collection-title-text' text={collectionTitle} />;
        const titleCount = <Title className='ms-search-result__collection-title-count' text={productCountText} />;

        return {
            TitleContainer: { className: 'ms-search-result-container__title' },
            title:{
            titlePrefix: titlePrefix,
            titleText: titleText,
            titleCount: titleCount
            }
        };

    }
    private _getCategoryHierarchy = (): ICategoryHierarchyViewProps => {
        const { data } = this.props;
        const categoryHierarchy = data.categoryHierarchy.result;
        const categoryLinks =
            categoryHierarchy && categoryHierarchy.map((value: CategoryHierarchyData, index: number) => {

                return (
                    <Link
                        key={index}
                        text={value.Name}
                        ariaLabel={`${this.props.resources.categoryLinkAriaLabel} ${value.Name}`}
                        href={value.Url}
                    />
                );
            });
        const categoryLinkSeparator = <Separator separator='/' />;

        return {
            CategoryHierarchyContainer: { tag: 'nav', className: 'ms-search-result-container__category-hierarchy' },
            categoryHierarchyList: categoryLinks,
            categoryHierarchySeparator: categoryLinkSeparator
        };

    }

    private _getSortingDropDown = (): ISortByViewProps => {
        const { resources } = this.props;
        const activeDropdown = this._getCurrentlySelectedOption() || this.state.sortingState.selectedSortByOption;
        const dropdown = (
        <LabeledDropdown
            labelClassname='reviews-list-sort-by'
            labelText={resources.sortByDropdownLabel}
            dropdownId='categorySortByDropdown'
            dropdownClassname='reviews-list-dropdown'
            toggleColor='link'
            dropdownOptions={this.sortByDropdownOptions}
            selectedOption={activeDropdown}
            onSelectOption={this._updateSortByDropdown}
            ref={this._sortAndFilterContainerRef}
        />);
        return {
            SortingContainer: { className: 'ms-search-result-container__Sort-by-category' },
            sortByDropDown:dropdown
        };
    }

    private _getPagination = (): React.ReactNode => {
        const { config, context, data, resources } = this.props;
        const listPageState = data && data.listPageState && data.listPageState.result;
        const fullUrl = getCurrentUrl(context.request);
        const itemsPerPage = config.itemsPerPage || 10;
        const skipCount = listPageState && listPageState.currentPageNumber !== null ?
            (listPageState.currentPageNumber * (this.props.config.itemsPerPage || 10)) :
            ((this.props.context.request.query && +this.props.context.request.query.skip) || 0);
        const totalItems = listPageState && listPageState.totalProductCount || 0;
        const previousText = resources.flipperPrevious;
        const nextText = resources.flipperNext;
        if (totalItems <= itemsPerPage) {
            return null;
        }
        return (
        <UncontrolledPagination
            className='ms-search-result-container__pagination'
            role='navigation'
            aria-label={resources.paginationAriaLabel}
            url={fullUrl.href}
            qsp={'skip'}
            items={totalItems}
            itemsPerPage={itemsPerPage}
            startingItem={skipCount}
            previousText={<div className='msc-pagination__prev'><span className='ms-search-result__pagination-left' aria-hidden='true'/><span className='prev-text'>{previousText}</span></div>}
            nextText={<div className='msc-pagination__next'><span className='next-text'>{nextText}</span><span className='ms-search-result__pagination-right' aria-hidden='true'/></div>}
            previousAriaLabel={previousText}
            nextAriaLabel={nextText}
            telemetryContent={this.telemetryContent}
        />);
    }

    private _getRefineMenu = (): IRefineMenuViewProps => {
        const { data, context, config } = this.props;
        const tempRangeTypeTODO = context.request.query && context.request.query.inputRange ? 'input' : 'slider';
        const validRefiners = data.refiners.result && data.refiners.result.filter(refiner => {
            return refiner.Values.length > 0;
        });

        const activeRefiners = (data.listPageState.result && data.listPageState.result.activeFilters) || [];

        this._getexpandRefinerCount(config.expandRefinersCount);
        const refinelist = this.expandrefinerCount === undefined ? 0 :  this.expandrefinerCount;
        const expandedRefiners = refinelist === 0 ? validRefiners && validRefiners.length: refinelist;
        const subMenus = validRefiners && validRefiners.map((productRefinerHierarchy: IProductRefinerHierarchy, index: number) => {
            return (data.listPageState.result!.totalProductCount !== 0 ?
                (
                <RefineSubmenu
                    productRefinerHierarchy={productRefinerHierarchy}
                    selectedRefinerValues={activeRefiners}
                    refineItemCommonProps={this._refineItemCommonProps}
                    minValueSliderThumbAriaLabel={this.props.resources.minValueSliderThumbAriaLabel}
                    maxValueSliderThumbAriaLabel={this.props.resources.maxValueSliderThumbAriaLabel}
                    key={index}
                    onUpdateRefiners={this._onUpdateRefiners}
                    urlBuilder={this._buildRefinerUrl}
                    isDisabled={false}
                    isExpandedOnInitialLoad={expandedRefiners && expandedRefiners > index ? true : false}
                    tempRangeTypeTODO={tempRangeTypeTODO}
                    context = {context}
                    moduleId={this.props.id}
                    moduleTypeName={this.props.typeName}
                    telemetryContent={this.telemetryContent}
                />) : null
            );
        });

        return {
            RefineMenuContainer:{className: 'ms-search-result-container__refine-menu' },
            RefinerSectionContainer:{className: 'ms-search-result-container__refiner-section'},
            refiners: subMenus
        };

    }

    private _getChoiceSummary = (): React.ReactNode => {
        const { resources, data, telemetry } = this.props;
        const selectedRefiners = (data.listPageState.result && data.listPageState.result.activeFilters) || [];
        return (
            <ChoiceSummary
                classNames='ms-choice-summary-by-category'
                clearAllText={resources.clearAllText}
                label={resources.choiceSummaryLabel}
                selectedChoices={selectedRefiners}
                // @ts-ignore: NOTE Type-unsafe line below, null refinersByCategoryHierarchy case not handled
                refinerHierarchy={data.refiners.result}
                choiceFormat={resources.choiceFormat}
                choiceRangeValueFormat={resources.choiceRangeValueFormat}
                telemetry={telemetry}
                onChoiceClicked={this._onChoiceClicked}
                urlBuilder={this._buildRefinerUrlForChoiceSummary}
                choiceAriaLabel={resources.choiceAriaLabel}
                telemetryContent={this.telemetryContent}
            />
        );

    }

    private _updateSortByDropdown = (notification: ILabeledDropdownOnChangeNotification): void => {
        const { context } = this.props;
        const requestContext = context && context.request;
        const actionContext = context && context.actionContext;

        if (!requestContext || !actionContext || !this.props.data.listPageState.result) {
            const error = `[sort-by-category] cannot sort without context: ${!requestContext ? 'requestContext ' : ''} ${!actionContext ? 'actionContext ' : ''} could not be found`;
            this.props.telemetry.warning(error);
        }

        window.history.pushState({}, '', buildListPageUrl(getCurrentUrl(this.props.context.request), undefined, [this._getSortColumnFromSelectedOption(notification.selectedOption)], undefined));
        transaction(() => {
            this.props.data.listPageState.result!.currentPageNumber = 0;
            this.props.data.listPageState.result!.sortingCritera = { Columns: [this._getSortColumnFromSelectedOption(notification.selectedOption)] };
        });
    }

    private _getSortColumnFromSelectedOption = (option: ILabeledDropdownOption): SortColumn => {
        const { data } = this.props;

        if (!data.searchConfiguration.result) {
            return {};
        }

        const mappedConfiguration = data.searchConfiguration.result.find((searchConfiguration) => { return searchConfiguration.key === option.key; });

        if (mappedConfiguration) {
            return mappedConfiguration.sortColumn;
        }

        return {};
    }

    private _getCurrentlySelectedOption = (): ILabeledDropdownOption | undefined => {
        const { data } = this.props;
        const sortCriteria = data.listPageState.result && data.listPageState.result.sortingCritera;

        const activeSortColumn =
            (sortCriteria && sortCriteria.Columns && sortCriteria.Columns[0]) ||
            (parseQueryParam<SortColumn[]>('sorting', this.props.context.request) || [])[0];

        if (activeSortColumn && data.searchConfiguration.result) {
            const activeMappedConfig = data.searchConfiguration.result.find((mappedSearchConfig) => {
                return (mappedSearchConfig.sortColumn.ColumnName === activeSortColumn.ColumnName) &&
                    (mappedSearchConfig.sortColumn.IsDescending === activeSortColumn.IsDescending);
            });
            if (activeMappedConfig) {
                return this.sortByDropdownOptions.find((dropdownOption) => dropdownOption.key === activeMappedConfig.key);
            }
        }

        return;
    }

    private _onUpdateRefiners = (itemToggleNotification: IRefineItemToggleNotification): void => {
        const { context } = this.props;
        const requestContext = context && context.request;
        const actionContext = context && context.actionContext;

        if (!requestContext || !actionContext || !this.props.data.listPageState.result) {
            const error = `Refine menu cannot refine search criteria: ${!requestContext ? 'requestContext ' : ''} ${!actionContext ? 'actionContext ' : ''} could not be found`;
            this.props.telemetry.warning(error);
        }

        const updatedRefinementCriteria = getUpdatedRefinementCriteria(itemToggleNotification, this.props.data.listPageState.result && this.props.data.listPageState.result.activeFilters || []);

        window.history.pushState({}, '', buildListPageUrl(getCurrentUrl(this.props.context.request), updatedRefinementCriteria));
        transaction(() => {
            this.props.data.listPageState.result!.currentPageNumber = 0;
            this.props.data.listPageState.result!.activeFilters = updatedRefinementCriteria;
        });
    }

    private _buildRefinerUrl = (itemToggleNotification: IRefineItemToggleNotification): string => {
        if (this.props.data.listPageState.result) {
            const newRefinementCriteria = getUpdatedRefinementCriteria(itemToggleNotification, this.props.data.listPageState.result.activeFilters || []);

            return buildListPageUrl(getCurrentUrl(this.props.context.request), newRefinementCriteria);
        } else {
            this.props.telemetry.warning(`[buildRefinerQueryString]List Page State Not available, unable to build refiner URL`);
            return '';
        }
    }

    private _onChoiceClicked = (notification: IChoiceSummaryClickNotification): void => {
        const { data, telemetry } = this.props;

        if (!data.listPageState.result) {
            telemetry.warning('[choice-summary-by-category._onChoiceClicked]ListPageState unavailable, unable to update refiners.');
            return;
        }

        let currentRefinementCriteria = (data.listPageState.result && data.listPageState.result.activeFilters) || [];

        if (!notification.clearAll) {
            const selectedChoice = notification.choiceClicked;
            if (!selectedChoice) {
                telemetry.warning('[choice-summary-by-category._onChoiceClicked] Choice could not be determined');
                return;
            }
            currentRefinementCriteria = currentRefinementCriteria.filter(
                (selectedCriterion: ProductRefinerValue) => !isMatchingRefinementCriterion(selectedChoice, selectedCriterion)
            );
        } else {
            currentRefinementCriteria = [];

            // set focus to sort and filter
            const dropdownElementId = this._sortAndFilterContainerRef.current && this._sortAndFilterContainerRef.current.props.dropdownId;
            const dropdownElement = dropdownElementId && document.getElementById(dropdownElementId);
            setTimeout(() => {
                dropdownElement && dropdownElement.focus();
            },
                       50);
        }

        const fullUrl = getCurrentUrl(this.props.context.request);
        window.history.pushState({}, '', buildListPageUrl(fullUrl, currentRefinementCriteria));
        data.listPageState.result.currentPageNumber = 0;
        data.listPageState.result.activeFilters = currentRefinementCriteria;
    }

    private _buildRefinerUrlForChoiceSummary = (selectedRefiner: ProductRefinerValue, isClearAll: boolean): string => {
        const { data, telemetry } = this.props;
        const fullUrl = getCurrentUrl(this.props.context.request);

        if (!data.listPageState.result) {
            telemetry.warning('[choice-summary-by-category._buildRefinerUrl]ListPageState unavailable, unable to create refiner URL.');
            return fullUrl.href;
        }

        let currentRefinementCriteria = (data.listPageState.result && data.listPageState.result.activeFilters) || [];

        if (!isClearAll) {
            if (!selectedRefiner) {
                telemetry.warning('[choice-summary-by-category._buildRefinerUrl] URL for Choice could not be determined');
                return fullUrl.href;
            }
            currentRefinementCriteria = currentRefinementCriteria.filter(
                (selectedCriterion: ProductRefinerValue) => !isMatchingRefinementCriterion(selectedRefiner, selectedCriterion)
            );
        } else {
            currentRefinementCriteria = [];
        }

        return buildListPageUrl(fullUrl, currentRefinementCriteria);
    }

    private _getViewport(): GridSize {
        const { context } = this.props;

        // always render in mobile viewport on a mobile device
        if (context.request && context.request.device && context.request.device.Type === 'Mobile') {
            return 'xs';
        }

        if (MsDyn365.isBrowser && window.innerWidth) {
            const gridSettings = context.request.gridSettings;
            if (gridSettings) {
                if (gridSettings.xs && window.innerWidth <= gridSettings.xs.w) {
                    return 'xs';
                } else if (gridSettings.sm && window.innerWidth <= gridSettings.sm.w) {
                    return 'sm';
                } else if (gridSettings.md && window.innerWidth <= gridSettings.md.w) {
                    return 'md';
                } else if (gridSettings.lg && window.innerWidth <= gridSettings.lg.w) {
                    return 'lg';
                } else {
                    return 'xl';
                }
            }
        }

        return 'lg';
    }

    private _toggleModal(): void {
        this.setState({
            modalIsOpen: !this.state.modalIsOpen
        });
    }

    private _updateViewport(): void {
        this._viewport = this._getViewport();

        if (this.state.modalIsOpen && !this.isMobile) {
            this._toggleModal();
        }
    }

    private _getexpandRefinerCount = (refinerCount?: expandRefinersCount): void => {
        switch(refinerCount) {
            case expandRefinersCount.all:
                this.expandrefinerCount = 0;
                break;
            case expandRefinersCount.one:
                this.expandrefinerCount = 1;
                break;
            case expandRefinersCount.two:
               this.expandrefinerCount = 2;
               break;
            case expandRefinersCount.three:
                this.expandrefinerCount = 3;
                break;
            case expandRefinersCount.four:
                this.expandrefinerCount = 4;
                break;
            default:
                this.expandrefinerCount = 0;
        }
    }

}
